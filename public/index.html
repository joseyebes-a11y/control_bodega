<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bodega serie -INDÓMITO-</title>

    <style>
        :root {
            --vino-oscuro: #140818;
            --vino: #783c7b;
            --magenta: #f3789c;
            --rose: #fff1f8;
            --arena: #f8f0ff;
            --oro: #f3c77b;
            --texto: #201024;
            --linea: rgba(255, 255, 255, 0.35);
            --accent: #c2a9ff;
            --gris-ligero: rgba(255,255,255,0.65);
        }

        * {
            box-sizing: border-box;
        }

body {
    margin: 0;
    padding: 0;
    font-family: "Inter", system-ui, -apple-system, Helvetica, Arial, sans-serif;
    background: radial-gradient(circle at 15% 20%, #2b1a36, #0b0511 55%);
    min-height: 100vh;
    color: var(--texto);
    position: relative;
}

body::before,
body::after {
    content: "";
    position: fixed;
    width: 520px;
    height: 520px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(195,168,255,0.25), transparent 70%);
    z-index: 0;
    filter: blur(18px);
}

body::before {
    top: -80px;
    right: -100px;
}

body::after {
    bottom: -200px;
    left: -120px;
}

        .topbar {
            width: 100%;
            background: transparent;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 5;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .user-chip {
            display: none;
        }

        .topbar-title {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            position: relative;
        }

        .topbar-title button {
            color: inherit;
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            border: 1px solid rgba(255,255,255,0.38);
            cursor: pointer;
            padding: 16px 26px;
            border-radius: 28px;
            transition: transform 0.18s ease, box-shadow 0.22s ease, background 0.2s ease;
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
            min-width: 260px;
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }

        .topbar-title .microbrand {
            font-size: 11px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.75);
            margin-bottom: 4px;
        }

.topbar-title button::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 32px;
            background: conic-gradient(from 120deg, rgba(243,199,123,0.35), rgba(195,169,255,0.35), rgba(243,199,123,0.35));
            opacity: 0.2;
            filter: blur(6px);
            z-index: -1;
        }

.topbar-title button::after {
            content: "";
            position: absolute;
            top: -190%;
            left: -70%;
            width: 180%;
            height: 500%;
            background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.52) 55%, transparent 100%);
            transform: rotate(12deg) translateX(-300%);
            opacity: 0;
            transition: opacity 0.25s ease;
        }

.topbar-title button:hover,
.topbar-title button.open {
            background:
              radial-gradient(circle at 30% 30%, rgba(255, 235, 200, 0.7), transparent 42%),
              linear-gradient(135deg, #ffd79c, #ff9fdc, #b07bff);
            box-shadow:
              0 26px 70px rgba(0,0,0,0.65),
              0 12px 28px rgba(0,0,0,0.4),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 10px rgba(255,255,255,0.08);
            transform: translateY(-4px) scale(1.01);
        }

.topbar-title button:hover::after,
.topbar-title button.open::after {
            opacity: 1;
            animation: shimmer 1s ease forwards;
        }

        .topbar-title .marca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 2.5px;
            text-transform: uppercase;
            font-size: 36px;
            color: #0b0b0b;
            background: none;
            background-clip: initial;
-webkit-background-clip: initial;
            text-shadow:
              0 8px 18px rgba(92, 14, 45, 0.4),
              0 4px 10px rgba(92, 14, 45, 0.25),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 14px rgba(92, 14, 45, 0.35);
            filter: drop-shadow(0 4px 10px rgba(92, 14, 45, 0.35));
        }

        .topbar-title .submarca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 6px;
            font-size: 20px;
            color: #1a1a1a;
            margin-top: 8px;
            text-shadow:
              0 6px 18px rgba(0,0,0,0.4),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 12px rgba(50, 0, 70, 0.45);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.32));
        }

        /* =====================
           Adaptación móvil
        ===================== */
        @media (max-width: 768px) {
            body {
                margin: 0;
            }

            .topbar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                padding: 12px;
            }

            .topbar-title {
                width: 100%;
            }

            .topbar-title button {
                width: 100%;
                min-width: 0;
                padding: 14px 18px;
            }

            .nav-dropdown-menu {
                position: relative;
                top: 8px;
                left: 0;
                right: 0;
                width: 100%;
                min-width: 0;
                box-shadow: 0 16px 40px rgba(0,0,0,0.35);
                border: 1px solid rgba(255,255,255,0.16);
                background: linear-gradient(145deg, rgba(20,10,30,0.92), rgba(8,4,16,0.9));
            }

            .content {
                padding: 12px;
            }

            .card {
                padding: 16px;
            }

            /* Botones de la toolbar de nodos a ancho completo en móvil */
            .flow-toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .flow-toolbar-group {
                width: 100%;
            }

            .flow-toolbar .btnPrimario,
            .flow-toolbar .btnSecundario {
                width: 100%;
                justify-content: center;
            }

            /* Formularios más cómodos */
            form input,
            form select,
            form button,
            form textarea {
                width: 100%;
                box-sizing: border-box;
                font-size: 16px;
            }

            form .btnPrimario,
            form .btnSecundario {
                justify-content: center;
            }
            
            .nav-dropdown-menu a {
                font-size: 16px;
                padding: 12px 18px;
            }
        }

@keyframes shimmer {
        0% { transform: translateX(-300%) rotate(12deg); opacity: 0; }
        20% { opacity: 1; }
        100% { transform: translateX(300%) rotate(12deg); opacity: 0; }
}

        .topbar-title button .caret {
            margin-top: 6px;
            font-size: 14px;
            color: rgba(255,255,255,0.65);
            transition: transform 0.2s ease;
        }

        .topbar-title button.open .caret {
            transform: rotate(180deg);
        }

.nav-dropdown-menu {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            display: none;
            flex-direction: column;
            background: rgba(8, 4, 15, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 18px;
            padding: 12px;
            min-width: 230px;
            width: 240px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.45);
            backdrop-filter: blur(18px);
            z-index: 20;
        }

.nav-dropdown-menu.visible {
            display: flex;
        }

.nav-dropdown-menu a {
            display: flex;
            align-items: center;
            color: #f9e5ff;
            padding: 10px 18px;
            border-radius: 999px;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.9;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.04);
            margin: 4px 0;
            width: 100%;
            min-width: 210px;
            justify-content: flex-start;
            box-sizing: border-box;
            min-height: 44px;
        }

.nav-dropdown-menu a:hover {
            background: rgba(255,255,255,0.12);
            opacity: 1;
        }

.nav-dropdown-menu a .emoji-barrica-lateral {
            position: relative;
            width: 44px;
            height: 30px;
            margin-right: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-1px);
        }

        .emoji-barrica-lateral span {
            position: absolute;
            display: block;
        }

        .emoji-barrica-lateral .sobrio-shadow {
            inset: auto 10px -8px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.25), transparent 70%);
            filter: blur(2px);
        }

        .emoji-barrica-lateral .sobrio-body {
            inset: 4px 8px;
            border-radius: 20px / 13px;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #c08342, #7e4a1f 70%);
            box-shadow:
                inset 0 0 8px rgba(0,0,0,0.4),
                0 3px 5px rgba(0,0,0,0.25);
        }

        .emoji-barrica-lateral .sobrio-body::before {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: inherit;
            border: 1px solid rgba(255,255,255,0.15);
            opacity: 0.8;
        }

        .emoji-barrica-lateral .sobrio-ring {
            left: 14px;
            right: 14px;
            height: 3px;
            border-radius: 3px;
            background: linear-gradient(90deg, #bfc2c5, #7c8086);
            box-shadow:
                inset 0 0 1px rgba(0,0,0,0.5),
                0 0 1px rgba(0,0,0,0.3);
        }

        .emoji-barrica-lateral .sobrio-ring.superior { top: 9px; }
        .emoji-barrica-lateral .sobrio-ring.inferior { top: 18px; }

        .emoji-barrica-lateral .sobrio-head {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #d19b5e, #8a5021);
            box-shadow: inset -2px -2px 3px rgba(0,0,0,0.35);
        }

        .emoji-barrica-lateral .sobrio-head.front { right: 3px; z-index: 2; }
        .emoji-barrica-lateral .sobrio-head.back {
            left: 3px;
            filter: brightness(0.85);
        }

.nav-barricas-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            width: 230px;
            box-sizing: border-box;
            height: 40px;
            padding-top: 8px;
            padding-bottom: 8px;
        }

.nav-barricas-icon {
            width: 30px;
            height: 30px;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.35));
            background: transparent;
            mix-blend-mode: multiply;
        }

.nav-dropdown-menu a.activo {
            background: linear-gradient(120deg, rgba(241,92,146,0.9), rgba(95,44,130,0.9));
            color: #fff;
            opacity: 1;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 6px 18px rgba(241, 92, 146, 0.35);
        }

.nav-dropdown-menu a .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .icon-barrica {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: linear-gradient(180deg, #c07b45, #7a3f1b);
            border: 2px solid #51260f;
            position: relative;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        }

        .icon-barrica::before,
        .icon-barrica::after {
            content: "";
            position: absolute;
            left: 2px;
            right: 2px;
            height: 2px;
            background: rgba(81,38,15,0.8);
            border-radius: 2px;
        }

        .icon-barrica::before { top: 4px; }
        .icon-barrica::after { bottom: 4px; }

.h1-emoji {
            font-size: 36px;
            display: inline-block;
            margin-right: 10px;
        }

        .content {
            padding: 60px 70px 110px;
            min-height: 100vh;
            position: relative;
            z-index: 1;
            max-width: 1920px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .content {
                padding: 35px 24px 70px;
                max-width: 100%;
            }
        }

       h1 {
           margin: 0 0 15px;
           font-size: 32px;
           font-weight: 700;
           color: var(--vino-oscuro);
           letter-spacing: 0.4px;
       }

        h2 {
            color: var(--vino);
            margin-top: 0;
            letter-spacing: 0.2px;
        }

        .topbar h2 {
            color: #fff;
        }

        .card {
            background: rgba(255, 255, 255, 0.92);
            padding: 36px;
            border-radius: 30px;
            margin-bottom: 36px;
            box-shadow: 0 25px 60px rgba(11, 5, 21, 0.35);
            border: 1px solid rgba(255,255,255,0.45);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(12px);
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 20%, rgba(241,92,146,0.2), transparent 55%),
                        radial-gradient(circle at 80% 0%, rgba(95,44,130,0.16), transparent 60%);
            pointer-events: none;
        }

        .card > * {
            position: relative;
            z-index: 1;
        }

        .chart-card {
            margin-top: 25px;
            background: rgba(255,255,255,0.55);
            border-radius: 24px;
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.35);
            backdrop-filter: blur(8px);
        }

       .indicadores-grid {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
           gap: 18px;
           margin-top: 24px;
       }

        .indicador-card {
            background: rgba(255,255,255,0.85);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 10px 30px rgba(20,8,32,0.2);
        }

        .indicador-card h4 {
            margin: 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(47,31,59,0.8);
        }

        .indicador-card p {
            margin: 10px 0 4px;
            font-size: 32px;
            font-weight: 700;
            color: var(--vino-oscuro);
        }

        .indicador-card small {
            color: rgba(47,31,59,0.7);
            display: block;
            font-size: 12px;
        }

        .estado-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #fff;
            min-width: 48px;
            text-transform: uppercase;
        }

        .estado-fa { background: #d85c5c; }
        .estado-fml { background: #c47d21; }
        .estado-reposo { background: #8c6ff7; }
        .estado-limpio { background: #40a578; }
        .estado-vacio { background: #9ba1b0; }
        .estado-mantenimiento { background: #f0a500; }
        .estado-analitica { background: #ff7aa8; }

        .estado-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #fff;
            margin-top: 6px;
        }

        .estado-pill.mini {
            position: absolute;
            top: 8px;
            right: 0;
            font-size: 9px;
            padding: 3px 8px;
        }

        .plano-item .estado-pill.mini {
            right: 8px;
            top: 8px;
            padding: 3px 10px;
            letter-spacing: 0.06em;
            opacity: 0.92;
            backdrop-filter: blur(8px);
        }

        .acciones-rapidas {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 28px 0 10px;
        }

       .acciones-rapidas button {
           background: rgba(255,255,255,0.15);
           border: 1px solid rgba(255,255,255,0.4);
           padding: 10px 18px;
           border-radius: 999px;
           color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s;
        }

        .acciones-rapidas button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        section.card {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        section.card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .flow-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 6px;
            padding-bottom: 0;
        }

        .flow-toolbar-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        /* Botones del mapa de nodos (más grandes y cómodos) */
        .flow-toolbar .btnPrimario,
        .flow-toolbar .btnSecundario {
            font-size: 13px;
            padding: 9px 14px;
            border-radius: 12px;
            min-height: 38px;
        }

        .flow-toolbar .btnPrimario span,
        .flow-toolbar .btnPrimario img {
            vertical-align: middle;
        }

        .flow-zoom-controls {
            margin-left: auto;
        }

        .flow-toolbar .flow-zoom-btn {
            width: 38px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

	        .flow-toolbar .flow-zoom-label {
	            min-width: 70px;
	            text-align: center;
	            padding: 9px 12px;
	            font-weight: 800;
	        }

	        .flow-replay-bar {
	            display: none;
	            margin-top: 10px;
	            padding: 12px 14px;
	            border-radius: 18px;
	            border: 1px solid rgba(255,255,255,0.12);
	            background: rgba(255,255,255,0.08);
	            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
	            backdrop-filter: blur(12px);
	        }

	        .flow-replay-bar.visible {
	            display: block;
	        }

	        .flow-replay-top {
	            display: flex;
	            align-items: flex-start;
	            justify-content: space-between;
	            gap: 12px;
	        }

	        .flow-replay-title {
	            font-weight: 900;
	            letter-spacing: 0.2px;
	            color: rgba(255,255,255,0.95);
	        }

	        .flow-replay-sub {
	            font-size: 12px;
	            color: rgba(255,255,255,0.7);
	            margin-top: 2px;
	        }

	        .flow-replay-controls {
	            display: flex;
	            align-items: center;
	            gap: 8px;
	            margin-top: 10px;
	        }

	        .flow-replay-range {
	            flex: 1;
	            min-width: 200px;
	        }

	        .flow-replay-date {
	            min-width: 120px;
	            text-align: right;
	            font-size: 12px;
	            font-weight: 800;
	            color: rgba(255,255,255,0.9);
	        }

	        .flow-replay-hint {
	            margin-top: 8px;
	            font-size: 12px;
	            color: rgba(255,255,255,0.6);
	        }

	        .flow-editor {
	            position: relative;
	            border: 1px dashed rgba(255,255,255,0.25);
	            border-radius: 24px;
	            background: rgba(8,4,15,0.5);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
            margin-top: 4px;
        }

        .flow-stage {
            position: relative;
            width: 5000px;
            height: 3000px;
            min-width: 1400px;
            min-height: 640px;
            overflow: hidden;
        }

        .flow-world {
            position: absolute;
            left: 0;
            top: 0;
            width: 5000px;
            height: 3000px;
            transform-origin: 0 0;
            transform: scale(1);
        }

        .demo-flow-stage {
            position: relative;
            min-height: 320px;
            border: 1px dashed rgba(255,255,255,0.25);
            border-radius: 18px;
            background: radial-gradient(circle at 12% 18%, rgba(255,255,255,0.05), transparent 55%),
                        radial-gradient(circle at 80% 8%, rgba(255,255,255,0.04), transparent 60%),
                        rgba(12,6,18,0.6);
            overflow: hidden;
            margin-top: 14px;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.25);
        }

        .demo-flow-node {
            min-width: 160px;
            padding: 10px 12px 14px;
            border-radius: 16px;
        }

        .flow-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: default;
            background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .flow-connections {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .flow-node {
            position: absolute;
            min-width: 72px;
            background: rgba(40, 18, 52, 0.95);
            border-radius: 7px;
            box-shadow: 0 8px 14px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.08);
            padding: 4px 6px 24px;
            cursor: grab;
            color: #f5e9ff;
            text-transform: uppercase;
            font-weight: 400;
            letter-spacing: 0.3px;
            overflow: hidden;
            isolation: isolate;
        }

        .flow-node.dragging {
            cursor: grabbing;
            box-shadow: 0 25px 50px rgba(0,0,0,0.35);
        }

        .flow-node h4 {
            margin: 0;
            font-size: 14px;
            color: #f7f2ff;
            text-align: right;
            font-weight: 700;
        }

        .flow-node-subtitle {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 1px;
            text-align: right;
        }

        .flow-node-metrics {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-top: 4px;
            font-size: 10px;
            text-transform: none;
            justify-content: flex-end;
        }

        .flow-chip {
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            letter-spacing: 0.2px;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .flow-node .fill-level {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 0%;
            background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
            mix-blend-mode: screen;
            transition: height 0.35s ease, background 0.3s ease;
            z-index: -1;
        }

        .flow-node .fill-level.red {
            background: linear-gradient(180deg, rgba(255,88,120,0.15), rgba(255,88,120,0.35));
        }

        .flow-node .fill-level.white {
            background: linear-gradient(180deg, rgba(255,236,200,0.2), rgba(255,236,200,0.45));
        }

        .flow-node.temp-alert {
            box-shadow: 0 0 14px rgba(255,90,90,0.8), 0 0 0 1px rgba(255,90,90,0.45);
            border-color: rgba(255,90,90,0.6);
        }

        .flow-state-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 6px;
            font-size: 14px;
            line-height: 1.2;
            letter-spacing: 0.4px;
            font-weight: 700;
            text-transform: uppercase;
            color: #ffd89c;
        }

        .flow-progress-ring {
            position: absolute;
            inset: -6px;
            border-radius: 14px;
            pointer-events: none;
            z-index: -2;
            opacity: 0.8;
            -webkit-mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
            mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
        }

        .flow-node-icon {
            font-size: 15px;
        }

        .flow-tooltip {
            position: fixed;
            z-index: 9999;
            display: none;
            max-width: min(360px, calc(100vw - 24px));
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(18, 10, 30, 0.92);
            border: 1px solid rgba(255,255,255,0.16);
            box-shadow: 0 20px 45px rgba(0,0,0,0.45);
            color: rgba(255,255,255,0.92);
            font-size: 12px;
            line-height: 1.25;
            white-space: pre-line;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .grape-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.35), 0 1px 4px rgba(0,0,0,0.35);
            margin-left: 2px;
        }

        .grape-badge.red {
            background: radial-gradient(circle at 30% 30%, #ffb3c9, #d43c68 55%, #7a0f38 100%);
            color: #fff;
        }

        .grape-badge.white {
            background: radial-gradient(circle at 30% 30%, #fff7d1, #f9d66b 55%, #c99a2a 100%);
            color: #3a2a00;
        }

        .flow-node small {
            display: none;
        }

        .flow-node .flow-unit {
            display: inline-block;
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            font-size: 9px;
            margin-top: 4px;
            letter-spacing: 0.4px;
        }

        .flow-node .flow-node-controls {
            position: absolute;
            bottom: 6px;
            right: 6px;
            display: flex;
            gap: 4px;
        }

        .flow-node .flow-node-controls button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .flow-node .flow-node-controls button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .flow-node .flow-node-controls button.blue::before {
            background: #2f7df0;
        }

        .flow-node .flow-node-controls button.green::before {
            background: #4caf50;
        }

        .flow-node .flow-node-controls button.red::before {
            background: #f44336;
        }
        .flow-node .flow-node-controls button.blue::after {
            content: "";
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.9);
            inset: 0;
            margin: auto;
        }

        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }
        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }

        .flow-node .flow-node-controls button.red::after {
            content: "×";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 8px;
        }

        .flow-node .flow-node-controls button.conectando::before {
            box-shadow: 0 0 6px rgba(243,120,156,0.8);
        }

        .flow-node-body {
            width: 100%;
            align-items: flex-end;
            text-align: right;
            padding-right: 6px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

	        .flow-connector-line {
	            stroke: rgba(255,255,255,0.65);
	            stroke-width: 1.6;
	            fill: none;
	            marker-end: url(#arrowHead);
	        }

	        .flow-connector-line.replay-future {
	            stroke: rgba(255,255,255,0.18);
	            stroke-dasharray: 6 6;
	        }

	        .flow-connector-line.replay-done {
	            stroke: rgba(255,255,255,0.55);
	        }

	        .flow-connector-line.replay-now {
	            stroke: rgba(255,215,155,0.9);
	            stroke-width: 2.6;
	        }

	        .flow-connector-line.replay-outside {
	            opacity: 0.18;
	        }

	        .flow-connector-label {
	            fill: rgba(255,255,255,0.85);
	            font-size: 11px;
	            font-family: "Inter", system-ui, sans-serif;
	            pointer-events: none;
	            text-shadow: 0 1px 4px rgba(0,0,0,0.55);
	        }

	        #flujo.replay-mode .flow-connections {
	            pointer-events: auto;
	        }

	        #flujo.replay-mode .flow-connector-line {
	            pointer-events: stroke;
	            cursor: help;
	        }

	        #flujo.replay-mode .flow-connector-label {
	            opacity: 0.16;
	        }

	        #flujo.replay-mode .flow-node {
	            cursor: default;
	        }

	        #flujo.replay-mode .flow-node.dragging {
	            cursor: default;
	        }

	        #flujo.replay-mode .flow-node .flow-node-controls button {
	            pointer-events: none;
	            opacity: 0.35;
	        }

	        #flujo.replay-mode .flow-node.replay-inactive {
	            opacity: 0.18;
	            filter: grayscale(0.35) saturate(0.85);
	        }

	        #flujo.replay-mode .flow-node.replay-outside {
	            opacity: 0.12;
	            filter: grayscale(0.45) saturate(0.75);
	        }

	        #flujo.replay-mode .flow-node.replay-current {
	            box-shadow: 0 0 0 2px rgba(255,215,155,0.35), 0 18px 35px rgba(0,0,0,0.35);
	            border-color: rgba(255,215,155,0.28);
	        }

        .flow-node-info {
            margin-top: 16px;
            padding: 14px 18px;
            border-radius: 16px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.05);
            min-height: 80px;
            font-size: 14px;
        }

        .flow-helper {
            margin-top: 14px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        .flow-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding: 140px 20px 40px;
            z-index: 12000;
            overflow-y: auto;
        }

        .flow-modal.visible {
            display: flex;
        }

        .flow-modal-content {
            background: #fff;
            border-radius: 18px;
            padding: 18px 20px;
            max-width: 450px;
            width: min(450px, 94%);
            box-shadow: 0 30px 60px rgba(0,0,0,0.35);
        }

        .flow-modal-content form label {
            margin-top: 10px;
            display: block;
            font-weight: 500;
        }

        .flow-modal-content form input,
        .flow-modal-content form textarea,
        .flow-modal-content form select {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 14px;
        }

        .field-readonly {
            background: rgba(0,0,0,0.05);
            color: #5c5c5c;
            cursor: not-allowed;
        }

        .flow-modal-content form textarea {
            min-height: 70px;
        }

        .campo-info {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(0,0,0,0.04);
            border: 1px dashed rgba(0,0,0,0.12);
            font-size: 13px;
            color: #444;
        }

        .tabla-control-fermentacion table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-control-fermentacion th,
        .tabla-control-fermentacion td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-control-fermentacion input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-control-fermentacion th:nth-child(1),
        .tabla-control-fermentacion td:nth-child(1) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(2),
        .tabla-control-fermentacion td:nth-child(2) {
            width: 80px;
        }

        .tabla-control-fermentacion th:nth-child(3),
        .tabla-control-fermentacion td:nth-child(3) {
            width: 60px;
        }

        .tabla-control-fermentacion th:nth-child(4),
        .tabla-control-fermentacion td:nth-child(4) {
            width: 140px;
        }

        .tabla-control-fermentacion tbody tr:last-child td {
            border-bottom: none;
        }

        .flow-modal-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .skeleton-line,
        .skeleton-block {
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .skeleton-line::before,
        .skeleton-block::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            animation: shimmer 1.3s infinite;
        }

        .skeleton-line {
            height: 10px;
            margin: 6px 0;
        }

        .skeleton-block {
            height: 36px;
            margin: 10px 0;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .form-feedback {
            margin-top: 12px;
            font-size: 13px;
            min-height: 18px;
            color: rgba(32, 16, 36, 0.7);
        }

        .form-feedback.success {
            color: #2f8f5b;
        }

        .form-feedback.error {
            color: #d95070;
        }
        .movimientos-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .movimientos-form {
            flex: 1.2;
            min-width: 320px;
        }

        .tabla-movimientos {
            flex: 1.6;
            min-width: 440px;
            min-height: 520px;
            overflow-x: auto;
            overflow-y: visible;
        }

        .movimientos-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            min-width: 760px;
        }

        .movimientos-table th,
        .movimientos-table td {
            font-size: 12px;
            white-space: nowrap;
            padding: 8px;
        }


        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 22px;
            margin-top: 16px;
        }

        .chart-item {
            background: linear-gradient(160deg, rgba(255,255,255,0.95), rgba(241,92,146,0.15));
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--vino);
        }

        .app-alerts {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .toast {
            min-width: 220px;
            background: rgba(15, 7, 20, 0.85);
            color: #fff;
            padding: 12px 18px;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.35);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(20px);
            animation: toast-in 0.25s forwards;
        }

        .toast.success { background: rgba(64, 165, 120, 0.9); }
        .toast.error { background: rgba(217, 80, 112, 0.9); }

        @keyframes toast-in {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chart-bar-bg {
            width: 100%;
            height: 12px;
            border-radius: 12px;
            background: rgba(75,15,77,0.15);
            overflow: hidden;
        }

        .chart-bar {
            height: 100%;
            border-radius: 12px;
            background: linear-gradient(90deg, #f76fb0, #5f2c82);
            width: 20%;
            transition: width 0.4s ease;
        }

        .chart-item small {
            display: block;
            margin-top: 8px;
            color: #6e5e6e;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
            background: rgba(255,255,255,0.95);
            border-radius: 22px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 10px 30px rgba(16,6,28,0.15);
        }

        th, td {
            padding: 13px;
            text-align: left;
        }

        th {
            border-bottom: 1px solid rgba(106,34,77,0.15);
            background: linear-gradient(90deg, rgba(95,44,130,0.15), rgba(241,92,146,0.15));
            font-weight: 600;
            color: var(--vino-oscuro);
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tbody tr:nth-child(even) {
            background: rgba(252,245,255,0.8);
        }

        tbody tr:hover {
            background-color: rgba(241, 92, 146, 0.08);
        }

        input, select {
            width: 100%;
            padding: 12px 14px;
            margin: 6px 0 14px;
            border-radius: 14px;
            border: 1px solid rgba(95,44,130,0.15);
            font-size: 14px;
            background: rgba(255, 255, 255, 0.85);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
            backdrop-filter: blur(4px);
        }

input:focus,
select:focus {
            outline: none;
            border-color: var(--magenta);
            box-shadow: 0 12px 25px rgba(241,92,146,0.2);
            transform: translateY(-1px);
        }

        button {
            padding: 12px 22px;
            border-radius: 14px;
            border: none;
            background: linear-gradient(120deg, #f76fb0, #5f2c82);
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            box-shadow: 0 15px 35px rgba(95, 44, 130, 0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 45px rgba(95, 44, 130, 0.4);
        }

        .small-btn {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 999px;
            background: rgba(95,44,130,0.15);
            color: var(--vino-oscuro);
            border: none;
            font-weight: 600;
            box-shadow: none;
        }

        .btnPrimario {
            width: fit-content;
        }

        .btnSecundario {
            background: transparent;
            color: var(--texto);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
        }

        .btnSecundario:hover {
            border-color: rgba(255, 255, 255, 0.7);
        }

        .btnActualizar {
            margin-bottom: 8px;
            background: var(--vino-oscuro);
            box-shadow: none;
        }

label {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: rgba(42,15,39,0.65);
}

.mensaje {
    font-size: 13px;
    color: var(--vino);
    min-height: 18px;
    margin-top: 4px;
}

.resaltado {
    animation: destello 1.5s ease;
}

@keyframes destello {
    0% { background-color: rgba(199, 144, 191, 0.3); }
    100% { background-color: transparent; }
}

        .filtros-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0 20px;
            background: rgba(255,255,255,0.65);
            padding: 22px;
            border-radius: 22px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 15px 40px rgba(17,7,30,0.12);
            backdrop-filter: blur(8px);
        }

        .filtros-movimientos > div {
            flex: 1;
            min-width: 160px;
        }

        .acciones-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
        }

        .grid-almacen {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            margin-top: 10px;
        }

        .grid-almacen > div {
            flex: 1;
            min-width: 280px;
        }

        .plano-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 360px;
            gap: 18px;
            margin-top: 14px;
            align-items: start;
        }

        .plano-editor {
            position: relative;
            border: 1px solid rgba(255,255,255,0.16);
            border-radius: 28px;
            background: linear-gradient(180deg, rgba(8,4,15,0.62), rgba(8,4,15,0.48));
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
                        inset 0 0 50px rgba(0,0,0,0.35);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
        }

        .plano-editor.pan-activo {
            cursor: grab;
        }

        .plano-editor.pan-activo.panning {
            cursor: grabbing;
        }

        .plano-stage {
            position: relative;
            width: 2800px;
            height: 1600px;
            overflow: hidden;
        }

        .plano-canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 2800px;
            height: 1600px;
            transform-origin: 0 0;
            transform: scale(1);
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 24px;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(0deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                radial-gradient(circle at 18% 22%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 82% 70%, rgba(195,169,255,0.10), transparent 60%);
            background-size: 24px 24px, 24px 24px, 120px 120px, 120px 120px, auto, auto;
            background-color: rgba(12,6,22,0.62);
            box-shadow: inset 0 0 32px rgba(0,0,0,0.28);
            backdrop-filter: blur(6px);
        }

        .plano-zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 12px 0 8px;
        }

        .plano-zoom-controls .plano-zoom-btn,
        .plano-zoom-controls .plano-zoom-label {
            border-radius: 12px;
            min-height: 38px;
        }

        .plano-zoom-controls .plano-zoom-btn {
            width: 40px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

        .plano-zoom-controls .plano-zoom-label {
            flex: 1;
            font-weight: 850;
            text-align: center;
            padding: 9px 12px;
        }

        .plano-zoom-range {
            width: 100%;
            margin: 0 0 12px;
        }

        .plano-inspector-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .plano-inspector-actions .btnSecundario,
        .plano-inspector-actions .btnPrimario {
            padding: 9px 12px;
            border-radius: 14px;
            font-size: 12px;
        }

        .plano-item.seleccionado {
            box-shadow:
                0 26px 70px rgba(0,0,0,0.40),
                0 0 0 5px rgba(243,120,156,0.16),
                0 26px 92px var(--plano-card-glow, rgba(195,169,255,0.16));
            transform: translateY(-2px);
            border-color: rgba(255,255,255,0.78);
        }

        .plano-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.08);
            background:
                radial-gradient(circle at 14% 18%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(195,169,255,0.10), transparent 60%),
                rgba(255,255,255,0.70);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.55);
        }

        .plano-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(47,31,59,0.12) 1px, transparent 1px),
                linear-gradient(90deg, rgba(47,31,59,0.12) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.35;
            pointer-events: none;
        }

        .plano-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .plano-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 14px rgba(0,0,0,0.20);
            border: 1px solid rgba(255,255,255,0.9);
            cursor: pointer;
            z-index: 1;
        }

        .plano-minimap-dot.deposito { background: rgba(79, 88, 104, 0.85); }
        .plano-minimap-dot.mastelone { background: rgba(139, 27, 43, 0.85); }
        .plano-minimap-dot.barrica { background: rgba(196, 138, 27, 0.90); }

        .plano-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.24), 0 0 0 6px rgba(243,120,156,0.14);
        }

        .plano-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(47,31,59,0.55);
            background: rgba(47,31,59,0.08);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.22);
            cursor: grab;
        }

        .plano-minimap-viewport:active {
            cursor: grabbing;
        }

        .plano-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(47,31,59,0.70);
        }

        .flow-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.14);
            background:
                radial-gradient(circle at 14% 18%, rgba(176,123,255,0.18), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(255,142,199,0.16), transparent 60%),
                rgba(12,7,20,0.72);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.30);
            touch-action: none;
        }

        .flow-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.10) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.10) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.28;
            pointer-events: none;
        }

        .flow-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .flow-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 8px 18px rgba(0,0,0,0.30);
            border: 1px solid rgba(255,255,255,0.75);
            cursor: pointer;
            z-index: 1;
        }

        .flow-minimap-dot.entrada { background: var(--flow-accent-entrada); }
        .flow-minimap-dot.fermentacion { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.estilo { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.deposito { background: var(--flow-accent-deposito); }
        .flow-minimap-dot.coupage { background: var(--flow-accent-coupage); }
        .flow-minimap-dot.barrica { background: var(--flow-accent-barrica); }
        .flow-minimap-dot.embotellado { background: var(--flow-accent-embotellado); }
        .flow-minimap-dot.almacen { background: var(--flow-accent-almacen); }
        .flow-minimap-dot.salida { background: var(--flow-accent-salida); }
        .flow-minimap-dot.prensado { background: var(--flow-accent-estilo); }

        .flow-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 12px 22px rgba(0,0,0,0.36), 0 0 0 6px rgba(243,120,156,0.16);
        }

        .flow-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(255,255,255,0.55);
            background: rgba(255,255,255,0.06);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.30);
            cursor: grab;
        }

        .flow-minimap-viewport:active {
            cursor: grabbing;
        }

        .flow-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255,255,255,0.68);
        }

        @media (max-width: 980px) {
            .plano-layout {
                grid-template-columns: 1fr;
            }

            .flow-inspector.plano-inspector {
                position: relative;
                top: auto;
                max-height: none;
            }
        }

.plano-item {
	    position: absolute;
	    width: 148px;
	    height: 176px;
	    padding: 10px 10px 10px 12px;
	    padding-right: 30px;
	    border-radius: 14px;
	    color: var(--texto);
	    font-size: 12px;
	    cursor: grab;
	    user-select: none;
	    box-shadow:
	      0 18px 44px rgba(6,2,10,0.26),
	      0 22px 72px var(--plano-card-glow, rgba(195,169,255,0.12));
	    transition: box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
	    display: flex;
	    flex-direction: column;
	    gap: 8px;
	    background: var(--plano-card-bg,
	      radial-gradient(circle at 22% 14%, rgba(243,120,156,0.06), transparent 55%),
	      radial-gradient(circle at 82% 78%, rgba(195,169,255,0.06), transparent 60%),
	      linear-gradient(180deg, rgba(255,255,255,0.94), rgba(255,255,255,0.86)));
	    border: 1px solid rgba(255,255,255,0.62);
	    backdrop-filter: blur(10px) saturate(1.08);
	    align-items: stretch;
	    overflow: hidden;
	    --plano-accent: rgba(143,151,168,0.95);
}

.plano-item::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,0.55),
      inset 0 0 0 1px rgba(0,0,0,0.06);
    opacity: 0.9;
}

.plano-item:not(.arrastrando):hover {
    transform: translateY(-2px);
    box-shadow:
      0 26px 70px rgba(0,0,0,0.32),
      0 26px 92px var(--plano-card-glow, rgba(195,169,255,0.16));
    border-color: rgba(255,255,255,0.72);
}

.plano-item.arrastrando {
    opacity: 0.9;
    cursor: grabbing;
    box-shadow: 0 35px 70px rgba(0,0,0,0.45);
}

.plano-card-header {
	    display: flex;
	    flex-direction: column;
	    align-items: flex-start;
	    font-size: 12px;
	    text-transform: none;
	    letter-spacing: 0.02em;
	    font-weight: 850;
	    color: var(--vino-oscuro);
	    text-align: left;
	    gap: 6px;
	    width: 100%;
	    word-break: break-word;
	    position: relative;
	    padding-top: 0;
	    padding-right: 40px;
}

.plano-card-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
}

.plano-card-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: var(--plano-accent);
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      flex: 0 0 auto;
}

.plano-card-code {
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.02em;
      color: rgba(18, 12, 28, 0.92);
}

.plano-card-header small {
	    font-size: 9px;
	    color: rgba(47,31,59,0.72);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.62);
      border: 1px solid rgba(0,0,0,0.06);
      white-space: nowrap;
}

.plano-card-body {
	    display: flex;
	    flex-direction: column;
	    gap: 10px;
	    width: 100%;
}

.plano-card-barrel {
	    width: 40px;
	    height: 52px;
	    border-radius: 26px / 18px;
	    border: 2px solid rgba(139,92,64,0.4);
	    position: relative;
	    display: flex;
	    align-items: center;
	    justify-content: center;
	    font-weight: 700;
	    flex-shrink: 0;
	    box-shadow: inset 0 -4px 0 rgba(0,0,0,0.08);
}

.plano-card-barrel span {
	    font-size: 11px;
	    letter-spacing: 0.06em;
}

.plano-card-barrel.deposito {
    background: linear-gradient(180deg, #e5e8ee, #b6bdc9);
    color: #3f4653;
    border-color: rgba(111,121,138,0.5);
}

.plano-card-barrel.mastelone {
    background: linear-gradient(180deg, #e9b2c0, #a3223c);
    color: #5a0f1f;
    border-color: rgba(163,34,60,0.55);
}

.plano-card-barrel.barrica {
    background: linear-gradient(180deg, #f3d48b, #c08c32);
    color: #5d3a0f;
    border-color: rgba(184,128,34,0.6);
}

.plano-card-barrel::before,
.plano-card-barrel::after {
    content: "";
    position: absolute;
    left: 7px;
    right: 7px;
    height: 2px;
    background: rgba(0,0,0,0.15);
    border-radius: 999px;
}

.plano-card-barrel::before {
    top: 10px;
}

.plano-card-barrel::after {
    bottom: 10px;
}

.plano-card-info {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    flex: 1;
    text-align: left;
    width: 100%;
}

.plano-card-info small {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: rgba(47,31,59,0.6);
}

.plano-card-info strong {
	    font-size: 12px;
	    font-variant-numeric: tabular-nums;
	    display: block;
	    color: var(--vino-oscuro);
}

.plano-card-extra {
	    font-size: 9px;
	    color: rgba(47,31,59,0.78);
	    text-align: left;
	    width: 100%;
      display: grid;
      gap: 2px;
}

.plano-card-extra-line {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
}

.plano-card-extra-line.primary {
      white-space: normal;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
}

.plano-card-anada {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.72);
      font-size: 9px;
      font-weight: 850;
      letter-spacing: 0.02em;
      color: rgba(47,31,59,0.82);
      width: fit-content;
}

.plano-card-uvas {
      font-size: 10px;
      font-weight: 800;
      color: rgba(32,22,46,0.86);
      white-space: pre-line;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 4;
      overflow: hidden;
      line-height: 1.15;
}

.plano-card-progress {
	    position: absolute;
	    top: 10px;
	    right: 8px;
	    width: 12px;
	    height: calc(100% - 20px);
	    background: rgba(47,31,59,0.08);
	    border-radius: 999px;
	    overflow: hidden;
	    display: flex;
	    align-items: flex-end;
	    justify-content: center;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.70);
}

.plano-card-progress-bar {
    width: 100%;
    border-radius: 999px;
    transition: height 0.3s ease;
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,0.22),
      inset 0 -10px 18px rgba(0,0,0,0.10);
}

.plano-card-progress span {
      display: none;
}

        #planoMensaje {
            margin-top: 14px;
            color: rgba(255,255,255,0.85);
            font-size: 14px;
        }

	        .plano-placeholder {
	            position: absolute;
	            top: 50%;
	            left: 50%;
	            transform: translate(-50%, -50%);
	            color: rgba(255,255,255,0.7);
	            font-size: 14px;
	        }

	        /* =====================
	           UI Refresh (especial: mapa de nodos)
	        ===================== */
	        :root {
	            --ui-focus: rgba(243,120,156,0.55);
	            --flow-surface: rgba(12, 7, 20, 0.72);
	            --flow-surface-2: rgba(26, 16, 38, 0.78);
	            --flow-border: rgba(255,255,255,0.14);
	            --flow-border-2: rgba(255,255,255,0.22);
	            --flow-text: rgba(255,255,255,0.92);
	            --flow-muted: rgba(255,255,255,0.68);
	            --flow-grid-dot: rgba(255,255,255,0.08);
	            --flow-grid-dot-strong: rgba(255,255,255,0.14);
	            --flow-accent-entrada: #ff8ec7;
	            --flow-accent-estilo: #b07bff;
	            --flow-accent-deposito: #f3c77b;
	            --flow-accent-barrica: #c2a9ff;
	            --flow-accent-coupage: #90f2c9;
	            --flow-accent-embotellado: #7ee2ff;
	            --flow-accent-almacen: #c2c9ff;
	            --flow-accent-salida: #ff7aa8;
	        }

	        :focus-visible {
	            outline: 2px solid var(--ui-focus);
	            outline-offset: 3px;
	        }

	        #flujo .flow-toolbar {
	            position: sticky;
	            top: 86px;
	            z-index: 6;
	            padding: 14px;
	            border-radius: 22px;
	            background: rgba(255,255,255,0.78);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 18px 45px rgba(0,0,0,0.22);
	            backdrop-filter: blur(14px);
	        }

	        #flujo .flow-toolbar-group {
	            padding: 6px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.40);
	            border: 1px solid rgba(0,0,0,0.06);
	        }

	        #flujo .flow-toolbar-group button {
	            margin-top: 0;
	        }

	        #flujo .flow-toolbar .btnPrimario,
	        #flujo .flow-toolbar .btnSecundario {
	            border-radius: 999px;
	            padding: 10px 14px;
	            min-height: 40px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            gap: 8px;
	        }

	        #flujo .flow-toolbar .btnSecundario {
	            background: rgba(255,255,255,0.55);
	            border-color: rgba(0,0,0,0.10);
	        }

	        #flujo .flow-toolbar .btnSecundario:hover {
	            border-color: rgba(0,0,0,0.18);
	        }

	        .flow-layout {
	            display: grid;
	            grid-template-columns: minmax(0, 1fr) 360px;
	            gap: 18px;
	            margin-top: 14px;
	            align-items: start;
	        }

	        #flujo .flow-helper {
	            margin-top: 16px;
	            padding: 12px 14px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.60);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 14px 35px rgba(0,0,0,0.14);
	        }

	        #flujo .flow-helper p {
	            margin: 0;
	            color: rgba(47,31,59,0.78);
	        }

	        .flow-inspector {
	            position: sticky;
	            top: 126px;
	            max-height: calc(100vh - 156px);
	            overflow: auto;
	            margin-top: 0;
	            border-radius: 24px;
	            padding: 16px;
	            background: rgba(255,255,255,0.88);
	            border: 1px solid rgba(255,255,255,0.65);
	            box-shadow: 0 22px 60px rgba(11, 5, 21, 0.22);
	        }

	        .flow-inspector .flow-inspector-header {
	            display: flex;
	            gap: 12px;
	            align-items: center;
	            margin-bottom: 14px;
	        }

	        .flow-inspector .flow-inspector-icon {
	            width: 44px;
	            height: 44px;
	            border-radius: 16px;
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            background: radial-gradient(circle at 25% 20%, rgba(255, 230, 180, 0.6), transparent 45%),
	                        linear-gradient(135deg, rgba(243,199,123,0.85), rgba(243,120,156,0.75), rgba(155,93,229,0.75));
	            box-shadow: 0 18px 40px rgba(0,0,0,0.2);
	            color: #140818;
	            font-weight: 900;
	        }

	        .flow-inspector .flow-inspector-title {
	            font-weight: 800;
	            font-size: 14px;
	            color: var(--vino-oscuro);
	            letter-spacing: 0.02em;
	        }

	        .flow-inspector .flow-inspector-sub {
	            margin-top: 2px;
	            font-size: 12px;
	            color: rgba(47,31,59,0.68);
	        }

	        .flow-inspector .flow-inspector-tags {
	            display: flex;
	            flex-wrap: wrap;
	            gap: 8px;
	            margin: 10px 0 14px;
	        }

	        .flow-inspector .flow-tag {
	            display: inline-flex;
	            align-items: center;
	            padding: 6px 10px;
	            border-radius: 999px;
	            border: 1px solid rgba(0,0,0,0.08);
	            background: rgba(255,255,255,0.65);
	            font-size: 11px;
	            font-weight: 700;
	            letter-spacing: 0.02em;
	            color: rgba(47,31,59,0.82);
	        }

	        .flow-inspector .flow-inspector-fields {
	            display: grid;
	            gap: 10px;
	            margin: 0;
	        }

	        .flow-inspector .flow-field {
	            display: grid;
	            grid-template-columns: 1fr 1fr;
	            gap: 10px;
	            padding: 10px 12px;
	            border-radius: 16px;
	            background: rgba(255,255,255,0.68);
	            border: 1px solid rgba(0,0,0,0.06);
	        }

	        .flow-inspector .flow-field dt {
	            margin: 0;
	            font-size: 11px;
	            font-weight: 800;
	            text-transform: uppercase;
	            letter-spacing: 0.09em;
	            color: rgba(47,31,59,0.55);
	        }

		        .flow-inspector .flow-field dd {
		            margin: 0;
		            font-size: 12px;
		            font-weight: 650;
		            color: rgba(47,31,59,0.88);
		            text-align: right;
		            display: -webkit-box;
		            -webkit-box-orient: vertical;
		            -webkit-line-clamp: 6;
		            overflow: hidden;
		            white-space: pre-line;
		            word-break: break-word;
		        }

	        #flujo .flow-editor {
	            border: 1px solid rgba(255,255,255,0.16);
	            border-radius: 28px;
	            background: linear-gradient(180deg, rgba(8,4,15,0.62), rgba(8,4,15,0.48));
	            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
	                        inset 0 0 50px rgba(0,0,0,0.35);
	            overflow: auto;
	        }

	        #flujo .flow-stage {
	            min-width: 1400px;
	        }

	        #flujo .flow-canvas {
	            background-image:
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot) 1.25px, transparent 0),
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot-strong) 1.35px, transparent 0),
	                radial-gradient(circle at 18% 18%, rgba(243,120,156,0.10), transparent 50%),
	                radial-gradient(circle at 70% 10%, rgba(195,169,255,0.10), transparent 55%),
	                radial-gradient(circle at 82% 72%, rgba(243,199,123,0.08), transparent 55%);
	            background-size: 28px 28px, 112px 112px, auto, auto, auto;
	            background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
	        }

	        #flowCanvas[data-mode="connecting"] {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node:not(.is-connect-source):hover {
	            border-color: rgba(116,245,162,0.55);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45), 0 0 0 6px rgba(116,245,162,0.10);
	        }

	        #flujo .flow-connector-line {
	            stroke: rgba(255,255,255,0.55);
	            stroke-width: 2.4;
	            filter: drop-shadow(0 10px 18px rgba(0,0,0,0.35));
	        }

	        #flujo .flow-connector-line.type-entrada { stroke: rgba(255,142,199,0.78); }
	        #flujo .flow-connector-line.type-estilo { stroke: rgba(176,123,255,0.78); }
	        #flujo .flow-connector-line.type-deposito { stroke: rgba(243,199,123,0.78); }
	        #flujo .flow-connector-line.type-barrica { stroke: rgba(255,215,156,0.78); }
	        #flujo .flow-connector-line.type-coupage { stroke: rgba(144,242,201,0.78); }
	        #flujo .flow-connector-line.type-embotellado { stroke: rgba(126,226,255,0.78); }
	        #flujo .flow-connector-line.type-almacen { stroke: rgba(194,201,255,0.78); }
	        #flujo .flow-connector-line.type-salida { stroke: rgba(255,122,168,0.78); }

	        #flujo .flow-connector-line.is-highlight {
	            stroke-width: 3.2;
	            opacity: 0.95;
	            filter: drop-shadow(0 12px 22px rgba(0,0,0,0.45));
	        }

	        #flujo .flow-connector-label {
	            font-weight: 750;
	            letter-spacing: 0.02em;
	            paint-order: stroke fill;
	            stroke: rgba(0,0,0,0.60);
	            stroke-width: 4px;
	        }

        #flujo .flow-node {
            min-width: 120px;
            padding: 6px 6px 30px;
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(34, 20, 52, 0.92), rgba(19, 10, 30, 0.82));
            border: 1px solid var(--flow-border);
            box-shadow: 0 16px 36px rgba(0,0,0,0.36);
            backdrop-filter: blur(10px);
            color: var(--flow-text);
            text-transform: none;
            letter-spacing: 0.2px;
        }

	        #flujo .flow-node::after {
	            content: "";
	            position: absolute;
	            left: 8px;
	            right: 8px;
	            top: 6px;
	            height: 2px;
	            border-radius: 999px;
	            background: var(--flow-accent, rgba(255,255,255,0.25));
	            opacity: 0.95;
	        }

	        #flujo .flow-node[data-tipo="entrada"] { --flow-accent: var(--flow-accent-entrada); }
	        #flujo .flow-node[data-tipo="estilo"] { --flow-accent: var(--flow-accent-estilo); }
	        #flujo .flow-node[data-tipo="deposito"] { --flow-accent: var(--flow-accent-deposito); }
	        #flujo .flow-node[data-tipo="barrica"] { --flow-accent: var(--flow-accent-barrica); }
	        #flujo .flow-node[data-tipo="coupage"] { --flow-accent: var(--flow-accent-coupage); }
	        #flujo .flow-node[data-tipo="embotellado"] { --flow-accent: var(--flow-accent-embotellado); }
	        #flujo .flow-node[data-tipo="almacen"] { --flow-accent: var(--flow-accent-almacen); }
	        #flujo .flow-node[data-tipo="salida"] { --flow-accent: var(--flow-accent-salida); }

	        #flujo .flow-node:hover {
	            border-color: var(--flow-border-2);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45);
	        }

	        #flujo .flow-node.is-selected {
	            border-color: rgba(243,120,156,0.55);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(243,120,156,0.12);
	        }

	        #flujo .flow-node.is-connect-source {
	            border-color: rgba(195,169,255,0.65);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(195,169,255,0.12);
	        }

	        #flujo .flow-node-header {
	            display: flex;
	            align-items: center;
	            gap: 6px;
	            margin: 3px 0 6px;
	        }

	        #flujo .flow-node-icon {
	            width: 20px;
	            height: 20px;
	            border-radius: 10px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            background: rgba(255,255,255,0.10);
	            border: 1px solid rgba(255,255,255,0.12);
	            box-shadow: 0 10px 20px rgba(0,0,0,0.22);
	            font-size: 13px;
	        }

        #flujo .flow-node h4 {
            font-size: 9px;
            margin: 0;
            font-weight: 850;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            text-align: left;
        }

        #flujo .flow-node-body {
            padding-right: 0;
            align-items: flex-start;
            text-align: left;
            gap: 3px;
        }

        #flujo .flow-node-subtitle {
            font-size: 10px;
            color: rgba(255,255,255,0.78);
            text-align: left;
            line-height: 1.2;
            max-width: 100%;
        }

        #flujo .flow-node-subtitle.flow-subtitle-variedad {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 4;
            overflow: hidden;
            white-space: pre-line;
        }

        #flujo .flow-node .flow-unit {
            padding: 1px 4px;
            border-radius: 999px;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(255,255,255,0.14);
            color: rgba(255,255,255,0.92);
            font-size: 8px;
            letter-spacing: 0.04em;
        }

        #flujo .flow-node .flow-node-controls {
            bottom: 8px;
            right: 8px;
            gap: 5px;
        }

        #flujo .flow-node .flow-node-controls button {
            width: 20px;
            height: 20px;
            border-radius: 9px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.10);
            margin: 0;
            padding: 0;
            box-shadow: 0 10px 18px rgba(0,0,0,0.24);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        #flujo .flow-node .flow-node-controls button:hover {
            transform: translateY(-1px);
            border-color: rgba(255,255,255,0.22);
            box-shadow: 0 18px 34px rgba(0,0,0,0.32);
        }

        #flujo .flow-node .flow-node-controls button::before {
            display: none;
        }

        #flujo .flow-node .flow-node-controls button.blue {
            background: linear-gradient(180deg, rgba(109,168,255,0.30), rgba(109,168,255,0.10));
        }

        #flujo .flow-node .flow-node-controls button.green {
            background: linear-gradient(180deg, rgba(116,245,162,0.26), rgba(116,245,162,0.10));
        }

        #flujo .flow-node .flow-node-controls button.red {
            background: linear-gradient(180deg, rgba(255,122,122,0.28), rgba(255,122,122,0.10));
        }

        #flujo .flow-node .flow-node-controls button.blue::after {
            content: "✎";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.green::after {
            content: "⟶";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.red::after {
            content: "✕";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.conectando {
            outline: 2px solid rgba(243,120,156,0.55);
            outline-offset: 2px;
        }

        #flowModal.flow-modal {
            background: rgba(4, 2, 8, 0.62);
            backdrop-filter: blur(10px);
            padding: 110px 20px 40px;
        }

	        #flowModal .flow-modal-content {
	            border-radius: 24px;
	            border: 1px solid rgba(255,255,255,0.65);
	            background: rgba(255,255,255,0.94);
	            box-shadow: 0 40px 90px rgba(0,0,0,0.55);
	            max-height: calc(100vh - 160px);
	            overflow: auto;
	        }

	        #flowModalTitulo {
	            margin: 4px 0 14px;
	            font-size: 18px;
	            letter-spacing: 0.02em;
	        }

	        #flowModal .flow-modal-content form label {
	            margin-top: 12px;
	            display: block;
	            font-weight: 800;
	            font-size: 12px;
	            letter-spacing: 0.08em;
	            text-transform: uppercase;
	            color: rgba(47,31,59,0.65);
	        }

	        #flowModal .flow-modal-content form input,
	        #flowModal .flow-modal-content form textarea,
	        #flowModal .flow-modal-content form select {
	            border-radius: 14px;
	            border: 1px solid rgba(95,44,130,0.18);
	            background: rgba(255,255,255,0.88);
	            transition: border-color 0.2s, box-shadow 0.2s;
	        }

	        #flowModal .flow-modal-content form input:focus,
	        #flowModal .flow-modal-content form textarea:focus,
	        #flowModal .flow-modal-content form select:focus {
	            outline: none;
	            border-color: rgba(243,120,156,0.75);
	            box-shadow: 0 0 0 4px rgba(243,120,156,0.18);
	        }

	        #flowModal .flow-modal-actions {
	            position: sticky;
	            bottom: -10px;
	            background: rgba(255,255,255,0.94);
	            padding: 14px 0 2px;
	            margin-top: 18px;
	            border-top: 1px solid rgba(0,0,0,0.06);
	        }

	        @media (max-width: 1100px) {
	            #flujo .flow-toolbar {
	                position: static;
	                top: auto;
	            }
	            .flow-layout {
	                grid-template-columns: 1fr;
	            }
	            .flow-inspector {
	                position: relative;
	                top: auto;
	                max-height: none;
	            }
	        }

	        @media (prefers-reduced-motion: reduce) {
	            *, *::before, *::after {
	                animation-duration: 0.01ms !important;
	                animation-iteration-count: 1 !important;
	                transition-duration: 0.01ms !important;
	                scroll-behavior: auto !important;
	            }
	        }
	    </style>
    <!-- Librerías para exportar PDF de la tabla de control -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-5Bg/sA0tE5mr39QQcvKA3evSvKWK2Kx4UvHQ3UKQY6u1/JmgvXIL1sSTB+kJDd/KikJS9rBDjocM9V0bP7nU5w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js" integrity="sha512-V8bfSFHzEIE8KPQrX61/6LvTItI+ZXhWU1Yai0udDCR0Y9uRMq8eGX2WizzKkbKhYzZ0vjFaZ8WFtQ28gLeg4A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
    <div id="appAlerts" class="app-alerts"></div>
    <!-- Top navigation -->
    <div class="topbar">
        <div class="topbar-title">
            <button type="button" id="navToggle">
                <span class="microbrand">MicroCellerStudio</span>
                <span class="marca" id="marcaTexto">Bodega VegaLuna</span>
                <span class="submarca" id="submarcaTexto"></span>
                <span class="caret">▼</span>
            </button>
            <div class="nav-dropdown-menu" id="navMenu">
                <a href="#" data-section="entradas" onclick="cerrarNavMenu(); mostrarSeccion('entradas')">🍇 Entradas de uva</a>
                <a href="#" data-section="depositos" onclick="cerrarNavMenu(); mostrarSeccion('depositos')">🛢 Depósitos</a>
	                <a href="#" data-section="barricas" onclick="cerrarNavMenu(); mostrarSeccion('barricas')" class="nav-barricas-link">
	                    <img src="/barricas.png" alt="Maderas" class="nav-barricas-icon" />
	                    Maderas
	                </a>
                <a href="#" data-section="plano" onclick="cerrarNavMenu(); mostrarSeccion('plano')">🗺 Plano bodega</a>
                <a href="#" data-section="flujo" onclick="cerrarNavMenu(); mostrarSeccion('flujo')">🔗 Mapa de nodos</a>
                <a href="#" data-section="movimientos" onclick="cerrarNavMenu(); mostrarSeccion('movimientos')">🔄 Movimientos</a>
                <a href="#" data-section="embotellado" onclick="cerrarNavMenu(); mostrarSeccion('embotellado')">🍾 Embotellado</a>
                <a href="#" data-section="enologicos" onclick="cerrarNavMenu(); mostrarSeccion('enologicos')">🧪 Productos enológicos</a>
                <a href="#" data-section="analiticos" onclick="cerrarNavMenu(); mostrarSeccion('analiticos')">📊 Registros analíticos</a>
                <a href="#" data-section="analisisLab" onclick="cerrarNavMenu(); mostrarSeccion('analisisLab')">📄 Análisis laboratorio</a>
                <a href="#" data-section="limpieza" onclick="cerrarNavMenu(); mostrarSeccion('limpieza')">🧽 Almacén limpieza</a>
                <a href="#" id="navLogout">🚪 Cerrar sesión</a>
            </div>
        </div>
        <button type="button" class="user-chip" id="userBadge" title="Usuario activo">—</button>
    </div>

    <div id="flowTooltip" class="flow-tooltip" role="tooltip"></div>

    <!-- Contenido principal -->
    <div class="content">

        <!-- SECCIÓN BODEGA (RESUMEN GENERAL) -->
        <section id="bodega" class="card visible">
            <h1><span class="h1-emoji">🏠</span>Resumen de la bodega</h1>
            <p>Visión rápida de cómo va todo.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div class="card" style="flex:1;">
                    <h3>🍇 Kilos de uva entrados</h3>
                    <p id="resumenKilos" style="font-size:32px; font-weight:bold;">0 kg</p>
                </div>

                <div class="card" style="flex:1;">
                    <h3>🛢 Depósitos registrados</h3>
                    <p id="resumenDepositos" style="font-size:32px; font-weight:bold;">0</p>
                </div>

                <div class="card" style="flex:1;">
                    <h3 style="display:flex; align-items:center; gap:8px;">
                        <img src="/barricas.png" alt="Barricas" style="width:22px; height:22px; object-fit:contain; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas registradas
                    </h3>
                    <p id="resumenBarricas" style="font-size:32px; font-weight:bold;">0</p>
                </div>

            </div>
            <div class="chart-card">
                <h2>Gráficos rápidos</h2>
                <div class="chart-grid">
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Kilos de uva</span>
                            <span id="chartKilosValue">0 kg</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartKilosBar"></div>
                        </div>
                        <small>Total registrado en entradas</small>
                    </div>
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Litros en bodega</span>
                            <span id="chartLitrosValue">0 L</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartLitrosBar"></div>
                        </div>
                        <small id="chartLitrosDetalle">Depósitos, mastelones y barricas</small>
                    </div>
                </div>
            </div>

            <div class="indicadores-grid">
                <div class="indicador-card">
                    <h4>🛢 Depósitos</h4>
                    <p id="indicadorDepositosPrincipal">--</p>
                    <small id="indicadorDepositosDetalle">Calculando ocupación...</small>
                    <small id="indicadorDepositosExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4><span style="color:#c94458;">🪣</span> Mastelones</h4>
                    <p id="indicadorMastelonesPrincipal">--</p>
                    <small id="indicadorMastelonesDetalle">Calculando ocupación...</small>
                    <small id="indicadorMastelonesExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 style="display:flex; align-items:center; gap:6px;">
                        <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas
                    </h4>
                    <p id="indicadorBarricasPrincipal">--</p>
                    <small id="indicadorBarricasDetalle">Calculando ocupación...</small>
                    <small id="indicadorBarricasExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4>🍾 Embotellado</h4>
                    <p id="indicadorEmbotelladosPrincipal">--</p>
                    <small id="indicadorEmbotelladosDetalle">Sin registros</small>
                </div>
            </div>

            <div class="card" style="margin-top:24px;">
                <h2>Aprovechamiento por añada</h2>
                <p>Relación entre los kilos de uva registrados y los litros actuales por cada añada.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Añada</th>
                            <th>Kilos de uva</th>
                            <th>Litros actuales</th>
                            <th>Aprovechamiento</th>
                        </tr>
                    </thead>
                    <tbody id="tablaAprovechamiento">
                        <tr><td colspan="4">Cargando...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
        <!-- SECCIÓN FLUJO -->
        <section id="flujo" class="card" style="display:none;">
	            <h1><span class="h1-emoji">🗺</span>Mapa de nodos de vinificación</h1>
	            <p>Diseña visualmente el recorrido de cada partida: arrastra nodos, conéctalos y edita la información con doble clic.</p>
		            <div class="flow-toolbar">
		                <div class="flow-toolbar-group">
		                    <button class="btnSecundario" type="button" onclick="sembrarNodosDesdeDatos()">Sembrar nodos desde datos</button>
		                </div>
	                <div class="flow-toolbar-group">
	                    <button class="btnPrimario" type="button" onclick="crearNodoManual('entrada')">🍇 Entrada de uva</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('estilo')">⚗️ Elaboración</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('deposito')">🛢 Depósito</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('coupage')">🧪 Coupage / Blend</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('barrica')">
                        <span style="display:inline-flex; align-items:center; gap:6px;">
                          <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                          Crianza
                        </span>
                    </button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('embotellado')">🍾 Embotellado</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('almacen')">📦 Almacén</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('salida')">🚛 Salida</button>
                </div>
	                <div class="flow-toolbar-group">
	                    <button class="btnSecundario" type="button" onclick="resetMapaFlujoLocal()">Limpiar mapa</button>
	                </div>
		                <div class="flow-toolbar-group">
		                    <button class="btnSecundario" type="button" onclick="exportarNodosComoImagen()">Exportar imagen</button>
		                </div>
		                <div class="flow-toolbar-group">
		                    <button id="flowReplayToggleBtn" class="btnSecundario" type="button" onclick="toggleReplayFlujo()">🎞 Replay</button>
		                </div>
		                <div class="flow-toolbar-group flow-zoom-controls">
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(-1)" title="Alejar" aria-label="Alejar">−</button>
		                    <button class="btnSecundario flow-zoom-label" id="flowZoomLabel" type="button" onclick="resetZoomMapaFlujo()" title="Reset zoom" aria-label="Reset zoom">100%</button>
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(1)" title="Acercar" aria-label="Acercar">+</button>
		                </div>
		            </div>
		            <div id="flowReplayBar" class="flow-replay-bar" aria-label="Replay de movimientos" role="region">
		                <div class="flow-replay-top">
		                    <div>
		                        <div class="flow-replay-title">🎞 Replay</div>
		                        <div class="flow-replay-sub" id="flowReplaySub">Selecciona una entrada (o cualquier nodo de su recorrido) y pulsa “Replay” para recorrer el historial por fechas.</div>
		                    </div>
		                    <div class="flow-replay-top-actions">
		                        <button class="btnSecundario" type="button" onclick="salirReplayFlujo()">Salir</button>
		                    </div>
		                </div>
		                <div class="flow-replay-controls">
		                    <button class="btnSecundario" type="button" onclick="replayPasoFlujo(-1)" title="Anterior">⏮</button>
		                    <button id="flowReplayPlayBtn" class="btnPrimario" type="button" onclick="togglePlayReplayFlujo()" title="Reproducir / Pausar">⏵</button>
		                    <button class="btnSecundario" type="button" onclick="replayPasoFlujo(1)" title="Siguiente">⏭</button>
		                    <input id="flowReplayRange" class="flow-replay-range" type="range" min="0" max="0" step="1" value="0" oninput="onReplayRangeInput(this.value)" aria-label="Línea de tiempo" />
		                    <div class="flow-replay-date" id="flowReplayDate">—</div>
		                </div>
		                <div class="flow-replay-hint" id="flowReplayHint">Hover en una conexión para ver litros y fecha. Las conexiones futuras se muestran punteadas.</div>
		            </div>
		            <div class="flow-layout">
		                <div class="flow-editor" id="flowEditor">
		                    <div class="flow-stage" id="flowStage">
		                        <div class="flow-world" id="flowWorld">
		                            <svg id="flowConnections" class="flow-connections">
	                                <defs>
	                                    <marker id="arrowHead" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
	                                        <path d="M0,0 L0,6 L6,3 z" fill="rgba(255,255,255,0.7)" />
	                                    </marker>
	                                </defs>
	                                <g id="flowConnectionsLayer"></g>
	                            </svg>
	                            <div id="flowCanvas" class="flow-canvas"></div>
	                        </div>
	                    </div>
	                </div>
	                <aside id="flowNodeInfo" class="flow-node-info flow-inspector">Selecciona un nodo para ver los detalles.</aside>
	            </div>
	            <div class="flow-helper">
	                <p>Doble clic en un nodo para editarlo. Pulsa “Conectar” en un nodo y luego haz clic sobre el destino para crear el hilo. Puedes arrastrar los nodos a cualquier punto del lienzo.</p>
	            </div>

            <div class="chart-card" style="margin-top:18px;">
                <h3 style="margin-top:0;">Demo rápida: arrastra tanques y barricas</h3>
                <p style="margin:6px 0 12px;">Usa el array <code>tanques</code> y esta zona sandbox para probar drag & drop ligero sin tocar el mapa principal.</p>
	                <div id="demoFlowStage" class="demo-flow-stage"></div>
	            </div>
	        </section>
        <div id="flowModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowModalTitulo">Editar nodo</h3>
                <form id="flowModalForm"></form>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarFlowModal()">Cancelar</button>
                    <button type="button" class="btnSecundario" onclick="eliminarNodoActivo()">Eliminar</button>
                    <button type="button" class="btnPrimario" onclick="guardarNodoDesdeModal()">Guardar</button>
                </div>
            </div>
        </div>
        <!-- SECCIÓN ENTRADAS DE UVA -->
        <section id="entradas" class="card" style="display:none;">
            <h1><span class="h1-emoji">🍇</span>Entradas de uva</h1>

            <form id="formEntradaUva" onsubmit="crearEntradaUva(event)">
                <label>Fecha</label>
                <input type="datetime-local" id="entradaFecha" required>

                <input type="hidden" id="entradaAnada">

                <label>Variedad</label>
                <input type="text" id="entradaVariedad" required>

                <label>Parcela</label>
                <input type="text" id="entradaParcela" placeholder="Parcela o referencia">

                <label>Viticultor</label>
                <input type="text" id="entradaViticultor" placeholder="Nombre del viticultor">

                <label>Tipo de suelo</label>
                <input type="text" id="entradaSuelo" placeholder="Arcilloso, calizo...">

                <label>Años de la vid</label>
                <input type="number" id="entradaAnosVid" min="0" placeholder="Edad aproximada">

                <label>Kilos</label>
                <input type="number" id="entradaKilos" required>

                <label>Densidad</label>
                <input type="number" id="entradaDensidad" step="0.001" placeholder="1.050">

                <label>Temperatura (°C)</label>
                <input type="number" id="entradaTemperatura" step="0.1" placeholder="18.5">

                <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:16px;">
                    <button type="submit" class="btnPrimario" id="btnGuardarEntrada">Registrar entrada</button>
                    <button type="button" class="btnSecundario" id="btnCancelarEdicionEntrada" style="display:none;" onclick="cancelarEdicionEntrada()">Cancelar edición</button>
                </div>
                <div class="form-feedback" id="feedbackEntradaUva"></div>
            </form>

            <h2 style="margin-top:30px;">Historial</h2>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Fecha</th>
                        <th>Añada</th>
                        <th>Variedad</th>
                        <th>Viticultor</th>
                        <th>Tipo de suelo</th>
                        <th>Parcela</th>
                        <th>Años de la vid</th>
                        <th>Kilos</th>
                        <th>Densidad</th>
                        <th>Temp (°C)</th>
                        <th>Acciones</th>
                    </tr>
                </thead>
                <tbody id="tablaEntradas"></tbody>
            </table>
            <h2 style="margin-top:30px;">Resumen por parcela</h2>
            <table>
                <thead>
                    <tr>
                        <th>Parcela</th>
                        <th>Viajes</th>
                        <th>Kilos</th>
                        <th>Última fecha</th>
                        <th>Hora de entrada</th>
                    </tr>
                </thead>
                <tbody id="tablaResumenParcelas"></tbody>
            </table>
        </section>

        <!-- SECCIÓN DEPÓSITOS -->
        <section id="depositos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🛢</span>Depósitos</h1>
            <p>Registro de depósitos con su capacidad, tipo y material. La variedad y los litros asignados se actualizan automáticamente cuando un nodo se conecta al depósito.</p>

<table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Nombre de depósito</th>
        <th>Capacidad (L)</th>
        <th>Tipo</th>
        <th>Material</th>
        <th>Variedad asignada</th>
        <th>Volumen transferido</th>
        <th>Acciones</th>
        <th>Borrar</th>
      </tr>
    </thead>
    <tbody id="tablaDepositos"></tbody>
</table>

<h2 style="margin-top:40px;">Nuevo depósito</h2>

<form id="formDeposito" onsubmit="crearDeposito(event)">
  <div style="display:flex; gap:20px; flex-wrap:wrap;">
    <div style="flex:1;">
      <label>Nombre de depósito</label>
      <input type="text" id="depCodigo" required>
    </div>
    <div style="flex:1;">
      <label>Capacidad (L)</label>
      <input type="number" id="depCapacidad" min="0" step="0.1" required>
    </div>
    <div style="flex:1;">
      <label>Tipo</label>
      <select id="depTipo" required>
        <option value="">Selecciona tipo</option>
        <option value="Siempre lleno">Siempre lleno</option>
        <option value="Cerrado">Cerrado</option>
        <option value="Mastelone">Mastelone</option>
        <option value="Ánfora">Ánfora</option>
        <option value="Foudre">Foudre</option>
        <option value="Barrica">Barrica</option>
        <option value="Damajuana">Damajuana</option>
      </select>
    </div>
    <div style="flex:1;">
      <label>Material</label>
      <select id="depMaterial" required>
        <option value="">Selecciona material</option>
        <option value="Inox">Inox</option>
        <option value="Fibra de vidrio">Fibra de vidrio</option>
        <option value="Cemento">Cemento</option>
        <option value="Barro">Barro</option>
        <option value="Madera">Madera</option>
        <option value="Cristal">Cristal</option>
        <option value="Plástico alimentario">Plástico alimentario</option>
      </select>
    </div>
  </div>
  <button type="submit" class="btnPrimario">Crear depósito</button>
  <div class="form-feedback" id="feedbackDepositos"></div>
</form>
        </section>

        <div id="modalDeposito" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar depósito</h3>
                <form id="formEditarDeposito" onsubmit="guardarEdicionDeposito(event)">
                    <label>Nombre de depósito</label>
                    <input type="text" id="depCodigoEdit" required>

                    <label>Capacidad (L)</label>
                    <input type="number" id="depCapacidadEdit" min="0" step="0.1" required>

                    <label>Volumen actual (L)</label>
                    <input type="number" id="depVolumenEdit" min="0" step="0.1" required>

                    <label>Tipo</label>
                    <select id="depTipoEdit" required></select>

                    <label>Material</label>
                    <select id="depMaterialEdit" required></select>

                    <label>Estado</label>
                    <select id="depEstadoEdit" required></select>

                    <p style="margin-top:10px; font-size:13px; opacity:0.7;">
                        Variedad asignada: <strong id="depVariedadInfo">—</strong>
                    </p>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalDeposito()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cambios</button>
                    </div>
                    <div class="form-feedback" id="feedbackEditarDeposito"></div>
                </form>
            </div>
        </div>

        <!-- SECCIÓN ALMACÉN LIMPIEZA -->
        <section id="limpieza" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧽</span>Almacén de limpieza</h1>
            <p>Control de stock y consumo de productos de limpieza con trazabilidad por lote.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaLimpieza"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formLimpieza" onsubmit="crearProductoLimpieza(event)">
                        <label>Producto</label>
                        <input type="text" id="limNombre" required>

                        <label>Lote</label>
                        <input type="text" id="limLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="limCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="limUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="limNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN PRODUCTOS ENOLÓGICOS -->
        <section id="enologicos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧪</span>Productos enológicos</h1>
            <p>Registro de aditivos y productos empleados en la elaboración del vino.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEnologicos"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formEnologicos" onsubmit="crearProductoEnologico(event)">
                        <label>Producto</label>
                        <input type="text" id="enoNombre" required>

                        <label>Lote</label>
                        <input type="text" id="enoLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="enoCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="enoUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="enoNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN EMBOTELLADO -->
        <section id="embotellado" class="card" style="display:none;">
            <h1><span class="h1-emoji">🍾</span>Registro de embotellado</h1>
            <p>Documenta cada lote embotellado con trazabilidad completa.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Historial</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Origen</th>
                                <th>Botellas</th>
                                <th>Lote</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEmbotellados"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar embotellado</h2>
                    <form id="formEmbotellado" onsubmit="crearEmbotellado(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="embFecha">

                        <label>Tipo contenedor</label>
                        <select id="embTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor (ID o código)</label>
                        <input type="text" id="embContenedor" placeholder="Ej. A1 o 3" required>

                        <label>Botellas</label>
                        <input type="number" id="embBotellas" min="0" step="1" required>

                        <label>Lote embotellado</label>
                        <input type="text" id="embLote" placeholder="Referencia de lote">

                        <label>Nota</label>
                        <input type="text" id="embNota">

                        <button class="btnPrimario">Registrar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN PLANO BODEGA -->
        <section id="plano" class="card" style="display:none;">
            <h1><span class="h1-emoji">🗺</span>Plano de la bodega</h1>
            <p>Arrastra para colocar, haz clic para ver el desglose, y usa el zoom para navegar por toda la bodega.</p>

            <div class="plano-layout">
                <div class="plano-editor" id="planoEditor" aria-label="Plano de la bodega (lienzo)">
                    <div class="plano-stage" id="planoStage">
                        <div class="plano-canvas" id="planoCanvas">
                            <div class="plano-placeholder">Añade depósitos, mastelones o barricas para empezar</div>
                        </div>
                    </div>
                </div>
                <aside id="planoInfo" class="flow-inspector plano-inspector">Cargando inspector…</aside>
            </div>
            <p id="planoMensaje">Añade depósitos, mastelones o barricas para empezar.</p>
        </section>
        <!-- SECCIÓN BARRICAS -->
        <section id="barricas" class="card" style="display:none;">
            <h1 style="display:flex; align-items:center; gap:10px;">
                <img src="/barricas.png" alt="Maderas" style="width:30px; height:30px; object-fit:contain; filter: drop-shadow(0 3px 6px rgba(0,0,0,0.35)); mix-blend-mode:multiply; background:transparent;">
                Maderas
            </h1>
            <p>Control de maderas y litros dentro.</p>

            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Código</th>
                        <th>Capacidad&nbsp;(L)</th>
                        <th>Roble / tostado</th>
                        <th>Marca</th>
                        <th>Año barrica</th>
                        <th>Añada</th>
                        <th>Tipo de vino</th>
                        <th>Volumen actual (L)</th>
                        <th>Acciones</th>
                        <th>Borrar</th>
                    </tr>
                </thead>
                <tbody id="tablaBarricas"></tbody>
            </table>

            <h2 style="margin-top:40px;">Nueva madera</h2>

            <form id="formBarrica" onsubmit="crearBarrica(event)">
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <div style="flex:1;">
                        <label>Código</label>
                        <input type="text" id="barCodigo" required>
                    </div>
                    <div style="flex:1;">
                        <label>Capacidad&nbsp;(L)</label>
                        <input type="number" id="barCapacidad" required>
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de roble</label>
                        <input type="text" id="barTipo" placeholder="Francés, americano…">
                    </div>
                    <div style="flex:1;">
                        <label>Tostado</label>
                        <input type="text" id="barTostado" placeholder="Ligero, medio, fuerte…">
                    </div>
                    <div style="flex:1;">
                        <label>Marca</label>
                        <input type="text" id="barMarca" placeholder="Coperage, proveedor…">
                    </div>
                    <div style="flex:1;">
                        <label>Año</label>
                        <input type="number" id="barAnio" min="1900" max="2100" placeholder="2020">
                    </div>
                    <div style="flex:1;">
                        <label>Añada</label>
                        <input type="number" id="barVinoAnio" min="1900" max="2100" placeholder="2023">
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de vino</label>
                        <select id="barVinoTipo">
                            <option value="">Selecciona</option>
                            <option value="Vino tinto">Vino tinto</option>
                            <option value="Vino blanco">Vino blanco</option>
                            <option value="Vino rosado">Vino rosado / Clarete</option>
                        </select>
                    </div>
                </div>

                <button>Crear barrica</button>
            </form>
        </section>

        <!-- SECCIÓN MOVIMIENTOS -->
        <section id="movimientos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🔄</span>Movimientos de vino</h1>
            <p>Trasiegos, mermas, embotellados, ajustes… Todo queda registrado.</p>

            <div class="filtros-movimientos">
                <div>
                    <label>Tipo</label>
                    <select id="filtroMovTipo">
                        <option value="">Todos</option>
                        <option value="trasiego">Trasiego</option>
                        <option value="merma">Merma</option>
                        <option value="embotellado">Embotellado</option>
                        <option value="ajuste">Ajuste</option>
                        <option value="otro">Otro</option>
                    </select>
                </div>
                <div>
                    <label>Desde</label>
                    <input type="date" id="filtroMovDesde">
                </div>
                <div>
                    <label>Hasta</label>
                    <input type="date" id="filtroMovHasta">
                </div>
                <div>
                    <label>ID Contenedor</label>
                    <input type="text" id="filtroMovContenedor" placeholder="Ej. A1 o 3">
        </div>
        <div>
            <label>Tipo contenedor</label>
            <select id="filtroMovContTipo">
                <option value="">Cualquiera</option>
                        <option value="deposito">Depósito</option>
                        <option value="mastelone">Mastelone</option>
                        <option value="barrica">Barrica</option>
                    </select>
                </div>
                <div class="acciones-movimientos">
                    <button type="button" onclick="aplicarFiltrosMovimientos()">Aplicar filtros</button>
                    <button type="button" onclick="limpiarFiltrosMovimientos()">Limpiar</button>
                    <button type="button" onclick="exportarMovimientosCSV()">Exportar CSV</button>
                    <button type="button" style="background:#c94458; color:#fff;" onclick="limpiarHistorialMovimientos()">Limpiar historial</button>
                </div>
            </div>

            <div class="movimientos-layout">
                <div class="movimientos-form">
                    <h2>Nuevo movimiento</h2>

                    <form id="formMovimiento" onsubmit="crearMovimiento(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="movFecha">

                        <label>Tipo de movimiento</label>
                        <select id="movTipo">
                            <option value="trasiego">Trasiego</option>
                            <option value="merma">Merma</option>
                            <option value="embotellado">Embotellado</option>
                            <option value="ajuste">Ajuste</option>
                            <option value="otro">Otro</option>
                            <option value="prensado">Prensado</option>
                        </select>

                        <h3>Origen</h3>
                        <label>Tipo origen</label>
                        <select id="movOrigenTipo">
                            <option value="">(Ninguno)</option>
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>ID Contenedor origen (ej. 1 o A1)</label>
<input type="text" id="movOrigenId">
                        <small id="movOrigenNota" style="display:none; color:#f5c66b;">
                            En los movimientos de prensado no es necesario indicar origen.
                        </small>

<h3>Destino</h3>
                        <label>Tipo destino</label>
                        <select id="movDestinoTipo">
                            <option value="">(Ninguno)</option>
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                            <option value="merma">Merma</option>
                            <option value="embotellado">Embotellado</option>
                            <option value="otro">Otro</option>
                        </select>

                    <label>ID Contenedor destino (ej. 1 o B1)</label>
                        <input type="text" id="movDestinoId">

                        <label>Litros</label>
                        <input type="number" id="movLitros" step="0.1" min="0">

                        <label>Pérdida (L)</label>
                        <input type="number" id="movPerdida" step="0.1" min="0">

                        <label>Nota</label>
                        <input type="text" id="movNota">

                        <button>Guardar movimiento</button>
                        <div class="form-feedback" id="feedbackMovimientos"></div>
                    </form>
                </div>

                <div class="tabla-movimientos">
                    <h2>Historial de movimientos</h2>

                    <table class="movimientos-table">
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Tipo</th>
                                <th>Litros</th>
                                <th>Pérdida</th>
                                <th>Origen</th>
                                <th>Destino</th>
                                <th>Nota</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaMovimientos"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCIÓN REGISTROS ANALÍTICOS -->
        <section id="analiticos" class="card" style="display:none;">
            <h1><span class="h1-emoji">📊</span>Registros analíticos</h1>
            <p>Densidad, temperatura, etc. por depósito, mastelone o barrica.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo registro</h2>

                    <form id="formAnalitico" onsubmit="crearRegistroAnalitico(event)">
                        <label>Tipo contenedor</label>
                        <select id="regTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor</label>
                        <input type="text" id="regId" placeholder="Ej. 3 o A1" required>

                        <label>Fecha y hora</label>
                        <input type="datetime-local" id="regFecha" required>

                        <label>Densidad</label>
                        <input type="number" id="regDensidad" step="0.1">

                        <label>Temperatura (°C)</label>
                        <input type="number" id="regTemperatura" step="0.1">

                        <label>Nota sensorial</label>
                        <input type="text" id="regNotaSensorial" placeholder="Ej. frutos rojos, especias">

                        <label>Nota</label>
                        <input type="text" id="regNota">

                        <button>Guardar registro</button>
                        <div id="regMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.2; min-width:260px;">
                    <h2>Historial por contenedor</h2>

                    <div style="display:flex; gap:10px; align-items:flex-end;">
                        <div style="flex:1;">
                            <label>Tipo</label>
                            <select id="histTipo">
                                <option value="deposito">Depósito</option>
                                <option value="mastelone">Mastelone</option>
                                <option value="barrica">Barrica</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label>Contenedor</label>
                            <input type="text" id="histId" placeholder="Ej. 5 o B1">
                        </div>
                        <div>
                            <button class="small-btn" onclick="cargarHistorialAnalitico()">Ver</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Evento</th>
                                <th>Detalle</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaRegistros"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCIÓN ANÁLISIS LABORATORIO -->
        <section id="analisisLab" class="card" style="display:none;">
            <h1><span class="h1-emoji">📄</span>Análisis de laboratorio externos</h1>
            <p>Sube PDFs de laboratorios externos y asócialos a un depósito o mastelone.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo análisis</h2>
                    <form id="formAnalisisLab" onsubmit="crearAnalisisLab(event)">
                        <label>Tipo de contenedor</label>
                        <select id="labTipoContenedor">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                        </select>

                        <label>Contenedor (ID o código)</label>
                        <input type="text" id="labDeposito" placeholder="Ej. 2 o D3" required>

                        <label>Fecha del análisis</label>
                        <input type="date" id="labFecha">

                        <label>Laboratorio</label>
                        <input type="text" id="labLaboratorio" placeholder="Nombre del laboratorio">

                        <label>Descripción / tipo de análisis</label>
                        <input type="text" id="labDescripcion" placeholder="Ej. Microbiológico, físico-químico">

                        <label>Archivo PDF</label>
                        <input type="file" id="labArchivo" accept="application/pdf" required>

                        <button>Subir análisis</button>
                        <div id="labMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.3; min-width:280px;">
                    <h2>Historial de PDFs</h2>
                    <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
                        <div style="flex:1; min-width:160px;">
                            <label>Filtrar por contenedor</label>
                            <input type="text" id="labFiltroDeposito" placeholder="Ej. 2 o D3">
                        </div>
                        <div>
                            <label>Tipo</label>
                            <select id="labFiltroTipo">
                                <option value="">Todos</option>
                                <option value="deposito">Depósito</option>
                                <option value="mastelone">Mastelone</option>
                            </select>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="aplicarFiltroAnalisisLab()">Filtrar</button>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="limpiarFiltroAnalisisLab()">Limpiar</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Contenedor</th>
                                <th>Laboratorio</th>
                                <th>Descripción</th>
                                <th>Archivo</th>
                            </tr>
                        </thead>
                        <tbody id="tablaAnalisisLab"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div> <!-- fin .content -->

  <script>
// ---- Mostrar secciones del menú lateral ---
function mostrarSeccion(id) {
  if (id !== "flujo" && flowReplay?.playing) {
    togglePlayReplayFlujo(false);
  }
  const secciones = document.querySelectorAll("section.card");
  secciones.forEach(sec => {
    const esObjetivo = sec.id === id;
    if (esObjetivo) {
      sec.style.display = "block";
      requestAnimationFrame(() => sec.classList.add("visible"));
      if (id === "plano") {
        requestAnimationFrame(() => {
          inicializarPlanoBodegaUI();
          renderPlano();
        });
      }
      if (id === "flujo") {
        requestAnimationFrame(() => {
          aplicarLayoutFlow({ mantenerCentro: true });
          renderFlowConnections();
          programarActualizacionMinimapFlow();
        });
      }
    } else if (sec.classList.contains("visible")) {
      sec.classList.remove("visible");
      setTimeout(() => {
        sec.style.display = "none";
      }, 250);
    } else {
      sec.style.display = "none";
    }
  });
  const links = document.querySelectorAll("[data-section]");
  links.forEach(link => {
    link.classList.toggle("activo", link.dataset.section === id);
  });
}
let cacheEntradas = [];
let cacheDepositos = [];
let cacheBarricas  = [];
let cacheMastelones = [];
let cacheMovimientos = [];
let cacheLimpieza = [];
let cacheEnologicos = [];
let cacheEmbotellados = [];
let cacheAnalisisLab = [];
let depositoEditando = null;
let temporizadorGuardadoFlujo = null;
const RETARDO_GUARDADO_FLUJO = 600;
const TITULOS_DINAMICOS = {
  estilo: () => null,
  deposito: nodo => {
    const nombre = nodo?.datos?.codigo || "Depósito";
    const fase = nodo?.datos?.fase;
    // Mostramos la fase en el badge coloreado, no en el título, para evitar duplicados.
    return nombre;
  },
  barrica: nodo => {
    const datos = nodo?.datos || {};
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const id = datos.contenedor_id || datos.id_ref;
    const info = id ? obtenerInfoContenedor(tipoCont, id) : null;
    const codigo = (info?.codigo || datos.codigo || "").toString().trim();
    if (!codigo) return null;
    return `${codigo} CRIANZA`;
  },
};
const CAMPOS_PRIORITARIOS_MODAL = ["fecha", "fecha_operacion"];
const CAMPOS_CARGA_NUMERICOS = ["kilos", "litros", "litros_directos", "volumen"];
const CAMPOS_CARGA_TEXTO = ["variedad", "anada"];
const CAMPOS_CARGA_METRICAS = ["densidad", "temperatura"];
const TIPOS_CONTENEDOR_FLUJO = new Set(["deposito", "barrica"]);
const VARIEDADES_BLANCAS = [
  "blanco",
  "malvar",
  "airen",
  "airén",
  "verdejo",
  "albariño",
  "albarino",
  "macabeo",
  "viura",
  "godello",
  "palomino",
  "parellada",
  "xarel·lo",
  "xarello",
  "moscatel",
  "moscat",
  "gewurztraminer",
  "gewürztraminer",
  "riesling",
  "viognier",
  "chardonnay",
  "sauvignon",
  "treixadura",
  "garnacha blanca",
  "albillo",
  "colombard",
  "gruner",
  "gruener",
  "grüner",
  "viosinho",
  "pedro ximenez",
  "pedro ximénez",
  "trebbiano",
  "pinot blanc",
  "pinot bianco",
  "marsanne",
  "roussanne",
  "chenin",
  "palomino",
  "godello",
  "loureira",
  "doña blanca",
  "dona blanca",
  "malvasia",
  "malvasía",
];
let VARIEDADES_BLANCAS_SET = null;
function obtenerNodoPorId(idBuscado) {
  const idNorm = normalizarIdNodo(idBuscado);
  return flujoNodos.find(n => normalizarIdNodo(n.id) === idNorm) || null;
}
function actualizarTituloNodo(nodo) {
  if (!nodo) return;
  const config = FLOW_NODE_TYPES[nodo.tipo];
  const generador = TITULOS_DINAMICOS[nodo.tipo];
  if (generador) {
    const titulo = generador(nodo);
    if (titulo) {
      nodo.titulo = titulo;
      return;
    }
  }
  nodo.titulo = config ? config.label : nodo.titulo || "Nodo";
}

function ordenarCamposParaModal(campos) {
  const originales = [...(campos || [])];
  const prioridad = CAMPOS_PRIORITARIOS_MODAL.map(id =>
    originales.find(campo => campo.id === id)
  ).filter(Boolean);
  const resto = originales.filter(campo => !CAMPOS_PRIORITARIOS_MODAL.includes(campo.id));
  return [...prioridad, ...resto];
}

function obtenerValorCampoVisual(nodo, campo) {
  if (!nodo || !campo) return "";

  if (campo.id === "capacidad" && nodo.tipo === "deposito") {
    const capacidadBase =
      nodo.datos?.capacidad ??
      nodo.datos?.capacidad_l ??
      (nodo.datos?.capacidad_hl != null ? nodo.datos.capacidad_hl * 100 : null);
    const volumenBase =
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos ??
      nodo.datos?.litros_blend ??
      null;
    const capNum = capacidadBase != null ? Number(capacidadBase) : NaN;
    const volNum = volumenBase != null ? Number(volumenBase) : NaN;
    const capTxt = Number.isFinite(capNum) ? formatearLitrosPlano(capNum) : "";
    const volTxt = Number.isFinite(volNum) ? formatearLitrosPlano(volNum) : "";
    const partes = [];
    if (capTxt) partes.push(capTxt);
    if (volTxt) partes.push(`Volumen: ${volTxt}`);
    const combinado = partes.join(" | ");
    if (combinado) return combinado;
  }

  if (campo.id === "variedad") {
    const texto = obtenerVariedadVisibleNodo(nodo);
    if (texto) return texto;
  }

  const valor = nodo.datos ? nodo.datos[campo.id] : "";
  if (valor === undefined || valor === null || valor === "") return "";
  if (campo.id === "fecha" || campo.id === "fecha_operacion") {
    return formatearFechaCorta(valor);
  }
  if (campo.id === "densidad") {
    return formatearDensidad(valor);
  }
  if (campo.id === "temperatura") {
    const num = normalizarNumero(valor);
    return num != null ? `${num.toFixed(1)} °C` : "";
  }
  return valor;
}

function esMetodoPrensado(metodo) {
  return (metodo || "").toLowerCase() === "prensado";
}

function esMetodoSangrado(metodo) {
  return (metodo || "").toLowerCase() === "sangrado";
}

function esNodoSangrado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "estilo") {
    return esMetodoSangrado(nodo.datos?.metodo);
  }
  return false;
}

function esNodoPrensado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "prensado") return true;
  if (nodo.tipo === "estilo") {
    const metodo = (nodo.datos?.metodo || "").toLowerCase();
    return metodo === "prensado" || metodo === "sangrado";
  }
  return false;
}

function esNodoConversor(nodo) {
  return esNodoPrensado(nodo) || esNodoSangrado(nodo);
}

	function obtenerPredecesores(id) {
	  const idNorm = normalizarIdNodo(id);
	  return flujoNodos.filter(n =>
	    (n.targets || []).some(targetId => normalizarIdNodo(targetId) === idNorm)
	  );
	}

function obtenerUnidadNodo(nodo, memo = new Map()) {
  if (!nodo) return "kilos";
  const clave = nodo.id || nodo;
  // Evitar recursión infinita si hay ciclos
  if (memo.get("visitando")?.has(clave)) return "kilos";
  if (memo.has(clave)) return memo.get(clave);
  const visitando = memo.get("visitando") || new Set();
  visitando.add(clave);
  memo.set("visitando", visitando);
  let unidad = esNodoConversor(nodo) ? "litros" : "kilos";
  if (unidad === "kilos") {
    const padres = obtenerPredecesores(nodo.id);
    if (padres.some(pre => obtenerUnidadNodo(pre, memo) === "litros")) {
      unidad = "litros";
    }
  }
  memo.set(clave, unidad);
  visitando.delete(clave);
  return unidad;
}

function obtenerUnidadEntrante(nodo) {
  if (!nodo) return "kilos";
  const padres = obtenerPredecesores(nodo.id);
  if (!padres.length) return "kilos";
  return padres.some(pre => obtenerUnidadNodo(pre) === "litros") ? "litros" : "kilos";
}

function obtenerUnidadDisponible(origen) {
  return obtenerUnidadNodo(origen);
}

function obtenerUnidadVisual(nodo) {
  return obtenerUnidadNodo(nodo) === "litros" ? "L" : "kg";
}

function asegurarAsignacionRegistro(destino, origenId, kilosPorDefecto = 0, litrosPorDefecto = 0) {
  destino.datos = destino.datos || {};
  destino.datos.asignaciones = destino.datos.asignaciones || {};
  const key = origenId.toString();
  const existente = destino.datos.asignaciones[key];
  if (!existente) {
    destino.datos.asignaciones[key] = {
      kilos: kilosPorDefecto,
      litros: litrosPorDefecto,
      __manual: false,
    };
  } else {
    if (existente.kilos == null && kilosPorDefecto) existente.kilos = kilosPorDefecto;
    if (existente.litros == null && litrosPorDefecto) existente.litros = litrosPorDefecto;
  }
  return destino.datos.asignaciones[key];
}

function normalizarIdNodo(nodo) {
  if (!nodo) return "";
  if (typeof nodo === "string" || typeof nodo === "number") return String(nodo);
  return nodo.id != null ? String(nodo.id) : "";
}

	function esAncestro(posibleAncestroId, nodoId, visitados = new Set()) {
	  const ancestroId = normalizarIdNodo(posibleAncestroId);
	  const nodoNorm = normalizarIdNodo(nodoId);
	  if (!ancestroId || !nodoNorm) return false;
	  if (ancestroId === nodoNorm) return true;
	  if (visitados.has(nodoNorm)) return false;
	  visitados.add(nodoNorm);
	  const padres = obtenerPredecesores(nodoNorm);
	  return padres.some(pre => esAncestro(ancestroId, pre.id, visitados));
	}

function limpiarAsignacionesOrfanas(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo) || !nodo.datos?.asignaciones) return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.asignaciones).forEach(key => {
    if (!clavesPermitidas.has(key)) {
      delete nodo.datos.asignaciones[key];
    }
  });
  limpiarAportesOrfanos(nodo);
  actualizarVariedadDesdeAportes(nodo);
}

function limpiarAportesOrfanos(nodo) {
  if (!nodo || !nodo.datos?.aportes || typeof nodo.datos.aportes !== "object") return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.aportes).forEach(key => {
    if (!clavesPermitidas.has(String(key))) {
      delete nodo.datos.aportes[key];
    }
  });
}

function recalcularDatosDesdeAportes(nodo) {
  if (!nodo || !nodo.datos || !nodo.datos.aportes || typeof nodo.datos.aportes !== "object") return;

  // En depósitos/coupages el volumen lo llevan las asignaciones (tabla), no los aportes.
  if (["deposito", "coupage"].includes(nodo.tipo)) return;

  const aportes = Object.values(nodo.datos.aportes || {});
  if (!aportes.length) {
    nodo.datos.kilos = 0;
    nodo.datos.litros = 0;
    nodo.datos.litros_directos = 0;
    nodo.datos.volumen = 0;
    nodo.datos.densidad = "";
    nodo.datos.temperatura = "";
    return;
  }

  let sumK = 0;
  let sumL = 0;
  let densidadSuma = 0;
  let densidadPeso = 0;
  let densidadPrimera = null;
  let tempSuma = 0;
  let tempPeso = 0;
  let tempPrimera = null;

  aportes.forEach(a => {
    const k = normalizarNumero(a?.kilos) || 0;
    const ld = normalizarNumero(a?.litros_directos) || 0;
    const l = normalizarNumero(a?.litros) || 0;
    if (k > 0) sumK += k;
    if (ld > 0) sumL += ld;
    else if (l > 0) sumL += l;
    const peso = (ld > 0 ? ld : l > 0 ? l : k > 0 ? k : 0) || 0;

    const dens = normalizarNumero(a?.densidad);
    if (dens != null) {
      const pesoD = peso || 1;
      densidadSuma += dens * pesoD;
      densidadPeso += pesoD;
      if (densidadPrimera == null) densidadPrimera = dens;
    }

    const temp = normalizarNumero(a?.temperatura);
    if (temp != null) {
      const pesoT = peso || 1;
      tempSuma += temp * pesoT;
      tempPeso += pesoT;
      if (tempPrimera == null) tempPrimera = temp;
    }
  });

  // Barricas: guardamos el volumen para el relleno visual.
  if (nodo.tipo === "barrica") {
    nodo.datos.kilos = Number(sumK.toFixed(2));
    nodo.datos.litros = Number(sumL.toFixed(2));
    nodo.datos.litros_directos = nodo.datos.litros;
    nodo.datos.volumen = nodo.datos.litros;
  } else {
    // Nodos de proceso: consolidamos totales.
    nodo.datos.kilos = Number(sumK.toFixed(2));
    if (sumL > 0) {
      nodo.datos.litros = Number(sumL.toFixed(2));
      nodo.datos.litros_directos = nodo.datos.litros;
      nodo.datos.volumen = nodo.datos.litros;
    } else {
      nodo.datos.litros = 0;
      nodo.datos.litros_directos = 0;
      nodo.datos.volumen = nodo.datos.kilos;
    }
  }

  const densidadMedia = densidadPeso > 0 ? densidadSuma / densidadPeso : densidadPrimera;
  const temperaturaMedia = tempPeso > 0 ? tempSuma / tempPeso : tempPrimera;
  nodo.datos.densidad =
    densidadMedia != null ? Number(densidadMedia.toFixed(4)) : "";
  nodo.datos.temperatura =
    temperaturaMedia != null ? Number(temperaturaMedia.toFixed(2)) : "";

  // Recalcular mezcla visible acorde a los aportes actuales.
  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix && comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    }
  } catch (e) {
    // noop
  }
}

function limpiarCargaNodo(nodo) {
  if (!nodo || !nodo.datos) return;
  CAMPOS_CARGA_NUMERICOS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = 0;
    }
  });
  CAMPOS_CARGA_METRICAS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  CAMPOS_CARGA_TEXTO.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  if ("aportes" in nodo.datos) {
    nodo.datos.aportes = {};
  }
  if ("asignaciones" in nodo.datos) {
    nodo.datos.asignaciones = {};
  }
  if ("composicionVariedades" in nodo.datos) {
    nodo.datos.composicionVariedades = [];
  }
}

function obtenerTextoVariedadColor(nodo) {
  const textos = [];
  if (!nodo) return textos;
  if (Array.isArray(nodo.datos?.composicionVariedades) && nodo.datos.composicionVariedades.length) {
    textos.push(...nodo.datos.composicionVariedades.map(c => c.nombre));
  }
  if (nodo.datos?.variedad) textos.push(nodo.datos.variedad);
  if (nodo.datos?.vino_tipo) textos.push(nodo.datos.vino_tipo);
  if (nodo.datos?.vino) textos.push(nodo.datos.vino);
  return textos;
}

function obtenerColorVino(nodo) {
  const textos = obtenerTextoVariedadColor(nodo).map(normalizarTextoUva).filter(Boolean);

  // Prioridad 1: tipoColor explícito
  const tipoColor = (nodo.datos?.tipoColor || "").toLowerCase();
  if (tipoColor === "blanca" || tipoColor === "blanco" || tipoColor === "white") return "white";
  if (tipoColor === "tinta" || tipoColor === "tinto" || tipoColor === "red") return "red";

  // Prioridad 2: si el nodo es de entrada y hay cache, usar la variedad de la entrada
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref && Array.isArray(cacheEntradas)) {
    const entrada = cacheEntradas.find(e => String(e.id) === String(nodo.datos.id_ref));
    if (entrada && entrada.variedad) {
      const txtEntrada = normalizarTextoUva(entrada.variedad);
      textos.unshift(txtEntrada);
    }
  }

  if (textos.some(txt => esVariedadBlanca(txt))) return "white";
  if (textos.some(txt => txt.includes("ros") || txt.includes("rosad"))) return "rosado";
  return "red";
}

function obtenerColorEmojiVino(colorVino) {
  if (colorVino === "white") return "#f7c859";
  if (colorVino === "rosado") return "#f58bb5";
  return "#d43c68";
}

function obtenerEstadoVisual(nodo) {
  if (!nodo || !nodo.datos) return null;
  const estadoRaw = (nodo.datos.fase || nodo.datos.estado || "").toString().trim();
  if (!estadoRaw) return null;
  const estadoNorm = estadoRaw.toLowerCase();
  const info = obtenerInfoEstadoDeposito ? obtenerInfoEstadoDeposito(estadoNorm) : null;
  const colorVino = obtenerColorVino(nodo);
  const colorTexto = colorVino === "white" ? "#f7c859" : "#d43c68";
  if (info) {
    return { id: info.id, label: info.label, color: colorTexto };
  }
  return { id: estadoNorm, label: estadoRaw.toUpperCase(), color: colorTexto };
}

function normalizarTextoUva(str) {
  if (!str) return "";
  return str
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
}

	function esVariedadBlanca(textoNormalizado) {
	  if (!textoNormalizado) return false;
	  if (textoNormalizado.includes("blanc") || textoNormalizado.includes("white") || textoNormalizado.includes("bianco")) {
	    return true;
	  }
  if (!VARIEDADES_BLANCAS_SET) {
    VARIEDADES_BLANCAS_SET = new Set(
      VARIEDADES_BLANCAS.map(nombre => normalizarTextoUva(nombre))
    );
  }
  const tokens = textoNormalizado.split(/[^a-z]+/).filter(Boolean);
  if (tokens.some(tok => VARIEDADES_BLANCAS_SET.has(tok))) return true;
  return Array.from(VARIEDADES_BLANCAS_SET).some(nombre => textoNormalizado.includes(nombre));
	}

	function calcularOcupacionNodo(nodo) {
	  if (!nodo) return null;
	  const datos = nodo.datos || {};
	  const capacidad =
	    normalizarNumero(datos.capacidad) ??
	    normalizarNumero(datos.capacidad_l) ??
	    (datos.capacidad_hl != null ? normalizarNumero(datos.capacidad_hl * 100) : null);
	  if (capacidad == null || !(capacidad > 0)) return null;
	  const volumenVisual = obtenerVolumenVisualNodo ? obtenerVolumenVisualNodo(nodo) : null;
	  const volumenBase =
	    volumenVisual != null
	      ? volumenVisual
	      : normalizarNumero(datos.volumen) ??
	        normalizarNumero(datos.litros_directos) ??
	        normalizarNumero(datos.litros) ??
	        normalizarNumero(datos.kilos);
	  if (volumenBase == null) return null;
	  return Math.max(0, Math.min(1, volumenBase / capacidad));
	}

function rellenarDatosEntradaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "entrada") return;
  const idRef = nodo.datos?.id_ref;
  if (!idRef || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => String(e.id) === String(idRef));
  if (!entrada) return;
  nodo.datos = nodo.datos || {};
  if (entrada.variedad) {
    nodo.datos.variedad = entrada.variedad;
    nodo.datos.vino_tipo = entrada.variedad;
    const varNorm = normalizarTextoUva(entrada.variedad);
    nodo.datos.tipoColor = esVariedadBlanca(varNorm) ? "blanca" : "tinta";
  }
  if (entrada.anada) nodo.datos.anada = entrada.anada;
}

function obtenerTemperaturaNodo(nodo) {
  if (!nodo) return null;
  if (normalizarNumero(nodo.datos?.temperatura) != null) {
    return normalizarNumero(nodo.datos.temperatura);
  }
  if (Array.isArray(nodo.datos?.control) && nodo.datos.control.length) {
    const ultimo = nodo.datos.control[nodo.datos.control.length - 1];
    if (normalizarNumero(ultimo?.temperatura) != null) {
      return normalizarNumero(ultimo.temperatura);
    }
  }
  return null;
}

function calcularProgresoBarrica(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  if (!inicioStr) return null;
  const inicio = parsearFechaValor(inicioStr);
  if (!inicio) return null;
  const ahora = new Date();

  const fin = finStr ? parsearFechaValor(finStr) : null;
  let msTotal = 0;
  if (fin) {
    msTotal = fin.getTime() - inicio.getTime();
  } else {
    const mesesObjetivo = normalizarNumero(finStr) || 12; // fallback si guardaron meses como número
    msTotal = mesesObjetivo * 30 * 24 * 60 * 60 * 1000;
  }
  if (!(msTotal > 0)) return null;

  const transcurrido = Math.max(0, ahora.getTime() - inicio.getTime());
  return Math.max(0, Math.min(1, transcurrido / msTotal));
}

function obtenerTooltipCrianza(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return "";
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  const inicio = inicioStr ? parsearFechaValor(inicioStr) : null;
  if (!inicio) {
    return 'Crianza\nDefine "Fecha operación" (inicio).';
  }

  const formatearFechaTooltip = date => {
    if (!date) return "—";
    const d = new Date(date);
    if (isNaN(d.getTime())) return "—";
    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = d.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  };

  const finDate = finStr ? parsearFechaValor(finStr) : null;
  let fin = finDate;
  let finEsEstimado = false;
  if (!finDate) {
    const meses = normalizarNumero(finStr);
    if (meses != null && meses > 0) {
      fin = new Date(inicio.getTime() + meses * 30 * 24 * 60 * 60 * 1000);
      finEsEstimado = true;
    }
  }

  if (!fin) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      'Define "Fin previsto de la crianza" para ver el avance.',
    ].join("\n");
  }

  const ahora = new Date();
  const msTotal = fin.getTime() - inicio.getTime();
  if (!(msTotal > 0)) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      `Fin: ${formatearFechaTooltip(fin)}`,
      "Revisa fechas: el fin debe ser posterior al inicio.",
    ].join("\n");
  }

  const msDia = 24 * 60 * 60 * 1000;
  const transcurridoMs = ahora.getTime() - inicio.getTime();
  const restanteMs = fin.getTime() - ahora.getTime();
  const pct = Math.max(0, Math.min(1, transcurridoMs / msTotal));
  const diasTotal = Math.max(1, Math.round(msTotal / msDia));
  const diasTrans = Math.max(0, Math.round(Math.max(0, transcurridoMs) / msDia));
  const diasRest = Math.max(0, Math.round(Math.max(0, restanteMs) / msDia));

  const lineas = [
    `Crianza: ${Math.round(pct * 100)}%`,
    `Inicio: ${formatearFechaTooltip(inicio)}`,
    `Fin: ${formatearFechaTooltip(fin)}${finEsEstimado ? " (estimado)" : ""}`,
    `Transcurrido: ${Math.min(diasTrans, diasTotal)}/${diasTotal} días`,
  ];
  if (restanteMs >= 0) {
    lineas.push(`Restan: ${diasRest} días`);
  } else {
    lineas.push(`Finalizada hace: ${Math.abs(Math.round(restanteMs / msDia))} días`);
  }
  return lineas.join("\n");
}

function getFlowTooltipEl() {
  return document.getElementById("flowTooltip");
}

function posicionarFlowTooltip(clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip || tip.style.display === "none") return;
  const padding = 12;
  const offset = 14;
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth || document.documentElement.clientWidth || 0;
  const vh = window.innerHeight || document.documentElement.clientHeight || 0;

  let x = clientX + offset;
  let y = clientY + offset;
  if (x + rect.width + padding > vw) x = Math.max(padding, clientX - rect.width - offset);
  if (y + rect.height + padding > vh) y = Math.max(padding, clientY - rect.height - offset);

  tip.style.left = `${Math.round(x)}px`;
  tip.style.top = `${Math.round(y)}px`;
}

function mostrarFlowTooltip(texto, clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  if (!texto) {
    tip.style.display = "none";
    return;
  }
  tip.textContent = texto;
  tip.style.display = "block";
  posicionarFlowTooltip(clientX, clientY);
}

function ocultarFlowTooltip() {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  tip.style.display = "none";
}

function limpiarNodosSinEntradas() {
  flujoNodos.forEach(nodo => {
    if (nodo.tipo === "entrada") return;
    const predecesores = obtenerPredecesores(nodo.id);
    if (!predecesores.length) {
      limpiarCargaNodo(nodo);
      if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
        actualizarVariedadDesdeAportes(nodo);
      }
    }
  });
}

function construirCargaDesdeDatos(datos = {}) {
  const carga = {};
  if (datos.variedad) carga.variedad = datos.variedad;
  if (datos.anada) carga.anada = datos.anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  if (datos.fecha_operacion) carga.fecha_operacion = datos.fecha_operacion;
  const kilos = normalizarNumero(datos.kilos);
  if (kilos != null) carga.kilos = kilos;
  const litros = normalizarNumero(datos.litros);
  if (litros != null) carga.litros = litros;
  const litrosDirectos = normalizarNumero(datos.litros_directos);
  if (litrosDirectos != null) carga.litros_directos = litrosDirectos;
  const densidad = normalizarNumero(datos.densidad);
  if (densidad != null) carga.densidad = densidad;
  const temperatura = normalizarNumero(datos.temperatura);
  if (temperatura != null) carga.temperatura = temperatura;
  return Object.keys(carga).length ? carga : null;
}

function obtenerCargaParaSembrar(origen) {
  if (!origen) return null;
  const visitados = new Set();
  const cola = [origen];
  while (cola.length) {
    const actual = cola.shift();
    if (!actual || visitados.has(actual.id)) continue;
    visitados.add(actual.id);
    if (actual.tipo === "entrada" && actual.datos?.id_ref) {
      intentarPoblarNodoEntrada(actual);
    }
    if (actual.tipo === "deposito" && actual.datos?.id_ref) {
      intentarPoblarNodoDeposito(actual);
    }
    let carga = obtenerCargaDesdeNodo(actual);
    if (!carga) {
      carga = construirCargaDesdeDatos(actual.datos);
    }
    if (carga) return carga;
    const padres = obtenerPredecesores(actual.id);
    padres.forEach(pre => {
      if (pre && !visitados.has(pre.id)) {
        cola.push(pre);
      }
    });
  }
  return null;
}

function sembrarDatosIniciales(origen, destino) {
  if (!origen || !destino) return;
  if (destino.tipo === "deposito") return;
  const carga = obtenerCargaParaSembrar(origen);
  if (!carga) return;
  aplicarCargaProcesoSinDuplicar(destino, origen.id, carga);
  guardarEstadoNodos();
}

function obtenerVariedadVisibleNodo(nodo) {
  if (!nodo) return "";
  const compArray = nodo.datos?.composicionVariedades;
  if (Array.isArray(compArray) && compArray.length) {
    return compArray
      .filter(c => c?.nombre && !esVariedadGenerica(c.nombre))
      .map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`)
      .join("\n");
  }
  const comp = calcularComposicionVariedades(nodo);
  const calculada = guardarComposicionEnNodo(nodo, comp.mix, comp.total);
  if (calculada.length) {
    return calculada
      .filter(c => c?.nombre && !esVariedadGenerica(c.nombre))
      .map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`)
      .join("\n");
  }
  const textoBase = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  if (!textoBase) return "";
  return textoBase
    .split(/[/·]/)
    .map(t => t.trim())
    .filter(Boolean)
    .filter(t => !esVariedadGenerica(t))
    .join("\n");
}

function limpiarTextoVariedad(variedad) {
  if (!variedad) return "";
  return variedad
    .split("·")
    .map(part => part.replace(/\s*\d+(\.\d+)?%/g, "").trim())
    .filter(Boolean)
    .join(" · ");
}

// Helper para sumar variedades ponderadas (admite listas con porcentajes)
function agregarVariedadAPeso(mix, texto, peso) {
  if (!mix || !texto) return;
  const pesoBase = Number.isFinite(Number(peso)) && Number(peso) > 0 ? Number(peso) : 1;
  const partes = texto
    .split(/[\/·,]/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) return;
  const items = partes.map(p => {
    const m = p.match(/^(.*?)(?:\s+(\d+(?:[.,]\d+)?)%?)?$/);
    return {
      nombre: m && m[1] ? m[1].trim() : p,
      pct: m && m[2] ? Number(String(m[2]).replace(",", ".")) : null,
    };
  });
  const conPct = items.filter(i => Number.isFinite(i.pct) && i.pct > 0);
  if (conPct.length) {
    conPct.forEach(i => {
      const nombre = limpiarTextoVariedad(i.nombre);
      if (!nombre || esVariedadGenerica(nombre)) return;
      const aporte = pesoBase * (i.pct / 100);
      mix.set(nombre, (mix.get(nombre) || 0) + aporte);
    });
    return;
  }
  const reparto = pesoBase / items.length;
  items.forEach(i => {
    const nombre = limpiarTextoVariedad(i.nombre);
    if (!nombre || esVariedadGenerica(nombre)) return;
    mix.set(nombre, (mix.get(nombre) || 0) + reparto);
  });
}

function mixToArray(mix, total) {
  if (!mix || !mix.size) return [];
  const entradas = Array.from(mix.entries());
  const sumatoria = total && total > 0 ? total : entradas.reduce((a, [, v]) => a + v, 0);
  const base = sumatoria > 0 ? sumatoria : entradas.length;
  const ordenadas = entradas.sort((a, b) => {
    if (sumatoria <= 0) return a[0].localeCompare(b[0]);
    return b[1] - a[1];
  });
  return ordenadas.map(([nombre, cantidad]) => {
    const peso = sumatoria > 0 ? cantidad : 1;
    const pct = base > 0 ? (peso / base) * 100 : 0;
    return { nombre, porcentaje: pct };
  });
}

function formatearPctVariedad(valor) {
  if (!Number.isFinite(valor)) return "0%";
  if (Math.abs(valor) < 1) return `${valor.toFixed(1)}%`;
  const redondeado = Math.round(valor);
  if (Math.abs(valor - redondeado) < 0.05) return `${redondeado}%`;
  return `${valor.toFixed(1)}%`;
}

function formatearResumenVariedades(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = item.nombre || item.variedad || "";
      const pct = formatearPctVariedad(
        Number.isFinite(item.porcentaje) ? item.porcentaje : Number(item.pct)
      );
      return nombre ? `${pct} ${nombre}` : "";
    })
    .filter(Boolean)
    .join(" / ");
}

function guardarComposicionEnNodo(nodo, mix, total) {
  if (!nodo) return [];
  nodo.datos = nodo.datos || {};
  const composicion = mixToArray(mix, total);
  // Mezcla dinámica calculada en el flujo
  nodo.datos.composicionVariedades = composicion;
  if (composicion.length) {
    nodo.datos.variedad = composicion
      .map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`)
      .join(" / ");
  } else if (!nodo.datos.variedad && nodo.datos.variedadBase) {
    // Fallback solo si no hay mezcla y tampoco texto
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
  return composicion;
}

function calcularComposicionVariedades(nodo, visitados = new Set()) {
  const mix = new Map();
  if (!nodo) return { total: 0, mix };
  const key = nodo.id || nodo;
  if (visitados.has(key)) return { total: 0, mix };
  visitados.add(key);

  const pesoNumerico = valor => {
    const num = Number(valor);
    return Number.isFinite(num) && num > 0 ? num : 0;
  };
  const sumar = (variedad, cantidad) => {
    const cant = pesoNumerico(cantidad);
    if (!cant) return;
    agregarVariedadAPeso(mix, variedad, cant);
  };
  const totalizar = () => Array.from(mix.values()).reduce((acc, v) => acc + v, 0);

  if (nodo.tipo === "entrada") {
    const entrada = nodo.datos?.id_ref ? buscarEntradaPorId(nodo.datos.id_ref) : null;
    const variedad = entrada?.variedad || nodo.datos?.variedad || nodo.datos?.vino || "";
    const peso =
      pesoNumerico(entrada?.kilos ?? nodo.datos?.kilos ?? nodo.datos?.litros ?? nodo.datos?.volumen) ||
      1;
    agregarVariedadAPeso(mix, variedad, peso);
    return { total: totalizar(), mix };
  }

  const tieneAsignaciones = nodo.datos?.asignaciones && Object.keys(nodo.datos.asignaciones).length;
  if (tieneAsignaciones) {
    const permitidos = new Set(obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre)));
    Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
      if (!permitidos.has(origenId)) return;
      const kilos = pesoNumerico(normalizarNumero(info?.kilos));
      const litros = pesoNumerico(normalizarNumero(info?.litros));
      const cantidad = kilos + litros;
      if (!(cantidad > 0)) return;
      const origen = obtenerNodoPorId(origenId);
      const comp = calcularComposicionVariedades(origen, visitados);
      if (!comp.mix.size) return;
      const factor = comp.total > 0 ? cantidad / comp.total : 1;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, valor * factor);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
    // Si hay asignaciones pero sin cantidades, no forzamos porcentajes: seguimos con aportes/padres.
    // Solo si no hay otra fuente de cantidad, haremos fallback al final.
    // Si no hay cantidades válidas, seguimos buscando en padres o dato propio.
  }

  // Si el nodo tiene aportes acumulados (nodos de proceso/trasiegos), usamos esa mezcla directa.
  // Filtramos por predecesores actuales para evitar aportes huérfanos o incompletos.
  if (nodo.datos?.aportes) {
    const predecesores = obtenerPredecesores(nodo.id);
    const idsPermitidos = new Set(predecesores.map(pre => normalizarIdNodo(pre)));
    if (idsPermitidos.size) {
      const entries = Object.entries(nodo.datos.aportes).filter(([origenId]) =>
        idsPermitidos.has(String(origenId))
      );
      // Si faltan aportes para algún predecesor, preferimos calcular desde los padres.
      if (!(idsPermitidos.size > 1 && entries.length < idsPermitidos.size)) {
        const aportes = entries.map(([, a]) => a);
        const pesos = aportes.map(a => {
          return (
            pesoNumerico(a?.litros_directos) ||
            pesoNumerico(a?.litros) ||
            pesoNumerico(a?.kilos) ||
            0
          );
        });
        const hayPesos = pesos.some(p => p > 0);
        aportes.forEach((a, idx) => {
          if (!a?.variedad) return;
          const peso = pesos[idx] || 0;
          if (hayPesos) {
            if (!(peso > 0)) return;
            agregarVariedadAPeso(mix, a.variedad, peso);
            return;
          }
          // Si no hay cantidad válida en ningún aporte, mostramos mezcla visual a partes iguales.
          agregarVariedadAPeso(mix, a.variedad, 1);
        });
        const total = totalizar();
        if (total > 0 && mix.size) {
          return { total, mix };
        }
      }
    }
  }

  const padres = obtenerPredecesores(nodo.id);
  if (padres.length) {
    padres.forEach(pre => {
      const pesoBase =
        pesoNumerico(pre?.datos?.litros ?? pre?.datos?.volumen ?? pre?.datos?.kilos) || 1;
      const comp = calcularComposicionVariedades(pre, visitados);
      if (!comp.mix.size) return;
      const factor = comp.total > 0 ? pesoBase / comp.total : pesoBase;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, valor * factor);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
  }

  // Fallback final: si hay asignaciones pero no cantidades, mezclamos a partes iguales por origen
  // (p.ej. recién conectado pero sin litros/kilos asignados todavía).
  if (tieneAsignaciones) {
    const permitidos = new Set(obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre)));
    Object.keys(nodo.datos.asignaciones).forEach(origenId => {
      if (!permitidos.has(origenId)) return;
      const origen = obtenerNodoPorId(origenId);
      const comp = calcularComposicionVariedades(origen, visitados);
      if (!comp.mix.size) return;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, 1);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
  }

  const propia = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  const pesoPropio =
    pesoNumerico(nodo.datos?.kilos ?? nodo.datos?.litros ?? nodo.datos?.volumen) || 1;
  sumar(propia, pesoPropio);
  return { total: totalizar(), mix };
}

function formatearComposicionVariedades(mix, total) {
  const composicion = mixToArray(mix, total);
  if (!composicion.length) return "";
  return composicion.map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`).join(" / ");
}

function obtenerTextoVolumenNodo(nodo) {
  if (!nodo) return "";
  const unidad = obtenerUnidadVisual(nodo);
  const unidadLabel = unidad === "L" ? "L" : "kg";
  const valorVisual = obtenerVolumenVisualNodo(nodo);
  const esDepositoOCoupage = nodo.tipo === "deposito" || nodo.tipo === "coupage";
  const valLitros = esDepositoOCoupage
    ? normalizarNumero(nodo.datos?.volumen) ??
      normalizarNumero(nodo.datos?.litros) ??
      normalizarNumero(nodo.datos?.litros_directos)
    : normalizarNumero(nodo.datos?.litros_directos) ??
      normalizarNumero(nodo.datos?.litros) ??
      normalizarNumero(nodo.datos?.volumen);
  const valKilos = normalizarNumero(nodo.datos?.kilos);
  const valor =
    valorVisual != null
      ? valorVisual
      : unidad === "L"
      ? valLitros != null
        ? valLitros
        : valKilos
      : valKilos != null
      ? valKilos
      : valLitros;

  const capBase =
    normalizarNumero(nodo.datos?.capacidad) ??
    normalizarNumero(nodo.datos?.capacidad_l) ??
    (nodo.datos?.capacidad_hl != null
      ? normalizarNumero(nodo.datos.capacidad_hl * 100)
      : null);

  const redondear = v => (Number.isFinite(v) ? Number(v.toFixed(0)) : null);
  const cap = redondear(capBase);
  const cont = redondear(valor);

  if ((nodo.tipo === "deposito" || nodo.tipo === "barrica") && (cap != null || cont != null)) {
    if (cap != null && cont != null) return `Volumen ${cont}/${cap} ${unidadLabel}`;
    if (cap != null) return `Volumen ${cap} ${unidadLabel}`;
  }
  if (cont != null) {
    const etiqueta = unidad === "L" ? "Volumen" : "Kilos";
    return `${etiqueta} ${cont} ${unidadLabel}`;
  }
  return "";
}

function describirNodoOrigen(origen) {
  if (!origen) return "Nodo";
  const base = origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
  const variedad = obtenerVariedadVisibleNodo(origen);
  if (origen.tipo === "estilo") {
    const metodo = origen.datos?.metodo ? ` · ${origen.datos.metodo}` : "";
    const variedadTexto = variedad ? ` (${variedad})` : "";
    return `${base}${metodo}${variedadTexto}`;
  }
  if (origen.tipo === "entrada") {
    if (origen.datos?.id_ref) {
      return obtenerEtiquetaEntrada(origen.datos.id_ref);
    }
    return variedad ? `${base} (${variedad})` : base;
  }
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    const info =
      origen.tipo === "deposito"
        ? buscarDepositoPorId(origen.datos?.id_ref)
        : (() => {
            const datos = origen.datos || {};
            const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
            const id = datos.contenedor_id || datos.id_ref;
            if (!id) return null;
            return tipoCont === "barrica" ? buscarBarricaPorId(id) : buscarDepositoPorId(id);
          })();
    const nombre = info?.codigo || origen.datos?.codigo || origen.titulo || base;
    const varTexto =
      info?.vino_tipo ||
      origen.datos?.vino_tipo ||
      origen.datos?.variedad ||
      variedad ||
      "";
    const varLabel = varTexto ? ` (${varTexto})` : "";
    return `${nombre}${varLabel}`;
  }
  return variedad ? `${base} (${variedad})` : base;
}

function describirNodoDestino(dest) {
  if (!dest) return "Nodo";
  const contenedor = obtenerContenedorPorIdRef(dest.datos?.id_ref);
  if (contenedor) {
    const nombre =
      contenedor.codigo ||
      dest.datos?.codigo ||
      dest.titulo ||
      (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad =
      contenedor.variedad ||
      dest.datos?.vino_tipo ||
      dest.datos?.variedad ||
      "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  if (dest.tipo === "deposito") {
    const info = dest.datos?.id_ref ? buscarDepositoPorId(dest.datos.id_ref) : null;
    const nodosMap = getNodosPorId();
    const mapaDep = crearMapaDeposPorRef(nodosMap);
    const refKey = dest.datos?.id_ref != null ? String(dest.datos.id_ref) : null;
    const nombreMapa = refKey && mapaDep[refKey] ? mapaDep[refKey].codigo : null;
    const nombre =
      info?.codigo ||
      nombreMapa ||
      dest.datos?.codigo ||
      dest.titulo ||
      (dest.datos?.id_ref ? `Depósito #${dest.datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || dest.datos?.vino_tipo || dest.datos?.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  return etiquetarDestinoFlow(dest);
}

function obtenerContenedorPrevio(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return null;
  visitados.add(origen.id);
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    return origen;
  }
  const padres = obtenerPredecesores(origen.id);
  for (const pre of padres) {
    const encontrado = obtenerContenedorPrevio(pre, visitados);
    if (encontrado) return encontrado;
  }
  return null;
}

function nombreOrigenBlend(origen) {
  if (!origen) return "Origen";
  const datos = origen.datos || {};
  const contenedorPrevio = obtenerContenedorPrevio(origen);
  if (contenedorPrevio && contenedorPrevio !== origen) {
    return nombreOrigenBlend(contenedorPrevio);
  }
  if (origen.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      (datos.id_ref ? `Depósito ${datos.id_ref}` : "Depósito")
    );
  }
  if (origen.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback = datos.contenedor_id
      ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
      : "";
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza"
    );
  }
  if (origen.tipo === "entrada") {
    return datos.id_ref ? obtenerEtiquetaEntrada(datos.id_ref) : origen.titulo || "Entrada";
  }
  return origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
}

function obtenerEtiquetaEntrada(id) {
  if (!id) return "";
  const entrada = cacheEntradas.find(e => String(e.id) === String(id));
  if (!entrada) return `Entrada #${id}`;
  const variedad = entrada.variedad ? ` (${entrada.variedad})` : "";
  return `Entrada #${id}${variedad}`;
}

function buscarEntradaPorId(id) {
  if (!id || !Array.isArray(cacheEntradas)) return null;
  return cacheEntradas.find(e => String(e.id) === String(id)) || null;
}

function buscarDepositoPorId(id) {
  if (!id || !Array.isArray(cacheDepositos)) return null;
  const dep = cacheDepositos.find(d => String(d.id) === String(id));
  if (dep) return dep;
  if (Array.isArray(cacheMastelones)) {
    const mas = cacheMastelones.find(m => String(m.id) === String(id));
    if (mas) return mas;
  }
  return null;
}

function buscarDepositoPorCodigo(codigo) {
  if (!codigo) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  const dep =
    (cacheDepositos || []).find(d => (d.codigo || "").toLowerCase() === codNorm) ||
    (cacheMastelones || []).find(d => (d.codigo || "").toLowerCase() === codNorm);
  return dep || null;
}

function resolverInfoDepositoDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "deposito") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.id_ref) {
    info = buscarDepositoPorId(datos.id_ref);
  }
  if (!info && datos.codigo) {
    info = buscarDepositoPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarDepositoPorCodigo(nodo.titulo);
  }
  return info;
}

function buscarBarricaPorId(id) {
  if (!id || !Array.isArray(cacheBarricas)) return null;
  return cacheBarricas.find(b => String(b.id) === String(id)) || null;
}

function buscarBarricaPorCodigo(codigo) {
  if (!codigo || !Array.isArray(cacheBarricas)) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  return cacheBarricas.find(b => (b.codigo || "").toLowerCase() === codNorm) || null;
}

function resolverInfoBarricaDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.contenedor_id) {
    info = buscarBarricaPorId(datos.contenedor_id);
  }
  if (!info && datos.codigo) {
    info = buscarBarricaPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarBarricaPorCodigo(nodo.titulo);
  }
  return info;
}

function obtenerContenedorPorIdRef(idRef) {
  if (!idRef) return null;
  const dep = buscarDepositoPorId(idRef);
  if (dep) {
    return { tipo: "deposito", codigo: dep.codigo, variedad: dep.vino_tipo };
  }
  const bar = buscarBarricaPorId(idRef);
  if (bar) {
    return { tipo: "barrica", codigo: bar.codigo, variedad: bar.vino_tipo };
  }
  return null;
}

function rellenarDatosDepositoDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "deposito" || !nodo.datos?.id_ref) return;
  const info = buscarDepositoPorId(nodo.datos.id_ref);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    nodo.datos.capacidad ||
    info.capacidad_l ||
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.vino_tipo = nodo.datos.vino_tipo || info.vino_tipo;
  const tieneMezcla = Array.isArray(nodo.datos.composicionVariedades) && nodo.datos.composicionVariedades.length > 0;
  nodo.datos.variedadBase = nodo.datos.variedadBase || info.vino_tipo || nodo.datos.variedad || "";
  if (!tieneMezcla && !nodo.datos.variedad) {
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
}

function rellenarDatosCrianzaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const tipoCont = claveContenedor(nodo.datos?.contenedor_tipo) || "barrica";
  const id = nodo.datos?.contenedor_id || nodo.datos?.id_ref;
  if (!id) return;
  const info =
    tipoCont === "barrica"
      ? buscarBarricaPorId(id) || buscarBarricaPorCodigo(nodo.datos?.codigo || nodo.titulo)
      : buscarDepositoPorId(id) || buscarDepositoPorCodigo(nodo.datos?.codigo || nodo.titulo);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  const capInfo =
    info.capacidad_l ??
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : null) ??
    nodo.datos.capacidad;
  if (capInfo != null) {
    nodo.datos.capacidad = capInfo;
    nodo.datos.capacidad_l = capInfo;
  }
  const volumenInfo = info.litros_actuales ?? info.volumen ?? null;
  if (volumenInfo != null) {
    nodo.datos.volumen = volumenInfo;
    nodo.datos.litros = volumenInfo;
    nodo.datos.litros_directos = volumenInfo;
  }
  nodo.datos.vino_tipo = nodo.datos.vino_tipo || info.vino_tipo;
  const tieneMezcla = Array.isArray(nodo.datos.composicionVariedades) && nodo.datos.composicionVariedades.length > 0;
  nodo.datos.variedadBase = nodo.datos.variedadBase || info.vino_tipo || nodo.datos.variedad || "";
  if (!tieneMezcla && !nodo.datos.variedad) {
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
  // Texto descriptivo del contenedor elegido para mostrar en modal/nodo.
  const tipoLabel = nodo.datos.contenedor_tipo || (tipoCont === "barrica" ? "Barrica" : "Depósito");
  const descripcion = describirContenedor(info, tipoLabel);
  if (descripcion) {
    nodo.datos.tipo = descripcion;
  } else if (tipoLabel) {
    nodo.datos.tipo = tipoLabel;
  }
}

// Cargar nodos (preferimos el estado en memoria) y mapear por id
function getNodosPorId() {
  const enMemoria = Array.isArray(flujoNodos) ? flujoNodos : [];
  const nodos =
    enMemoria.length > 0
      ? enMemoria
      : JSON.parse(localStorage.getItem("flowNodes") || "[]");
  return Object.fromEntries(nodos.map(n => [n.id, n]));
}

function crearMapaDeposPorRef(nodosPorId) {
  const mapa = {};
  Object.values(nodosPorId || {}).forEach(nodo => {
    if (nodo.tipo === "deposito" && nodo.datos?.id_ref != null) {
      const clave = String(nodo.datos.id_ref);
      rellenarDatosDepositoDesdeCache(nodo);
      if (!mapa[clave]) {
        mapa[clave] = {
          codigo: nodo.datos.codigo || nodo.titulo || `Depósito #${clave}`,
          nodoId: nodo.id,
        };
      }
    }
  });
  return mapa;
}

function getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef) {
  const nodo = nodosPorId[idNodoDestino];
  if (!nodo) return `Nodo ${idNodoDestino}`;

  const datos = nodo.datos || {};
  const mapa = mapaDepRef || crearMapaDeposPorRef(nodosPorId);

  switch (nodo.tipo) {
    case "deposito":
      // A1, A2, A3…
      if (datos.id_ref != null) {
        const depMap = mapa[String(datos.id_ref)];
        if (depMap?.codigo) return depMap.codigo;
        const info = buscarDepositoPorId(datos.id_ref);
        if (info?.codigo) return info.codigo;
      }
      return `${datos.codigo || nodo.titulo || "Depósito"}`;

    case "barrica":
      // Crianza / Barrica 500L Francés, etc.
      return nodo.titulo || datos.tipo || "Crianza";

    case "entrada":
      // Solo por si algún día enlazas a otra entrada
      return `Entrada #${datos.id_ref || "?"}${
        datos.variedad ? ` (${datos.variedad})` : ""
      }`;

    default:
      return nodo.titulo || nodo.tipo || `Nodo ${idNodoDestino}`;
  }
}

function buildRepartoDestinos(nodoElaboracion) {
  if (!nodoElaboracion) return [];
  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const distribucion = nodoElaboracion.datos?.distribucion || {};
  return Object.entries(distribucion).map(([idNodoDestino, valores]) => {
    return {
      idNodoDestino,
      nombre: getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef),
      kilos: (valores && valores.kilos) || 0,
      litros: (valores && valores.litros) || 0,
    };
  });
}

function etiquetarDestinoFlow(dest) {
  if (!dest) return "Nodo";
  const datos = dest.datos || {};

  if (dest.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    const nombre =
      info?.codigo ||
      datos.codigo ||
      dest.titulo ||
      (datos.id_ref ? `Depósito #${datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback =
      datos.contenedor_id
        ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
        : "";
    const nombre =
      info?.codigo ||
      dest.titulo ||
      datos.codigo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza";
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "entrada" && datos.id_ref) {
    return obtenerEtiquetaEntrada(datos.id_ref);
  }

  // Si viene con id_ref de contenedor aunque el tipo no sea depósito/barrica, intentamos resolverlo
  const contenedor = obtenerContenedorPorIdRef(datos.id_ref);
  if (contenedor) {
    const nombre = contenedor.codigo || dest.titulo || (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad = contenedor.variedad || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  return dest.titulo || dest.tipo || "Nodo";
}

function obtenerEtiquetaNodoLimite(nodo) {
  if (!nodo) return "Este nodo";
  if (nodo.tipo === "entrada") {
    return obtenerEtiquetaEntrada(nodo.datos?.id_ref) || "Esta entrada";
  }
  if (nodo.tipo === "deposito") {
    return nodo.datos?.codigo || nodo.titulo || "Depósito";
  }
  return nodo.titulo || "Este nodo";
}

	function sumarConsumoDesdeNodo(origen) {
	  if (!origen) return 0;
	  const unidad = obtenerUnidadNodo(origen);
	  const origenKey = normalizarIdNodo(origen);
	  return (origen.targets || []).reduce((total, targetId) => {
	    const destino = obtenerNodoPorId(targetId);
	    if (!destino) return total;

	    const registroAsignacion =
	      destino.datos?.asignaciones?.[origenKey] ||
	      destino.datos?.asignaciones?.[String(origen.id)];
	    // En contenedores (depósito/coupage), la fuente de verdad para el consumo son las asignaciones (tabla).
	    if (registroAsignacion && (destino.tipo === "deposito" || destino.tipo === "coupage")) {
	      const litros = normalizarNumero(registroAsignacion.litros) || 0;
	      const kilos = normalizarNumero(registroAsignacion.kilos) || 0;
	      const valor =
	        unidad === "litros"
	          ? litros > 0
	            ? litros
	            : kilos
	          : kilos > 0
	          ? kilos
	          : litros;
	      return total + (valor > 0 ? valor : 0);
	    }

	    const aporte =
	      destino.datos?.aportes?.[origenKey] ||
	      destino.datos?.aportes?.[String(origen.id)];
	    if (aporte) {
	      const litros = normalizarNumero(aporte.litros_directos ?? aporte.litros) || 0;
	      const kilos = normalizarNumero(aporte.kilos) || 0;
	      const valor =
	        unidad === "litros"
	          ? litros > 0
	            ? litros
	            : kilos
	          : kilos > 0
	          ? kilos
	          : litros;
	      return total + (valor > 0 ? valor : 0);
	    }

	    if (registroAsignacion) {
	      const litros = normalizarNumero(registroAsignacion.litros) || 0;
	      const kilos = normalizarNumero(registroAsignacion.kilos) || 0;
	      const valor =
	        unidad === "litros"
	          ? litros > 0
	            ? litros
	            : kilos
	          : kilos > 0
	          ? kilos
	          : litros;
	      return total + (valor > 0 ? valor : 0);
	    }
	    return total;
	  }, 0);
	}

function obtenerLimiteNodo(nodo) {
  if (!nodo) return null;
  const unidad = obtenerUnidadNodo(nodo);
  // Recalcular/normalizar la carga antes de validar para evitar inconsistencias visual vs. validación.
  const carga = obtenerCargaDesdeNodo(nodo);
  if (unidad === "litros") {
    const litros = normalizarNumero(carga?.litros_directos ?? carga?.litros);
    if (litros != null) return litros;
    const kilosComoLitros = normalizarNumero(carga?.kilos ?? nodo.datos?.kilos);
    return kilosComoLitros != null ? kilosComoLitros : null;
  }
  const kilos = normalizarNumero(carga?.kilos ?? nodo.datos?.kilos);
  if (kilos != null) return kilos;
  const fallback = normalizarNumero(
    carga?.litros_directos ??
      carga?.litros ??
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos
  );
  return fallback != null ? fallback : null;
}

function obtenerVolumenRestanteNodo(nodo) {
  if (!nodo) return null;
  const limite = obtenerLimiteNodo(nodo);
  if (limite == null) return null;
  // La entrada de uva es una referencia: sus kilos no se descuentan visualmente.
  if (nodo.tipo === "entrada") return limite;
  const consumo = sumarConsumoDesdeNodo(nodo);
  const consumoSeguro = Number.isFinite(consumo) ? consumo : 0;
  const restante = Number(limite) - consumoSeguro;
  if (!Number.isFinite(restante)) return null;
  return Math.max(0, restante);
}

function validarLimitesFlujo() {
  for (const nodo of flujoNodos) {
    const limite = obtenerLimiteNodo(nodo);
    if (limite == null) continue;
    const consumoAsignaciones = sumarConsumoDesdeNodo(nodo);
    const consumo = consumoAsignaciones;
    if (consumo > limite + 0.0001) {
      return {
        ok: false,
        nodo,
        consumo,
        limite,
        unidad: obtenerUnidadVisual(nodo),
      };
    }
  }
  return { ok: true };
}

function obtenerFechaNodoParaReplay(nodo) {
  if (!nodo) return null;
  const datos = nodo.datos || {};
  const raw = datos.fecha_operacion || datos.fecha || datos.fecha_hora || "";
  const fecha = parsearFechaValor(String(raw || ""));
  return fecha ? fecha.getTime() : null;
}

function obtenerLitrosTransferenciaEntreNodos(origen, destino) {
  if (!origen || !destino) return 0;
  const key = normalizarIdNodo(origen);
  const datos = destino.datos || {};
  const regAsig = datos.asignaciones?.[key] || datos.asignaciones?.[String(origen.id)];
  if (regAsig) {
    const litros = normalizarNumero(regAsig.litros);
    if (litros != null) return litros > 0 ? litros : 0;
  }
  const aporte = datos.aportes?.[key] || datos.aportes?.[String(origen.id)];
  if (aporte) {
    const litros = normalizarNumero(aporte.litros_directos ?? aporte.litros);
    if (litros != null) return litros > 0 ? litros : 0;
  }
  return 0;
}

function construirModeloReplayFlujo(rootId) {
  const root = obtenerNodoPorId(rootId);
  if (!root) return null;

  const rootNorm = normalizarIdNodo(root);
  const nodesSet = new Set();
  const stack = [rootNorm];
  while (stack.length) {
    const id = stack.pop();
    if (!id || nodesSet.has(id)) continue;
    nodesSet.add(id);
    const nodo = obtenerNodoPorId(id);
    if (!nodo) continue;
    (nodo.targets || []).forEach(t => {
      const tid = normalizarIdNodo(t);
      if (tid && !nodesSet.has(tid)) stack.push(tid);
    });
  }

  const nodes = new Map();
  nodesSet.forEach(id => {
    const nodo = obtenerNodoPorId(id);
    if (nodo) nodes.set(id, nodo);
  });

  const nodeTs = new Map();
  let sinFecha = 0;
  nodes.forEach((nodo, id) => {
    const ts = obtenerFechaNodoParaReplay(nodo);
    if (ts == null) sinFecha += 1;
    else nodeTs.set(id, ts);
  });

  const rootTs = nodeTs.get(rootNorm) ?? null;
  const pasosOrdenados = Array.from(new Set(Array.from(nodeTs.values()))).sort((a, b) => a - b);
  const pasos = rootTs != null ? pasosOrdenados.filter(ts => ts >= rootTs) : pasosOrdenados;

  const edges = [];
  const inCount = new Map();
  nodes.forEach((origen, origenId) => {
    (origen.targets || []).forEach(destIdRaw => {
      const destId = normalizarIdNodo(destIdRaw);
      if (!destId || !nodes.has(destId)) return;
      const destino = nodes.get(destId);
      const litros = obtenerLitrosTransferenciaEntreNodos(origen, destino);
      const ts = nodeTs.get(destId) ?? null;
      edges.push({ origenId, destId, litros, ts });
      inCount.set(destId, (inCount.get(destId) || 0) + 1);
    });
  });

  const baseLitros = new Map();
  nodes.forEach((nodo, id) => {
    const tieneEntradas = (inCount.get(id) || 0) > 0;
    if (tieneEntradas) {
      baseLitros.set(id, 0);
      return;
    }
    const datos = nodo.datos || {};
    const baseRaw =
      normalizarNumero(datos.litros_directos) ??
      normalizarNumero(datos.litros) ??
      normalizarNumero(datos.volumen) ??
      0;
    const base = Number.isFinite(baseRaw) && baseRaw > 0 ? baseRaw : 0;
    baseLitros.set(id, base);
  });

  return {
    rootId: rootNorm,
    nodesSet,
    nodes,
    nodeTs,
    pasos,
    edges,
    baseLitros,
    sinFecha,
  };
}

function calcularEstadoReplayFlujo(model, timeMs) {
  const activeNodes = new Set();
  model.nodes.forEach((nodo, id) => {
    const ts = model.nodeTs.get(id);
    if (ts == null || ts <= timeMs) activeNodes.add(id);
  });

  const inflow = new Map();
  const outflow = new Map();
  const currentEdges = new Set();

  model.edges.forEach(edge => {
    if (!activeNodes.has(edge.destId) || !activeNodes.has(edge.origenId)) return;
    if (edge.ts != null && edge.ts === timeMs) {
      currentEdges.add(`${edge.origenId}→${edge.destId}`);
    }
    const litros = normalizarNumero(edge.litros) || 0;
    if (!(litros > 0)) return;
    inflow.set(edge.destId, (inflow.get(edge.destId) || 0) + litros);
    outflow.set(edge.origenId, (outflow.get(edge.origenId) || 0) + litros);
  });

  const stockLitros = new Map();
  model.nodes.forEach((nodo, id) => {
    if (!FLOW_REPLAY_TIPOS_LITROS.has(nodo.tipo)) return;
    const base = model.baseLitros.get(id) || 0;
    const inL = inflow.get(id) || 0;
    const outL = outflow.get(id) || 0;
    const v = base + inL - outL;
    stockLitros.set(id, Math.max(0, Number(v.toFixed(4))));
  });

  return { activeNodes, inflow, outflow, stockLitros, currentEdges };
}

function obtenerVolumenVisualNodo(nodo) {
  if (!nodo) return null;
  const nodoId = normalizarIdNodo(nodo);
  if (flowReplay?.activo && flowReplay.model && flowReplay.state && flowReplay.model.nodesSet?.has(nodoId)) {
    if (nodo.tipo === "entrada") {
      const limite = obtenerLimiteNodo(nodo);
      return limite != null ? limite : null;
    }
    if (FLOW_REPLAY_TIPOS_LITROS.has(nodo.tipo)) {
      const activo = flowReplay.state.activeNodes?.has(nodoId);
      if (!activo) return 0;
      const v = flowReplay.state.stockLitros?.get(nodoId);
      return v != null ? v : 0;
    }
  }
  return obtenerVolumenRestanteNodo(nodo);
}

function formatearFechaReplay(ms) {
  if (ms == null) return "—";
  const d = new Date(ms);
  if (Number.isNaN(d.getTime())) return "—";
  return d.toLocaleDateString("es-ES");
}

function actualizarUIReplayFlujo() {
  const section = document.getElementById("flujo");
  const bar = document.getElementById("flowReplayBar");
  const toggleBtn = document.getElementById("flowReplayToggleBtn");
  const range = document.getElementById("flowReplayRange");
  const dateEl = document.getElementById("flowReplayDate");
  const sub = document.getElementById("flowReplaySub");
  const hint = document.getElementById("flowReplayHint");
  const playBtn = document.getElementById("flowReplayPlayBtn");

  const activo = Boolean(flowReplay?.activo && flowReplay.model);
  if (section) section.classList.toggle("replay-mode", activo);
  if (bar) bar.classList.toggle("visible", activo);
  if (toggleBtn) toggleBtn.textContent = activo ? "Salir replay" : "🎞 Replay";

  if (!activo) {
    if (playBtn) playBtn.textContent = "⏵";
    return;
  }

  const pasos = flowReplay.model.pasos || [];
  const max = Math.max(0, pasos.length - 1);
  if (range) {
    range.min = "0";
    range.max = String(max);
    range.step = "1";
    range.value = String(Math.min(flowReplay.idx || 0, max));
    range.disabled = max <= 0;
  }

  if (dateEl) {
    dateEl.textContent = pasos.length ? formatearFechaReplay(flowReplay.timeMs) : "Sin fechas";
  }

  if (sub) {
    const root = obtenerNodoPorId(flowReplay.rootId);
    const rootLabel = root ? root.titulo || root.tipo || "Nodo" : "Nodo";
    const sinFecha = flowReplay.model.sinFecha || 0;
    const extra = sinFecha ? ` · ${sinFecha} nodo(s) sin fecha` : "";
    sub.textContent = `Replay de: ${rootLabel}${extra}`;
  }

  if (hint) {
    hint.textContent = pasos.length
      ? "Hover en una conexión para ver litros y fecha. Las conexiones futuras se muestran punteadas."
      : "No hay fechas en este recorrido. Añade “Fecha operación” en los nodos para usar Replay.";
  }

  if (playBtn) {
    playBtn.textContent = flowReplay.playing ? "⏸" : "⏵";
  }
}

function obtenerEntradasAncestroParaReplay(nodoId) {
  const start = obtenerNodoPorId(nodoId);
  if (!start) return [];
  const visitados = new Set();
  const entradas = new Map();
  const stack = [normalizarIdNodo(start)];
  while (stack.length) {
    const actualId = stack.pop();
    if (!actualId || visitados.has(actualId)) continue;
    visitados.add(actualId);
    const nodo = obtenerNodoPorId(actualId);
    if (!nodo) continue;
    if (nodo.tipo === "entrada") {
      entradas.set(actualId, nodo);
      continue;
    }
    const padres = obtenerPredecesores(actualId);
    padres.forEach(pre => {
      const pid = normalizarIdNodo(pre);
      if (pid && !visitados.has(pid)) stack.push(pid);
    });
  }
  return Array.from(entradas.values());
}

function iniciarReplayFlujo() {
  if (!nodoSeleccionadoId) {
    mostrarAviso("Selecciona una entrada (o un nodo de su recorrido) para iniciar el replay.", "info");
    return;
  }
  const seleccionado = obtenerNodoPorId(nodoSeleccionadoId);
  if (!seleccionado) {
    mostrarAviso("No se encontró el nodo seleccionado.", "error");
    return;
  }
  let entradaRoot = null;
  if (seleccionado.tipo === "entrada") {
    entradaRoot = seleccionado;
  } else {
    const entradas = obtenerEntradasAncestroParaReplay(seleccionado.id);
    if (!entradas.length) {
      mostrarAviso("Este nodo no tiene una entrada de uva asociada aguas arriba.", "error");
      return;
    }
    if (entradas.length > 1) {
      const etiquetas = entradas
        .slice(0, 6)
        .map(e => (e.datos?.id_ref ? `Entrada #${e.datos.id_ref}` : e.titulo || "Entrada"))
        .join(", ");
      mostrarAviso(
        `Hay varias entradas posibles (${etiquetas}${entradas.length > 6 ? ", …" : ""}). Selecciona una entrada y vuelve a pulsar Replay.`,
        "info"
      );
      return;
    }
    entradaRoot = entradas[0];
    nodoSeleccionadoId = entradaRoot.id;
  }

  const model = construirModeloReplayFlujo(entradaRoot.id);
  if (!model) {
    mostrarAviso("No se pudo construir el replay para este nodo.", "error");
    return;
  }
  flowReplay.activo = true;
  flowReplay.playing = false;
  flowReplay.rootId = model.rootId;
  flowReplay.model = model;
  flowReplay.idx = 0;
  flowReplay.timeMs = model.pasos.length ? model.pasos[0] : Date.now();
  flowReplay.state = calcularEstadoReplayFlujo(model, flowReplay.timeMs);
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function salirReplayFlujo() {
  if (flowReplay.timer) {
    clearInterval(flowReplay.timer);
    flowReplay.timer = null;
  }
  flowReplay.playing = false;
  flowReplay.activo = false;
  flowReplay.rootId = null;
  flowReplay.model = null;
  flowReplay.state = null;
  flowReplay.idx = 0;
  flowReplay.timeMs = null;
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function toggleReplayFlujo() {
  if (flowReplay?.activo) {
    salirReplayFlujo();
    return;
  }
  iniciarReplayFlujo();
}

function onReplayRangeInput(valor) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  if (!pasos.length) return;
  const idx = Math.max(0, Math.min(Number(valor) || 0, pasos.length - 1));
  flowReplay.idx = idx;
  flowReplay.timeMs = pasos[idx];
  flowReplay.state = calcularEstadoReplayFlujo(flowReplay.model, flowReplay.timeMs);
  if (flowReplay.playing && idx >= pasos.length - 1) {
    togglePlayReplayFlujo(false);
  }
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function replayPasoFlujo(delta) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  if (!pasos.length) return;
  const max = pasos.length - 1;
  const next = Math.max(0, Math.min(max, (flowReplay.idx || 0) + (delta || 0)));
  const range = document.getElementById("flowReplayRange");
  flowReplay.idx = next;
  flowReplay.timeMs = pasos[next];
  flowReplay.state = calcularEstadoReplayFlujo(flowReplay.model, flowReplay.timeMs);
  if (range) range.value = String(next);
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function togglePlayReplayFlujo(force) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  const max = pasos.length - 1;
  const shouldPlay = force == null ? !flowReplay.playing : Boolean(force);

  if (!shouldPlay || max <= 0) {
    if (flowReplay.timer) clearInterval(flowReplay.timer);
    flowReplay.timer = null;
    flowReplay.playing = false;
    actualizarUIReplayFlujo();
    return;
  }

  if (flowReplay.timer) clearInterval(flowReplay.timer);
  flowReplay.playing = true;
  flowReplay.timer = setInterval(() => {
    const pasosLocal = flowReplay.model?.pasos || [];
    const maxLocal = pasosLocal.length - 1;
    if (!pasosLocal.length || flowReplay.idx >= maxLocal) {
      togglePlayReplayFlujo(false);
      return;
    }
    replayPasoFlujo(1);
  }, FLOW_REPLAY_INTERVAL_MS);

  actualizarUIReplayFlujo();
}

function crearTablaControlFermentacion(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.control)) {
    nodo.datos.control = [];
  }
  const contenedor = document.createElement("div");
  contenedor.className = "tabla-control-fermentacion";

  const toolbar = document.createElement("div");
  toolbar.style.display = "flex";
  toolbar.style.justifyContent = "flex-end";
  toolbar.style.marginBottom = "6px";
  const btnPdf = document.createElement("button");
  btnPdf.type = "button";
  btnPdf.className = "small-btn";
  btnPdf.textContent = "PDF";
  btnPdf.addEventListener("click", () => exportarTablaControlPDF(nodo));
  toolbar.appendChild(btnPdf);
  contenedor.appendChild(toolbar);

  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Fecha</th>
      <th>Densidad</th>
      <th>°C</th>
      <th>Productos</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.control.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="5" style="text-align:center; color:#777;">Sin registros</td>`;
      tbody.appendChild(fila);
      return;
    }
    nodo.datos.control.forEach((registro, index) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="date" value="${registro.fecha || ""}" data-index="${index}" data-campo="fecha"></td>
        <td><input type="number" step="0.001" value="${registro.densidad || ""}" data-index="${index}" data-campo="densidad"></td>
        <td><input type="number" step="0.1" value="${registro.temperatura || ""}" data-index="${index}" data-campo="temperatura"></td>
        <td><input type="text" value="${registro.productos || ""}" data-index="${index}" data-campo="productos"></td>
        <td><button type="button" class="small-btn" data-index="${index}" data-accion="eliminar">✕</button></td>`;
      tbody.appendChild(tr);
    });
  };
  renderFilas();
  tabla.appendChild(tbody);
  tabla.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    guardarEstadoNodos();
  });
  tabla.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = btn.dataset.index;
    nodo.datos.control.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
  });
  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ Añadir control";
  btnAdd.addEventListener("click", () => {
    nodo.datos.control.push({
      fecha: nodo.datos.fecha_operacion || nodo.datos.fecha || "",
      densidad: "",
      temperatura: "",
      productos: "",
    });
    guardarEstadoNodos();
    renderFilas();
  });
  contenedor.appendChild(tabla);
  contenedor.appendChild(btnAdd);
  return contenedor;
}

function crearTablaAsignacionesDeposito(nodo, soloLectura = false) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  limpiarAsignacionesOrfanas(nodo);
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) {
    const mensaje =
      nodo.tipo === "coupage"
        ? "Conecta depósitos para seleccionar los litros de cada uno."
        : "Conecta este depósito para repartir kilos/litros.";
    wrapper.innerHTML = `<p style='font-size:13px; color:#666;'>${mensaje}</p>`;
    return wrapper;
  }
  nodo.datos = nodo.datos || {};
  nodo.datos.asignaciones = nodo.datos.asignaciones || {};
  const esCoupage = nodo.tipo === "coupage";
  if (esCoupage) {
    const infoDest = obtenerTotalesDestino(nodo);
    if (infoDest) {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#777";
      info.textContent = `Destino: capacidad ${infoDest.capTotal.toFixed(2)} L · Libre ${infoDest.libre.toFixed(2)} L`;
      wrapper.appendChild(info);
    } else {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#c06";
      info.textContent = "Conecta este blend a un destino (depósito o barrica) para ver la capacidad libre, o revisa que el destino tenga capacidad/volumen definidos.";
      wrapper.appendChild(info);
    }
  }
  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Origen</th>
        ${esCoupage ? "" : "<th>Kilos</th>"}
        <th>Litros</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  predecesores.forEach(origen => {
    const key = origen.id.toString();
    const cargaOrigen = obtenerCargaDesdeNodo(origen) || {};
    const kilosPorDefecto = Number(cargaOrigen.kilos || 0);
    const litrosPorDefecto = Number(cargaOrigen.litros_directos ?? (cargaOrigen.litros || 0));
    const litrosNodoDisponibles = (() => {
      if (!esCoupage) return litrosPorDefecto;
      if (origen.tipo === "deposito") {
        const idRef = origen.datos?.id_ref || origen.datos?.contenedor_id || origen.id;
        const idNum = idRef != null ? Number(idRef) : null;
        const vol = obtenerVolumenFinalNodoContenedor("deposito", idNum);
        if (Number.isFinite(vol)) return vol;
        const fallbackVol =
          origen.datos?.volumen ??
          origen.datos?.litros ??
          origen.datos?.litros_directos ??
          litrosPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      if (origen.tipo === "barrica") {
        const idRef = origen.datos?.contenedor_id || origen.datos?.id_ref || origen.id;
        const idNum = idRef != null ? Number(idRef) : null;
        const vol = obtenerVolumenFinalNodoContenedor("barrica", idNum);
        if (Number.isFinite(vol)) return vol;
        const fallbackVol =
          origen.datos?.volumen ??
          origen.datos?.litros ??
          origen.datos?.litros_directos ??
          litrosPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      return litrosPorDefecto;
    })();
    const registro = asegurarAsignacionRegistro(
      nodo,
      origen.id,
      esCoupage ? 0 : (Number.isFinite(kilosPorDefecto) && kilosPorDefecto > 0 ? kilosPorDefecto : 0),
      esCoupage ? 0 : (Number.isFinite(litrosPorDefecto) && litrosPorDefecto > 0 ? litrosPorDefecto : 0)
    );
    const tr = document.createElement("tr");
    const nombreBase = describirNodoOrigen(origen);
    const nombre = esCoupage
      ? nombreOrigenBlend(origen)
      : nombreBase;
    const disponibleTexto = esCoupage ? `Disponible: ${Number(litrosNodoDisponibles || 0).toFixed(2)} L` : describirNodoOrigen(origen);
    const valorKilos = registro.kilos && registro.kilos !== 0 ? registro.kilos : "";
    const valorLitros = registro.litros && registro.litros !== 0 ? registro.litros : "";
    tr.innerHTML = `
      <td>${nombre}<br><small>${disponibleTexto}</small></td>
      ${
        esCoupage
          ? ""
          : `<td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorKilos}" data-origen="${key}" data-tipo="kilos"></td>`
      }
      <td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorLitros}" data-origen="${key}" data-tipo="litros"${esCoupage && Number.isFinite(litrosNodoDisponibles) ? ` data-max-litros="${Number(litrosNodoDisponibles).toFixed(4)}"` : ""}></td>`;
    if (!soloLectura) {
      const inputs = tr.querySelectorAll("input");
      inputs.forEach(input => {
	        input.addEventListener("input", () => {
	          const valor = Number(input.value);
	          const tipo = input.dataset.tipo;
	          registro[tipo] = Number.isFinite(valor) ? valor : "";
	          registro.__manual = true;
	          if (esCoupage && tipo === "litros") {
	            const maxAttr = input.dataset.maxLitros;
	            const max = maxAttr != null ? Number(maxAttr) : null;
	            if (Number.isFinite(max) && max > 0 && valor > max) {
              registro.litros = max;
              input.value = max.toFixed(2);
              mostrarAviso("No puedes usar más litros de los disponibles en el depósito.", "error");
            }
            const capDestino = obtenerCapacidadDisponibleDesdeTargets(nodo);
            if (capDestino != null) {
              const totalAsignado = sumarAsignacionesLitros(nodo);
              if (totalAsignado > capDestino + 0.0001) {
                const restante = capDestino - (totalAsignado - (registro.litros || 0));
                const nuevoValor = Math.max(0, restante);
                registro.litros = nuevoValor;
                input.value = nuevoValor.toFixed(2);
                mostrarAviso(
                  `No caben más de ${capDestino.toFixed(2)} L en el destino del blend.`,
                  "error"
                );
              }
            }
          }
          actualizarVariedadDesdeAportes(nodo);
          actualizarVolumenDesdeAsignaciones(nodo);
          guardarEstadoNodos();
          renderFlowNodes();
        });
      });
    }
    tbody.appendChild(tr);
  });
  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function limpiarDistribucionEstilo(nodo) {
  if (!nodo || nodo.tipo !== "estilo" || !nodo.datos?.distribucion) return;
  const permitidos = new Set((nodo.targets || []).map(id => String(id)));
  Object.keys(nodo.datos.distribucion).forEach(key => {
    if (!permitidos.has(key)) {
      delete nodo.datos.distribucion[key];
    }
  });
}

function crearTablaDistribucionEstilo(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const distribucion = nodo.datos?.distribucion || {};
  const entradasDistrib = Object.entries(distribucion);
  if (!entradasDistrib.length) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta este nodo a otro para repartir los kilos/litros.</p>";
    return wrapper;
  }
  const mapaNodos = getNodosPorId();
  const cargaDisponible = obtenerCargaDesdeNodo(nodo) || {};
  const dispKilos = Number(cargaDisponible.kilos || 0);
  const dispLitros = Number(
    cargaDisponible.litros_directos != null
      ? cargaDisponible.litros_directos
      : cargaDisponible.litros || 0
  );
  const totDestinos = nodo.tipo === "coupage" ? obtenerTotalesDestino(nodo) : null;
  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  const infoCap =
    totDestinos
      ? ` | Destino: ${Number.isFinite(totDestinos.capTotal) ? totDestinos.capTotal.toFixed(2) + " L cap" : "capacidad n/d"} · Libre ${Number.isFinite(totDestinos.libre) ? totDestinos.libre.toFixed(2) + " L" : "—"}`
      : "";
  resumen.textContent = `Disponible: ${dispKilos.toFixed(2)} kg · ${dispLitros.toFixed(2)} L${infoCap}`;
  wrapper.appendChild(resumen);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Kilos</th>
        <th>Litros</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  const destinos = buildRepartoDestinos(nodo);

  destinos.forEach(dest => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${dest.nombre}</td>
      <td><input type="number" step="0.01" min="0" value="${dest.kilos || ""}" data-destino="${dest.idNodoDestino}" data-tipo="kilos"></td>
      <td><input type="number" step="0.01" min="0" value="${dest.litros || ""}" data-destino="${dest.idNodoDestino}" data-tipo="litros"></td>`;
    tr.querySelectorAll("input").forEach(input => {
      input.addEventListener("input", () => {
        const valor = Number(input.value);
        const tipo = input.dataset.tipo;
        if (!nodo.datos.distribucion[dest.idNodoDestino]) {
          nodo.datos.distribucion[dest.idNodoDestino] = { kilos: 0, litros: 0 };
        }
        nodo.datos.distribucion[dest.idNodoDestino][tipo] = Number.isFinite(valor) ? valor : "";
        guardarEstadoNodos();
        renderFlowNodes();
      });
    });
    tbody.appendChild(tr);
  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function obtenerCargaDistribuida(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "estilo") return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  if (!registro) return null;
  const kilos = normalizarNumero(registro.kilos);
  const litros = normalizarNumero(registro.litros);
  if (!(kilos > 0 || litros > 0)) return null;
  const carga = { ...cargaBase };
  if (kilos != null) {
    carga.kilos = kilos > 0 ? kilos : 0;
  }
  if (litros != null) {
    const litrosPositivos = litros > 0 ? litros : 0;
    carga.litros_directos = litrosPositivos;
    carga.litros = litrosPositivos;
  }
  return carga;
}


function actualizarVariedadDesdeAportes(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  nodo.datos = nodo.datos || {};
  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    } else {
      nodo.datos.composicionVariedades = [];
      nodo.datos.variedad = obtenerVariedadDesdeAsignaciones(nodo);
    }
  } catch (e) {
    console.warn("No se pudo recalcular la composición del nodo:", e);
  }
  actualizarVolumenDesdeAsignaciones(nodo);
}

function obtenerVariedadDesdeAsignaciones(nodo) {
  if (!nodo) return "";
  const variedadExistente = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  if (!nodo.datos?.asignaciones) return variedadExistente;
  const comp = calcularComposicionVariedades(nodo);
  const mezcla = formatearComposicionVariedades(comp.mix, comp.total);
  return mezcla || variedadExistente;
}

function capYVolDesdeInfo(info, fallbackCap, fallbackVol, extraCap = null) {
  if (!info && fallbackCap == null && fallbackVol == null && extraCap == null) return { cap: null, vol: null };
  const capRaw =
    (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
    fallbackCap ??
    extraCap;
  const volRaw =
    (info && (info.litros_actuales ?? info.volumen)) ??
    fallbackVol ??
    0;
  return { cap: Number(capRaw), vol: Number(volRaw) };
}

function capacidadDisponibleContenedorDesdeInfo(info, fallbackCap, fallbackVol) {
  const { cap, vol } = capYVolDesdeInfo(info, fallbackCap, fallbackVol);
  if (cap == null || Number.isNaN(cap)) return null;
  const capacidad = Number(cap);
  const volumen = Number(vol) || 0;
  if (!Number.isFinite(capacidad)) return null;
  return Math.max(0, capacidad - volumen);
}

function obtenerCapacidadDisponibleContenedor(nodoDestino) {
  if (!nodoDestino) return null;
  const datos = nodoDestino.datos || {};
  if (nodoDestino.tipo === "deposito") {
    const info = resolverInfoDepositoDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      datos.volumen ?? datos.litros ?? datos.litros_directos
    );
  }
  if (nodoDestino.tipo === "barrica") {
    const info = resolverInfoBarricaDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      datos.volumen ?? datos.litros ?? datos.litros_directos
    );
  }
  return null;
}

function obtenerTotalesDestino(nodo) {
  if (!nodo || !Array.isArray(nodo.targets) || !nodo.targets.length) return null;
  let capTotal = 0;
  let volTotal = 0;
  let tieneDestino = false;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const datos = dest.datos || {};
    tieneDestino = true;
    if (dest.tipo === "deposito") {
      if (datos.id_ref && (!datos.capacidad && !datos.capacidad_l)) {
        intentarPoblarNodoDeposito(dest);
      }
      const info = resolverInfoDepositoDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    } else if (dest.tipo === "barrica") {
      const info = resolverInfoBarricaDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    }
  });
  if (!tieneDestino) return null;
  const libreCalc = Number.isFinite(capTotal) ? Math.max(0, capTotal - volTotal) : null;
  return { capTotal, volTotal, libre: libreCalc };
}

function obtenerCapacidadDisponibleDesdeTargets(nodo) {
  if (!nodo || !Array.isArray(nodo.targets)) return null;
  let total = 0;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const cap = obtenerCapacidadDisponibleContenedor(dest);
    if (cap != null) total += cap;
  });
  return total > 0 ? total : null;
}

function sumarAsignacionesLitros(nodo) {
  if (!nodo?.datos?.asignaciones) return 0;
  return Object.values(nodo.datos.asignaciones).reduce((acc, reg) => {
    const val = Number(reg?.litros);
    return acc + (Number.isFinite(val) ? val : 0);
  }, 0);
}

function calcularTotalesAsignaciones(nodo) {
  if (!nodo?.datos?.asignaciones) return null;
  const permitidos = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  let totalKilos = 0;
  let totalLitros = 0;
  Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
    if (!permitidos.has(origenId)) return;
    const kilos = normalizarNumero(info?.kilos);
    const litros = normalizarNumero(info?.litros);
    if (litros > 0) totalLitros += litros;
    if (kilos > 0) totalKilos += kilos;
  });
  const total = totalLitros + totalKilos;
  if (total <= 0) return null;
  return { totalKilos, totalLitros, total }; 
}

function actualizarVolumenDesdeAsignaciones(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  nodo.datos = nodo.datos || {};
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) return;

  const total = predecesores.reduce(
    (acc, pre) => {
      const key = normalizarIdNodo(pre);
      const reg = nodo.datos?.asignaciones?.[key];
      const aporte = reg
        ? null
        : nodo.datos?.aportes?.[key] || nodo.datos?.aportes?.[String(pre.id)];
      const kilos = normalizarNumero(reg?.kilos ?? aporte?.kilos) || 0;
      const litros =
        normalizarNumero(reg?.litros ?? aporte?.litros_directos ?? aporte?.litros) || 0;
      if (kilos > 0) acc.totalKilos += kilos;
      if (litros > 0) acc.totalLitros += litros;
      return acc;
    },
    { totalKilos: 0, totalLitros: 0 }
  );

  if (!(total.totalKilos > 0 || total.totalLitros > 0)) return;

  nodo.datos.kilos = Number(total.totalKilos.toFixed(2));
  const volumenCalculado = total.totalLitros + total.totalKilos;
  const volumenFinal = Number(volumenCalculado.toFixed(2));

  nodo.datos.litros_directos = volumenFinal;
  nodo.datos.volumen = volumenFinal;
  nodo.datos.litros = volumenFinal;
  if (nodo.tipo === "coupage") {
    nodo.datos.litros_blend = nodo.datos.volumen;
  }
}

function obtenerEstadoDepositoDesdeNodo(idDeposito) {
  if (!idDeposito || !Array.isArray(flujoNodos)) return null;
  const volumenNodo = obtenerVolumenFinalNodoContenedor("deposito", idDeposito);
  let volumen = null;
  let variedadTexto = "";
  const nodoDeposito = flujoNodos.find(
    n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idDeposito)
  );
  if (nodoDeposito) {
    try {
      variedadTexto = obtenerVariedadVisibleNodo(nodoDeposito) || "";
    } catch (e) {
      console.warn("No se pudo calcular mezcla del depósito en mapa:", e);
    }
  }
  if (Number.isFinite(volumenNodo)) {
    volumen = volumenNodo;
  } else {
    if (!nodoDeposito) return null;
    actualizarVolumenDesdeAsignaciones(nodoDeposito);
    if (nodoDeposito.datos && nodoDeposito.datos.volumen != null) {
      volumen = Number(nodoDeposito.datos.volumen);
    }
  }
  return volumen != null
    ? {
        variedad: variedadTexto,
        volumen,
        enMapa: true,
      }
    : null;
}


const ETAPAS_FLUJO = [
  { id: "entrada", titulo: "Entrada de uva", unidad: "kg" },
  { id: "despalillado", titulo: "Despalillado", unidad: "L" },
  { id: "deposito", titulo: "Depósitos", unidad: "L" },
  { id: "barrica", titulo: "Barricas", unidad: "L" },
  { id: "embotellado", titulo: "Embotellado", unidad: "L" },
  { id: "salida", titulo: "Salida de bodega", unidad: "L" },
];
const OPCIONES_TIPO_CONTENEDOR = [
  "Siempre lleno",
  "Cerrado",
  "Mastelone",
  "Ánfora",
  "Foudre",
  "Barrica",
  "Damajuana",
];
const OPCIONES_MATERIAL_CONTENEDOR = [
  "Inox",
  "Fibra de vidrio",
  "Cemento",
  "Barro",
  "Madera",
  "Cristal",
  "Plástico alimentario",
];

function poblarSelectOpciones(selectId, opciones, placeholder = "Selecciona") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    select.appendChild(placeholderOption);
  }
  opciones.forEach(op => {
    const option = document.createElement("option");
    option.value = op;
    option.textContent = op;
    select.appendChild(option);
  });
  if (valorActual && opciones.includes(valorActual)) {
    select.value = valorActual;
  }
}

const FLOW_NODE_TYPES = {
  entrada: {
    label: "Entrada de uva",
    icono: "🍇",
    campos: [
      { id: "id_ref", label: "ID existente", tipo: "number", placeholder: "ID en Entradas" },
      { id: "kilos", label: "Kilos", tipo: "number", placeholder: "1000" },
      { id: "variedad", label: "Variedad", tipo: "text", placeholder: "Tempranillo" },
      { id: "densidad", label: "Densidad", tipo: "info" },
      { id: "temperatura", label: "Temperatura", tipo: "info" },
    ],
  },
  fermentacion: {
    label: "Fermentación",
    icono: "⚗️",
    campos: [
      {
        id: "estilo",
        label: "Fermentación / Elaboración",
        tipo: "select",
        opciones: ["FA", "FML"],
        placeholder: "Selecciona tipo",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  estilo: {
    label: "Elaboración",
    icono: "⚗️",
    campos: [
      { id: "kilos", label: "Kilos asignados", tipo: "info" },
      {
        id: "metodo",
        label: "Método de elaboración",
        tipo: "select",
        opciones: ["Despalillado", "Pisado", "Prensado", "Uva entera", "Mixto", "Sangrado", "Trasvase"],
      },
      { id: "descripcion", label: "Descripción de elaboración", tipo: "textarea", placeholder: "Detalles adicionales" },
    ],
  },
  deposito: {
    label: "Depósito",
    icono: "🛢️",
    campos: [
      { id: "id_ref", label: "Nombre de depósito", tipo: "number", placeholder: "Selecciona depósito" },
      { id: "capacidad", label: "Capacidad y volumen (L)", tipo: "info" },
      { id: "tipo", label: "Tipo", tipo: "info" },
      { id: "material", label: "Material", tipo: "info" },
      {
        id: "fase",
        label: "Estado",
        tipo: "select",
        opciones: ["FA", "FML", "CRIANZA"],
        placeholder: "Selecciona estado",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  coupage: {
    label: "Coupage / Blend",
    icono: "🍷",
    campos: [
      { id: "nombre_blend", label: "Nombre del coupage/vino", tipo: "text", placeholder: "Coupage Tempranillo-Malvar" },
      { id: "litros_blend", label: "Litros totales del blend", tipo: "info" },
      { id: "descripcion", label: "Notas del blend", tipo: "textarea", placeholder: "Proporciones, estilo..." },
    ],
  },
  barrica: {
    label: "Crianza",
    icono: '<img src="/barricas.png" alt="Barrica" style="width:26px;height:26px;object-fit:contain;vertical-align:middle;">',
    campos: [
      { id: "nombre_vino", label: "Nombre vino", tipo: "text", placeholder: "Nombre del vino en crianza" },
      {
        id: "contenedor_id",
        label: "Contenedor asignado",
        tipo: "select",
        opciones: [],
        placeholder: "Selecciona contenedor",
      },
      { id: "tipo", label: "Tipo de contenedor", tipo: "info" },
      { id: "tiempo", label: "Fin previsto de la crianza", tipo: "date", placeholder: "" },
      { id: "tiempo_estimado", label: "Duración estimada", tipo: "info" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Batonnage mensual" },
    ],
  },
  embotellado: {
    label: "Embotellado",
    icono: "🍾",
    campos: [
      {
        id: "botella",
        label: "Tipo de botella",
        tipo: "select",
        opciones: [
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgoña 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
      { id: "filtrado", label: "Filtrado", tipo: "text", placeholder: "Tierra blanca" },
      {
        id: "cierre",
        label: "Tipo de cierre",
        tipo: "select",
        opciones: [
          "Corcho natural",
          "Corcho técnico",
          "Corcho aglomerado",
          "Tapón sintético",
          "Stelvin / Screw-cap",
          "Corona",
          "Vidrio Vinolok",
          "Tapa de rosca",
        ],
        placeholder: "Selecciona cierre",
      },
      { id: "botellas_resultantes", label: "Botellas resultantes", tipo: "info" },
    ],
  },
  almacen: {
    label: "Almacén",
    icono: "📦",
    campos: [
      { id: "condicion", label: "Condición de guarda", tipo: "text", placeholder: "Horizontal, 15 ºC" },
      { id: "fecha", label: "Fecha de entrada", tipo: "date", placeholder: "" },
    ],
  },
  salida: {
    label: "Salida de bodega",
    icono: "🚛",
    campos: [
      { id: "destino", label: "Destino", tipo: "text", placeholder: "Cliente / País" },
      { id: "transporte", label: "Cantidad de salida (botellas)", tipo: "text", placeholder: "Palet / Caja / Botella" },
      {
        id: "formato_botella",
        label: "Formato de botella",
        tipo: "select",
        opciones: [
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgoña 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
    ],
  },
  prensado: {
    label: "Prensado",
    icono: "🌀",
    campos: [
      { id: "merma", label: "Merma (%)", tipo: "number", placeholder: "30" },
      { id: "presion", label: "Presión", tipo: "text", placeholder: "0.8 bar" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Observaciones" },
    ],
  },
};
Object.keys(FLOW_NODE_TYPES).forEach(key => {
  const tipo = FLOW_NODE_TYPES[key];
  tipo.campos = tipo.campos || [];
  const ids = new Set(tipo.campos.map(c => c.id));
  const esEntrada = key === "entrada";
  const asegurarCampo = (id, campo) => {
    if (!ids.has(id)) {
      tipo.campos.unshift({ id, ...campo });
      ids.add(id);
    }
  };
  asegurarCampo("fecha", {
    label: "Fecha de entrada",
    tipo: "info",
    soloLectura: true,
  });
  asegurarCampo("variedad", {
    label: "Variedad de uva",
    tipo: "text",
    placeholder: "Tempranillo",
    soloLectura: !esEntrada,
  });
  if (key !== "deposito" && key !== "entrada") {
    asegurarCampo("merma", {
      label: "Merma / pérdida (%)",
      tipo: "number",
      placeholder: "0",
    });
  }
  if (key !== "entrada") {
    asegurarCampo("fecha_operacion", {
      label: "Fecha operación",
      tipo: "date",
      placeholder: "",
    });
  }
});
	let datosEtapasFlujo = {};
		let flujoNodos = [];
		let nodoConectandoOrigen = null;
			let nodoSeleccionadoId = null;
			let nodoEnEdicion = null;
			let dragEstado = null;
			let ultimoNodoManual = null;
			let flowZoom = 1;
      let flowMinimapDrag = null;
      let flowMinimapRaf = null;
	  let flowReplay = {
	    activo: false,
	    playing: false,
	    rootId: null,
	    model: null,
	    state: null,
	    idx: 0,
	    timeMs: null,
	    timer: null,
	  };
	  const FLOW_REPLAY_INTERVAL_MS = 900;
	  const FLOW_REPLAY_TIPOS_LITROS = new Set(["deposito", "coupage", "barrica", "almacen", "embotellado", "salida"]);
			const FLOW_ZOOM_MIN = 0.3;
			const FLOW_ZOOM_MAX = 2;
			const FLOW_ZOOM_STEP = 0.1;
			const FLOW_WORLD_BASE = { width: 5000, height: 3000 };
	let filtrosMovimientos = {
  tipo: "",
  desde: "",
  hasta: "",
  contenedor: "",
  contenedor_tipo: "",
};
let filtroAnalisisDeposito = null;

function mostrarAviso(mensaje, tipo = "info") {
  const contenedor = document.getElementById("appAlerts");
  if (!contenedor) return;
  const toast = document.createElement("div");
  toast.className = `toast ${tipo}`;
  toast.textContent = mensaje;
  contenedor.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateX(20px)";
  }, 3500);
  setTimeout(() => toast.remove(), 4200);
}

function mostrarSkeletonTabla(tbodyId, columnas, filas = 3) {
  const tbody = document.getElementById(tbodyId);
  if (!tbody) return;
  const celda = '<td><div class="skeleton-line"></div></td>';
  const fila = `<tr>${celda.repeat(columnas)}</tr>`;
  tbody.innerHTML = new Array(filas).fill(fila).join("");
}

function setFormFeedback(id, mensaje, tipo = "info") {
  const elemento = document.getElementById(id);
  if (!elemento) return;
  elemento.textContent = mensaje || "";
  elemento.className = `form-feedback ${tipo === "error" ? "error" : tipo === "success" ? "success" : ""}`;
}

function obtenerAnadaDesdeFecha(fechaStr) {
  if (!fechaStr) return "";
  const match = fechaStr.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function obtenerValorAnada(valor) {
  if (!valor) return "Sin añada";
  return valor.toString();
}

function coincideConFiltros(anadaVal, vinoVal, filtros) {
  const anadaComparar = obtenerValorAnada(anadaVal);
  const vinoComparar = (vinoVal || "").trim() || "Sin clasificar";
  const okAnada = filtros.anada === "todos" || filtros.anada === anadaComparar;
  const okVino = filtros.vino === "todos" || vinoComparar === filtros.vino;
  return okAnada && okVino;
}

function obtenerInfoContenedor(tipo, id) {
  if (tipo === "deposito") {
    return mapaDepositosPorId && mapaDepositosPorId.get(id);
  }
  if (tipo === "mastelone") {
    return mapaMastelonesPorId && mapaMastelonesPorId.get(id);
  }
  if (tipo === "barrica") {
    return mapaBarricasPorId && mapaBarricasPorId.get(id);
  }
  return null;
}

function obtenerCapacidadFormateada(info) {
  if (!info) return "";
  const capacidad =
    info.capacidad_l != null
      ? Number(info.capacidad_l)
      : info.capacidad_hl != null
      ? Number(info.capacidad_hl) * 100
      : null;
  if (!Number.isFinite(capacidad) || capacidad <= 0) return "";
  return capacidad % 1 === 0 ? `${capacidad.toFixed(0)}L` : `${capacidad.toFixed(2)}L`;
}

function describirContenedor(info, tipoLabel) {
  const partes = [];
  if (tipoLabel) partes.push(tipoLabel);
  if (info) {
    const cap = obtenerCapacidadFormateada(info);
    if (cap) partes.push(cap);
    const material =
      info.material ||
      info.tipo_roble ||
      info.tipo ||
      info.marca ||
      info.clase ||
      "";
    if (material) partes.push(material);
  }
  return partes.join(" ").trim();
}

function parsearFechaValor(valor) {
  if (!valor) return null;
  let base = valor.trim();
  if (!base) return null;
  if (base.includes("/")) {
    const partes = base.split("/");
    if (partes.length === 3) {
      // dd/mm/yyyy -> yyyy-mm-dd
      base = `${partes[2]}-${partes[1].padStart(2, "0")}-${partes[0].padStart(2, "0")}`;
    }
  }
  const fecha = new Date(base);
  return isNaN(fecha.getTime()) ? null : fecha;
}

function calcularMesesEntre(fechaInicio, fechaFin) {
  const inicio = parsearFechaValor(fechaInicio);
  const fin = parsearFechaValor(fechaFin);
  if (!inicio || !fin) return null;
  let meses = (fin.getFullYear() - inicio.getFullYear()) * 12 + (fin.getMonth() - inicio.getMonth());
  if (fin.getDate() < inicio.getDate()) {
    meses -= 1;
  }
  if (meses < 0) meses = 0;
  return meses;
}

function actualizarDuracionPrevista(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const inicio = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const fin = nodo.datos?.tiempo;
  if (!inicio || !fin) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  const meses = calcularMesesEntre(inicio, fin);
  if (meses == null) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  nodo.datos.tiempo_estimado = meses === 1 ? "1 mes" : `${meses} meses`;
}

function refrescarDuracionModal(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  actualizarDuracionPrevista(nodo);
  const display = document.getElementById("flowField-tiempo_estimado-display");
  if (display) {
    display.textContent = nodo.datos?.tiempo_estimado || "—";
  }
  const hidden = document.getElementById("flowField-tiempo_estimado");
  if (hidden) {
    hidden.value = nodo.datos?.tiempo_estimado || "";
  }
}

function obtenerVinosEntrada(entrada) {
  const vinos = new Set();
  if (Array.isArray(entrada.destinos)) {
    entrada.destinos.forEach(dest => {
      const info = obtenerInfoContenedor(dest.contenedor_tipo, dest.contenedor_id);
      if (info && info.vino_tipo) {
        vinos.add(info.vino_tipo);
      }
    });
  }
  if (!vinos.size && entrada.variedad) {
    vinos.add(entrada.variedad);
  }
  return vinos;
}

function calcularDatosMapaFlujo() {
  const resultado = {
    entrada: { valor: 0, detalle: "" },
    despalillado: { valor: 0, detalle: "" },
    deposito: { valor: 0, detalle: "" },
    barrica: { valor: 0, detalle: "" },
    embotellado: { valor: 0, detalle: "" },
    salida: { valor: 0, detalle: "" },
  };

  const entradas = cacheEntradas || [];
  resultado.entrada.valor = entradas.reduce((acc, e) => acc + (Number(e.kilos) || 0), 0);
  resultado.entrada.detalle = `${entradas.length} entradas registradas`;

  let litrosDesp = 0;
  entradas.forEach(entrada => {
    if (Array.isArray(entrada.destinos) && entrada.destinos.length) {
      entrada.destinos.forEach(dest => {
        const kilos = Number(dest.kilos) || 0;
        if (dest.directo_prensa) {
          const merma = dest.merma_factor != null ? Number(dest.merma_factor) : FACTOR_MERMA_PRENSA;
          litrosDesp += kilos * (1 - merma);
        } else {
          litrosDesp += kilos;
        }
      });
    } else {
      litrosDesp += Number(entrada.kilos) || 0;
    }
  });
  resultado.despalillado.valor = litrosDesp;
  resultado.despalillado.detalle = "Estimación tras despalillado / prensado";

  const depositos = (cacheDepositos || []).concat(cacheMastelones || []);
  resultado.deposito.valor = depositos.reduce((acc, d) => acc + (Number(d.litros_actuales) || 0), 0);
  resultado.deposito.detalle = `${depositos.length} depósitos / mastelones`;

  const barricas = cacheBarricas || [];
  resultado.barrica.valor = barricas.reduce((acc, b) => acc + (Number(b.litros_actuales) || 0), 0);
  resultado.barrica.detalle = `${barricas.length} barricas activas`;

  const embotellados = cacheEmbotellados || [];
  resultado.embotellado.valor = embotellados.reduce((acc, e) => acc + (Number(e.litros) || 0), 0);
  resultado.embotellado.detalle = `${embotellados.length} lotes embotellados`;

  const salidas = (cacheMovimientos || []).filter(m => {
    const tipo = (m.tipo || "").toLowerCase();
    return tipo === "venta" || tipo === "salida" || tipo === "expedicion" || m.destino_tipo === "venta";
  });
  resultado.salida.valor = salidas.reduce((acc, m) => acc + (Number(m.litros) || 0), 0);
  resultado.salida.detalle = `${salidas.length} movimientos de salida`;

  return resultado;
}

function actualizarMapaFlujo() {
  datosEtapasFlujo = calcularDatosMapaFlujo();
}

function limitarZoomFlow(valor) {
  const num = Number(valor);
  if (!Number.isFinite(num)) return 1;
  return Math.min(Math.max(num, FLOW_ZOOM_MIN), FLOW_ZOOM_MAX);
}

function actualizarEtiquetaZoomFlow() {
  const label = document.getElementById("flowZoomLabel");
  if (!label) return;
  label.textContent = `${Math.round(flowZoom * 100)}%`;
}

function aplicarLayoutFlow({ mantenerCentro = false } = {}) {
  const editor = document.getElementById("flowEditor");
  const stage = document.getElementById("flowStage");
  const world = document.getElementById("flowWorld");
  if (!editor || !stage || !world) return;

  const prevZoom = flowZoom || 1;
  let centroWorld = null;
  if (mantenerCentro) {
    const cx = editor.scrollLeft + editor.clientWidth / 2;
    const cy = editor.scrollTop + editor.clientHeight / 2;
    centroWorld = { x: cx / prevZoom, y: cy / prevZoom };
  }

  flowZoom = limitarZoomFlow(flowZoom);
  world.style.width = `${FLOW_WORLD_BASE.width}px`;
  world.style.height = `${FLOW_WORLD_BASE.height}px`;
  world.style.transform = `scale(${flowZoom})`;
  stage.style.width = `${FLOW_WORLD_BASE.width * flowZoom}px`;
  stage.style.height = `${FLOW_WORLD_BASE.height * flowZoom}px`;

  if (centroWorld) {
    editor.scrollLeft = Math.max(0, centroWorld.x * flowZoom - editor.clientWidth / 2);
    editor.scrollTop = Math.max(0, centroWorld.y * flowZoom - editor.clientHeight / 2);
  }

  actualizarEtiquetaZoomFlow();
  programarActualizacionMinimapFlow();
}

function aplicarZoomMapaFlujo(nuevoZoom, { mantenerCentro = true } = {}) {
  flowZoom = limitarZoomFlow(nuevoZoom);
  aplicarLayoutFlow({ mantenerCentro });
  try {
    localStorage.setItem("flowZoom", String(flowZoom));
  } catch (err) {
    // noop
  }
  renderFlowConnections();
}

function zoomMapaFlujo(direccion) {
  const delta = Number(direccion) || 0;
  if (!delta) return;
  aplicarZoomMapaFlujo(flowZoom + delta * FLOW_ZOOM_STEP);
}

function resetZoomMapaFlujo() {
  aplicarZoomMapaFlujo(1);
}

function programarActualizacionMinimapFlow() {
  if (flowMinimapRaf) return;
  flowMinimapRaf = requestAnimationFrame(() => {
    flowMinimapRaf = null;
    actualizarMinimapFlow();
  });
}

function inicializarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const viewport = document.getElementById("flowMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("flowEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    flowMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapFlow(ev);
    world.addEventListener("pointermove", moverDesdeMinimapFlow);
    world.addEventListener("pointerup", finalizarMinimapFlow);
    world.addEventListener("pointercancel", finalizarMinimapFlow);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, editor } = flowMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / (rect.width || 1)) * (FLOW_WORLD_BASE.width || 1);
  const worldY = (relY / (rect.height || 1)) * (FLOW_WORLD_BASE.height || 1);
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, worldX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function finalizarMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, pointerId } = flowMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapFlow);
  world.removeEventListener("pointerup", finalizarMinimapFlow);
  world.removeEventListener("pointercancel", finalizarMinimapFlow);
  flowMinimapDrag = null;
}

function centrarNodoFlowEnVista(nodo) {
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!editor || !canvas) return;
  const el = Array.from(canvas.querySelectorAll(".flow-node")).find(n => n.dataset.id === nodo.id);
  const w = el ? el.offsetWidth : 160;
  const h = el ? el.offsetHeight : 110;
  const centerX = (Number(nodo.x) || 0) + w / 2;
  const centerY = (Number(nodo.y) || 0) + h / 2;
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, centerX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function actualizarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const dotsHost = document.getElementById("flowMinimapDots");
  const viewport = document.getElementById("flowMinimapViewport");
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const baseW = FLOW_WORLD_BASE.width || 1;
  const baseH = FLOW_WORLD_BASE.height || 1;
  const aspect = baseH / baseW;
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = flowZoom || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / baseW) * mmW}px`;
  viewport.style.top = `${(viewY / baseH) * mmH}px`;
  viewport.style.width = `${(viewW / baseW) * mmW}px`;
  viewport.style.height = `${(viewH / baseH) * mmH}px`;

  const nodeEls = Array.from(canvas.querySelectorAll(".flow-node"));
  dotsHost.innerHTML = "";
  nodeEls.forEach(nodeEl => {
    const id = nodeEl.dataset.id || "";
    const tipo = nodeEl.dataset.tipo || "";
    const x = parseFloat(nodeEl.style.left || "") || 0;
    const y = parseFloat(nodeEl.style.top || "") || 0;
    const cx = x + nodeEl.offsetWidth / 2;
    const cy = y + nodeEl.offsetHeight / 2;
    const px = (cx / baseW) * mmW;
    const py = (cy / baseH) * mmH;
    const dot = document.createElement("div");
    dot.className = `flow-minimap-dot ${tipo || ""}`;
    if (id && nodoSeleccionadoId && String(nodoSeleccionadoId) === String(id)) {
      dot.classList.add("seleccionado");
    }
    dot.style.left = `${px}px`;
    dot.style.top = `${py}px`;
    const nodo = id ? obtenerNodoPorId(id) : null;
    dot.title = nodo?.titulo ? nodo.titulo : tipo ? tipo : "Nodo";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!id) return;
      const nodoClick = obtenerNodoPorId(id);
      if (!nodoClick) return;
      nodoSeleccionadoId = nodoClick.id;
      renderFlowNodes();
      mostrarInfoNodo(nodoClick.id);
      requestAnimationFrame(() => centrarNodoFlowEnVista(nodoClick));
    });
    dotsHost.appendChild(dot);
  });
}

function exportarNodosComoImagen() {
  const editor = document.querySelector(".flow-editor");
  if (!editor) return;

  const descargarCanvas = canvas => {
    const data = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = data;
    link.download = "mapa-nodos.png";
    document.body.appendChild(link);
    link.click();
    link.remove();
  };

  const hacerCaptura = () => {
    if (window.html2canvas) {
      window.html2canvas(editor, {
        backgroundColor: "#0b0515",
        scale: 2,
        useCORS: true,
        logging: false,
      }).then(descargarCanvas);
      return true;
    }
    return false;
  };

  if (hacerCaptura()) return;

  // Cargar html2canvas al vuelo si no está disponible
  const script = document.createElement("script");
  script.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
  script.onload = () => hacerCaptura();
  script.onerror = () => mostrarAviso("No se pudo exportar la imagen. Intenta con otra captura.", "error");
  document.body.appendChild(script);
}

	async function inicializarFlowEditor() {
	  await cargarNodosGuardados();
	  try {
	    const savedZoom = Number(localStorage.getItem("flowZoom"));
	    if (Number.isFinite(savedZoom)) {
	      flowZoom = savedZoom;
	    }
	  } catch (err) {
	    // noop
	  }
	  flowZoom = limitarZoomFlow(flowZoom);
	  aplicarLayoutFlow();
	  renderFlowNodes();
	  const editor = document.getElementById("flowEditor");
	  if (editor) {
	    editor.addEventListener("scroll", programarActualizacionMinimapFlow, { passive: true });
	  }
	  const canvas = document.getElementById("flowCanvas");
		  if (canvas) {
		    canvas.addEventListener("click", e => {
		      if (!e.target.closest(".flow-node")) {
		        ocultarFlowTooltip();
		        nodoSeleccionadoId = null;
	        try {
	          mostrarInfoNodo(null);
	        } catch (err) {
	          // noop
	        }
	        canvas
	          .querySelectorAll(".flow-node.is-selected")
	          .forEach(el => el.classList.remove("is-selected"));
	      }
		      cancelarConexionEnCurso();
		    });
		  }
		  window.addEventListener("resize", renderFlowConnections);
		  window.addEventListener("resize", programarActualizacionMinimapFlow);
		  try {
		    mostrarInfoNodo(null);
		  } catch (err) {
		    // noop
		  }
		  programarActualizacionMinimapFlow();
		  actualizarUIReplayFlujo();
		}

function generarIdNodo() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `nodo-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
}

function crearNodoManual(tipo) {
  try {
    console.log("Crear nodo manual", tipo, "flujoNodos len:", Array.isArray(flujoNodos) ? flujoNodos.length : flujoNodos);
    const config = FLOW_NODE_TYPES[tipo];
    if (!config) {
      console.error("Tipo de nodo desconocido", tipo);
      mostrarAviso("No se reconoce este tipo de nodo.", "error");
      return;
    }
    const nodo = {
      id: generarIdNodo(),
      tipo,
      titulo: config.label,
      x: 60 + flujoNodos.length * 40,
      y: 60 + flujoNodos.length * 20,
      datos: {},
      targets: [],
    };
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    flujoNodos.push(nodo);
    ultimoNodoManual = nodo.id;
    guardarEstadoNodos();
    console.log("Nodo creado", nodo.id, "total nodos", flujoNodos.length);
    renderFlowNodes();
    abrirFlowModal(nodo.id);
  } catch (err) {
    console.error("Error creando nodo", err);
    const msg = err && err.message ? err.message : "Error desconocido";
    mostrarAviso(`No se pudo crear el nodo: ${msg}`, "error");
  }
}

async function sembrarNodosDesdeDatos() {
  // Refrescar datos antes de sembrar
  await Promise.all([cargarResumen(), cargarDepositos(), cargarBarricas(), cargarEntradas(), cargarMovimientos()]);
  actualizarMapaFlujo();
  flujoNodos = ETAPAS_FLUJO.map((etapa, idx) => {
    const nodo = {
      id: generarIdNodo(),
      tipo:
        etapa.id === "despalillado"
          ? "estilo"
          : etapa.id === "barrica"
          ? "barrica"
          : etapa.id === "embotellado"
          ? "embotellado"
          : etapa.id === "salida"
          ? "salida"
          : etapa.id === "entrada"
          ? "entrada"
          : "deposito",
      titulo: etapa.titulo,
      x: 80 + idx * 180,
      y: 120 + (idx % 2) * 120,
      datos: {
        resumen: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].detalle
          : "",
        valor: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].valor.toLocaleString("es-ES", { maximumFractionDigits: 1 })
          : "0",
      },
      targets: [],
    };
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    return nodo;
  });
  for (let i = 0; i < flujoNodos.length - 1; i++) {
    flujoNodos[i].targets.push(flujoNodos[i + 1].id);
  }
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  guardarEstadoNodos();
  renderFlowNodes();
}

// Override renderFlowNodes with a clean version (prev block had duplicated closures)
		function renderFlowNodes() {
		  const canvas = document.getElementById("flowCanvas");
		  if (!canvas) return;
		  aplicarLayoutFlow();
		  canvas.innerHTML = "";
		  canvas.dataset.mode = nodoConectandoOrigen ? "connecting" : "default";
	
	  flujoNodos.forEach(nodo => {
	    if (nodo.tipo === "entrada") {
	      rellenarDatosEntradaDesdeCache(nodo);
    } else if (nodo.tipo === "deposito") {
      rellenarDatosDepositoDesdeCache(nodo);
      actualizarTituloNodo(nodo);
    } else if (nodo.tipo === "barrica") {
      rellenarDatosCrianzaDesdeCache(nodo);
      actualizarTituloNodo(nodo);
    }
	    // Recalcular mezcla visible por si el nodo recibe varias variedades
	    const compRender = calcularComposicionVariedades(nodo);
	    if (compRender.mix.size) {
	      guardarComposicionEnNodo(nodo, compRender.mix, compRender.total);
	    }
	    if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
	      actualizarVolumenDesdeAsignaciones(nodo);
	    }

		    const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo" };
		    const div = document.createElement("div");
		    div.className = "flow-node";
		    div.dataset.tipo = nodo.tipo;
		    if (flowReplay?.activo && flowReplay.model) {
		      const nodoId = normalizarIdNodo(nodo);
		      if (!flowReplay.model.nodesSet?.has(nodoId)) {
		        div.classList.add("replay-outside");
		      } else if (!flowReplay.state?.activeNodes?.has(nodoId)) {
		        div.classList.add("replay-inactive");
		      } else {
		        const ts = flowReplay.model.nodeTs?.get(nodoId);
		        if (ts != null && flowReplay.timeMs != null && ts === flowReplay.timeMs) {
		          div.classList.add("replay-current");
		        }
		      }
		    }
		    if (nodo.tipo === "barrica") {
		      const tooltip = obtenerTooltipCrianza(nodo);
		      if (tooltip) div.title = tooltip;
		      div.addEventListener("pointerenter", e => {
		        if (e.pointerType !== "mouse") return;
	        ocultarFlowTooltip();
	        mostrarFlowTooltip(tooltip, e.clientX, e.clientY);
	      });
	      div.addEventListener("pointermove", e => {
	        if (e.pointerType !== "mouse") return;
	        posicionarFlowTooltip(e.clientX, e.clientY);
	      });
	      div.addEventListener("pointerleave", () => ocultarFlowTooltip());
	      div.addEventListener("pointerdown", () => ocultarFlowTooltip());
	    }
	    if (nodoConectandoOrigen === nodo.id) {
	      div.classList.add("is-connect-source");
	    }
	    if (nodoSeleccionadoId && nodoSeleccionadoId === nodo.id) {
	      div.classList.add("is-selected");
	    }
	
	    const fill = document.createElement("div");
	    fill.className = "fill-level";
	    const colorVino = obtenerColorVino(nodo);
	    div.dataset.vino = colorVino === "white" ? "white" : "red";
	    fill.classList.add(colorVino === "white" ? "white" : "red");
    const ocupacion = calcularOcupacionNodo(nodo);
    if (ocupacion != null) {
      fill.style.height = `${(ocupacion * 100).toFixed(1)}%`;
    }
    div.appendChild(fill);

	    const progresoBarrica = calcularProgresoBarrica(nodo);
	    if (progresoBarrica != null) {
	      const ring = document.createElement("div");
	      const pct = Math.max(0, Math.min(1, progresoBarrica));
	      const ang = pct * 360;
	      ring.className = "flow-progress-ring";
	      ring.style.background = `conic-gradient(from -90deg, var(--flow-accent, rgba(255,255,255,0.75)) 0deg ${ang}deg, rgba(255,255,255,0.08) ${ang}deg 360deg)`;
	      div.appendChild(ring);
	    }

	    div.style.left = `${nodo.x}px`;
	    div.style.top = `${nodo.y}px`;
	    div.dataset.id = nodo.id;
	
	    const headerWrap = document.createElement("div");
	    headerWrap.className = "flow-node-header";
	    const icon = document.createElement("span");
	    icon.className = "flow-node-icon";
	    if (config.icono && config.icono.trim().startsWith("<")) {
	      icon.innerHTML = config.icono;
    } else {
      let iconChar = config.icono || "●";
      if (config.icono === "🍇") iconChar = "🍇";
      icon.textContent = iconChar;
    }
    headerWrap.appendChild(icon);
    if (config.icono === "🍇") {
      const badge = document.createElement("span");
      const tono = colorVino === "white" ? "white" : "red";
      badge.className = `grape-badge ${tono}`;
      badge.title = tono === "white" ? "Uva blanca" : "Uva tinta";
      headerWrap.appendChild(badge);
    }
    const header = document.createElement("h4");
    const estadoInline = obtenerEstadoVisual(nodo);
    header.textContent = nodo.titulo || config.label;
    if (estadoInline) {
      const estadoSpan = document.createElement("span");
      estadoSpan.className = "flow-state-inline";
      const separador = header.textContent ? " - " : "";
      estadoSpan.textContent = `${separador}${estadoInline.label}`;
      if (estadoInline.color) {
        estadoSpan.style.color = estadoInline.color;
      }
      header.appendChild(estadoSpan);
    }
    headerWrap.appendChild(header);
    div.appendChild(headerWrap);

    const body = document.createElement("div");
    body.className = "flow-node-body";
    const densidadNodo = nodo.tipo === "entrada" ? normalizarNumero(nodo.datos?.densidad) : null;
    const temperaturaNodo = nodo.tipo === "entrada" ? normalizarNumero(nodo.datos?.temperatura) : null;
    if (nodo.tipo === "entrada" && (densidadNodo != null || temperaturaNodo != null)) {
      const metrics = document.createElement("div");
      metrics.className = "flow-node-metrics";
      if (densidadNodo != null) {
        const chip = document.createElement("span");
        chip.className = "flow-chip";
        chip.textContent = `${formatearDensidad(densidadNodo)} dens`;
        metrics.appendChild(chip);
      }
      if (temperaturaNodo != null) {
        const chip = document.createElement("span");
        chip.className = "flow-chip";
        chip.textContent = `${temperaturaNodo.toFixed(1)}°C`;
        metrics.appendChild(chip);
      }
      body.appendChild(metrics);
    }

	    const variedadVisible = obtenerVariedadVisibleNodo(nodo);
	    if (variedadVisible) {
	      const subtitleVar = document.createElement("div");
	      subtitleVar.className = "flow-node-subtitle flow-subtitle-variedad";
	      subtitleVar.textContent = variedadVisible;
	      subtitleVar.title = variedadVisible;
	      body.appendChild(subtitleVar);
	    }

    const textoVolumen = obtenerTextoVolumenNodo(nodo);
    if (textoVolumen) {
      const volEl = document.createElement("div");
      volEl.className = "flow-node-subtitle";
      volEl.textContent = textoVolumen;
      body.appendChild(volEl);
    } else {
      const unidadBadge = document.createElement("div");
      unidadBadge.className = "flow-unit";
      unidadBadge.textContent = obtenerUnidadVisual(nodo);
      body.appendChild(unidadBadge);
    }

    div.appendChild(body);

	    if (nodo.tipo === "estilo" && nodo.datos?.metodo) {
	      const metodoSubtitle = document.createElement("div");
	      metodoSubtitle.className = "flow-node-subtitle";
	      metodoSubtitle.textContent = nodo.datos.metodo;
	      div.appendChild(metodoSubtitle);
	    }

    const controls = document.createElement("div");
    controls.className = "flow-node-controls";
    const btnEditar = document.createElement("button");
    btnEditar.className = "blue";
    btnEditar.title = "Editar";
    btnEditar.addEventListener("pointerdown", e => e.stopPropagation());
    btnEditar.addEventListener("click", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });
    const btnConectar = document.createElement("button");
    btnConectar.className = `green ${nodoConectandoOrigen === nodo.id ? "conectando" : ""}`;
    btnConectar.title = "Conectar";
    if (nodoConectandoOrigen === nodo.id) btnConectar.classList.add("conectando");
    btnConectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnConectar.addEventListener("click", e => {
      e.stopPropagation();
      prepararConexion(nodo.id);
    });
    const btnDesconectar = document.createElement("button");
    btnDesconectar.className = "red";
    btnDesconectar.title = "Desconectar";
    btnDesconectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnDesconectar.addEventListener("click", e => {
      e.stopPropagation();
      if (!nodo._clickDesconectar) {
        desconectarNodo(nodo.id);
        nodo._clickDesconectar = Date.now();
        mostrarAviso("Pulsa de nuevo rápidamente para eliminar el nodo.", "info");
        setTimeout(() => {
          if (nodo._clickDesconectar && Date.now() - nodo._clickDesconectar > 800) delete nodo._clickDesconectar;
        }, 900);
      } else if (Date.now() - nodo._clickDesconectar < 800) {
        delete nodo._clickDesconectar;
        eliminarNodoPorId(nodo.id);
      } else {
        nodo._clickDesconectar = Date.now();
      }
    });
    controls.appendChild(btnEditar);
    controls.appendChild(btnConectar);
    controls.appendChild(btnDesconectar);
    div.appendChild(controls);

    const tempNodo = obtenerTemperaturaNodo(nodo);
    const estado = (nodo.datos?.estado || "").toLowerCase();
    const enFermentacion = estado.includes("ferment");
    if (enFermentacion && tempNodo != null && tempNodo >= 28) {
      div.classList.add("temp-alert");
    }

	    div.addEventListener("pointerdown", e => iniciarArrastreNodo(e, nodo.id));
	    div.addEventListener("click", () => {
	      if (dragEstado && dragEstado.activo) return;
	      if (nodoConectandoOrigen && nodoConectandoOrigen !== nodo.id) {
	        conectarNodos(nodoConectandoOrigen, nodo.id);
	        nodoConectandoOrigen = null;
	        renderFlowNodes();
	      } else {
	        nodoSeleccionadoId = nodo.id;
	        const canvasEl = document.getElementById("flowCanvas");
	        if (canvasEl) {
	          canvasEl
	            .querySelectorAll(".flow-node.is-selected")
	            .forEach(el => el.classList.remove("is-selected"));
	          div.classList.add("is-selected");
	        }
	        mostrarInfoNodo(nodo.id);
	      }
	    });
    div.addEventListener("dblclick", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });

    canvas.appendChild(div);
  });

  renderFlowConnections();
  programarActualizacionMinimapFlow();
}

function resumenNodo(nodo) {
  const datos = nodo.datos || {};
  if (datos.resumen) return datos.resumen;
  const keys = Object.keys(datos).filter(k => datos[k]);
  if (!keys.length) return "Doble clic para detallar";
  return keys
    .slice(0, 2)
    .map(k => `${k}: ${datos[k]}`)
    .join(" · ");
}

	function renderFlowConnections() {
	  const svg = document.getElementById("flowConnections");
	  const canvas = document.getElementById("flowCanvas");
	  const layer = document.getElementById("flowConnectionsLayer");
	  if (!svg || !canvas) return;
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  const targetLayer = layer || svg;
  if (layer) {
    layer.innerHTML = "";
  } else {
    svg.innerHTML = "";
  }
  const nodosDom = new Map();
  canvas.querySelectorAll(".flow-node").forEach(nodeEl => {
    nodosDom.set(nodeEl.dataset.id, nodeEl);
  });

	  flujoNodos.forEach(nodo => {
	    try {
	      const origenEl = nodosDom.get(nodo.id);
	      if (!origenEl) return;
      const x1 = nodo.x + origenEl.offsetWidth / 2;
      const y1 = nodo.y + origenEl.offsetHeight / 2;
      (nodo.targets || []).forEach(targetId => {
        const destinoEl = nodosDom.get(targetId);
        if (!destinoEl) return;
        const destinoNodo = flujoNodos.find(n => n.id === targetId);
        if (!destinoNodo) return;
	        const x2 = destinoNodo.x + destinoEl.offsetWidth / 2;
	        const y2 = destinoNodo.y + destinoEl.offsetHeight / 2;
	        const curva = document.createElementNS("http://www.w3.org/2000/svg", "path");
	        const delta = Math.max(Math.abs(x2 - x1) / 2, 60);
	        const d = `M${x1} ${y1} C ${x1 + delta} ${y1}, ${x2 - delta} ${y2}, ${x2} ${y2}`;
	        curva.setAttribute("d", d);
	        const tipoLinea = String(nodo.tipo || "").toLowerCase();
	        const seleccion = nodoSeleccionadoId && (nodoSeleccionadoId === nodo.id || nodoSeleccionadoId === targetId);
	        const replayActivo = Boolean(flowReplay?.activo && flowReplay.model && flowReplay.state);
	        const origenIdNorm = normalizarIdNodo(nodo);
	        const destinoIdNorm = normalizarIdNodo(destinoNodo);
	        const enReplay =
	          replayActivo &&
	          flowReplay.model.nodesSet?.has(origenIdNorm) &&
	          flowReplay.model.nodesSet?.has(destinoIdNorm);
	        const edgeKey = `${origenIdNorm}→${destinoIdNorm}`;
	        const futuro = enReplay && !flowReplay.state.activeNodes?.has(destinoIdNorm);
	        const current = enReplay && flowReplay.state.currentEdges?.has(edgeKey);
	        curva.setAttribute(
	          "class",
	          `flow-connector-line${tipoLinea ? " type-" + tipoLinea : ""}${seleccion ? " is-highlight" : ""}${
	            replayActivo
	              ? enReplay
	                ? current
	                  ? " replay-now"
	                  : futuro
	                  ? " replay-future"
	                  : " replay-done"
	                : " replay-outside"
	              : ""
	          }`
	        );
	        (layer || svg).appendChild(curva);

	        if (replayActivo && enReplay) {
	          const litros = obtenerLitrosTransferenciaEntreNodos(nodo, destinoNodo);
	          const ts = flowReplay.model.nodeTs?.get(destinoIdNorm) ?? null;
	          const fechaTxt = ts != null ? formatearFechaReplay(ts) : "Sin fecha";
	          const litrosTxt = litros > 0 ? formatearLitrosPlano(litros) : "—";
	          const estadoTxt = futuro ? "Pendiente" : "Hecho";
	          const tooltip = `${nodo.titulo || nodo.tipo || "Origen"} → ${destinoNodo.titulo || destinoNodo.tipo || "Destino"}\nFecha: ${fechaTxt}\nLitros: ${litrosTxt}\nEstado: ${estadoTxt}`;
	          curva.addEventListener("pointerenter", e => {
	            if (e.pointerType !== "mouse") return;
	            mostrarFlowTooltip(tooltip, e.clientX, e.clientY);
	          });
	          curva.addEventListener("pointermove", e => {
	            if (e.pointerType !== "mouse") return;
	            posicionarFlowTooltip(e.clientX, e.clientY);
	          });
	          curva.addEventListener("pointerleave", () => ocultarFlowTooltip());
	          curva.addEventListener("pointerdown", () => ocultarFlowTooltip());
	        }

	        // Etiqueta de composición de variedades en la mitad del conector
	        try {
	          const comp = calcularComposicionVariedades(nodo);
	          const textoComp = formatearComposicionVariedades(comp.mix, comp.total);
          if (textoComp) {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2 - 6;
            label.setAttribute("x", midX);
            label.setAttribute("y", midY);
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("class", "flow-connector-label");
            label.textContent = textoComp;
            (layer || svg).appendChild(label);
          }
        } catch (err) {
          console.warn("No se pudo calcular la composición del conector:", err);
        }
      });
    } catch (err) {
      console.error("Error renderizando conexiones", err);
    }
  });
}

	function iniciarArrastreNodo(ev, nodoId) {
	  if (flowReplay?.activo) return;
	  const nodo = flujoNodos.find(n => n.id === nodoId);
	  if (!nodo) return;
	  const editor = document.getElementById("flowEditor");
	  const canvas = document.getElementById("flowCanvas");
  const editorRect = editor.getBoundingClientRect();
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  dragEstado = {
    id: nodoId,
    offsetX: posX - nodo.x,
    offsetY: posY - nodo.y,
    startX: ev.clientX,
    startY: ev.clientY,
    activo: false,
    elemento: ev.currentTarget,
    editor,
  };
  ev.currentTarget.classList.add("dragging");
  ev.currentTarget.setPointerCapture(ev.pointerId);
  ev.currentTarget.addEventListener("pointermove", moverNodoArrastre);
  ev.currentTarget.addEventListener("pointerup", finalizarArrastreNodo);
  ev.currentTarget.addEventListener("pointercancel", finalizarArrastreNodo);
}

function moverNodoArrastre(ev) {
  if (!dragEstado) return;
  const nodo = flujoNodos.find(n => n.id === dragEstado.id);
  if (!nodo) return;
  const canvas = document.getElementById("flowCanvas");
  const editor = dragEstado.editor || document.getElementById("flowEditor");
  const editorRect = editor.getBoundingClientRect();
  const dx = ev.clientX - dragEstado.startX;
  const dy = ev.clientY - dragEstado.startY;
  if (!dragEstado.activo) {
    if (Math.abs(dx) + Math.abs(dy) < 4) {
      return;
    }
    dragEstado.activo = true;
  }
  const nodoWidth = dragEstado.elemento ? dragEstado.elemento.offsetWidth : 120;
  const nodoHeight = dragEstado.elemento ? dragEstado.elemento.offsetHeight : 70;
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  const maxX = Math.max(0, canvas.offsetWidth - nodoWidth - 10);
  const maxY = Math.max(0, canvas.offsetHeight - nodoHeight - 10);
  nodo.x = Math.min(Math.max(posX - dragEstado.offsetX, 10), maxX);
  nodo.y = Math.min(Math.max(posY - dragEstado.offsetY, 10), maxY);
  if (dragEstado.elemento) {
    dragEstado.elemento.style.left = `${nodo.x}px`;
    dragEstado.elemento.style.top = `${nodo.y}px`;
  }
  renderFlowConnections();
  programarActualizacionMinimapFlow();
}

function finalizarArrastreNodo(ev) {
  if (ev.currentTarget) {
    ev.currentTarget.classList.remove("dragging");
    ev.currentTarget.removeEventListener("pointermove", moverNodoArrastre);
    ev.currentTarget.removeEventListener("pointerup", finalizarArrastreNodo);
    ev.currentTarget.removeEventListener("pointercancel", finalizarArrastreNodo);
  }
  if (dragEstado && dragEstado.activo) {
    guardarEstadoNodos();
  }
  dragEstado = null;
}

	function prepararConexion(id) {
	  if (flowReplay?.activo) {
	    mostrarAviso("Sal del replay para conectar nodos.", "info");
	    return;
	  }
	  if (nodoConectandoOrigen === id) {
	    nodoConectandoOrigen = null;
	  } else if (!nodoConectandoOrigen) {
	    nodoConectandoOrigen = id;
  } else {
    conectarNodos(nodoConectandoOrigen, id);
    nodoConectandoOrigen = null;
  }
  renderFlowNodes();
}

function cancelarConexionEnCurso() {
  if (nodoConectandoOrigen) {
    nodoConectandoOrigen = null;
    renderFlowNodes();
    mostrarAviso("Conexión cancelada.", "info");
  }
}

function conectarNodos(origenId, destinoId, silencioso = false) {
  if (origenId === destinoId) return;
  const origen = flujoNodos.find(n => n.id === origenId);
  const destino = flujoNodos.find(n => n.id === destinoId);
  if (!origen) return;
  if (esAncestro(origenId, destinoId)) {
    mostrarAviso("No puedes crear ciclos en el flujo.", "error");
    return;
  }
  if (destino && esNodoPrensado(destino) && obtenerUnidadNodo(origen) === "litros") {
    mostrarAviso("No puedes enviar litros a un nodo de prensado/sangrado. La conversión ya se realizó antes.", "error");
    return;
  }
  origen.targets = origen.targets || [];
  if (!origen.targets.includes(destinoId)) {
    const snapshot = JSON.parse(JSON.stringify(flujoNodos));
    origen.targets.push(destinoId);
    if (origen.tipo === "estilo") {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoId.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { kilos: 0, litros: 0 };
      }
    }
    if (destino) {
      sembrarDatosIniciales(origen, destino);
    }
    redistribuirCargas(origen);
    const validacion = validarLimitesFlujo();
    if (!validacion.ok) {
      flujoNodos = snapshot;
      renderFlowNodes();
      const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
      const unidad = validacion.unidad || "u.";
      mostrarAviso(
        `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}.`,
        "error"
      );
      return;
    }
    guardarEstadoNodos();
    renderFlowNodes();
    if (!silencioso) {
      mostrarAviso("Nodos conectados.", "success");
    }
  }
}

function completarCargaVisual(carga) {
  if (!carga) return null;
  if (carga.litros == null && carga.litros_directos != null) {
    const litrosDirectos = normalizarNumero(carga.litros_directos);
    if (litrosDirectos > 0) {
      carga.litros = Number(litrosDirectos.toFixed(4));
    }
  }
  return carga;
}

function obtenerLitrosDesdePredecesores(nodo) {
  if (!nodo) return 0;
  const padres = obtenerPredecesores(nodo.id);
  return padres.reduce((acc, pre) => {
    const carga = obtenerCargaDesdeNodo(pre);
    const litros = normalizarNumero(
      carga?.litros_directos != null ? carga.litros_directos : carga?.litros
    );
    return acc + (Number.isFinite(litros) ? litros : 0);
  }, 0);
}

function actualizarBotellasResultantes(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return;
  const selectBotella = document.getElementById("flowField-botella");
  const display = document.getElementById("flowField-botellas_resultantes-display");
  const hidden = document.getElementById("flowField-botellas_resultantes");
  if (!selectBotella || !display || !hidden) return;
  const litrosDisponibles = obtenerLitrosDesdePredecesores(nodo);
  const volBotella = VOLUMEN_BOTELLA_L[selectBotella.value] || 0;
  const botellas = volBotella > 0 ? Math.floor(litrosDisponibles / volBotella) : 0;
  display.textContent = botellas ? `${botellas} uds (${litrosDisponibles.toFixed(2)} L disponibles)` : "—";
  hidden.value = botellas;
}

async function asegurarJsPDF() {
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  const cargar = src =>
    new Promise(resolve => {
      const script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.onload = resolve;
      script.onerror = resolve;
      document.head.appendChild(script);
    });
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js");
  return window.jspdf && window.jspdf.jsPDF ? window.jspdf.jsPDF : null;
}

async function exportarTablaControlPDF(nodo) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se cargó). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const anada =
      nodo.datos?.anada ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha) ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha_operacion) ||
      "";
    const titulo = `Control analítico de ${nodo.titulo || "Depósito"}${anada ? " · añada " + anada : ""}`;
    doc.setFontSize(14);
    doc.text(titulo, 14, 18);
    doc.setFontSize(11);

    const depInfo = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const variedad = depInfo?.vino_tipo || nodo.datos?.variedad || nodo.datos?.vino || "";
    const tipoDep = depInfo?.tipo || nodo.datos?.tipo || "Depósito";
    const capacidadRaw =
      depInfo?.capacidad_l ??
      (depInfo?.capacidad_hl != null ? depInfo.capacidad_hl * 100 : nodo.datos?.capacidad);
    const capacidad = Number.isFinite(capacidadRaw) ? `${Number(capacidadRaw).toFixed(2)} L` : "—";
    const volumenRaw =
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos ??
      depInfo?.litros_actuales;
    const volumen = Number.isFinite(Number(volumenRaw))
      ? `${Number(volumenRaw).toFixed(2)} L`
      : "—";

    const infoLines = [
      `Variedad de uva: ${variedad || "—"}`,
      `Tipo de depósito: ${tipoDep || "—"}`,
      `Capacidad depósito: ${capacidad}`,
      `Volumen uva/vino: ${volumen}`,
    ];
    doc.setFontSize(10);
    infoLines.forEach((linea, idx) => {
      doc.text(linea, 14, 24 + idx * 6);
    });

    const startYTable = 24 + infoLines.length * 6 + 6;

    const formatearFechaCorta = fechaStr => {
      if (!fechaStr) return "";
      const d = new Date(fechaStr);
      if (isNaN(d.getTime())) return fechaStr;
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    };

    const filas = (nodo.datos?.control || []).map(reg => [
      formatearFechaCorta(reg.fecha),
      reg.densidad || "",
      reg.temperatura || "",
      reg.productos || "",
    ]);
    const body = filas.length ? filas : [["", "", "", ""]];
    const headers = [["Fecha", "Densidad", "°C", "Productos"]];
    const autoTable = (window.jspdf && window.jspdf.autoTable) || (doc && doc.autoTable);
    if (autoTable) {
      (window.jspdf && window.jspdf.autoTable ? window.jspdf.autoTable : doc.autoTable).call(doc, {
        head: headers,
        body,
        startY: startYTable,
        styles: { fontSize: 11, cellPadding: 4 },
        headStyles: { fillColor: [60, 0, 90], textColor: 255 },
        alternateRowStyles: { fillColor: [245, 240, 248] },
      });
    } else {
      let y = startYTable;
      doc.text(headers[0].join(" | "), 14, y);
      y += 8;
      body.forEach(row => {
        doc.text(row.join(" | "), 14, y);
        y += 8;
      });
    }
    const nombreArchivo = `control-${(nodo.titulo || "deposito").toString().replace(/\s+/g, "-")}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de control:", err);
    alert("No se pudo generar el PDF.");
  }
}

function escalarCarga(cargaBase, factor) {
  if (!cargaBase || !Number.isFinite(factor)) return null;
  const carga = { ...cargaBase };
  if (carga.kilos != null) carga.kilos = Number((carga.kilos * factor).toFixed(4));
  if (carga.litros_directos != null) {
    carga.litros_directos = Number((carga.litros_directos * factor).toFixed(4));
  }
  if (carga.litros != null) {
    carga.litros = Number((carga.litros * factor).toFixed(4));
  }
  return completarCargaVisual(carga);
}

function prepararCargaParaDestino(origen, destino, cargaBase, totalDestinos) {
  if (!origen || !destino || !cargaBase) return null;
  const origenKey = normalizarIdNodo(origen);
  let carga = null;
  if (origen.tipo === "estilo") {
    carga = obtenerCargaDistribuida(origen, destino.id, cargaBase);
  }
  if (carga) {
    return completarCargaVisual(carga);
  }
  if (destino.tipo === "deposito") {
    const kilosBase = normalizarNumero(cargaBase.kilos);
    const litrosBase = normalizarNumero(
      cargaBase.litros_directos != null ? cargaBase.litros_directos : cargaBase.litros
    );
    const registro = asegurarAsignacionRegistro(
      destino,
      origen.id,
      kilosBase > 0 ? kilosBase : 0,
      litrosBase > 0 ? litrosBase : 0
    );
    const kilos = normalizarNumero(registro.kilos);
    const litros = normalizarNumero(registro.litros);
    const tieneCarga = (kilos > 0) || (litros > 0);
    const carga = { ...cargaBase };
    if (!tieneCarga) {
      carga.kilos = 0;
      carga.litros_directos = 0;
      return completarCargaVisual(carga);
    }
    carga.kilos = kilos > 0 ? kilos : 0;
    carga.litros_directos = litros > 0 ? litros : 0;
    return completarCargaVisual(carga);
  }
  const registro = destino.datos?.asignaciones?.[origenKey];
  if (registro) {
    const kilos = normalizarNumero(registro.kilos);
    const litros = normalizarNumero(registro.litros);
    const carga = { ...cargaBase };
    if (kilos >= 0) carga.kilos = Number.isFinite(kilos) ? kilos : undefined;
    if (litros >= 0) carga.litros_directos = Number.isFinite(litros) ? litros : undefined;
    return completarCargaVisual(carga);
  }

  // Reparto automático: dividir entre destinos si el origen tiene varias salidas
  if (totalDestinos <= 1) {
    return { ...cargaBase };
  }
  const cargaDividida = escalarCarga(cargaBase, 1 / totalDestinos);
  return cargaDividida;
}

function redistribuirCargas(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return;
  visitados.add(origen.id);
  const targets = (origen.targets || [])
    .map(id => flujoNodos.find(n => n.id === id))
    .filter(Boolean);
  if (!targets.length) {
    visitados.delete(origen.id);
    return;
  }
  const cargaBase = obtenerCargaDesdeNodo(origen);
  if (!cargaBase) {
    visitados.delete(origen.id);
    return;
  }
  // Reparto automático solo si no hay asignaciones manuales en destinos contenedor
  const hayAsignacionesManuales = targets.some(dest => {
    const reg = dest?.datos?.asignaciones?.[origen.id];
    return reg?.__manual === true;
  });
  if (targets.length > 1 && !hayAsignacionesManuales) {
    const shareKilos =
      cargaBase.kilos != null ? Number((Number(cargaBase.kilos) / targets.length).toFixed(4)) : null;
    const baseLitros =
      cargaBase.litros_directos != null
        ? Number(cargaBase.litros_directos)
        : cargaBase.litros != null
        ? Number(cargaBase.litros)
        : null;
    const shareLitros = baseLitros != null ? Number((baseLitros / targets.length).toFixed(4)) : null;
    targets.forEach(dest => {
      if (TIPOS_CONTENEDOR_FLUJO.has(dest.tipo)) {
        const registro = asegurarAsignacionRegistro(dest, origen.id);
        registro.__manual = false;
        if (shareKilos != null) registro.kilos = shareKilos;
        if (shareLitros != null) {
          registro.litros = shareLitros;
        }
      }
    });
  }
  let cargaLibre = { ...cargaBase };
  const totalDestinos = targets.length;
  targets.forEach((dest, idx) => {
    // En nodos de elaboración restamos lo ya asignado; para mantener el reparto automático correcto,
    // dividimos por los destinos restantes (no por el total original) cuando usamos `cargaLibre`.
    const destinosRestantes =
      origen.tipo === "estilo" ? Math.max(1, totalDestinos - idx) : totalDestinos;
    const cargaDestino = prepararCargaParaDestino(origen, dest, cargaLibre, destinosRestantes);
    if (cargaDestino) {
      const aplicado = manejarTransferenciaNodo(origen, dest, cargaDestino);
      if (origen.tipo === "estilo" && aplicado) {
        const kilosUsados = normalizarNumero(aplicado.kilos) || 0;
        const litrosUsados = normalizarNumero(aplicado.litros_directos ?? aplicado.litros) || 0;
        if (cargaLibre.kilos != null) {
          cargaLibre.kilos = Math.max(0, cargaLibre.kilos - kilosUsados);
        }
        if (cargaLibre.litros_directos != null) {
          cargaLibre.litros_directos = Math.max(0, cargaLibre.litros_directos - litrosUsados);
          cargaLibre.litros = cargaLibre.litros_directos;
        }
      }
    } else if (dest.tipo === "deposito") {
      actualizarVariedadDesdeAportes(dest);
    }
    redistribuirCargas(dest, visitados);
  });
  visitados.delete(origen.id);
}

	function manejarTransferenciaNodo(origen, destino, cargaPersonalizada = null) {
	  if (!origen || !destino) return null;
	  origen.datos = origen.datos || {};
	  destino.datos = destino.datos || {};
	  asegurarMermaPorDefecto(origen);
	  asegurarMermaPorDefecto(destino);
	  const cargaBase = obtenerCargaDesdeNodo(origen);
	  if (!cargaBase) return null;
	  const unidadOrigen = obtenerUnidadNodo(origen);
	  const esCargaManual = cargaPersonalizada?.__manual === true;
	  let carga = completarCargaVisual(cargaPersonalizada ? { ...cargaPersonalizada } : { ...cargaBase });

	  if (!carga) return null;

	  const factorMermaOrigen = !esNodoConversor(origen) ? obtenerFactorMermaNodo(origen) : 0;
	  if (factorMermaOrigen > 0 && !esCargaManual) {
	    carga = aplicarMermaACarga(carga, factorMermaOrigen);
	  }

	  if (esNodoPrensado(destino)) {
	    if (unidadOrigen === "litros") {
	      mostrarAviso("Ya estás trabajando en litros; no puedes volver a convertir con otro prensado o sangrado.", "error");
	      return null;
	    }
	    const kilosAsignados = normalizarNumero(carga.kilos);
	    const litrosDirectosAsignados = normalizarNumero(carga.litros_directos);
	    if (!(kilosAsignados > 0 || litrosDirectosAsignados > 0)) {
	      return null;
	    }
	    const factor = obtenerFactorMermaNodo(destino);
	    const litrosPrensados = kilosAsignados > 0 ? aplicarMerma(kilosAsignados, factor) : 0;
	    const totalSalida = litrosPrensados + (litrosDirectosAsignados > 0 ? litrosDirectosAsignados : 0);
	    // Guardar entrada en kilos (para consumo) y salida ya convertida en litros (para volumen).
	    carga.kilos = kilosAsignados > 0 ? kilosAsignados : 0;
	    carga.litros_directos = totalSalida;
	    carga.litros = totalSalida;
	  }

	  

  // Trasiego: contenedor a contenedor (depósitos, barricas, almacén).
  if (esConexionTrasiego(origen, destino)) {
    const baseLitros =
      normalizarNumero(carga.litros) ?? normalizarNumero(carga.litros_directos);
    const baseKilos = normalizarNumero(carga.kilos);
    const factorTrasiego = Math.max(
      obtenerFactorMermaNodo(origen),
      obtenerFactorMermaNodo(destino)
    );
    if (baseLitros > 0) {
      const litrosTrasiego = factorTrasiego > 0 ? aplicarMerma(baseLitros, factorTrasiego) : baseLitros;
      carga.litros = litrosTrasiego;
      carga.litros_directos = litrosTrasiego;
      carga.kilos = 0;
    } else if (baseKilos > 0) {
      const kilosTrasiego = factorTrasiego > 0 ? aplicarMerma(baseKilos, factorTrasiego) : baseKilos;
      carga.kilos = kilosTrasiego;
      carga.litros = null;
      carga.litros_directos = null;
    }
  }

  carga = completarCargaVisual(carga);

  aplicarCargaProcesoSinDuplicar(destino, origen.id, carga);

  if (destino.tipo === "deposito" && destino.datos.id_ref) {
    actualizarDepositoContenido(destino.datos.id_ref, carga.variedad, carga.litros, carga.anada);
  }
	  if (destino.tipo === "deposito" || destino.tipo === "coupage") {
	    const registro = asegurarAsignacionRegistro(destino, origen.id);
	    const litrosFinales =
	      normalizarNumero(carga.litros_directos) ??
	      normalizarNumero(carga.litros) ??
      0;
    const kilosFinales = normalizarNumero(carga.kilos) ?? 0;
    if (litrosFinales > 0) {
      registro.litros = Number(litrosFinales.toFixed(2));
    }
    if (kilosFinales > 0) {
      registro.kilos = Number(kilosFinales.toFixed(2));
    } else if (esNodoPrensado(origen)) {
      registro.kilos = 0;
    }
	    actualizarVariedadDesdeAportes(destino);
	    actualizarVolumenDesdeAsignaciones(destino);
	    guardarEstadoNodos();
	  }
	  return carga;
	}

function normalizarNumero(valor) {
  if (valor === undefined || valor === null || valor === "") return null;
  const limpio = typeof valor === "string" ? valor.replace(",", ".") : valor;
  const numero = Number(limpio);
  return Number.isFinite(numero) ? numero : null;
}

function formatearDensidad(valor) {
  const num = normalizarNumero(valor);
  if (num == null) return "";
  const entero = Math.round(num);
  return entero.toString().padStart(4, "0");
}

function obtenerVariedadNodo(nodo, visitados = new Set()) {
  const comp = calcularComposicionVariedades(nodo, visitados);
  if (comp.mix.size) {
    const composicion = guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    return composicion.map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`).join(" / ");
  }
  return nodo?.datos?.variedad || nodo?.datos?.variedadBase || "";
}

	function obtenerCargaDesdeNodo(nodo, visitados = new Set()) {
	  if (!nodo) return null;
	  const clave = nodo.id || nodo;
	  if (visitados.has(clave)) return null;
	  visitados.add(clave);
	  const unidadNodo = obtenerUnidadNodo(nodo);
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref && nodo.datos?.kilos == null) {
    intentarPoblarNodoEntrada(nodo);
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref && nodo.datos?.codigo == null) {
    intentarPoblarNodoDeposito(nodo);
  }
  if ((nodo.tipo === "deposito" || nodo.tipo === "coupage") && nodo.datos?.asignaciones) {
    actualizarVolumenDesdeAsignaciones(nodo);
  }
  const datos = { ...(nodo.datos || {}) };
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref) {
    const entrada = buscarEntradaPorId(nodo.datos.id_ref);
    if (entrada) {
      if (datos.kilos == null && entrada.kilos != null) datos.kilos = entrada.kilos;
      if (!datos.variedad && entrada.variedad) datos.variedad = entrada.variedad;
      if (!datos.anada && entrada.anada) datos.anada = entrada.anada;
      if (!datos.fecha && entrada.fecha) datos.fecha = entrada.fecha.slice(0, 10);
      if (datos.densidad == null && entrada.densidad != null) datos.densidad = entrada.densidad;
      if (datos.temperatura == null && entrada.temperatura != null) datos.temperatura = entrada.temperatura;
    }
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref) {
    const deposito = buscarDepositoPorId(nodo.datos.id_ref);
    if (deposito) {
      if (datos.volumen == null && deposito.litros_actuales != null) datos.volumen = deposito.litros_actuales;
      if (!datos.variedad && deposito.vino_tipo) datos.variedad = deposito.vino_tipo;
      if (!datos.anada && deposito.vino_anio) datos.anada = deposito.vino_anio;
      if (!datos.fecha && deposito.fecha_uso) datos.fecha = deposito.fecha_uso.slice(0, 10);
    }
  }
  const variedad = obtenerVariedadNodo(nodo);
  const kilos = normalizarNumero(datos.kilos);
  const litrosDirectos = normalizarNumero(datos.litros_directos);
  const litrosVolumen = normalizarNumero(
    datos.volumen != null ? datos.volumen : datos.litros != null ? datos.litros : datos.valor
  );
  const carga = {};
  if (variedad) carga.variedad = variedad;
  if (unidadNodo === "litros") {
    const litrosFinal =
      litrosDirectos != null
        ? litrosDirectos
        : litrosVolumen != null
        ? litrosVolumen
        : kilos != null
        ? kilos
        : null;
    if (litrosFinal != null) {
      const litrosVal = Number(litrosFinal.toFixed(4));
      carga.litros_directos = litrosVal;
      carga.litros = litrosVal;
    }
    if (carga.litros != null) {
      carga.kilos = 0;
    }
  } else {
    if (kilos != null) carga.kilos = kilos;
    if (litrosDirectos != null) carga.litros_directos = litrosDirectos;
    if (carga.kilos == null && litrosVolumen != null) {
      carga.kilos = litrosVolumen;
    }
  }
  if (datos.parcela) carga.parcela = datos.parcela;
  const anada = datos.anada || obtenerAnadaDesdeFecha(datos.fecha);
  if (anada) carga.anada = anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  const densidad = normalizarNumero(datos.densidad);
  if (densidad != null) {
    carga.densidad = densidad;
  }
  const temperatura = normalizarNumero(datos.temperatura);
  if (temperatura != null) {
    carga.temperatura = temperatura;
  }

  const sinKilos = !(carga.kilos > 0);
  const sinLitros = !(carga.litros > 0) && !(carga.litros_directos > 0);
	  if (sinKilos && sinLitros && nodo.id != null) {
	    let sumK = 0;
	    let sumL = 0;
	    obtenerPredecesores(nodo.id).forEach(pre => {
	      const cargaPre = obtenerCargaDesdeNodo(pre, visitados);
	      if (!cargaPre) return;
	      const k = normalizarNumero(cargaPre.kilos);
	      const l = normalizarNumero(cargaPre.litros_directos ?? cargaPre.litros);
	      if (k > 0) sumK += k;
	      if (l > 0) sumL += l;
	    });
	    if (sumK > 0) {
	      carga.kilos = Number(sumK.toFixed(2));
	    }
	    if (sumL > 0) {
	      const lnum = Number(sumL.toFixed(2));
	      carga.litros_directos = lnum;
	      carga.litros = lnum;
	    }
	  }

	  if (nodo.id != null && esNodoConversor(nodo)) {
	    const factor = obtenerFactorMermaNodo(nodo);
	    let kilosEntrantes = 0;
	    let litrosDirectosEntrantes = 0;

	    const aportesObj = nodo.datos?.aportes;
	    const aportes = aportesObj && typeof aportesObj === "object" ? Object.values(aportesObj) : [];

	    // Preferimos los aportes reales del nodo (cantidad asignada a ESTE nodo) para evitar
	    // sobrecontar cuando un padre reparte su carga entre varios destinos.
	    if (aportes.length) {
	      aportes.forEach(a => {
	        const k = normalizarNumero(a?.kilos) || 0;
	        const l = normalizarNumero(a?.litros_directos ?? a?.litros) || 0;
	        if (k > 0) {
	          kilosEntrantes += k;
	          return;
	        }
	        if (l > 0) {
	          litrosDirectosEntrantes += l;
	        }
	      });
	    } else {
	      // Fallback: si aún no hay aportes (recién conectado), usamos los padres.
	      const padres = obtenerPredecesores(nodo.id);
	      padres.forEach(pre => {
	        const cargaPre = obtenerCargaDesdeNodo(pre, visitados);
	        if (!cargaPre) return;
	        const k = normalizarNumero(cargaPre.kilos) || 0;
	        const l = normalizarNumero(cargaPre.litros_directos ?? cargaPre.litros) || 0;
	        if (k > 0) kilosEntrantes += k;
	        if (l > 0) litrosDirectosEntrantes += l;
	      });
	    }

	    const litrosConvertidos = kilosEntrantes > 0 ? aplicarMerma(kilosEntrantes, factor) : 0;
	    const totalSalida = litrosConvertidos + (litrosDirectosEntrantes > 0 ? litrosDirectosEntrantes : 0);
	    if (totalSalida > 0) {
	      const totalRed = Number(totalSalida.toFixed(2));
	      carga.kilos = 0;
	      carga.litros_directos = totalRed;
	      carga.litros = totalRed;
	      nodo.datos = nodo.datos || {};
	      nodo.datos.kilos = 0;
	      nodo.datos.litros_directos = totalRed;
	      nodo.datos.litros = totalRed;
	      nodo.datos.volumen = totalRed;
	    }
	  }

	  visitados.delete(clave);
	  return Object.keys(carga).length ? carga : null;
	}

function obtenerMermaDefault(nodo) {
  // Por defecto no aplicamos merma; solo se usa la que indique el usuario.
  return MERMA_DEFAULT_GENERAL;
}

function asegurarMermaPorDefecto(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  const mermaActual = normalizarNumero(nodo.datos.merma);
  if (mermaActual == null) {
    nodo.datos.merma = 0;
  }
}

function obtenerFactorMermaNodo(nodo) {
  const mermaDatos = nodo?.datos ? normalizarNumero(nodo.datos.merma) : null;
  const base = mermaDatos != null ? mermaDatos : obtenerMermaDefault(nodo);
  const factor = Number.isFinite(base) ? base / 100 : 0;
  return Math.min(Math.max(factor, 0), 0.95);
}

function aplicarMerma(base, factor) {
  const resultado = base * (1 - factor);
  return Number.isFinite(resultado) ? Number(resultado.toFixed(2)) : 0;
}

function aplicarMermaACarga(carga, factor) {
  if (!carga || !(factor > 0)) return carga;
  const copia = { ...carga };
  if (copia.kilos != null) copia.kilos = aplicarMerma(copia.kilos, factor);
  if (copia.litros != null) copia.litros = aplicarMerma(copia.litros, factor);
  if (copia.litros_directos != null) {
    copia.litros_directos = aplicarMerma(copia.litros_directos, factor);
  }
  return copia;
}

function esConexionTrasiego(origen, destino) {
  return (
    TIPOS_NODO_CONTENEDOR.has(origen.tipo) &&
    TIPOS_NODO_CONTENEDOR.has(destino.tipo) &&
    origen.id !== destino.id
  );
}

function aplicarCargaANodo(nodo, carga) {
  nodo.datos = nodo.datos || {};
  const unidadDestino = obtenerUnidadNodo(nodo);
  const esContenedor = TIPOS_NODO_CONTENEDOR.has(nodo.tipo);
  const acumular = false; // evitar acumulados duplicados // en nodos de proceso sumamos aportes múltiples
  const prevK = normalizarNumero(nodo.datos.kilos) || 0;
  const prevL = normalizarNumero(nodo.datos.litros) || 0;
  const prevLD = normalizarNumero(nodo.datos.litros_directos) || 0;
  if (carga.variedad) {
    nodo.datos.variedad = carga.variedad;
  }
  if (carga.parcela) {
    nodo.datos.parcela = carga.parcela;
  }
  if (carga.anada) {
    nodo.datos.anada = carga.anada;
  }
  if (carga.kilos != null) {
    const nuevos = Number(carga.kilos.toFixed(2));
    nodo.datos.kilos = acumular ? Number((prevK + nuevos).toFixed(2)) : nuevos;
  }
  if (carga.litros != null) {
    const litros = Number(carga.litros.toFixed(2));
    const lFinal = acumular ? Number((prevL + litros).toFixed(2)) : litros;
    nodo.datos.volumen = lFinal;
    nodo.datos.litros = lFinal;
  }
  if (carga.litros_directos != null) {
    const ld = Number(carga.litros_directos.toFixed(2));
    nodo.datos.litros_directos = acumular ? Number((prevLD + ld).toFixed(2)) : ld;
  }
  // Si el destino opera en litros y es contenedor, no guardamos kilos derivados para evitar duplicidad.
  if (unidadDestino === "litros" && esContenedor) {
    nodo.datos.kilos = 0;
  }
  if (carga.fecha) {
    nodo.datos.fecha = carga.fecha;
    if (!nodo.datos.fecha_operacion) {
      nodo.datos.fecha_operacion = carga.fecha;
    }
  }
  const densidadCarga = normalizarNumero(carga.densidad);
  if (densidadCarga != null) {
    nodo.datos.densidad = Number(densidadCarga.toFixed(4));
  }
  const tempCarga = normalizarNumero(carga.temperatura);
  if (tempCarga != null) {
    nodo.datos.temperatura = Number(tempCarga.toFixed(2));
  }
}
function aplicarCargaProcesoSinDuplicar(destino, origenId, carga) {
  if (!destino) return;
  destino.datos = destino.datos || {};
  destino.datos.aportes = destino.datos.aportes || {};
  const aporte = {
    kilos: carga.kilos != null ? Number(carga.kilos.toFixed(2)) : 0,
    litros: carga.litros != null ? Number(carga.litros.toFixed(2)) : 0,
    litros_directos:
      carga.litros_directos != null ? Number(carga.litros_directos.toFixed(2)) : 0,
    variedad: carga.variedad,
    anada: carga.anada,
    parcela: carga.parcela,
    fecha: carga.fecha,
    densidad: normalizarNumero(carga.densidad),
    temperatura: normalizarNumero(carga.temperatura),
  };
  destino.datos.aportes[normalizarIdNodo(origenId)] = aporte;
  limpiarAportesOrfanos(destino);
  let sumK = 0;
  let sumL = 0;
  const mixVariedades = new Map();
  let densidadSuma = 0;
  let densidadPeso = 0;
  let densidadPrimera = null;
  let tempSuma = 0;
  let tempPeso = 0;
  let tempPrimera = null;
  Object.values(destino.datos.aportes).forEach(a => {
    if (a.kilos > 0) sumK += a.kilos;
    if (a.litros_directos > 0) sumL += a.litros_directos;
    else if (a.litros > 0) sumL += a.litros;
    const peso = (a.litros_directos > 0 ? a.litros_directos : a.litros > 0 ? a.litros : a.kilos) || 0;
    if (a.variedad && peso > 0) {
      agregarVariedadAPeso(mixVariedades, a.variedad, peso);
    }
    const dens = normalizarNumero(a.densidad);
    if (dens != null) {
      const pesoD = peso || 1;
      densidadSuma += dens * pesoD;
      densidadPeso += pesoD;
      if (densidadPrimera == null) densidadPrimera = dens;
    }
    const temp = normalizarNumero(a.temperatura);
    if (temp != null) {
      const pesoT = peso || 1;
      tempSuma += temp * pesoT;
      tempPeso += pesoT;
      if (tempPrimera == null) tempPrimera = temp;
    }
  });
  const totalMix = Array.from(mixVariedades.values()).reduce((acc, v) => acc + v, 0);
  if (mixVariedades.size) {
    guardarComposicionEnNodo(destino, mixVariedades, totalMix);
  } else if (aporte.variedad) {
    destino.datos.composicionVariedades = [];
    destino.datos.variedad = aporte.variedad;
  }
  if (aporte.anada) destino.datos.anada = aporte.anada;
  if (aporte.parcela) destino.datos.parcela = aporte.parcela;
  if (aporte.fecha) destino.datos.fecha = aporte.fecha;
  const densidadMedia =
    densidadPeso > 0 ? densidadSuma / densidadPeso : densidadPrimera;
  const temperaturaMedia = tempPeso > 0 ? tempSuma / tempPeso : tempPrimera;
  destino.datos.densidad =
    densidadMedia != null ? Number(densidadMedia.toFixed(4)) : "";
  destino.datos.temperatura =
    temperaturaMedia != null ? Number(temperaturaMedia.toFixed(2)) : "";

  // Para contenedores dejamos que el volumen lo gestionen asignaciones; solo propagamos mezcla.
  if (TIPOS_NODO_CONTENEDOR.has(destino.tipo)) {
    // Aseguramos que el mix se refleje aunque las asignaciones estén vacías
    if (mixVariedades.size) {
      guardarComposicionEnNodo(destino, mixVariedades, totalMix);
    }
    // En barricas no tenemos tabla de asignaciones, así que guardamos volumen para el relleno visual.
    if (destino.tipo === "barrica") {
      destino.datos.kilos = Number(sumK.toFixed(2));
      destino.datos.litros = Number(sumL.toFixed(2));
      destino.datos.litros_directos = destino.datos.litros;
      destino.datos.volumen = destino.datos.litros;
    }
    return;
  }

  // En nodos de proceso sí consolidamos los volúmenes/kilos para mostrar totales.
  destino.datos.kilos = Number(sumK.toFixed(2));
  if (sumL > 0) {
    destino.datos.litros = Number(sumL.toFixed(2));
    destino.datos.litros_directos = destino.datos.litros;
    destino.datos.volumen = destino.datos.litros;
  } else {
    destino.datos.litros = 0;
    destino.datos.litros_directos = 0;
    destino.datos.volumen = destino.datos.kilos;
  }
}

function desconectarNodo(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  if (!nodo) return;
  const afectados = new Set();
  nodo.targets = [];
  flujoNodos.forEach(other => {
    if (other.targets) {
      const longitudInicial = other.targets.length;
      other.targets = other.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== other.targets.length) {
        afectados.add(other.id);
        if (other.tipo === "estilo") {
          limpiarDistribucionEstilo(other);
        }
      }
    }
  });
  if (nodo.tipo === "estilo") {
    limpiarDistribucionEstilo(nodo);
  }
  if (nodoConectandoOrigen === id) {
    nodoConectandoOrigen = null;
  }
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => recalcularDatosDesdeAportes(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  limpiarVariedadDepositosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Conexiones eliminadas para este nodo.", "info");
}

function limpiarVariedadDepositosSinEntradas() {
  flujoNodos
    .filter(n => n.tipo === "deposito")
    .forEach(dep => {
      const padres = obtenerPredecesores(dep.id);
      const sinEntradas = !padres || padres.length === 0;
      if (sinEntradas) {
        dep.datos = dep.datos || {};
        dep.datos.variedad = "";
        dep.datos.variedadBase = "";
        dep.datos.vino_tipo = "";
        dep.datos.composicionVariedades = [];
        dep.datos.aportes = {};
        if (dep.datos.id_ref) {
          actualizarDepositoContenido(dep.datos.id_ref, "", dep.datos.volumen, dep.datos.anada);
        }
      }
    });
}

function eliminarNodoPorId(id) {
  const afectados = new Set();
  flujoNodos = flujoNodos.filter(n => n.id !== id);
  flujoNodos.forEach(n => {
    if (n.targets) {
      const longitudInicial = n.targets.length;
      n.targets = n.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== n.targets.length) {
        afectados.add(n.id);
        if (n.tipo === "estilo") {
          limpiarDistribucionEstilo(n);
        }
      }
    }
  });
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => recalcularDatosDesdeAportes(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  nodoEnEdicion = null;
  mostrarInfoNodo(null);
  cerrarFlowModal();
  mostrarAviso("Nodo eliminado.", "error");
}

async function actualizarDepositoContenido(idRef, variedad, volumen, anada) {
  if (!idRef) return;
  const dep = cacheDepositos.find(d => d.id === Number(idRef));
  if (!dep) return;
  const materialActual = dep.material || dep.contenido || "";
  // Intentar usar la mezcla real del nodo de flujo si existe
  let variedadNodo = "";
  const nodoDepo = flujoNodos.find(
    n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idRef)
  );
  if (nodoDepo) {
    try {
      const comp = calcularComposicionVariedades(nodoDepo);
      if (comp.mix.size) {
        guardarComposicionEnNodo(nodoDepo, comp.mix, comp.total);
        variedadNodo = formatearComposicionVariedades(comp.mix, comp.total);
      } else {
        variedadNodo = nodoDepo.datos?.variedad || nodoDepo.datos?.variedadBase || "";
      }
    } catch (e) {
      console.warn("No se pudo calcular mezcla del depósito para guardar:", e);
    }
  }
  const variedadFinal = variedadNodo || variedad || dep.vino_tipo;
  try {
    const res = await fetch(`/api/depositos/${idRef}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo: dep.codigo,
        tipo: dep.tipo,
        capacidad_l:
          dep.capacidad_l != null ? dep.capacidad_l : dep.capacidad_hl != null ? dep.capacidad_hl * 100 : null,
        material: materialActual,
        contenido: materialActual,
        elaboracion: dep.elaboracion,
        vino_tipo: variedadFinal,
        vino_anio: anada || dep.vino_anio,
        fecha_uso: dep.fecha_uso,
        clase: dep.clase || "deposito",
        estado: dep.estado || "vacio",
      }),
    });
    if (res.ok) {
      await cargarDepositos();
    }
  } catch (err) {
    console.error("No se pudo actualizar el depósito:", err);
  }
}

	function mostrarInfoNodo(id) {
	  const panel = document.getElementById("flowNodeInfo");
	  if (!panel) return;
	  const escapeHtml = value =>
	    String(value ?? "")
	      .replace(/&/g, "&amp;")
	      .replace(/</g, "&lt;")
	      .replace(/>/g, "&gt;")
	      .replace(/\"/g, "&quot;")
	      .replace(/'/g, "&#39;");

	  const minimapHtml = `
	    <div class="flow-minimap-world" id="flowMinimapWorld" aria-label="Minimapa del mapa de nodos" role="img">
	      <div class="flow-minimap-grid"></div>
	      <div class="flow-minimap-dots" id="flowMinimapDots"></div>
	      <div class="flow-minimap-viewport" id="flowMinimapViewport"></div>
	    </div>
	    <div class="flow-minimap-hint">Minimapa: clic o arrastra para moverte · Zoom: botones ±</div>
	  `;

	  const renderEmpty = () => {
	    panel.innerHTML = `
	      <div class="flow-inspector-header">
	        <div class="flow-inspector-icon">🔎</div>
	        <div>
	          <div class="flow-inspector-title">Inspector</div>
	          <div class="flow-inspector-sub">Selecciona un nodo en el mapa para ver detalles.</div>
	        </div>
	      </div>
	      ${minimapHtml}
	      <div class="flow-inspector-tags">
	        <span class="flow-tag">Doble clic: editar</span>
	        <span class="flow-tag">Conectar: origen → destino</span>
	        <span class="flow-tag">Arrastrar: mover</span>
	        <span class="flow-tag">Click fuera: limpiar</span>
	      </div>
	      <dl class="flow-inspector-fields">
	        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Exportar imagen” para compartir el flujo.</dd></div>
	      </dl>
	    `;
	    inicializarMinimapFlow();
	    programarActualizacionMinimapFlow();
	  };

	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) {
	    renderEmpty();
	    return;
	  }

	  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
	  const iconHtml =
	    config.icono && config.icono.trim().startsWith("<")
	      ? config.icono
	      : escapeHtml(config.icono || "●");
	  const tituloNodo = escapeHtml(nodo.titulo || config.label);
	  const tipoLabel = escapeHtml(config.label || nodo.tipo || "Nodo");

	  const entradas = obtenerPredecesores(nodo.id).length;
	  const salidas = (nodo.targets || []).length;
	  const unidad = obtenerUnidadVisual(nodo);
	  const textoVolumen = obtenerTextoVolumenNodo(nodo);

	  const tags = [
	    `Tipo: ${tipoLabel}`,
	    `Entradas: ${entradas}`,
	    `Salidas: ${salidas}`,
	    `Unidad: ${unidad}`,
	  ];

	  const campos = (config.campos || []).filter(campo => campo && campo.tipo !== "tablaControl");
	  const filas = campos
	    .map(campo => ({
	      label: campo.label,
	      value: obtenerValorCampoVisual(nodo, campo),
	    }))
	    .filter(item => item.label && item.value);

	  const detalles =
	    filas.length > 0
	      ? `<dl class="flow-inspector-fields">${filas
	          .map(
	            item =>
	              `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
	          )
	          .join("")}</dl>`
	      : `<div class="flow-inspector-sub">Sin datos adicionales.</div>`;

	  panel.innerHTML = `
	    <div class="flow-inspector-header">
	      <div class="flow-inspector-icon">${iconHtml}</div>
	      <div>
	        <div class="flow-inspector-title">${tituloNodo}</div>
	        <div class="flow-inspector-sub">${escapeHtml(textoVolumen || "")}</div>
	      </div>
	    </div>
	    ${minimapHtml}
	    <div class="flow-inspector-tags">${tags
	      .map(t => `<span class="flow-tag">${escapeHtml(t)}</span>`)
	      .join("")}</div>
	    ${detalles}
	  `;
	  inicializarMinimapFlow();
	  programarActualizacionMinimapFlow();
	}

	function abrirFlowModal(id) {
	  if (flowReplay?.activo) {
	    mostrarAviso("Sal del replay para editar nodos.", "info");
	    return;
	  }
	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) return;
	  // Asegurar que la mezcla/variedad esté recalculada antes de pintar el formulario (modal).
	  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix && comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    }
  } catch (e) {
    // noop
  }
  nodoEnEdicion = nodo;
  const modal = document.getElementById("flowModal");
  const titulo = document.getElementById("flowModalTitulo");
  const form = document.getElementById("flowModalForm");
  if (!modal || !titulo || !form) return;
  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
  let nombreExtra = "";
  if (nodo.tipo === "deposito") {
    const infoDep = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const nom = nodo.datos?.codigo || infoDep?.codigo;
    if (nom) nombreExtra = ` ${nom}`;
  } else if (nodo.tipo === "barrica") {
    const infoBar = nodo.datos?.contenedor_id ? buscarBarricaPorId(nodo.datos.contenedor_id) : null;
    const nom = nodo.datos?.tipo || infoBar?.codigo || (nodo.datos?.contenedor_id ? `#${nodo.datos.contenedor_id}` : "");
    if (nom) nombreExtra = ` ${nom}`;
  }
  const tituloTexto = `Editar ${config.label}${nombreExtra}`;
  if (config.icono && config.icono.trim().startsWith("<")) {
    titulo.innerHTML = `${config.icono} ${tituloTexto}`;
  } else if (config.icono) {
    titulo.textContent = `${config.icono} ${tituloTexto}`;
  } else {
    titulo.textContent = tituloTexto;
  }
  form.innerHTML = "";
  const camposOrdenados = ordenarCamposParaModal(config.campos);
  camposOrdenados.forEach(campo => {
    const label = document.createElement("label");
    label.textContent = campo.label;
    form.appendChild(label);
    if (campo.tipo === "tablaControl") {
      const tabla = crearTablaControlFermentacion(nodo);
      form.appendChild(tabla);
      return;
    }
    if (campo.tipo === "info") {
      const info = document.createElement("div");
      info.className = "campo-info";
      info.id = `flowField-${campo.id}-display`;
      const texto = obtenerValorCampoVisual(nodo, campo);
      info.textContent = texto || "—";
      form.appendChild(info);
      const hidden = document.createElement("input");
      hidden.type = "hidden";
      hidden.id = `flowField-${campo.id}`;
      hidden.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
      form.appendChild(hidden);
      return;
    }
    const esCampoProtegido =
      (nodo.tipo === "entrada" && campo.id !== "id_ref" && campo.id !== "merma") ||
      (["variedad", "fecha"].includes(campo.id) && nodo.tipo !== "entrada");
  const esCampoUnidadBloqueada =
      ["kilos", "litros", "litros_directos", "volumen"].includes(campo.id) &&
      nodo.tipo !== "entrada";
    let input;
    if (campo.tipo === "textarea") {
      input = document.createElement("textarea");
    } else if (campo.tipo === "select") {
      input = document.createElement("select");
      if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
        const tipoSeleccionado = nodo.datos?.contenedor_tipo || "";
        poblarSelectContenedorCrianza(input, tipoSeleccionado, nodo.datos?.contenedor_id || "");
      } else {
        if (campo.placeholder) {
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = campo.placeholder;
          placeholderOption.disabled = true;
          placeholderOption.selected = true;
          input.appendChild(placeholderOption);
        }
        (campo.opciones || []).forEach(op => {
          const option = document.createElement("option");
          option.value = op;
          option.textContent = op;
          input.appendChild(option);
        });
      }
    } else if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input = document.createElement("select");
      const ids = nodo.tipo === "entrada"
        ? (cacheEntradas || []).map(e => {
            const dens = formatearDensidad(e.densidad);
            const temp = normalizarNumero(e.temperatura);
            const kilosVal = normalizarNumero(e.kilos);
            const mixEntrada = formatearResumenVariedades(e.composicionVariedades || e.composicion_variedades);
            const variedadesTexto = mixEntrada || e.variedad || "";
            const partes = [];
            if (variedadesTexto) partes.push(variedadesTexto);
            if (kilosVal != null) partes.push(`${kilosVal.toFixed(0)} kg`);
            if (dens) partes.push(`${dens} dens`);
            if (temp != null) partes.push(`${temp.toFixed(1)}°C`);
            const sufijo = partes.length ? ` (${partes.join(" · ")})` : "";
            return { id: e.id, label: `Entrada #${e.id}${sufijo}` };
          })
        : ([...(cacheDepositos || []), ...(cacheMastelones || [])].map(d => {
            const mixDep = formatearResumenVariedades(d.composicionVariedades || d.composicion_variedades);
            let variedades = mixDep || d.vino_tipo || "";
            // Si el depósito está en el mapa de nodos, usar su mezcla real aunque aún no esté persistida en la BD.
            try {
              const nodoDepo = flujoNodos.find(
                n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(d.id)
              );
              if (nodoDepo) {
                const comp = calcularComposicionVariedades(nodoDepo);
                const texto = formatearComposicionVariedades(comp.mix, comp.total);
                if (texto) variedades = texto;
              }
            } catch (e) {
              // noop
            }
            const labelVar = variedades ? ` · ${variedades}` : "";
            return {
              id: d.id,
              label: (d.codigo || `Depósito #${d.id}`) + labelVar,
            };
          }));
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "Selecciona ID";
      input.appendChild(empty);
      ids.forEach(item => {
        const option = document.createElement("option");
        option.value = item.id;
        option.textContent = item.label;
        input.appendChild(option);
      });
    } else {
      input = document.createElement("input");
      input.type = campo.tipo || "text";
    }
    input.id = `flowField-${campo.id}`;
    if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      const clave = claveContenedor(nodo.datos?.contenedor_tipo);
      input.value =
        clave && nodo.datos?.contenedor_id
          ? `${clave}:${nodo.datos.contenedor_id}`
          : "";
    } else {
      input.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
    }
    if (campo.placeholder) input.placeholder = campo.placeholder;
    if (esCampoProtegido || campo.soloLectura || esCampoUnidadBloqueada) {
      if (input.tagName === "SELECT") {
        input.disabled = true;
      } else {
        input.readOnly = true;
      }
      input.classList.add("field-readonly");
      input.title = esCampoProtegido
        ? "Dato sincronizado desde Entrada de uva"
        : "El volumen se calcula automáticamente en el flujo";
    }
    if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos.id_ref = input.value;
        if (nodo.tipo === "entrada") {
          intentarPoblarNodoEntrada(nodo);
        } else {
          intentarPoblarNodoDeposito(nodo);
        }
        config.campos.forEach(c => {
          const campoInput = document.getElementById(`flowField-${c.id}`);
          if (campoInput && nodo.datos[c.id] != null) {
            campoInput.value = nodo.datos[c.id];
          }
          const displayEl = document.getElementById(`flowField-${c.id}-display`);
          if (displayEl) {
            const texto = obtenerValorCampoVisual(nodo, c) || "—";
            displayEl.textContent = texto;
          }
        });
        renderFlowNodes();
        mostrarInfoNodo(nodo.id);
      });
    } else if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        const valor = input.value;
        if (!valor) {
          nodo.datos.contenedor_id = "";
          nodo.datos.contenedor_tipo = "";
          nodo.datos.tipo = "";
          guardarEstadoNodos();
          renderFlowNodes();
          return;
        }
        const [tipoSeleccionado, idSeleccionado] = valor.split(":");
        const idNumerico = idSeleccionado ? Number(idSeleccionado) : "";
        nodo.datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
        nodo.datos.contenedor_id = idNumerico;
        const infoCont = obtenerInfoContenedor(
          nodo.datos.contenedor_tipo === "Barrica" ? "barrica" : "deposito",
          idNumerico
        );
        const descripcion = describirContenedor(infoCont, nodo.datos.contenedor_tipo);
        nodo.datos.tipo = descripcion || nodo.datos.contenedor_tipo || "";
        // Rellenamos capacidad/volumen de la crianza al seleccionar contenedor para que el llenado funcione como en depósitos.
        if (infoCont) {
          const capInfo =
            infoCont.capacidad_l ??
            (infoCont.capacidad_hl != null ? infoCont.capacidad_hl * 100 : null);
          if (capInfo != null) {
            nodo.datos.capacidad = capInfo;
            nodo.datos.capacidad_l = capInfo;
          }
          if (infoCont.litros_actuales != null || infoCont.volumen != null) {
            const vol = infoCont.litros_actuales ?? infoCont.volumen;
            nodo.datos.volumen = vol;
            nodo.datos.litros = vol;
            nodo.datos.litros_directos = vol;
          }
          nodo.datos.vino_tipo = nodo.datos.vino_tipo || infoCont.vino_tipo;
          nodo.datos.variedadBase = nodo.datos.variedadBase || infoCont.vino_tipo || "";
          if (!Array.isArray(nodo.datos.composicionVariedades) || !nodo.datos.composicionVariedades.length) {
            nodo.datos.variedad = nodo.datos.variedad || nodo.datos.variedadBase;
          }
        }
        const tipoInput = document.getElementById("flowField-tipo");
        if (tipoInput) {
          tipoInput.value = nodo.datos.tipo;
        }
        guardarEstadoNodos();
        renderFlowNodes();
      });
    }
    if (
      nodo.tipo === "barrica" &&
      (campo.id === "tiempo" || campo.id === "fecha_operacion")
    ) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = input.value;
        refrescarDuracionModal(nodo);
      });
    }
    if (nodo.tipo === "embotellado" && campo.id === "botella") {
      input.addEventListener("change", () => actualizarBotellasResultantes(nodo));
    }
    form.appendChild(input);
  });
  if (nodo.tipo === "barrica") {
    refrescarDuracionModal(nodo);
  }
  if (nodo.tipo === "embotellado") {
    actualizarBotellasResultantes(nodo);
  }
  if (nodo.tipo === "coupage") {
    const labelAsign = document.createElement("label");
    labelAsign.textContent =
      "Selecciona los litros de cada depósito para el blend";
    form.appendChild(labelAsign);
    form.appendChild(crearTablaAsignacionesDeposito(nodo));
  }
  if (nodo.tipo === "estilo") {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de kilos/litros hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEstilo(nodo));
  }
  modal.classList.add("visible");
}

function cerrarFlowModal() {
  const modal = document.getElementById("flowModal");
  if (modal) modal.classList.remove("visible");
  nodoEnEdicion = null;
}

function guardarNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  const nodoId = nodoEnEdicion.id;
  const snapshot = JSON.parse(JSON.stringify(flujoNodos));
  const config = FLOW_NODE_TYPES[nodoEnEdicion.tipo];
  const datos = {};
  const metodoPrevio = nodoEnEdicion.datos?.metodo || "";
  const eraConversorAntes =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoPrevio) ||
    esMetodoSangrado(metodoPrevio);
  if (config) {
    config.campos.forEach(campo => {
      if (campo.tipo === "tablaControl") return;
      const input = document.getElementById(`flowField-${campo.id}`);
      if (input) {
        if (campo.id === "contenedor_id" && nodoEnEdicion.tipo === "barrica") {
          const valor = input.value;
          if (!valor) {
            datos.contenedor_id = "";
            datos.contenedor_tipo = "";
          } else {
            const [tipoSeleccionado, idSeleccionado] = valor.split(":");
            datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
            datos.contenedor_id = idSeleccionado ? Number(idSeleccionado) : "";
          }
        } else {
          datos[campo.id] = input.value;
        }
      } else if (nodoEnEdicion.datos && nodoEnEdicion.datos[campo.id] != null) {
        datos[campo.id] = nodoEnEdicion.datos[campo.id];
      }
    });
  }
  const metodoCandidato = datos.metodo != null ? datos.metodo : metodoPrevio;
  const esConversorCandidato =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoCandidato) ||
    esMetodoSangrado(metodoCandidato);
  if (esConversorCandidato && obtenerUnidadEntrante(nodoEnEdicion) === "litros") {
    const inputMetodo = document.getElementById("flowField-metodo");
    if (inputMetodo) inputMetodo.value = metodoPrevio || "";
    mostrarAviso("Ya tienes líquido en litros antes de este punto; no puedes volver a convertir con prensado o sangrado.", "error");
    return;
  }
  nodoEnEdicion.datos = { ...(nodoEnEdicion.datos || {}), ...datos };
  asegurarMermaPorDefecto(nodoEnEdicion);
  if (esConversorCandidato) {
    const mermaActual = normalizarNumero(nodoEnEdicion.datos.merma);
    const mermaDeseada = esMetodoSangrado(metodoCandidato)
      ? MERMA_DEFAULT_SANGRADO
      : MERMA_DEFAULT_PRENSADO;
    if (mermaActual == null || (mermaActual === MERMA_DEFAULT_GENERAL && !eraConversorAntes)) {
      nodoEnEdicion.datos.merma = mermaDeseada;
    }
  }
  actualizarDuracionPrevista(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "deposito") {
    const volumenEditado = Number(nodoEnEdicion.datos.volumen);
    if (Number.isFinite(volumenEditado)) {
      nodoEnEdicion.datos.kilos = volumenEditado;
    }
  }
  actualizarTituloNodo(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "entrada") {
    intentarPoblarNodoEntrada(nodoEnEdicion);
  } else if (nodoEnEdicion.tipo === "deposito") {
    intentarPoblarNodoDeposito(nodoEnEdicion);
    actualizarVariedadDesdeAportes(nodoEnEdicion);
  }
  redistribuirCargas(nodoEnEdicion);
  const validacion = validarLimitesFlujo();
  if (!validacion.ok) {
    flujoNodos = snapshot;
    nodoEnEdicion = flujoNodos.find(n => n.id === nodoId) || null;
    renderFlowNodes();
    const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
    const unidad = validacion.unidad || "u.";
    mostrarAviso(
      `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}. Reduce la cantidad antes de continuar.`,
      "error"
    );
    return;
  }
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarInfoNodo(nodoId);
  sincronizarNodoConSistema(nodoEnEdicion);
  cerrarFlowModal();
}

function intentarPoblarNodoEntrada(nodo) {
  const id = Number(nodo.datos.id_ref);
  if (!id || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => e.id === id);
  if (!entrada) {
    mostrarAviso("No se encontró la entrada con ese ID.", "error");
    return;
  }
  nodo.datos.fecha = entrada.fecha ? entrada.fecha.slice(0, 10) : nodo.datos.fecha;
  if (!nodo.datos.fecha_operacion && nodo.datos.fecha) {
    nodo.datos.fecha_operacion = nodo.datos.fecha;
  }
  nodo.datos.kilos = entrada.kilos ?? nodo.datos.kilos;
  nodo.datos.variedad = entrada.variedad || nodo.datos.variedad;
  nodo.datos.parcela = entrada.parcela || nodo.datos.parcela;
  const anadaEntrada = entrada.anada || obtenerAnadaDesdeFecha(entrada.fecha);
  nodo.datos.anada = anadaEntrada || nodo.datos.anada;
  nodo.datos.viticultor = entrada.viticultor || nodo.datos.viticultor;
  nodo.datos.tipo_suelo = entrada.tipo_suelo || nodo.datos.tipo_suelo;
  nodo.datos.anos_vid = entrada.anos_vid || nodo.datos.anos_vid;
  nodo.datos.densidad = entrada.densidad ?? nodo.datos.densidad;
  nodo.datos.temperatura = entrada.temperatura ?? nodo.datos.temperatura;
  actualizarTituloNodo(nodo);
  mostrarAviso("Datos del nodo cargados desde la entrada.", "success");
  redistribuirCargas(nodo);
}

function intentarPoblarNodoDeposito(nodo) {
  const id = Number(nodo.datos.id_ref);
  if (!id || !Array.isArray(cacheDepositos)) return;
  const deposito = cacheDepositos.find(d => d.id === id);
  if (!deposito) {
    mostrarAviso("No se encontró el depósito con ese ID.", "error");
    return;
  }
  const camposResguardar = ["volumen", "tipo", "material", "fase", "kilos", "variedad"];
  const valoresPrevios = {};
  camposResguardar.forEach(campo => {
    if (!nodo.datos) return;
    const valor = nodo.datos[campo];
    if (valor == null || valor === "") return;
    // Si viene a 0 (default), dejamos que el depósito real rellene el volumen/kilos.
    if (["volumen", "kilos"].includes(campo)) {
      const num = normalizarNumero(valor);
      if (num != null && num !== 0) {
        valoresPrevios[campo] = valor;
      }
      return;
    }
    valoresPrevios[campo] = valor;
  });
  const controlPrevio = Array.isArray(nodo.datos.control)
    ? nodo.datos.control.map(item => ({ ...item }))
    : null;
  const asignacionesPrevias = nodo.datos.asignaciones
    ? JSON.parse(JSON.stringify(nodo.datos.asignaciones))
    : null;
  nodo.datos.codigo = deposito.codigo || nodo.datos.codigo;
  nodo.datos.capacidad = deposito.capacidad_l || (deposito.capacidad_hl ? deposito.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.volumen = deposito.litros_actuales ?? nodo.datos.volumen;
  nodo.datos.vino = deposito.vino_tipo || nodo.datos.vino;
  // No sobreescribir variedad: se hereda desde la entrada/asignaciones
  nodo.datos.estado = deposito.estado || nodo.datos.estado;
  nodo.datos.fecha = deposito.fecha_uso ? deposito.fecha_uso.slice(0, 10) : nodo.datos.fecha;
  nodo.datos.material = deposito.material || deposito.contenido || nodo.datos.material;
  nodo.datos.tipo = deposito.tipo || nodo.datos.tipo;
  Object.entries(valoresPrevios).forEach(([campo, valor]) => {
    nodo.datos[campo] = valor;
  });
  if (controlPrevio) {
    nodo.datos.control = controlPrevio;
  }
  if (asignacionesPrevias) {
    nodo.datos.asignaciones = asignacionesPrevias;
  }
  actualizarTituloNodo(nodo);
  mostrarAviso("Datos del nodo cargados desde el depósito.", "success");
  redistribuirCargas(nodo);
}

function eliminarNodoActivo() {
  if (!nodoEnEdicion) return;
  eliminarNodoPorId(nodoEnEdicion.id);
}

function guardarEstadoNodos() {
  try {
    localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
  } catch (err) {
    console.warn("No se pudo guardar nodos en localStorage:", err);
  }
  if (temporizadorGuardadoFlujo) {
    clearTimeout(temporizadorGuardadoFlujo);
  }
  temporizadorGuardadoFlujo = setTimeout(() => {
    temporizadorGuardadoFlujo = null;
    guardarFlujoEnServidor();
  }, RETARDO_GUARDADO_FLUJO);
}

async function cargarNodosGuardados() {
  try {
    const res = await fetch("/api/flujo");
    if (res.ok) {
      const data = await res.json();
      if (Array.isArray(data.nodos)) {
        flujoNodos = data.nodos;
        flujoNodos.forEach(n => {
          limpiarAportesOrfanos(n);
          recalcularDatosDesdeAportes(n);
          actualizarTituloNodo(n);
          actualizarVariedadDesdeAportes(n);
          asegurarMermaPorDefecto(n);
          if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
            intentarPoblarNodoDeposito(n);
          }
        });
        localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
        return;
      }
    }
  } catch (err) {
    console.warn("No se pudo cargar flujo del servidor:", err);
  }
  try {
    const guardados = JSON.parse(localStorage.getItem("flowNodes"));
    if (Array.isArray(guardados)) {
      flujoNodos = guardados;
      flujoNodos.forEach(n => {
        limpiarAportesOrfanos(n);
        recalcularDatosDesdeAportes(n);
        actualizarTituloNodo(n);
        actualizarVariedadDesdeAportes(n);
        asegurarMermaPorDefecto(n);
        if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
          intentarPoblarNodoDeposito(n);
        }
      });
    }
  } catch (err) {
    flujoNodos = [];
  }
}

async function guardarFlujoEnServidor() {
  try {
    await fetch("/api/flujo", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ nodos: flujoNodos }),
    });
  } catch (err) {
    console.warn("No se pudo sincronizar el flujo con el servidor:", err);
  }
}

function limpiarNodosFlujo() {
  if (!confirm("¿Eliminar todos los nodos del mapa?")) return;
  flujoNodos = [];
  guardarEstadoNodos();
  renderFlowNodes();
  guardarFlujoEnServidor();
}

// Resetea el mapa localmente sin pedir confirmación extra (botón rápido)
function resetMapaFlujoLocal() {
  flujoNodos = [];
  guardarEstadoNodos();
  guardarFlujoEnServidor();
  renderFlowNodes();
  mostrarAviso("Mapa vaciado.", "success");
}

// Carga un mapa mínimo con entrada → depósito para probar desde cero
function seedMapaSimple() {
  const entradaId = generarIdNodo();
  const depositoId = generarIdNodo();
  const entrada = {
    id: entradaId,
    tipo: "entrada",
    titulo: "Entrada de uva",
    x: 120,
    y: 140,
    datos: {
      variedad: "Tempranillo",
      kilos: 1000,
      fecha: new Date().toISOString().slice(0, 10),
    },
    targets: [depositoId],
  };
  asegurarMermaPorDefecto(entrada);
  const deposito = {
    id: depositoId,
    tipo: "deposito",
    titulo: "Depósito A1",
    x: 380,
    y: 160,
    datos: {
      codigo: "A1",
      capacidad: 1500,
      volumen: 0,
      variedad: "",
    },
    targets: [],
  };
  asegurarMermaPorDefecto(deposito);
  flujoNodos = [entrada, deposito];
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Mapa simple cargado.", "success");
}

async function sincronizarNodoConSistema(nodo) {
  if (!nodo || nodo.datos?.sincronizado) return;
  try {
    switch (nodo.tipo) {
      case "entrada":
        await sincronizarEntradaDesdeNodo(nodo);
        break;
      case "embotellado":
        await sincronizarEmbotelladoDesdeNodo(nodo);
        break;
      default:
        // Para depósitos y barricas solo se crea desde el formulario manual.
        break;
    }
  } catch (err) {
    console.error("No se pudo sincronizar nodo:", err);
    mostrarAviso("No se pudo sincronizar el nodo con la base de datos.", "error");
  }
}

async function sincronizarEntradaDesdeNodo(nodo) {
  if (nodo.datos.id_ref) {
    mostrarAviso("La entrada ya existe en la base de datos.", "info");
    nodo.datos.sincronizado = true;
    return;
  }
  const kilos = Number(nodo.datos.kilos || 0);
  if (!kilos) {
    mostrarAviso("Indica kilos para sincronizar la entrada.", "error");
    return;
  }
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    variedad: nodo.datos.variedad || "Variedad nodo",
    viticultor: "",
    tipo_suelo: "",
    parcela: nodo.datos.parcela || "",
    anos_vid: null,
    kilos,
    destinos: [],
  };
  const res = await fetch("/api/entradas_uva", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la entrada desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Entrada creada desde el nodo.", "success");
    await cargarEntradas();
  }
}

async function sincronizarDepositoDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || nodo.datos.volumen || 0);
  if (!capacidad) {
    mostrarAviso("Indica capacidad para el depósito.", "error");
    return;
  }
  const material = nodo.datos.material || nodo.datos.contenido || "";
  const body = {
    codigo,
    clase: "deposito",
    tipo: nodo.datos.tipo || "",
    capacidad_l: capacidad,
    material,
    contenido: material,
    vino_tipo: nodo.datos.variedad || nodo.datos.vino || "",
    vino_anio: nodo.datos.anada || "",
    elaboracion: nodo.datos.elaboracion || "",
    fecha_uso: nodo.datos.fecha || null,
    estado: nodo.datos.estado || "vacio",
  };
  const res = await fetch("/api/depositos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el depósito desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Depósito creado desde el nodo.", "success");
    await cargarDepositos();
  }
}

async function sincronizarBarricaDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || 225);
  const body = {
    codigo,
    capacidad_l: capacidad,
    tipo_roble: nodo.datos.tipo || "",
    tostado: nodo.datos.tostado || "",
    marca: nodo.datos.marca || "",
    anio: nodo.datos.anio || "",
    vino_anio: nodo.datos.anada || "",
    vino_tipo: nodo.datos.vino || "",
  };
  const res = await fetch("/api/barricas", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la barrica desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Barrica creada desde el nodo.", "success");
    await cargarBarricas();
  }
}

async function sincronizarEmbotelladoDesdeNodo(nodo) {
  const litros = Number(nodo.datos.litros || 0);
  if (!litros) {
    mostrarAviso("Indica litros para el embotellado.", "error");
    return;
  }
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    contenedor_tipo: nodo.datos.origen_tipo || "deposito",
    contenedor_id: Number(nodo.datos.origen_id || 1),
    litros,
    botellas: Number(nodo.datos.botellas || 0) || null,
    lote: nodo.datos.lote || "",
    nota: nodo.datos.notas || "",
  };
  const res = await fetch("/api/embotellados", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el embotellado desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Embotellado creado desde el nodo.", "success");
    await cargarEmbotellados();
  }
}

function toggleNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (!menu || !toggle) return;
  menu.classList.toggle("visible");
  toggle.classList.toggle("open");
}

function cerrarNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (menu) menu.classList.remove("visible");
  if (toggle) toggle.classList.remove("open");
}

function obtenerInicialesUsuario(usuario) {
  if (!usuario) return "--";
  const partes = usuario
    .split(/[^A-Za-z0-9]+/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) {
    return usuario.slice(0, 2).toUpperCase();
  }
  if (partes.length === 1) {
    return (partes[0][0] || partes[0]).toUpperCase().slice(0, 2);
  }
  return (
    (partes[0][0] || "") +
    (partes[1][0] || "")
  ).toUpperCase();
}

function obtenerVolumenFinalNodoContenedor(tipo, idRef) {
  if (!idRef || !Array.isArray(flujoNodos)) return null;
  const idStr = String(idRef);
  const coincide = n =>
    n.tipo === tipo &&
    n.datos &&
    (
      (n.datos.id_ref != null && String(n.datos.id_ref) === idStr) ||
      (n.datos.contenedor_id != null && String(n.datos.contenedor_id) === idStr) ||
      (n.datos.codigo != null && String(n.datos.codigo) === idStr) ||
      String(n.id) === idStr
    );
  const candidatos = flujoNodos.filter(coincide);
  if (!candidatos.length) return null;
  const esFinal = nodo => {
    const targets = nodo.targets || [];
    return !targets.some(tid => {
      const target = obtenerNodoPorId(tid);
      return target && TIPOS_CONTENEDOR_FLUJO.has(target.tipo);
    });
  };
  const finales = candidatos.filter(esFinal);
  const elegidos = finales.length ? finales : candidatos;
  const ultimo = elegidos[elegidos.length - 1];
  const restante = obtenerVolumenRestanteNodo(ultimo);
  if (restante != null) return restante;
  const volumen = Number(ultimo?.datos?.volumen ?? ultimo?.datos?.litros);
  return Number.isFinite(volumen) ? volumen : null;
}

function obtenerEstadoBarricaDesdeNodo(idBarrica) {
  if (!idBarrica || !Array.isArray(flujoNodos)) return null;
  const volumenNodo = obtenerVolumenFinalNodoContenedor("barrica", idBarrica);
  const idStr = String(idBarrica);
  const nodo = flujoNodos.find(
    n =>
      n.tipo === "barrica" &&
      n.datos &&
      (String(n.datos.id_ref || "") === idStr ||
        String(n.datos.contenedor_id || "") === idStr ||
        String(n.datos.codigo || "") === idStr ||
        String(n.id || "") === idStr)
  );
  let variedadTexto = "";
  if (nodo) {
    try {
      variedadTexto = obtenerVariedadVisibleNodo(nodo) || "";
    } catch (e) {
      // noop
    }
  }
  if (Number.isFinite(volumenNodo)) {
    return { volumen: volumenNodo, variedad: variedadTexto, enMapa: true };
  }
  if (!nodo) return null;
  const volumen = nodo.datos?.volumen != null ? Number(nodo.datos.volumen) : null;
  return volumen != null ? { volumen, variedad: variedadTexto, enMapa: true } : null;
}

async function cargarUsuarioActivo() {
  const badge = document.getElementById("userBadge");
  const marca = document.getElementById("marcaTexto");
  const submarca = document.getElementById("submarcaTexto");
  if (!badge) return;
  badge.textContent = "—";
  try {
    const res = await fetch("/api/me", { credentials: "same-origin" });
    if (!res.ok) {
      badge.textContent = "??";
      return;
    }
    const data = await res.json();
    badge.textContent = obtenerInicialesUsuario(data.usuario);
    badge.setAttribute("title", data.usuario);
    if (marca && data.bodega_nombre) {
      const nombre = data.bodega_nombre || "";
      const prefijo = /^bodega\b/i.test(nombre.trim()) ? nombre.trim() : `Bodega ${nombre.trim()}`;
      marca.textContent = prefijo;
    }
    if (submarca) {
      submarca.textContent = "";
    }
  } catch (err) {
    console.error("Error cargando usuario:", err);
    badge.textContent = "!!";
  }
}

function irAFormulario(seccion, campo) {
  mostrarSeccion(seccion);
  setTimeout(() => {
    const elemento = document.getElementById(campo);
    if (elemento) {
      elemento.scrollIntoView({ behavior: "smooth", block: "center" });
      elemento.focus();
    }
  }, 320);
}

document.addEventListener("click", event => {
  const navMenu = document.getElementById("navMenu");
  const navToggle = document.getElementById("navToggle");
  if (
    navMenu &&
    navToggle &&
    !navMenu.contains(event.target) &&
    !navToggle.contains(event.target)
  ) {
    cerrarNavMenu();
  }
});

document.addEventListener("DOMContentLoaded", () => {
  mostrarSeccion("bodega");
  poblarSelectOpciones("depTipo", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterial", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectOpciones("depTipoEdit", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterialEdit", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectEstados("depEstadoEdit");
  const navToggleBtn = document.getElementById("navToggle");
  if (navToggleBtn) {
    navToggleBtn.addEventListener("click", event => {
      event.stopPropagation();
      mostrarSeccion("bodega");
      toggleNavMenu();
    });
  }
  inicializarFlowEditor();
  cargarUsuarioActivo();
});
let planoDrag = null;
let planoSeleccion = null;
let planoSeleccionItemActual = null;
let planoZoom = 1;
let planoWorldBase = { width: 2800, height: 1600 };
let planoUIInicializada = false;
let planoPanBloqueado = false;
let planoPanSpace = false;
let planoPanDrag = null;
let planoMinimapDrag = null;
let planoMinimapRaf = null;
const PLANO_ZOOM_MIN = 0.2;
const PLANO_ZOOM_MAX = 2.5;
const PLANO_ZOOM_STEP = 0.1;
const PLANO_DRAG_THRESHOLD_PX = 4;
const PLANO_CARD_WIDTH = 148;
const PLANO_CARD_HEIGHT = 176;
let mapaDepositosPorId = new Map();
let mapaBarricasPorId = new Map();
let mapaMastelonesPorId = new Map();
let entradaEditandoId = null;
const MERMA_DEFAULT_PRENSADO = 30;
const MERMA_DEFAULT_SANGRADO = 40;
const MERMA_DEFAULT_GENERAL = 0;
const FACTOR_MERMA_PRENSA = MERMA_DEFAULT_PRENSADO / 100;
const FACTOR_MERMA_TRASIEGO = 0.02;
const ESTADOS_DEPOSITO_UI = [
  { id: "fa", label: "FA", descripcion: "Fermentación alcohólica", color: "#d85c5c" },
  { id: "fml", label: "FML", descripcion: "Fermentación maloláctica", color: "#c47d21" },
  { id: "reposo", label: "Reposo", descripcion: "Reposo / Crianza", color: "#8c6ff7" },
  { id: "limpio", label: "Limpio", descripcion: "Limpio y listo", color: "#40a578" },
  { id: "vacio", label: "Vacío", descripcion: "Vacío", color: "#9ba1b0" },
  { id: "mantenimiento", label: "Mant.", descripcion: "Mantenimiento / Limpieza", color: "#f0a500" },
  { id: "analitica", label: "Analítica", descripcion: "Analítica pendiente", color: "#ff7aa8" },
];
const TIPOS_NODO_CONTENEDOR = new Set(["deposito", "barrica", "almacen", "coupage"]);
const VOLUMEN_BOTELLA_L = {
  "Split 0,187 L": 0.187,
  "Demi 0,375 L": 0.375,
  "Borgoña 0,75 L": 0.75,
  "Bordelesa 0,75 L": 0.75,
  "Magnum 1,5 L": 1.5,
  "Doble Magnum 3 L": 3,
  "Jeroboam 3 L": 3,
  "Rehoboam 4,5 L": 4.5,
  "Methuselah 6 L": 6,
  "Salmanazar 9 L": 9,
  "Balthazar 12 L": 12,
  "Nebuchadnezzar 15 L": 15,
};

function obtenerInfoEstadoDeposito(id) {
  if (!id) return ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
  return ESTADOS_DEPOSITO_UI.find(e => e.id === id) || ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
}

function poblarSelectEstados(selectId, placeholder = "Selecciona estado") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder;
    opt.disabled = true;
    opt.selected = true;
    select.appendChild(opt);
  }
  ESTADOS_DEPOSITO_UI.forEach(estado => {
    const option = document.createElement("option");
    option.value = estado.id;
    option.textContent = `${estado.label} · ${estado.descripcion}`;
    select.appendChild(option);
  });
  if (valorActual) {
    const existente = Array.from(select.options).find(op => op.value === valorActual);
    if (existente) {
      select.value = valorActual;
    }
  }
}

function claveContenedor(tipo) {
  if (!tipo) return "";
  const normal = tipo.toString().toLowerCase();
  if (normal.includes("barrica")) return "barrica";
  return "deposito";
}

function poblarSelectContenedorCrianza(select, tipoPreferido = "", valorId = "") {
  if (!select) return;
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Selecciona depósito o barrica";
  placeholder.disabled = true;
  if (!valorId) {
    placeholder.selected = true;
  }
  select.appendChild(placeholder);
  const agregarOpciones = (lista, tipoLabel) => {
    if (!Array.isArray(lista)) return;
    const tipoKey = tipoLabel === "Barrica" ? "barrica" : "deposito";
    lista.forEach(item => {
      const option = document.createElement("option");
      option.value = `${tipoKey}:${item.id}`;
      option.dataset.tipo = tipoKey;
      option.dataset.id = item.id;
      const etiquetaBase = item.codigo || item.nombre || item.etiqueta || "";
      const fallback = tipoLabel === "Barrica" ? `Barrica #${item.id}` : `Depósito #${item.id}`;
      option.textContent = `${tipoLabel} · ${etiquetaBase || fallback}`;
      select.appendChild(option);
    });
  };
  agregarOpciones(cacheDepositos, "Depósito");
  agregarOpciones(cacheBarricas, "Barrica");
  let valorSeleccionado = "";
  if (valorId) {
    const tipoKey = claveContenedor(tipoPreferido) || "deposito";
    valorSeleccionado = `${tipoKey}:${valorId}`;
  }
  if (valorSeleccionado) {
    select.value = valorSeleccionado;
  } else {
    select.selectedIndex = 0;
  }
}

async function manejarRespuesta(res, mensajeError) {
  if (res.ok) return true;
  let info = null;
  try {
    info = await res.json();
  } catch (e) {}
  mostrarAviso((info && info.error) || mensajeError, "error");
  return false;
}

function actualizarBarra(idBar, idLabel, valor, unidad, max) {
  const bar = document.getElementById(idBar);
  const label = document.getElementById(idLabel);
  if (label) {
    const rounded = Math.round(valor).toLocaleString();
    label.textContent = `${rounded} ${unidad}`;
  }
  if (bar) {
    const porcentaje = max > 0 ? Math.max(8, (valor / max) * 100) : 0;
    bar.style.width = `${Math.min(100, porcentaje)}%`;
  }
}

function calcularLitrosResumenDesdeCaches() {
  const sumarLitros = (lista, tipoNodo) =>
    (lista || []).reduce((acc, item) => {
      const capacidad = Number(item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)) || 0;
      const volNodo = tipoNodo ? obtenerVolumenFinalNodoContenedor(tipoNodo, item.id) : null;
      const volumenFallback = Number(item.litros_actuales ?? 0) || 0;
      const volumen = Number.isFinite(volNodo) ? Number(volNodo) : volumenFallback;
      return { capacidad: acc.capacidad + capacidad, volumen: acc.volumen + (Number.isFinite(volumen) ? volumen : 0) };
    }, { capacidad: 0, volumen: 0 });

  const dep = sumarLitros(cacheDepositos, "deposito");
  const mast = sumarLitros(cacheMastelones, "deposito");
  const bar = sumarLitros(cacheBarricas, "barrica");
  const kilos = (cacheEntradas || []).reduce((acc, e) => acc + (Number(e.kilos) || 0), 0);

  return {
    kilos_entrados: kilos,
    litros_depositos: dep.volumen,
    litros_mastelones: mast.volumen,
    litros_barricas: bar.volumen,
  };
}

function refrescarGraficosResumenDesdeCaches() {
  const chartKilos = document.getElementById("chartKilosValue");
  const chartLitros = document.getElementById("chartLitrosValue");
  if (!chartKilos || !chartLitros) return;
  const calculado = calcularLitrosResumenDesdeCaches();
  actualizarGraficosResumen(calculado);
}

function actualizarGraficosResumen(data) {
  const calculado = calcularLitrosResumenDesdeCaches();
  const elegir = (valorApi, valorLocal) => {
    const apiNum = Number(valorApi);
    if (Number.isFinite(apiNum) && apiNum > 0) return apiNum;
    const localNum = Number(valorLocal);
    return Number.isFinite(localNum) ? localNum : 0;
  };
  const kilos = elegir(data?.kilos_entrados, calculado.kilos_entrados);
  const litrosDepositos = elegir(data?.litros_depositos, calculado.litros_depositos);
  const litrosMastelones = elegir(data?.litros_mastelones, calculado.litros_mastelones);
  const litrosBarricas = elegir(data?.litros_barricas, calculado.litros_barricas);
  const litrosTotales = litrosDepositos + litrosMastelones + litrosBarricas;
  const maxValor = Math.max(kilos, litrosTotales, 1);

  actualizarBarra("chartKilosBar", "chartKilosValue", kilos, "kg", maxValor);
  actualizarBarra("chartLitrosBar", "chartLitrosValue", litrosTotales, "L", maxValor);

  const detalle = document.getElementById("chartLitrosDetalle");
  if (detalle) {
    const depTxt = `${Math.round(litrosDepositos).toLocaleString()} L`;
    const mastTxt = `${Math.round(litrosMastelones).toLocaleString()} L`;
    const barrTxt = `${Math.round(litrosBarricas).toLocaleString()} L`;
    detalle.innerHTML = `
      🛢 Depósitos: ${depTxt} ·
      🪣 Mastelones: ${mastTxt} ·
      <span style="display:inline-flex; align-items:center; gap:4px;">
        <img src="/barricas.png" alt="Barricas" style="width:16px; height:16px; object-fit:contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); mix-blend-mode:multiply; background:transparent;">
        Barricas: ${barrTxt}
      </span>
    `;
  }
}

function formatearNumeroCorto(valor) {
  const num = Number(valor) || 0;
  if (Math.abs(num) >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (Math.abs(num) >= 1000) return `${(num / 1000).toFixed(1)}k`;
  return num.toLocaleString("es-ES", { maximumFractionDigits: 0 });
}

function actualizarIndicadores() {
  const depPrincipal = document.getElementById("indicadorDepositosPrincipal");
  if (!depPrincipal) return;

  const calcularTotales = (lista, tipoNodo) =>
    (lista || []).reduce(
      (acc, item) => {
        const capacidad = Number(
          item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)
        ) || 0;
        const volNodo = tipoNodo ? obtenerVolumenFinalNodoContenedor(tipoNodo, item.id) : null;
        const volumen = Number.isFinite(volNodo)
          ? Number(volNodo)
          : (Number(item.litros_actuales || 0) || 0);
        return {
          capacidad: acc.capacidad + capacidad,
          volumen: acc.volumen + volumen,
        };
      },
      { capacidad: 0, volumen: 0 }
    );

  const dep = calcularTotales(cacheDepositos, "deposito");
  const depPorcentaje = dep.capacidad > 0 ? Math.round((dep.volumen / dep.capacidad) * 100) : 0;
  depPrincipal.textContent = `${depPorcentaje}% ocupado`;
  const depDetalle = document.getElementById("indicadorDepositosDetalle");
  if (depDetalle) {
    depDetalle.textContent = `${formatearLitrosPlano(dep.volumen)} de ${formatearLitrosPlano(
      dep.capacidad
    )}`;
  }
  const depExtra = document.getElementById("indicadorDepositosExtra");
  if (depExtra) {
    const libre = Math.max(dep.capacidad - dep.volumen, 0);
    depExtra.textContent = libre
      ? `${formatearLitrosPlano(libre)} libres`
      : "Sin capacidad libre";
  }

  const mast = calcularTotales(cacheMastelones, "deposito");
  const mastPrincipal = document.getElementById("indicadorMastelonesPrincipal");
  if (mastPrincipal) {
    const mastPorcentaje =
      mast.capacidad > 0 ? Math.round((mast.volumen / mast.capacidad) * 100) : 0;
    mastPrincipal.textContent = `${mastPorcentaje}% ocupado`;
    const mastDetalle = document.getElementById("indicadorMastelonesDetalle");
    if (mastDetalle) {
      mastDetalle.textContent = `${formatearLitrosPlano(mast.volumen)} de ${formatearLitrosPlano(
        mast.capacidad
      )}`;
    }
    const mastExtra = document.getElementById("indicadorMastelonesExtra");
    if (mastExtra) {
      const libre = Math.max(mast.capacidad - mast.volumen, 0);
      mastExtra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Sin capacidad libre";
    }
  }

  const bar = calcularTotales(cacheBarricas, "barrica");
  const barPrincipal = document.getElementById("indicadorBarricasPrincipal");
  if (barPrincipal) {
    const barPorcentaje = bar.capacidad > 0 ? Math.round((bar.volumen / bar.capacidad) * 100) : 0;
    barPrincipal.textContent = `${barPorcentaje}% ocupado`;
    const detalle = document.getElementById("indicadorBarricasDetalle");
    if (detalle) {
      detalle.textContent = `${formatearLitrosPlano(bar.volumen)} de ${formatearLitrosPlano(
        bar.capacidad
      )}`;
    }
    const extra = document.getElementById("indicadorBarricasExtra");
    if (extra) {
      const libre = Math.max(bar.capacidad - bar.volumen, 0);
      extra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Barricas al máximo";
    }
  }

  const totalBotellas = (cacheEmbotellados || []).reduce(
    (acc, e) => acc + (Number(e.botellas) || 0),
    0
  );
  const embPrincipal = document.getElementById("indicadorEmbotelladosPrincipal");
  if (embPrincipal) {
    embPrincipal.textContent = `${formatearNumeroCorto(totalBotellas)} botellas`;
    const detalle = document.getElementById("indicadorEmbotelladosDetalle");
    if (detalle) {
      detalle.textContent = totalBotellas
        ? `${totalBotellas.toLocaleString("es-ES")} botellas embotelladas`
        : "Aún no hay embotellados recientes";
    }
  }
}
function actualizarAprovechamientoAnual() {
  const tbody = document.getElementById("tablaAprovechamiento");
  if (!tbody) return;

  const kilosPorAnada = {};
  (cacheEntradas || []).forEach(e => {
    const anada = (e.anada || obtenerAnadaDesdeFecha(e.fecha || "") || "Sin añada").toString();
    const kilos = Number(e.kilos || 0);
    kilosPorAnada[anada] = (kilosPorAnada[anada] || 0) + kilos;
  });

  const litrosPorAnada = {};
  const acumularLitros = (coleccion, campoAnada) => {
    coleccion.forEach(item => {
      const litros = Number(item.litros_actuales || 0);
      if (!litros) return;
      const anada = (item[campoAnada] || "Sin añada").toString();
      litrosPorAnada[anada] = (litrosPorAnada[anada] || 0) + litros;
    });
  };
  acumularLitros(cacheDepositos || [], "vino_anio");
  acumularLitros(cacheMastelones || [], "vino_anio");
  acumularLitros(cacheBarricas || [], "vino_anio");

  const todas = Array.from(new Set([...Object.keys(kilosPorAnada), ...Object.keys(litrosPorAnada)]));
  todas.sort((a, b) => {
    const numA = Number(a);
    const numB = Number(b);
    if (Number.isNaN(numA) || Number.isNaN(numB)) return a.localeCompare(b);
    return numB - numA;
  });

  tbody.innerHTML = "";
  if (!todas.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="4">No hay datos disponibles todavía.</td>';
    tbody.appendChild(tr);
    return;
  }

  todas.forEach(anada => {
    const kilos = kilosPorAnada[anada] || 0;
    const litros = litrosPorAnada[anada] || 0;
    const aprovechamiento = kilos > 0 ? ((litros / kilos) * 100) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${anada}</td>
      <td>${kilos.toLocaleString("es-ES", { maximumFractionDigits: 0 })} kg</td>
      <td>${litros.toLocaleString("es-ES", { maximumFractionDigits: 1 })} L</td>
      <td>${aprovechamiento.toFixed(1)} %</td>
    `;
    tbody.appendChild(tr);
  });
}

function limitarZoomPlanoBodega(valor) {
  const z = Number(valor);
  if (!Number.isFinite(z)) return 1;
  return Math.max(PLANO_ZOOM_MIN, Math.min(PLANO_ZOOM_MAX, z));
}

function actualizarZoomPlanoBodegaUI() {
  const label = document.getElementById("planoZoomLabel");
  if (label) {
    label.textContent = `${Math.round((planoZoom || 1) * 100)}%`;
  }
  const range = document.getElementById("planoZoomRange");
  if (range) {
    range.value = String(Math.round((planoZoom || 1) * 100));
  }
}

function aplicarZoomPlanoBodega(nuevoZoom, opciones = {}) {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const prevZoom = planoZoom || 1;
  const centroWorld = opciones.centroWorld || {
    x: (editor.scrollLeft + editor.clientWidth / 2) / prevZoom,
    y: (editor.scrollTop + editor.clientHeight / 2) / prevZoom,
  };

  planoZoom = limitarZoomPlanoBodega(nuevoZoom);
  try {
    localStorage.setItem("planoZoom", String(planoZoom));
  } catch (e) {
    // noop
  }

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;
  canvas.style.transform = `scale(${planoZoom})`;
  stage.style.width = `${planoWorldBase.width * planoZoom}px`;
  stage.style.height = `${planoWorldBase.height * planoZoom}px`;

  editor.scrollLeft = Math.max(0, centroWorld.x * planoZoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centroWorld.y * planoZoom - editor.clientHeight / 2);

  actualizarZoomPlanoBodegaUI();
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function zoomPlanoBodega(direccion) {
  const signo = direccion < 0 ? -1 : 1;
  aplicarZoomPlanoBodega((planoZoom || 1) + signo * PLANO_ZOOM_STEP);
}

function resetZoomPlanoBodega() {
  aplicarZoomPlanoBodega(1);
}

function setZoomPlanoBodega(valorPorcentaje) {
  const pct = Number(valorPorcentaje);
  if (!Number.isFinite(pct)) return;
  aplicarZoomPlanoBodega(pct / 100);
}

function esSeccionPlanoActiva() {
  const sec = document.getElementById("plano");
  return Boolean(sec && sec.classList.contains("visible"));
}

function actualizarModoManoPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const activo = Boolean(planoPanBloqueado || planoPanSpace);
  editor.classList.toggle("pan-activo", activo);
}

function toggleModoManoPlanoBodega() {
  planoPanBloqueado = !planoPanBloqueado;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarPanPlanoBodega(ev, editor) {
  if (!editor) return;
  if (planoPanDrag) return;
  ev.preventDefault();
  planoPanDrag = {
    editor,
    pointerId: ev.pointerId,
    startX: ev.clientX,
    startY: ev.clientY,
    startScrollLeft: editor.scrollLeft,
    startScrollTop: editor.scrollTop,
  };
  editor.classList.add("panning");
  try {
    editor.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  editor.addEventListener("pointermove", moverPanPlanoBodega);
  editor.addEventListener("pointerup", finalizarPanPlanoBodega);
  editor.addEventListener("pointercancel", finalizarPanPlanoBodega);
}

function moverPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, startX, startY, startScrollLeft, startScrollTop } = planoPanDrag;
  const dx = ev.clientX - startX;
  const dy = ev.clientY - startY;
  editor.scrollLeft = startScrollLeft - dx;
  editor.scrollTop = startScrollTop - dy;
  programarActualizacionMinimapPlanoBodega();
}

function finalizarPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, pointerId } = planoPanDrag;
  try {
    editor.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  editor.classList.remove("panning");
  editor.removeEventListener("pointermove", moverPanPlanoBodega);
  editor.removeEventListener("pointerup", finalizarPanPlanoBodega);
  editor.removeEventListener("pointercancel", finalizarPanPlanoBodega);
  planoPanDrag = null;
}

function manejarPointerDownPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const target = ev.target;
  if (target && target.closest && target.closest(".plano-item")) return;

  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanBloqueado || planoPanSpace || boton === 1);
  if (esPan) {
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  limpiarSeleccionPlanoBodega();
}

function manejarWheelPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (!(ev.ctrlKey || ev.metaKey)) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  ev.preventDefault();
  const signo = ev.deltaY < 0 ? 1 : -1;
  const nuevoZoom = (planoZoom || 1) + signo * PLANO_ZOOM_STEP;
  const rect = editor.getBoundingClientRect();
  const pointerX = ev.clientX - rect.left;
  const pointerY = ev.clientY - rect.top;
  const centroWorld = {
    x: (editor.scrollLeft + pointerX) / (planoZoom || 1),
    y: (editor.scrollTop + pointerY) / (planoZoom || 1),
  };
  aplicarZoomPlanoBodega(nuevoZoom, { centroWorld });
}

function onPlanoKeyDown(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (ev.code !== "Space") return;
  const target = ev.target;
  if (
    target &&
    (target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.tagName === "SELECT" ||
      target.isContentEditable)
  ) {
    return;
  }
  if (planoPanSpace) return;
  planoPanSpace = true;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function onPlanoKeyUp(ev) {
  if (ev.code !== "Space") return;
  if (!planoPanSpace) return;
  planoPanSpace = false;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function programarActualizacionMinimapPlanoBodega() {
  if (planoMinimapRaf) return;
  planoMinimapRaf = requestAnimationFrame(() => {
    planoMinimapRaf = null;
    actualizarMinimapPlanoBodega();
  });
}

function seleccionarPlanoBodegaPorClave(tipo, id, opciones = {}) {
  if (!tipo || id == null) return;
  planoSeleccion = { tipo, id };
  renderPlano();
  if (opciones.centrar) {
    requestAnimationFrame(() => centrarSeleccionPlanoBodega());
  }
}

function inicializarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const viewport = document.getElementById("planoMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    planoMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapPlanoBodega(ev);
    world.addEventListener("pointermove", moverDesdeMinimapPlanoBodega);
    world.addEventListener("pointerup", finalizarMinimapPlanoBodega);
    world.addEventListener("pointercancel", finalizarMinimapPlanoBodega);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, editor } = planoMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / rect.width) * (planoWorldBase.width || 1);
  const worldY = (relY / rect.height) * (planoWorldBase.height || 1);
  editor.scrollLeft = Math.max(0, worldX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * (planoZoom || 1) - editor.clientHeight / 2);
  programarActualizacionMinimapPlanoBodega();
}

function finalizarMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, pointerId } = planoMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapPlanoBodega);
  world.removeEventListener("pointerup", finalizarMinimapPlanoBodega);
  world.removeEventListener("pointercancel", finalizarMinimapPlanoBodega);
  planoMinimapDrag = null;
}

function actualizarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const dotsHost = document.getElementById("planoMinimapDots");
  const viewport = document.getElementById("planoMinimapViewport");
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const aspect = (planoWorldBase.height || 1) / (planoWorldBase.width || 1);
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = planoZoom || 1;
  const worldW = planoWorldBase.width || 1;
  const worldH = planoWorldBase.height || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / worldW) * mmW}px`;
  viewport.style.top = `${(viewY / worldH) * mmH}px`;
  viewport.style.width = `${(viewW / worldW) * mmW}px`;
  viewport.style.height = `${(viewH / worldH) * mmH}px`;

  const cardWidth = PLANO_CARD_WIDTH;
  const cardHeight = PLANO_CARD_HEIGHT;
  const itemEls = Array.from(canvas.querySelectorAll(".plano-item"));
  dotsHost.innerHTML = "";
  itemEls.forEach(el => {
    const tipo = el.dataset.tipo || "";
    const id = el.dataset.id || "";
    const codigo = el.dataset.codigo || "";
    const xPct = parseFloat(el.dataset.posx || "") || 0;
    const yPct = parseFloat(el.dataset.posy || "") || 0;
    const worldX = (xPct / 100) * worldW + cardWidth / 2;
    const worldY = (yPct / 100) * worldH + cardHeight / 2;
    const x = (worldX / worldW) * mmW;
    const y = (worldY / worldH) * mmH;
    const dot = document.createElement("div");
    dot.className = `plano-minimap-dot ${tipo}`;
    if (el.classList.contains("seleccionado")) dot.classList.add("seleccionado");
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.title = tipo ? `${tipo} ${codigo || `#${id}`}` : "Contenedor";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      seleccionarPlanoBodegaPorClave(tipo, id, { centrar: true });
    });
    dotsHost.appendChild(dot);
  });
}

function limpiarSeleccionPlanoBodega() {
  planoSeleccion = null;
  planoSeleccionItemActual = null;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  renderInspectorPlanoBodega(null);
}

function seleccionarPlanoBodega(item, elemento) {
  if (!item || !item.tipo || item.id == null) return;
  planoSeleccion = { tipo: item.tipo, id: item.id };
  planoSeleccionItemActual = item;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  if (elemento) elemento.classList.add("seleccionado");
  renderInspectorPlanoBodega(item);
}

function abrirSeleccionPlanoBodega() {
  if (!planoSeleccionItemActual) return;
  irAlContenedor(planoSeleccionItemActual);
}

function centrarSeleccionPlanoBodega() {
  if (!planoSeleccion) return;
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const selector = `.plano-item[data-tipo="${planoSeleccion.tipo}"][data-id="${planoSeleccion.id}"]`;
  const el = canvas.querySelector(selector);
  if (!el) return;

  const xPct = parseFloat(el.dataset.posx || "") || 0;
  const yPct = parseFloat(el.dataset.posy || "") || 0;
  const centerX = (xPct / 100) * planoWorldBase.width + el.offsetWidth / 2;
  const centerY = (yPct / 100) * planoWorldBase.height + el.offsetHeight / 2;
  editor.scrollLeft = Math.max(0, centerX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * (planoZoom || 1) - editor.clientHeight / 2);
}

function ajustarVistaPlanoBodega() {
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const items = Array.from(canvas.querySelectorAll(".plano-item"));
  if (!items.length) {
    resetZoomPlanoBodega();
    editor.scrollLeft = 0;
    editor.scrollTop = 0;
    return;
  }

  const baseW = planoWorldBase.width || canvas.clientWidth || 1200;
  const baseH = planoWorldBase.height || canvas.clientHeight || 620;
  const cardWidth = PLANO_CARD_WIDTH;
  const cardHeight = PLANO_CARD_HEIGHT;
  const cardWPercent = (cardWidth / baseW) * 100;
  const cardHPercent = (cardHeight / baseH) * 100;

  let minX = 100;
  let minY = 100;
  let maxX = 0;
  let maxY = 0;
  items.forEach(el => {
    const x = parseFloat(el.dataset.posx || "") || 0;
    const y = parseFloat(el.dataset.posy || "") || 0;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + cardWPercent);
    maxY = Math.max(maxY, y + cardHPercent);
  });

  const bboxW = ((maxX - minX) / 100) * baseW;
  const bboxH = ((maxY - minY) / 100) * baseH;
  if (!(bboxW > 0 && bboxH > 0)) return;

  const padding = 0.92;
  const zoom = padding * Math.min(editor.clientWidth / bboxW, editor.clientHeight / bboxH);
  const centerX = (((minX + maxX) / 2) / 100) * baseW;
  const centerY = (((minY + maxY) / 2) / 100) * baseH;
  aplicarZoomPlanoBodega(zoom, { centroWorld: { x: centerX, y: centerY } });
}

function inicializarPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const baseW = parseFloat(canvas.style.width) || canvas.clientWidth || canvas.offsetWidth || 2800;
  const baseH = parseFloat(canvas.style.height) || canvas.clientHeight || canvas.offsetHeight || 1600;
  planoWorldBase = {
    width: Math.max(600, Math.round(baseW)),
    height: Math.max(520, Math.round(baseH)),
  };

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;

  if (!planoUIInicializada) {
    editor.addEventListener("pointerdown", manejarPointerDownPlanoEditor);
    editor.addEventListener("wheel", manejarWheelPlanoEditor, { passive: false });
    editor.addEventListener("scroll", programarActualizacionMinimapPlanoBodega, { passive: true });
    window.addEventListener("keydown", onPlanoKeyDown);
    window.addEventListener("keyup", onPlanoKeyUp);
    window.addEventListener("resize", programarActualizacionMinimapPlanoBodega);
    planoUIInicializada = true;
  }

  let initZoom = 1;
  try {
    const saved = Number(localStorage.getItem("planoZoom"));
    if (Number.isFinite(saved) && saved > 0) {
      initZoom = saved;
    } else {
      const fit = Math.min(
        1,
        (editor.clientWidth || planoWorldBase.width) / planoWorldBase.width,
        (editor.clientHeight || planoWorldBase.height) / planoWorldBase.height
      );
      initZoom = fit;
    }
  } catch (e) {
    // noop
  }
  aplicarZoomPlanoBodega(initZoom);
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function renderInspectorPlanoBodega(item) {
  const panel = document.getElementById("planoInfo");
  if (!panel) return;
  const escapeHtml = value =>
    String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");

  const zoomPct = Math.round((planoZoom || 1) * 100);
  const zoomMin = Math.round(PLANO_ZOOM_MIN * 100);
  const zoomMax = Math.round(PLANO_ZOOM_MAX * 100);
  const modoManoActivo = Boolean(planoPanBloqueado);
  const modoManoBtnClass = modoManoActivo ? "btnPrimario" : "btnSecundario";
  const modoManoBtnLabel = modoManoActivo ? "🖐 Mano: ON" : "🖐 Mano";

  const zoomHtml = `
    <div class="plano-zoom-controls">
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(-1)" title="Alejar" aria-label="Alejar">−</button>
      <button class="btnSecundario plano-zoom-label" id="planoZoomLabel" type="button" onclick="resetZoomPlanoBodega()" title="Reset zoom" aria-label="Reset zoom">${zoomPct}%</button>
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(1)" title="Acercar" aria-label="Acercar">+</button>
    </div>
    <input class="plano-zoom-range" id="planoZoomRange" type="range" min="${zoomMin}" max="${zoomMax}" step="5" value="${zoomPct}" oninput="setZoomPlanoBodega(this.value)" aria-label="Zoom del plano" />
  `;

  const minimapHtml = `
    <div class="plano-minimap-world" id="planoMinimapWorld" aria-label="Minimapa del plano" role="img">
      <div class="plano-minimap-grid"></div>
      <div class="plano-minimap-dots" id="planoMinimapDots"></div>
      <div class="plano-minimap-viewport" id="planoMinimapViewport"></div>
    </div>
    <div class="plano-minimap-hint">Minimapa: clic o arrastra para moverte · Space o “Mano” para arrastrar el lienzo</div>
  `;

  const baseHeader = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🛢</div>
      <div>
        <div class="flow-inspector-title">Inspector del plano</div>
        <div class="flow-inspector-sub">Selecciona un depósito, mastelone o barrica para ver el desglose.</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
  `;

  if (!item) {
    panel.innerHTML = `
      ${baseHeader}
      <div class="flow-inspector-tags">
        <span class="flow-tag">Click: seleccionar</span>
        <span class="flow-tag">Arrastrar: mover</span>
        <span class="flow-tag">Doble clic: abrir ficha</span>
        <span class="flow-tag">Space/Mano: pan</span>
        <span class="flow-tag">Click fuera: limpiar</span>
      </div>
      <dl class="flow-inspector-fields">
        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Ajustar vista” para ver todos los contenedores.</dd></div>
      </dl>
    `;
    inicializarMinimapPlanoBodega();
    programarActualizacionMinimapPlanoBodega();
    actualizarModoManoPlanoBodegaUI();
    return;
  }

  const etiquetaBase = item.tipo === "deposito" ? "Dep" : item.tipo === "mastelone" ? "Mas" : "Bar";
  const etiqueta = item.codigo ? `${etiquetaBase} ${item.codigo}` : `${etiquetaBase} #${item.id}`;
  const subtitulo = item.tipo === "deposito" ? "Depósito" : item.tipo === "mastelone" ? "Mastelone" : "Barrica";
  const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
  const volumen = item.volumen != null ? Number(item.volumen) : 0;
  const libre = capacidad && capacidad > 0 ? Math.max(capacidad - volumen, 0) : null;
  const porcentaje =
    capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

  const estadoTexto =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? obtenerInfoEstadoDeposito(item.estado)?.descripcion || ""
      : "";
  const vinoTipo = item.variedadNodo || item.vino_tipo || "";
  const vinoAnio = item.vino_anio || "";

  const tags = [
    `Tipo: ${subtitulo}`,
    capacidad && capacidad > 0 ? `Llenado: ${porcentaje}%` : "Sin capacidad",
    item.enMapa ? "Fuente: mapa de nodos" : "Fuente: ficha",
  ];

  const filas = [
    { label: "Código", value: etiqueta },
    { label: "Capacidad", value: capacidad != null ? formatearLitrosPlano(capacidad) : "—" },
    { label: "Contenido", value: formatearLitrosPlano(volumen) },
    { label: "Libre", value: libre != null ? formatearLitrosPlano(libre) : "—" },
    vinoTipo ? { label: "Vino", value: vinoTipo } : null,
    vinoAnio ? { label: "Añada", value: vinoAnio } : null,
    estadoTexto ? { label: "Estado", value: estadoTexto } : null,
    item.tipo !== "barrica" && item.contenido ? { label: "Material", value: item.contenido } : null,
    item.tipo !== "barrica" && item.elaboracion ? { label: "Elaboración", value: item.elaboracion } : null,
    item.tipo === "barrica" && item.detalle ? { label: "Roble / tostado", value: item.detalle } : null,
    item.tipo === "barrica" && item.marca ? { label: "Marca", value: item.marca } : null,
    item.tipo === "barrica" && item.anio ? { label: "Año barrica", value: item.anio } : null,
    item.tipo !== "barrica" && item.detalle ? { label: "Notas", value: item.detalle } : null,
  ].filter(Boolean);

  panel.innerHTML = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🧭</div>
      <div>
        <div class="flow-inspector-title">${escapeHtml(etiqueta)}</div>
        <div class="flow-inspector-sub">${escapeHtml(subtitulo)}</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="centrarSeleccionPlanoBodega()">Centrar</button>
      <button class="btnPrimario" type="button" onclick="abrirSeleccionPlanoBodega()">Abrir ficha</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
    <div class="flow-inspector-tags">${tags.map(t => `<span class="flow-tag">${escapeHtml(t)}</span>`).join("")}</div>
    <dl class="flow-inspector-fields">${filas
      .map(
        item =>
          `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
      )
      .join("")}</dl>
  `;
  inicializarMinimapPlanoBodega();
  programarActualizacionMinimapPlanoBodega();
  actualizarModoManoPlanoBodegaUI();
}

function renderPlano() {
  const canvas = document.getElementById("planoCanvas");
  const mensaje = document.getElementById("planoMensaje");
  if (!canvas || !mensaje) return;

  const canvasWidth = canvas.clientWidth || canvas.offsetWidth || 600;
  const canvasHeight = canvas.clientHeight || canvas.offsetHeight || 400;
  const cardWidth = PLANO_CARD_WIDTH;
  const cardHeight = PLANO_CARD_HEIGHT;
  const offsetXPercent = (cardWidth / canvasWidth) * 100;
  const offsetYPercent = (cardHeight / canvasHeight) * 100;

  canvas.innerHTML = "";
  const elementos = [
    ...cacheDepositos.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "deposito",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
    ...cacheMastelones.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "mastelone",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
    ...cacheBarricas.map(b => {
      const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(b.composicionVariedades || b.composicion_variedades) ||
        (esVariedadGenerica(b.vino_tipo) ? "" : (b.vino_tipo || ""));
      return {
        tipo: "barrica",
        id: b.id,
        codigo: b.codigo,
        pos_x: b.pos_x,
        pos_y: b.pos_y,
        capacidad: b.capacidad_l ?? null,
        volumen: volumenNodo != null ? volumenNodo : b.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: [b.tipo_roble, b.tostado].filter(Boolean).join(" · "),
        vino_tipo: b.vino_tipo || "",
        vino_anio: b.vino_anio || "",
        marca: b.marca || "",
        anio: b.anio || "",
        colorReferencia: b.vino_tipo || "",
      };
    }),
  ];

  if (!elementos.length) {
    mensaje.textContent = "Añade depósitos, mastelones o barricas para empezar.";
    limpiarSeleccionPlanoBodega();
    const placeholder = document.createElement("div");
    placeholder.className = "plano-placeholder";
    placeholder.textContent = "Sin elementos todavía";
    canvas.appendChild(placeholder);
    return;
  }

  mensaje.textContent = "Arrastra las tarjetas para guardar su posición.";
  let seleccionEncontrada = false;
  elementos.forEach((item, idx) => {
    const bloque = document.createElement("div");
    bloque.className = `plano-item ${item.tipo}`;
    bloque.dataset.id = String(item.id);
    bloque.dataset.tipo = item.tipo;
    if (item.codigo != null) bloque.dataset.codigo = String(item.codigo);
    if (planoSeleccion && planoSeleccion.tipo === item.tipo && String(planoSeleccion.id) === String(item.id)) {
      bloque.classList.add("seleccionado");
      seleccionEncontrada = true;
      planoSeleccionItemActual = item;
    }
    const etiqueta = item.codigo ? String(item.codigo) : String(item.id);
    const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
    const volumen = item.volumen != null ? Number(item.volumen) : 0;
    const porcentaje =
      capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

    const header = document.createElement("div");
    header.className = "plano-card-header";
    const subtitulo =
      item.tipo === "deposito"
        ? "Depósito"
        : item.tipo === "mastelone"
        ? "Mastelone"
        : "Barrica";
    header.innerHTML = `
      <div class="plano-card-title-row">
        <span class="plano-card-dot" aria-hidden="true"></span>
        <span class="plano-card-code">${etiqueta}</span>
      </div>
      <small>${subtitulo}</small>
    `;
    const estaVacio = !Number.isFinite(volumen) || volumen <= 0;
    if (estaVacio) {
      const estadoInfo = obtenerInfoEstadoDeposito("vacio");
      const estadoBadge = document.createElement("span");
      estadoBadge.className = `estado-pill mini estado-${estadoInfo.id}`;
      estadoBadge.textContent = estadoInfo.label;
      header.appendChild(estadoBadge);
    }
    bloque.appendChild(header);

    const body = document.createElement("div");
    body.className = "plano-card-body";
    const materialColor = obtenerColorMaterialContenedor(
      item.tipo === "barrica" ? "Madera" : item.contenido || item.detalle || "",
      item.tipo
    );

    const info = document.createElement("div");
    info.className = "plano-card-info";
    info.innerHTML = `
      <div>
        <small>Capacidad</small>
        <strong>${formatearLitrosPlano(capacidad)}</strong>
      </div>
      <div>
        <small>Contenido</small>
        <strong>${formatearLitrosPlano(volumen)}</strong>
      </div>
    `;
    body.appendChild(info);

    const colorVino =
      obtenerColorVinoReferencia(item.variedadNodo || item.vino_tipo || item.colorReferencia) ||
      materialColor ||
      (item.tipo === "barrica"
        ? "#c48a1b"
        : item.tipo === "mastelone"
        ? "#8b1b2b"
        : "#8f97a8");
    try {
      const acento = (colorVino || materialColor || "#8f97a8").toString();
      bloque.style.setProperty("--plano-accent", acento);
      const pastel = mezclarHexConBlanco(acento, 0.86, 0.18);
      const glow = mezclarHexConBlanco(acento, 0.8, 0.14);
      bloque.style.setProperty(
        "--plano-card-bg",
        `radial-gradient(circle at 16% 16%, ${pastel} 0%, rgba(255,255,255,0) 58%),` +
          `radial-gradient(circle at 84% 78%, ${pastel} 0%, rgba(255,255,255,0) 62%),` +
          `linear-gradient(180deg, rgba(255,255,255,0.94), rgba(255,255,255,0.86))`
      );
      bloque.style.setProperty("--plano-card-glow", glow);
    } catch (e) {
      // noop
    }
    const progress = document.createElement("div");
    progress.className = "plano-card-progress";
    const barra = document.createElement("div");
    barra.className = "plano-card-progress-bar";
    barra.style.background = colorVino;
    const alturaBarra = capacidad && capacidad > 0 ? porcentaje : 0;
    barra.style.height = `${alturaBarra}%`;
    const etiquetaPorcentaje = document.createElement("span");
    etiquetaPorcentaje.textContent = `${porcentaje}%`;
    progress.appendChild(barra);
    progress.appendChild(etiquetaPorcentaje);

    bloque.appendChild(progress);
    bloque.appendChild(body);

    const extra = document.createElement("div");
    extra.className = "plano-card-extra";
    const uvasTexto = (item.variedadNodo || item.vino_tipo || "").toString();
    const anioTxt = (item.vino_anio || "").toString().trim();

    if (anioTxt) {
      const anada = document.createElement("div");
      anada.className = "plano-card-anada";
      anada.textContent = anioTxt;
      anada.title = "Añada";
      extra.appendChild(anada);
    }

    const uvas = document.createElement("div");
    uvas.className = "plano-card-uvas";
    uvas.textContent = uvasTexto ? uvasTexto : "Sin uva";
    uvas.title = uvasTexto || "";
    extra.appendChild(uvas);
    bloque.appendChild(extra);

  const defaultX = 6 + (idx * 13) % 80;
  const defaultY = 8 + (idx * 17) % 70;
  const x = item.pos_x != null ? item.pos_x : defaultX;
  const y = item.pos_y != null ? item.pos_y : defaultY;

  const clampedX = Math.max(0, Math.min(100 - offsetXPercent, x));
  const clampedY = Math.max(0, Math.min(100 - offsetYPercent, y));
    bloque.style.left = `${clampedX}%`;
    bloque.style.top = `${clampedY}%`;
  bloque.dataset.posx = clampedX;
  bloque.dataset.posy = clampedY;
  bloque.addEventListener("dblclick", () => irAlContenedor(item));

  bloque.addEventListener("pointerdown", ev => iniciarArrastrePlano(ev, item, bloque));
  canvas.appendChild(bloque);
});

  if (planoSeleccion && !seleccionEncontrada) {
    planoSeleccion = null;
    planoSeleccionItemActual = null;
  }
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarArrastrePlano(ev, item, elemento) {
  const editor = document.getElementById("planoEditor");
  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanBloqueado || planoPanSpace || boton === 1);
  if (esPan && editor) {
    ev.stopPropagation();
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  ev.stopPropagation();
  ev.preventDefault();
  const canvas = document.getElementById("planoCanvas");
  if (!canvas) return;
  seleccionarPlanoBodega(item, elemento);
  const rect = elemento.getBoundingClientRect();

  planoDrag = {
    item,
    elemento,
    pointerId: ev.pointerId,
    canvas,
    offsetX: ev.clientX - rect.left,
    offsetY: ev.clientY - rect.top,
    startClientX: ev.clientX,
    startClientY: ev.clientY,
    moved: false,
    startPos: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
    current: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
  };

  try {
    elemento.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  window.addEventListener("pointermove", moverElementoPlano);
  window.addEventListener("pointerup", soltarElementoPlano);
  window.addEventListener("pointercancel", cancelarArrastrePlano);
}

function moverElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  const { canvas, elemento, offsetX, offsetY } = planoDrag;
  const rect = canvas.getBoundingClientRect();
  const elRect = elemento.getBoundingClientRect();

  if (!planoDrag.moved) {
    const dx = ev.clientX - (planoDrag.startClientX || 0);
    const dy = ev.clientY - (planoDrag.startClientY || 0);
    if (Math.hypot(dx, dy) < PLANO_DRAG_THRESHOLD_PX) return;
    planoDrag.moved = true;
    elemento.classList.add("arrastrando");
  }

  let px = ev.clientX - rect.left - offsetX;
  let py = ev.clientY - rect.top - offsetY;

  const maxX = rect.width - elRect.width;
  const maxY = rect.height - elRect.height;

  px = Math.max(0, Math.min(maxX, px));
  py = Math.max(0, Math.min(maxY, py));

  const xPercent = (px / rect.width) * 100;
  const yPercent = (py / rect.height) * 100;

  elemento.style.left = `${xPercent}%`;
  elemento.style.top = `${yPercent}%`;
  elemento.dataset.posx = xPercent;
  elemento.dataset.posy = yPercent;
  planoDrag.current = { x: xPercent, y: yPercent };
}

function soltarElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  finalizarArrastrePlano(true);
}

function cancelarArrastrePlano() {
  finalizarArrastrePlano(false);
}

function finalizarArrastrePlano(guardar) {
  if (!planoDrag) return;
  window.removeEventListener("pointermove", moverElementoPlano);
  window.removeEventListener("pointerup", soltarElementoPlano);
  window.removeEventListener("pointercancel", cancelarArrastrePlano);

  if (planoDrag.elemento) {
    try {
      planoDrag.elemento.releasePointerCapture(planoDrag.pointerId);
    } catch (e) {
      // noop
    }
    planoDrag.elemento.classList.remove("arrastrando");
  }

  if (!planoDrag.moved) {
    planoDrag = null;
    return;
  }

  if (guardar && planoDrag.current) {
    guardarPosicionPlano(planoDrag.item, planoDrag.current.x, planoDrag.current.y);
  } else {
    renderPlano();
  }

  planoDrag = null;
}

async function guardarPosicionPlano(item, x, y) {
  const url =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? `/api/depositos/${item.id}/posicion`
      : `/api/barricas/${item.id}/posicion`;
  const pos = {
    pos_x: Math.round(x * 100) / 100,
    pos_y: Math.round(y * 100) / 100,
  };

  try {
    const res = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pos),
    });
    if (!res.ok) throw new Error("Error HTTP " + res.status);
    actualizarCachePlano(item, pos.pos_x, pos.pos_y);
  } catch (err) {
    console.error("Error guardando posición:", err);
    alert("No se pudo guardar la nueva ubicación. Se restaurará la vista.");
    renderPlano();
  }
}

function actualizarCachePlano(item, x, y) {
  if (item.tipo === "deposito") {
    const dep = cacheDepositos.find(d => d.id === item.id);
    if (dep) {
      dep.pos_x = x;
      dep.pos_y = y;
    }
  } else if (item.tipo === "mastelone") {
    const mas = cacheMastelones.find(d => d.id === item.id);
    if (mas) {
      mas.pos_x = x;
      mas.pos_y = y;
    }
  } else {
    const bar = cacheBarricas.find(b => b.id === item.id);
    if (bar) {
      bar.pos_x = x;
      bar.pos_y = y;
    }
  }
}

// ---------- Resumen (bodega) ----------
async function cargarResumen() {
  try {
    // 1) Resumen principal (kilos, depósitos, barricas)
    const res = await fetch("/api/resumen");
    if (!res.ok) return;
    const data = await res.json();
    const calculado = calcularLitrosResumenDesdeCaches();

    document.getElementById("resumenKilos").textContent =
      (Number(calculado.kilos_entrados || 0) || Number(data.kilos_entrados || 0) || 0).toFixed(0) + " kg";

    document.getElementById("resumenDepositos").textContent =
      data.depositos || 0;

    document.getElementById("resumenBarricas").textContent =
      data.barricas || 0;
    actualizarGraficosResumen({ ...data, ...calculado });

  } catch (err) {
    console.error("Error cargando resumen:", err);
  }
}
        // ---------- Entradas de uva ----------
        async function cargarEntradas() {
            try {
                mostrarSkeletonTabla("tablaEntradas", 12, 4);
                const res = await fetch("/api/entradas_uva");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEntradas = datos;

                const tbody = document.getElementById("tablaEntradas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="10">No hay entradas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const anada = e.anada || obtenerAnadaDesdeFecha(e.fecha || "");
                    const fechaEntrada = formatearFechaCorta(e.fecha);
                    const densidad = formatearDensidad(e.densidad);
                    const temperaturaVal = Number(e.temperatura);
                    const temperatura = Number.isFinite(temperaturaVal) ? temperaturaVal.toFixed(1) : "";
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${e.id}</td>
                        <td>${fechaEntrada}</td>
                        <td>${anada}</td>
                        <td>${e.variedad || ""}</td>
                        <td>${e.viticultor || ""}</td>
                        <td>${e.tipo_suelo || ""}</td>
                        <td>${e.parcela || ""}</td>
                        <td>${e.anos_vid || ""}</td>
                        <td>${e.kilos ?? ""}</td>
                        <td>${densidad}</td>
                        <td>${temperatura}</td>
                        <td>
                            <button class="small-btn" style="margin-right:6px;"
                                onclick="editarEntradaUva(${e.id})">
                                Editar
                            </button>
                            <button class="small-btn" style="background:#c00; color:#fff;"
                                onclick="eliminarEntradaUva(${e.id})">
                                Borrar
                            </button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
                renderResumenParcelas();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
                renderFlowNodes();
            } catch (err) {
                console.error("Error cargando entradas:", err);
            }
        }

function renderResumenParcelas() {
            const tbody = document.getElementById("tablaResumenParcelas");
            if (!tbody) return;
            tbody.innerHTML = "";

            if (!cacheEntradas.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin datos todavía.</td>';
                tbody.appendChild(tr);
                return;
            }

            const resumen = {};
            cacheEntradas.forEach(e => {
                const parcela = (e.parcela || "Sin parcela").trim() || "Sin parcela";
                if (!resumen[parcela]) {
                    resumen[parcela] = { viajes: 0, kilos: 0, ultima: null };
                }
                resumen[parcela].viajes += 1;
                const kilos = Number(e.kilos || 0);
                resumen[parcela].kilos += Number.isNaN(kilos) ? 0 : kilos;
                const fecha = e.fecha || "";
                if (!resumen[parcela].ultima || fecha > resumen[parcela].ultima) {
                    resumen[parcela].ultima = fecha;
                }
            });

            Object.entries(resumen).forEach(([parcela, info]) => {
                const fecha = info.ultima ? new Date(info.ultima) : null;
                const fechaStr = formatearFechaCorta(info.ultima);
                const horaStr =
                    fecha && !Number.isNaN(fecha)
                        ? fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })
                        : "";
                const kilosValor = Number(info.kilos || 0);
                const kilosTexto =
                    kilosValor > 0
                        ? `${kilosValor.toLocaleString("es-ES", { minimumFractionDigits: 0 })} kg`
                        : "0 kg";
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${parcela}</td>
                    <td>${info.viajes}</td>
                    <td>${kilosTexto}</td>
                    <td>${fechaStr}</td>
                    <td>${horaStr}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function cancelarEdicionEntrada() {
            entradaEditandoId = null;
            const form = document.getElementById("formEntradaUva");
            if (form) form.reset();
            actualizarAnadaEntrada();
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Registrar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "none";
        }

        async function crearEntradaUva(ev) {
            ev.preventDefault();
            setFormFeedback("feedbackEntradaUva", "");
            const fecha = document.getElementById("entradaFecha").value;
            const variedad = document.getElementById("entradaVariedad").value;
            const viticultor = document.getElementById("entradaViticultor").value;
            const parcela = document.getElementById("entradaParcela").value;
            const tipo_suelo = document.getElementById("entradaSuelo").value;
            const anos_vid = document.getElementById("entradaAnosVid").value;
            const parseValor = (id) => {
                const raw = (document.getElementById(id).value || "").toString().trim();
                if (!raw) return null;
                const limpio = raw.replace(",", ".");
                const num = parseFloat(limpio);
                return Number.isFinite(num) ? num : null;
            };
            const kilos = parseValor("entradaKilos") || 0;
            const densidad = parseValor("entradaDensidad");
            const temperatura = parseValor("entradaTemperatura");

            if (!fecha || !variedad || !kilos) {
                setFormFeedback("feedbackEntradaUva", "Faltan datos: fecha, variedad o kilos.", "error");
                return;
            }

            try {
                const body = {
                    fecha,
                    variedad,
                    viticultor,
                    tipo_suelo,
                    parcela,
                    anos_vid,
                    kilos,
                    densidad,
                    temperatura
                };
                const url = entradaEditandoId ? `/api/entradas_uva/${entradaEditandoId}` : "/api/entradas_uva";
                const metodo = entradaEditandoId ? "PUT" : "POST";
                const res = await fetch(url, {
                    method: metodo,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                cancelarEdicionEntrada();
                await Promise.all([
                    cargarEntradas(),
                    cargarResumen(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarMovimientos(),
                ]);
                setFormFeedback("feedbackEntradaUva", "Entrada registrada correctamente.", "success");
                mostrarAviso("Entrada registrada en la bodega.", "success");
            } catch (err) {
                console.error("Error creando entrada:", err);
                setFormFeedback("feedbackEntradaUva", "Error al registrar la entrada de uva.", "error");
                mostrarAviso("No se pudo registrar la entrada.", "error");
            }
        }

        function editarEntradaUva(id) {
            const entrada = cacheEntradas.find(e => e.id === id);
            if (!entrada) {
                mostrarAviso("No encuentro esa entrada.", "error");
                return;
            }
            entradaEditandoId = id;
            document.getElementById("entradaFecha").value = formatearFechaParaInput(entrada.fecha);
            document.getElementById("entradaVariedad").value = entrada.variedad || "";
            document.getElementById("entradaParcela").value = entrada.parcela || "";
            document.getElementById("entradaViticultor").value = entrada.viticultor || "";
            document.getElementById("entradaSuelo").value = entrada.tipo_suelo || "";
            document.getElementById("entradaAnosVid").value = entrada.anos_vid || "";
            document.getElementById("entradaKilos").value = entrada.kilos ?? "";
            document.getElementById("entradaDensidad").value = entrada.densidad ?? "";
            document.getElementById("entradaTemperatura").value = entrada.temperatura ?? "";
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Actualizar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "inline-flex";
            document.getElementById("entradas").scrollIntoView({ behavior: "smooth", block: "start" });
        }

        async function eliminarEntradaUva(id) {
            if (!confirm("¿Seguro que quieres borrar esta entrada de uva?")) return;
            try {
                const res = await fetch(`/api/entradas_uva/${id}`, { method: "DELETE" });
                if (!res.ok) throw new Error();
                if (entradaEditandoId === id) {
                    cancelarEdicionEntrada();
                }
                await Promise.all([cargarEntradas(), cargarResumen(), cargarDepositos(), cargarBarricas(), cargarMovimientos()]);
            } catch (err) {
                console.error("Error borrando entrada:", err);
                alert("No se pudo borrar la entrada.");
            }
        }
// ---------- Depósitos (con edición de volumen, contenido y fecha) ----------
async function cargarDepositos() {
  try {
    mostrarSkeletonTabla("tablaDepositos", 9);
    const res = await fetch("/api/depositos");
    if (!res.ok) {
      console.error("Error HTTP al cargar depósitos:", res.status);
      return;
    }

    const datos = await res.json();
    const separados = datos.reduce(
      (acc, item) => {
        const clase = (item.clase || "deposito").toLowerCase();
        if (clase === "mastelone") {
          acc.mastelones.push(item);
        } else {
          acc.depositos.push(item);
        }
        return acc;
      },
      { depositos: [], mastelones: [] }
    );

    cacheDepositos = separados.depositos;
    cacheMastelones = separados.mastelones;
    // Volúmenes desde nodos (último eslabón)
    cacheDepositos.forEach(d => {
      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
      if (Number.isFinite(volNodo)) {
        d.litros_actuales = volNodo;
      }
    });
    cacheMastelones.forEach(d => {
      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
      if (Number.isFinite(volNodo)) {
        d.litros_actuales = volNodo;
      }
    });
    mapaDepositosPorId = new Map(cacheDepositos.map(d => [d.id, d]));
    mapaMastelonesPorId = new Map(cacheMastelones.map(d => [d.id, d]));

    const listaTabla = [...cacheDepositos, ...cacheMastelones];
    renderTablaContenedores(listaTabla, "tablaDepositos", "No hay depósitos ni mastelones.");
    renderPlano();
    renderAnalisisLab();
    actualizarIndicadores();
    refrescarGraficosResumenDesdeCaches();
    actualizarAprovechamientoAnual();
    actualizarMapaFlujo();
  } catch (err) {
    console.error("Error cargando depósitos:", err);
  }
}

function renderTablaContenedores(lista, tablaId, mensajeVacio) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  tbody.innerHTML = "";

  if (!lista.length) {
    tbody.innerHTML = `<tr><td colspan="9">${mensajeVacio}</td></tr>`;
    return;
  }

  lista.forEach(d => {
    const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
    let vol = Number(d.litros_actuales || 0);
    let variedad = d.vino_tipo || "";
    if (estadoNodo && estadoNodo.enMapa) {
      if (estadoNodo.volumen != null) {
        vol = Number(estadoNodo.volumen);
      }
      if (estadoNodo.variedad) {
        variedad = estadoNodo.variedad;
      }
    } else {
      vol = null;
      variedad = "";
    }
    const capacidad =
      d.capacidad_l != null
        ? Number(d.capacidad_l).toFixed(0)
        : d.capacidad_hl != null
        ? Number(d.capacidad_hl * 100).toFixed(0)
        : "";
    const material = d.material || d.contenido || "";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${d.id}</td>
      <td>${d.codigo || ""}</td>
      <td>${capacidad}</td>
      <td>${d.tipo || ""}</td>
      <td>${material}</td>
      <td>${variedad || "—"}</td>
      <td>${vol != null ? formatearLitrosPlano(vol) : "—"}</td>
      <td>
        <button class="small-btn"
          onclick="editarDepositoDatos(${d.id})">
          Editar
        </button>
      </td>
      <td>
        <button
          onclick="eliminarDeposito(${d.id}, ${vol})"
          style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
          Borrar
        </button>
      </td>
    `;
    tbody.appendChild(tr);
  });
}
  // No dejar borrar si tiene vino dentro
async function eliminarDeposito(id, volumen) {
  const registro =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  const clase = registro ? (registro.clase || "deposito") : "deposito";
  const etiqueta = clase === "mastelone" ? "mastelone" : "depósito";

  if (volumen > 0) {
    alert(`No puedes borrar un ${etiqueta} que todavía tiene vino. Pon el volumen a 0 primero.`);
    return;
  }

  const ok = confirm(`¿Seguro que quieres borrar este ${etiqueta}?`);
  if (!ok) return;

  try {
    const res = await fetch(`/api/depositos/${id}`, {
      method: "DELETE"
    });

    if (!res.ok) {
      alert("Error borrando el depósito.");
      console.error("Error HTTP al borrar depósito:", res.status);
      return;
    }

    alert("Depósito borrado.");
    cargarDepositos();
  } catch (err) {
    console.error("Error borrando depósito:", err);
    alert("Error borrando el depósito (mira la consola del servidor).");
  }
}
async function crearDeposito(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackDepositos", "");

  const codigo = document.getElementById("depCodigo").value.trim();
  const tipo = document.getElementById("depTipo").value;
  const clase = (tipo || "").trim().toLowerCase() === "mastelone" ? "mastelone" : "deposito";
  const capacidad_l = Number(document.getElementById("depCapacidad").value || 0);
  const estado = "vacio";
  const material = document.getElementById("depMaterial").value;
  const vino_tipo = "";
  const vino_anio = "";
  const elaboracion = "";
  const fecha_uso = null;
  if (!codigo) {
    setFormFeedback("feedbackDepositos", "El código del contenedor es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackDepositos", "Introduce una capacidad válida en litros.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackDepositos", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackDepositos", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch("/api/depositos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        clase,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        vino_tipo,
        vino_anio,
        elaboracion,
        fecha_uso,
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "Error creando depósito");
    if (!ok) return;

    // Limpia el formulario
    document.getElementById("formDeposito").reset();
    // Vuelve a cargar la tabla
    await Promise.all([cargarDepositos(), cargarResumen()]);
    setFormFeedback("feedbackDepositos", "Contenedor creado correctamente.", "success");
    mostrarAviso("Nuevo contenedor registrado.", "success");
  } catch (err) {
    console.error("Error creando depósito:", err);
    setFormFeedback("feedbackDepositos", "Error creando depósito.", "error");
    mostrarAviso("No se pudo crear el contenedor.", "error");
  }
}
function editarDepositoDatos(id) {
  const dep =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  if (!dep) {
    mostrarAviso("No encuentro ese depósito.", "error");
    return;
  }
  abrirModalDeposito(dep);
}

function abrirModalDeposito(dep) {
  depositoEditando = { ...dep };
  const modal = document.getElementById("modalDeposito");
  if (!modal) return;
  const capacidad =
    dep.capacidad_l != null
      ? Number(dep.capacidad_l)
      : dep.capacidad_hl != null
      ? Number(dep.capacidad_hl * 100)
      : "";
  const campos = {
    depCodigoEdit: dep.codigo || "",
    depCapacidadEdit: capacidad || "",
    depVolumenEdit: dep.litros_actuales != null ? Number(dep.litros_actuales).toFixed(1) : "0",
  };
  Object.entries(campos).forEach(([id, valor]) => {
    const input = document.getElementById(id);
    if (input) input.value = valor ?? "";
  });
  const tipoSelect = document.getElementById("depTipoEdit");
  if (tipoSelect) {
    tipoSelect.value = dep.tipo || "";
  }
  const materialSelect = document.getElementById("depMaterialEdit");
  if (materialSelect) {
    materialSelect.value = dep.material || dep.contenido || "";
  }
  const estadoSelect = document.getElementById("depEstadoEdit");
  if (estadoSelect) {
    estadoSelect.value = dep.estado || "vacio";
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = dep.vino_tipo || "Sin variedad";
  }
  setFormFeedback("feedbackEditarDeposito", "");
  modal.classList.add("visible");
}

function cerrarModalDeposito() {
  depositoEditando = null;
  const modal = document.getElementById("modalDeposito");
  if (modal) {
    modal.classList.remove("visible");
  }
  const form = document.getElementById("formEditarDeposito");
  if (form) {
    form.reset();
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = "—";
  }
  setFormFeedback("feedbackEditarDeposito", "");
}

async function guardarEdicionDeposito(ev) {
  ev.preventDefault();
  if (!depositoEditando) return;
  const codigo = document.getElementById("depCodigoEdit").value.trim();
  const capacidad_l = Number(document.getElementById("depCapacidadEdit").value || 0);
  const volumenNuevo = Number(document.getElementById("depVolumenEdit").value || 0);
  const tipo = document.getElementById("depTipoEdit").value;
  const material = document.getElementById("depMaterialEdit").value;
  const estado = document.getElementById("depEstadoEdit").value || "vacio";

  if (!codigo) {
    setFormFeedback("feedbackEditarDeposito", "El código es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackEditarDeposito", "Introduce una capacidad válida.", "error");
    return;
  }
  if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
    setFormFeedback("feedbackEditarDeposito", "El volumen debe ser un número positivo.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch(`/api/depositos/${depositoEditando.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        elaboracion: depositoEditando.elaboracion,
        vino_tipo: depositoEditando.vino_tipo,
        vino_anio: depositoEditando.vino_anio,
        fecha_uso: depositoEditando.fecha_uso,
        clase: depositoEditando.clase || "deposito",
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo actualizar el depósito.");
    if (!ok) return;
    await aplicarAjusteDeposito(
      depositoEditando.id,
      Number(depositoEditando.litros_actuales || 0),
      volumenNuevo,
      depositoEditando.clase || "deposito"
    );
    await Promise.all([cargarDepositos(), cargarMovimientos(), cargarResumen()]);
    mostrarAviso("Depósito actualizado.", "success");
    cerrarModalDeposito();
  } catch (err) {
    console.error("Error actualizando depósito:", err);
    setFormFeedback("feedbackEditarDeposito", "No se pudo actualizar el depósito.", "error");
  }
}
async function aplicarAjusteDeposito(id, volumenActual, nuevo, clase = "deposito") {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const tipoMovimiento = clase === "mastelone" ? "mastelone" : "deposito";
  const etiqueta = tipoMovimiento === "mastelone" ? "mastelone" : "depósito";
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: tipoMovimiento,
        destino_id: id,
        litros: delta,
        perdida_litros: null,
        nota: `Ajuste de volumen desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: tipoMovimiento,
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        perdida_litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste de volumen:", err);
    alert("No se pudo registrar el ajuste de volumen.");
  }
}
async function editarBarricaDatos(id) {
    const bar = cacheBarricas.find(b => b.id === id);
    if (!bar) {
        alert("No encuentro esa barrica.");
        return;
    }

    const codigo = prompt("Código:", bar.codigo || "");
    if (codigo === null || !codigo.trim()) return;

    const capacidadStr = prompt(
        "Capacidad (L):",
        bar.capacidad_l != null ? bar.capacidad_l : ""
    );
    if (capacidadStr === null) return;
    const capacidad_l = Number(capacidadStr);
    if (Number.isNaN(capacidad_l) || capacidad_l <= 0) {
        alert("Introduce una capacidad válida.");
        return;
    }

    const volumenStr = prompt(
        "Volumen actual (L):",
        bar.litros_actuales != null ? bar.litros_actuales : 0
    );
    if (volumenStr === null) return;
    const volumenNuevo = Number(volumenStr);
    if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
        alert("Introduce un volumen válido.");
        return;
    }

    const tipoResp = prompt("Tipo de roble:", bar.tipo_roble || "");
    if (tipoResp === null) return;
    const tipo_roble = tipoResp.trim() || null;

    const tostadoResp = prompt("Tostado:", bar.tostado || "");
    if (tostadoResp === null) return;
    const tostado = tostadoResp.trim() || null;

    const marcaResp = prompt("Marca:", bar.marca || "");
    if (marcaResp === null) return;
    const marca = marcaResp.trim() || null;

    const anioResp = prompt("Año:", bar.anio || "");
    if (anioResp === null) return;
    const anio = anioResp.trim() || null;

    const vinoAnioResp = prompt("Añada:", bar.vino_anio || "");
    if (vinoAnioResp === null) return;
    const vino_anio = vinoAnioResp.trim() || null;

    const vinoResp = prompt(
        "Tipo de vino (1=tinto, 2=blanco, 3=rosado/clarete o escribe texto):",
        bar.vino_tipo || ""
    );
    if (vinoResp === null) return;
    const vino_tipo_normalizado = normalizarTipoVino(vinoResp, bar.vino_tipo);
    const vino_tipo = vino_tipo_normalizado || null;

    try {
        const res = await fetch(`/api/barricas/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                codigo: codigo.trim(),
                capacidad_l,
                tipo_roble,
                tostado,
                marca,
                anio,
                vino_anio,
                vino_tipo,
            }),
        });
        const ok = await manejarRespuesta(res, "No se pudo actualizar la barrica.");
        if (!ok) return;
        await aplicarAjusteBarrica(id, Number(bar.litros_actuales || 0), volumenNuevo);
        await cargarBarricas();
        await cargarMovimientos();
        await cargarResumen();
    } catch (err) {
        console.error("Error actualizando barrica:", err);
        alert("No se pudo actualizar la barrica.");
    }
}

async function eliminarBarrica(id, volumen) {
    if (volumen > 0) {
        alert("No puedes borrar una barrica que aún tiene vino. Ajusta el volumen a 0 primero.");
        return;
    }

    if (!confirm("¿Seguro que quieres borrar esta barrica?")) return;

    try {
        const res = await fetch(`/api/barricas/${id}`, { method: "DELETE" });
        if (!res.ok) throw new Error();
        alert("Barrica borrada.");
        await cargarBarricas();
        await cargarResumen();
    } catch (err) {
        console.error("Error borrando barrica:", err);
        alert("No se pudo borrar la barrica.");
    }
}
async function aplicarAjusteBarrica(id, volumenActual, nuevo) {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: "barrica",
        destino_id: id,
        litros: delta,
        nota: `Ajuste de volumen en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: "barrica",
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste en barrica:", err);
    alert("No se pudo registrar el ajuste de volumen en la barrica.");
  }
}

function obtenerNombreDeposito(id) {
  const dep = mapaDepositosPorId.get(id);
  return dep ? dep.codigo || `Depósito ${id}` : `Depósito ${id}`;
}

function obtenerNombreMastelone(id) {
  const mas = mapaMastelonesPorId.get(id);
  return mas ? mas.codigo || `Mastelone ${id}` : `Mastelone ${id}`;
}

function obtenerNombreBarrica(id) {
  const bar = mapaBarricasPorId.get(id);
  return bar ? bar.codigo || `Barrica ${id}` : `Barrica ${id}`;
}

function formatearUbicacionMovimiento(tipo, id) {
  if (!tipo || !id) return "";
  if (tipo === "deposito") {
    return obtenerNombreDeposito(Number(id));
  }
  if (tipo === "mastelone") {
    return obtenerNombreMastelone(Number(id));
  }
  if (tipo === "barrica") {
    return obtenerNombreBarrica(Number(id));
  }
  return `${tipo.charAt(0).toUpperCase() + tipo.slice(1)} ${id}`;
}

function formatearLitrosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} L`;
}

function formatearFechaCorta(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  return fecha.toLocaleDateString("es-ES");
}

function formatearFechaParaInput(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const pad = numero => numero.toString().padStart(2, "0");
  const año = fecha.getFullYear();
  const mes = pad(fecha.getMonth() + 1);
  const dia = pad(fecha.getDate());
  const horas = pad(fecha.getHours());
  const minutos = pad(fecha.getMinutes());
  return `${año}-${mes}-${dia}T${horas}:${minutos}`;
}

function obtenerColorVinoReferencia(texto) {
  if (!texto) return null;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (t.includes("blanc")) return "#f5d372";
  if (t.includes("ros") || t.includes("clarete")) return "#f48fb1";
  if (t.includes("tinto") || t.includes("red") || t.includes("tannat")) return "#7b1b47";
  return null;
}

function obtenerColorMaterialContenedor(material, tipo = "") {
  const base = (material || tipo || "")
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();

  if (!base && tipo === "barrica") return "#c69c6d"; // madera (por defecto)

  if (base.includes("inox")) return "#c0c7d1"; // plata
  if (base.includes("fibra")) return "#ff8a3d"; // anaranjado
  if (base.includes("cement")) return "#4a4f59"; // gris oscuro
  if (base.includes("barro") || base.includes("anfora") || base.includes("tinaja")) return "#8a5a3c"; // marrón
  if (base.includes("madera") || base.includes("roble") || base.includes("wood")) return "#c69c6d"; // marrón claro
  if (base.includes("cristal") || base.includes("vidrio") || base.includes("glass")) return "#8fd3ff"; // azul claro
  if (base.includes("plast") || base.includes("plastico")) return "#7b1b47"; // granate

  // fallback por tipo
  if (tipo === "barrica") return "#c69c6d";
  return "#8f97a8";
}

function esColorOscuroHex(hex) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  if (!match) return false;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const luminancia = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminancia < 0.55;
}

function mezclarHexConBlanco(hex, factorBlanco = 0.75, alpha = 0.32) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  const f = Number(factorBlanco);
  const factor = Number.isFinite(f) ? Math.max(0, Math.min(1, f)) : 0.75;
  const a = Number(alpha);
  const opacidad = Number.isFinite(a) ? Math.max(0, Math.min(1, a)) : 0.32;
  if (!match) return `rgba(255,255,255,${opacidad})`;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const rr = Math.round(r + (255 - r) * factor);
  const gg = Math.round(g + (255 - g) * factor);
  const bb = Math.round(b + (255 - b) * factor);
  return `rgba(${rr},${gg},${bb},${opacidad})`;
}

function esVariedadGenerica(texto) {
  if (!texto) return false;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();
  if (!t) return false;
  if (t === "tinto" || t === "vino tinto") return true;
  if (t === "blanco" || t === "vino blanco") return true;
  if (t === "rosado" || t === "vino rosado") return true;
  if (t === "clarete" || t === "vino clarete") return true;
  if (t.includes("vino rosado") && t.includes("clarete")) return true;
  if (t === "vino rosado / clarete") return true;
  return false;
}

function filtrarVariedadesMultilinea(texto) {
  if (!texto) return "";
  const lineas = texto
    .toString()
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => {
      const sinPct = l.replace(/^\d+(?:[.,]\d+)?%\s*/g, "").trim();
      return !esVariedadGenerica(sinPct);
    });
  return lineas.join("\n");
}

function formatearVariedadesMultilinea(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = (item?.nombre || item?.variedad || "").toString().trim();
      if (!nombre || esVariedadGenerica(nombre)) return "";
      const porcentaje = Number.isFinite(item?.porcentaje) ? item.porcentaje : Number(item?.pct);
      const pct = formatearPctVariedad(Number(porcentaje));
      return pct && pct !== "0%" ? `${pct} ${nombre}` : nombre;
    })
    .filter(Boolean)
    .join("\n");
}

function normalizarTipoVino(entrada, actual = "") {
  if (entrada == null) return actual || "";
  const textoOriginal = entrada.toString().trim();
  if (!textoOriginal) return actual || "";
  const limpio = textoOriginal
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();

  if (["1", "tinto", "vino tinto"].includes(limpio)) return "Vino tinto";
  if (["2", "blanco", "vino blanco"].includes(limpio)) return "Vino blanco";
  if (
    ["3", "rosado", "rosa", "clarete", "vino rosado", "vino clarete"].includes(limpio)
  ) {
    return "Vino rosado / Clarete";
  }
  return textoOriginal;
}

function obtenerAnadaDesdeFecha(fecha) {
  if (!fecha) return "";
  const match = fecha.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function actualizarAnadaEntrada() {
  const fecha = document.getElementById("entradaFecha");
  const campo = document.getElementById("entradaAnada");
  if (!campo) return;
  campo.value = fecha ? obtenerAnadaDesdeFecha(fecha.value) : "";
}

function resolverContenedorId(tipo, valor) {
  if (!valor) return null;
  if (/^\d+$/.test(valor)) {
    return Number(valor);
  }
  const normalizado = valor.toLowerCase();
  if (tipo === "deposito") {
    const dep = cacheDepositos.find(d => (d.codigo || "").toLowerCase() === normalizado);
    return dep ? dep.id : null;
  }
  if (tipo === "mastelone") {
    const mas = cacheMastelones.find(m => (m.codigo || "").toLowerCase() === normalizado);
    return mas ? mas.id : null;
  }
  if (tipo === "barrica") {
    const bar = cacheBarricas.find(b => (b.codigo || "").toLowerCase() === normalizado);
    return bar ? bar.id : null;
  }
  return null;
}

function irAlContenedor(item) {
  if (!item || !item.tipo) return;
  if (item.tipo === "deposito" || item.tipo === "mastelone") {
    mostrarSeccion("depositos");
    scrollToContenedor("tablaDepositos", dep => dep.codigo === item.codigo || dep.id === item.id);
  } else if (item.tipo === "barrica") {
    mostrarSeccion("barricas");
    scrollToContenedor("tablaBarricas", bar => bar.codigo === item.codigo || bar.id === item.id);
  }
}

function scrollToContenedor(tablaId, predicate) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  const filas = Array.from(tbody.querySelectorAll("tr"));
  const target = filas.find(tr => {
    const celdas = tr.querySelectorAll("td");
    if (!celdas.length) return false;
    const id = Number(celdas[0].textContent.trim());
    const codigo = celdas[1] ? celdas[1].textContent.trim() : "";
    return predicate({ id, codigo });
  });
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    target.classList.add("resaltado");
    setTimeout(() => target.classList.remove("resaltado"), 1500);
  }
}

function obtenerMovimientosFiltrados() {
  let datos = Array.isArray(cacheMovimientos) ? [...cacheMovimientos] : [];
  const { tipo, desde, hasta, contenedor, contenedor_tipo } = filtrosMovimientos;
  if (tipo) {
    const filtroTipo = tipo.toLowerCase();
    datos = datos.filter(m => (m.tipo || "").toLowerCase() === filtroTipo);
  }

  const fechaDesde = desde ? new Date(desde) : null;
  const fechaHasta = hasta ? new Date(hasta) : null;

  if (fechaDesde instanceof Date && !Number.isNaN(fechaDesde.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp >= fechaDesde.getTime();
    });
  }

  if (fechaHasta instanceof Date && !Number.isNaN(fechaHasta.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp <= fechaHasta.getTime();
    });
  }

  if (contenedor) {
    const valor = contenedor.trim();
    const candidatos = [];
    if (!contenedor_tipo || contenedor_tipo === "deposito") {
      const idDep = resolverContenedorId("deposito", valor);
      if (idDep) candidatos.push({ tipo: "deposito", id: idDep });
    }
    if (!contenedor_tipo || contenedor_tipo === "mastelone") {
      const idMas = resolverContenedorId("mastelone", valor);
      if (idMas) candidatos.push({ tipo: "mastelone", id: idMas });
    }
    if (!contenedor_tipo || contenedor_tipo === "barrica") {
      const idBar = resolverContenedorId("barrica", valor);
      if (idBar) candidatos.push({ tipo: "barrica", id: idBar });
    }
    if (!candidatos.length) {
      return [];
    }
    datos = datos.filter(m =>
      candidatos.some(
        info =>
          (m.origen_tipo === info.tipo && Number(m.origen_id) === info.id) ||
          (m.destino_tipo === info.tipo && Number(m.destino_id) === info.id)
      )
    );
  }

  return datos;
}

function renderMovimientos() {
  const tbody = document.getElementById("tablaMovimientos");
  if (!tbody) return;
  const datos = obtenerMovimientosFiltrados();
  tbody.innerHTML = "";

  if (!datos.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="8">No hay movimientos registrados.</td>';
    tbody.appendChild(tr);
    return;
  }

  datos.forEach(m => {
    const fecha = m.fecha || m.fecha_hora || "";
    const fechaTexto = formatearFechaCorta(fecha);
    const litros = m.litros != null ? m.litros : m.volumen_l ?? "";
    const origen = formatearUbicacionMovimiento(m.origen_tipo, m.origen_id);
    const destino = formatearUbicacionMovimiento(m.destino_tipo, m.destino_id);
    const tr = document.createElement("tr");
    tr.innerHTML = `
        <td>${fechaTexto}</td>
        <td>${m.tipo || ""}</td>
        <td>${litros}</td>
        <td>${m.perdida_litros != null ? m.perdida_litros : ""}</td>
        <td>${origen.trim()}</td>
        <td>${destino.trim()}</td>
        <td>${m.nota || ""}</td>
        <td><button class="small-btn" style="background:#c04b4b; color:#fff;" onclick="eliminarMovimiento(${m.id})">Borrar</button></td>
    `;
    tbody.appendChild(tr);
  });
}

async function limpiarHistorialMovimientos() {
  const confirmar = confirm(
    "¿Seguro que quieres borrar todo el historial de movimientos? Esta acción no se puede deshacer."
  );
  if (!confirmar) return;

  try {
    const res = await fetch("/api/movimientos", { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo limpiar el historial.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error limpiando historial de movimientos:", err);
    alert("Error al limpiar el historial de movimientos.");
  }
}

async function eliminarMovimiento(id) {
  const confirmar = confirm("¿Borrar este movimiento? Esta acción no se puede deshacer.");
  if (!confirmar) return;
  try {
    const res = await fetch(`/api/movimientos/${id}`, { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo borrar el movimiento.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error borrando movimiento:", err);
    alert("No se pudo borrar el movimiento.");
  }
}

function aplicarFiltrosMovimientos() {
  filtrosMovimientos = {
    tipo: (document.getElementById("filtroMovTipo").value || "").toLowerCase(),
    desde: document.getElementById("filtroMovDesde").value || "",
    hasta: document.getElementById("filtroMovHasta").value || "",
    contenedor: document.getElementById("filtroMovContenedor").value.trim(),
    contenedor_tipo: document.getElementById("filtroMovContTipo").value || "",
  };
  renderMovimientos();
}

function limpiarFiltrosMovimientos() {
  document.getElementById("filtroMovTipo").value = "";
  document.getElementById("filtroMovDesde").value = "";
  document.getElementById("filtroMovHasta").value = "";
  document.getElementById("filtroMovContenedor").value = "";
  document.getElementById("filtroMovContTipo").value = "";
  filtrosMovimientos = { tipo: "", desde: "", hasta: "", contenedor: "", contenedor_tipo: "" };
  renderMovimientos();
}

async function exportarMovimientosCSV() {
  try {
    const res = await fetch("/api/export/movimientos");
    if (!res.ok) throw new Error();
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const enlace = document.createElement("a");
    const fecha = new Date().toISOString().slice(0, 10);
    enlace.href = url;
    enlace.download = `movimientos-${fecha}.csv`;
    document.body.appendChild(enlace);
    enlace.click();
    enlace.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Error exportando movimientos:", err);
    alert("No se pudo exportar el historial de movimientos.");
  }
}

async function obtenerHistorialCompleto(tipo, id) {
  try {
    const res = await fetch(`/api/contenedores/${tipo}/${id}/historial`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (err) {
    console.warn("Fallo al usar endpoint combinado, usando modo local:", err);
    return await construirHistorialLocal(tipo, id);
  }
}

async function construirHistorialLocal(tipo, id) {
  const registrosRes = await fetch(`/api/registros/${tipo}/${id}`);
  if (!registrosRes.ok) throw new Error("No se pudieron obtener registros analíticos");
  const registros = await registrosRes.json();

  let movimientos = cacheMovimientos;
  if (!movimientos || !movimientos.length) {
    const movRes = await fetch("/api/movimientos");
    if (!movRes.ok) throw new Error("No se pudieron obtener movimientos");
    movimientos = await movRes.json();
  }

  const analiticosNormalizados = registros.map(r => ({
    categoria: "analitico",
    fecha: r.fecha_hora,
    densidad: r.densidad,
    temperatura_c: r.temperatura_c,
    nota_sensorial: r.nota_sensorial,
    nota: r.nota,
  }));

  const movimientosRelacionados = movimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .map(m => ({
      categoria: "movimiento",
      fecha: m.fecha,
      tipo: m.tipo,
      litros: m.litros,
      origen_tipo: m.origen_tipo,
      origen_id: m.origen_id,
      destino_tipo: m.destino_tipo,
      destino_id: m.destino_id,
      nota: m.nota,
    }));

  return [...analiticosNormalizados, ...movimientosRelacionados].sort(
    (a, b) => new Date(b.fecha || 0) - new Date(a.fecha || 0)
  );
}
        // ---------- Barricas ----------
        async function cargarBarricas() {
            try {
                mostrarSkeletonTabla("tablaBarricas", 11);
                const res = await fetch("/api/barricas");
                if (!res.ok) return;
                const datos = await res.json();
                cacheBarricas = datos;
                cacheBarricas.forEach(b => {
                    const volNodo = obtenerVolumenFinalNodoContenedor("barrica", b.id);
                    if (Number.isFinite(volNodo)) {
                        b.litros_actuales = volNodo;
                    }
                });
                mapaBarricasPorId = new Map(datos.map(b => [b.id, b]));
                renderPlano();

                const tbody = document.getElementById("tablaBarricas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="11">No hay barricas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

               datos.forEach(b => {
                    const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
                    const vol = estadoNodo?.volumen != null
                        ? Number(estadoNodo.volumen || 0).toFixed(1)
                        : Number(b.litros_actuales || 0).toFixed(1);
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
        <td>${b.id}</td>
        <td>${b.codigo || ""}</td>
        <td>${b.capacidad_l ?? ""}</td>
        <td>${(b.tipo_roble || "")} ${b.tostado || ""}</td>
        <td>${b.marca || ""}</td>
        <td>${b.anio || ""}</td>
        <td>${b.vino_anio || ""}</td>
        <td>${b.vino_tipo || ""}</td>
        <td>${vol}</td>
        <td>
            <button class="small-btn"
                onclick="editarBarricaDatos(${b.id})">
                Editar
            </button>
        </td>
        <td>
            <button
                onclick="eliminarBarrica(${b.id}, ${vol})"
                style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                Borrar
            </button>
        </td>
    `;
                    tbody.appendChild(tr);
});
                actualizarIndicadores();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando barricas:", err);
            }
        }

        async function crearBarrica(ev) {
            ev.preventDefault();
            const codigo = document.getElementById("barCodigo").value;
            const capacidad_l = parseFloat(document.getElementById("barCapacidad").value || "0");
            const tipo_roble = document.getElementById("barTipo").value;
            const tostado = document.getElementById("barTostado").value;
            const marca = document.getElementById("barMarca").value;
            const anio = document.getElementById("barAnio").value;
            const vino_anio = document.getElementById("barVinoAnio").value;
            const vino_tipo = document.getElementById("barVinoTipo").value;

            if (!codigo || !capacidad_l) {
                alert("Faltan datos de la barrica (código, capacidad).");
                return;
            }

            try {
                const body = { codigo, capacidad_l, tipo_roble, tostado, marca, anio, vino_anio, vino_tipo };
                const res = await fetch("/api/barricas", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al crear la barrica.");
                if (!ok) return;

                document.getElementById("formBarrica").reset();
                cargarBarricas();
                cargarResumen();
            } catch (err) {
                console.error("Error creando barrica:", err);
            }
        }

        // ---------- Almacén de limpieza ----------
        async function cargarLimpieza() {
            try {
                const res = await fetch("/api/limpieza");
                if (!res.ok) return;
                const datos = await res.json();
                cacheLimpieza = datos;

                const tbody = document.getElementById("tablaLimpieza");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoLimpieza(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos de limpieza:", err);
            }
        }

        async function crearProductoLimpieza(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("limNombre").value.trim();
            const lote = document.getElementById("limLote").value.trim();
            const cantidad = parseFloat(document.getElementById("limCantidad").value || "0");
            const unidad = document.getElementById("limUnidad").value.trim();
            const nota = document.getElementById("limNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/limpieza", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formLimpieza").reset();
                cargarLimpieza();
            } catch (err) {
                console.error("Error creando producto de limpieza:", err);
            }
        }

        async function registrarUsoLimpieza(id) {
            const prod = cacheLimpieza.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inválida.");
                return;
            }

            let destino_tipo = null;
            let destino_id = null;
            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vacío:", "")
                .trim()
                .toLowerCase();
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("Código o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor válido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/limpieza/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarLimpieza();
            } catch (err) {
                console.error("Error registrando consumo de limpieza:", err);
            }
        }

        // ---------- Productos enológicos ----------
        async function cargarEnologicos() {
            try {
                const res = await fetch("/api/enologicos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEnologicos = datos;
                const tbody = document.getElementById("tablaEnologicos");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoEnologico(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos enológicos:", err);
            }
        }

        async function crearProductoEnologico(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("enoNombre").value.trim();
            const lote = document.getElementById("enoLote").value.trim();
            const cantidad = parseFloat(document.getElementById("enoCantidad").value || "0");
            const unidad = document.getElementById("enoUnidad").value.trim();
            const nota = document.getElementById("enoNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/enologicos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formEnologicos").reset();
                cargarEnologicos();
            } catch (err) {
                console.error("Error creando producto enológico:", err);
            }
        }

async function registrarUsoEnologico(id) {
            const prod = cacheEnologicos.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inválida.");
                return;
            }

            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vacío:", "")
                .trim()
                .toLowerCase();
            let destino_tipo = null;
            let destino_id = null;
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("Código o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor válido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/enologicos/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarEnologicos();
            } catch (err) {
                console.error("Error registrando consumo enológico:", err);
            }
        }

        // ---------- Movimientos ----------
        async function cargarMovimientos() {
            try {
                mostrarSkeletonTabla("tablaMovimientos", 8, 4);
                const res = await fetch("/api/movimientos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheMovimientos = datos;
                renderMovimientos();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando movimientos:", err);
            }
        }

        function actualizarCamposMovimiento() {
            const tipoSelect = document.getElementById("movTipo");
            const origenTipo = document.getElementById("movOrigenTipo");
            const origenId = document.getElementById("movOrigenId");
            const origenNota = document.getElementById("movOrigenNota");
            const esPrensado = tipoSelect && tipoSelect.value === "prensado";

            if (esPrensado) {
                if (origenTipo) {
                    origenTipo.value = "";
                    origenTipo.disabled = true;
                }
                if (origenId) {
                    origenId.value = "";
                    origenId.disabled = true;
                }
                if (origenNota) {
                    origenNota.style.display = "block";
                }
            } else {
                if (origenTipo) {
                    origenTipo.disabled = false;
                }
                if (origenId) {
                    origenId.disabled = false;
                }
                if (origenNota) {
                    origenNota.style.display = "none";
                }
            }
        }

        async function crearMovimiento(ev) {
            ev.preventDefault();
            let fecha = document.getElementById("movFecha").value;
            if (!fecha) {
                fecha = new Date().toISOString();
            }
            const fecha_hora = fecha;

            const tipo = document.getElementById("movTipo").value;
            const destino_tipo = document.getElementById("movDestinoTipo").value || null;
            const origenTipoEl = document.getElementById("movOrigenTipo");
            const origenIdEl = document.getElementById("movOrigenId");
            let origen_tipo = origenTipoEl ? (origenTipoEl.value || null) : null;
            const origenRaw = origenIdEl ? origenIdEl.value.trim() : "";
            const destinoRaw = document.getElementById("movDestinoId").value.trim();

            let origen_id = null;
            let destino_id = null;
            const esPrensado = tipo === "prensado";

            if (!esPrensado && origenRaw) {
                if (/^\d+$/.test(origenRaw)) {
                    origen_id = parseInt(origenRaw, 10);
                } else if (origen_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === origenRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = dep.id;
                } else if (origen_tipo === "mastelone") {
                    const mas = cacheMastelones.find(m => m.codigo === origenRaw);
                    if (!mas) {
                        setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = mas.id;
                } else if (origen_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === origenRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = bar.id;
                } else {
                    setFormFeedback("feedbackMovimientos", "Para usar un código como origen, el tipo debe ser depósito, mastelone o barrica.", "error");
                    return;
                }
            }

            if (esPrensado) {
                origen_tipo = null;
                origen_id = null;
            }

            if (destinoRaw) {
                if (/^\d+$/.test(destinoRaw)) {
                    destino_id = parseInt(destinoRaw, 10);
                } else if (destino_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === destinoRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = dep.id;
                } else if (destino_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === destinoRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = bar.id;
    } else if (destino_tipo === "mastelone") {
        const mas = cacheMastelones.find(m => m.codigo === destinoRaw);
        if (!mas) {
            setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + destinoRaw, "error");
            return;
        }
        destino_id = mas.id;
    } else {
        setFormFeedback("feedbackMovimientos", "Para usar un código como destino, el tipo debe ser depósito, mastelone o barrica.", "error");
        return;
    }
}

            const litros = parseFloat(document.getElementById("movLitros").value || "0");
            const perdida_litros = document.getElementById("movPerdida").value
                ? parseFloat(document.getElementById("movPerdida").value)
                : null;
            const nota = document.getElementById("movNota").value;

            if (!litros || litros <= 0) {
                setFormFeedback("feedbackMovimientos", "Los litros deben ser mayores que 0.", "error");
                return;
            }

            const body = {
                fecha,
                fecha_hora,
                tipo,
                origen_tipo,
                origen_id,
                destino_tipo,
                destino_id,
                litros,
                perdida_litros,
                nota,
            };

            try {
                const res = await fetch("/api/movimientos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al guardar el movimiento.");
                if (!ok) return;

                document.getElementById("formMovimiento").reset();
                actualizarCamposMovimiento();
                await Promise.all([
                    cargarMovimientos(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarResumen(),
                ]);
                setFormFeedback("feedbackMovimientos", "Movimiento registrado.", "success");
                mostrarAviso("Movimiento registrado.", "success");
            } catch (err) {
                console.error("Error creando movimiento:", err);
                setFormFeedback("feedbackMovimientos", "No se pudo crear el movimiento.", "error");
                mostrarAviso("Error al crear el movimiento.", "error");
            }
        }

        // ---------- Embotellado ----------
        async function cargarEmbotellados() {
            try {
                const res = await fetch("/api/embotellados");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEmbotellados = datos;
                const tbody = document.getElementById("tablaEmbotellados");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">Aún no hay embotellados registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const origen = formatearUbicacionMovimiento(e.contenedor_tipo, e.contenedor_id);
                    const fecha = formatearFechaCorta(e.fecha);
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${origen}</td>
                        <td>${e.botellas ?? ""}</td>
                        <td>${e.lote || ""}</td>
                        <td>${e.nota || ""}</td>
                    `;
                    tbody.appendChild(tr);
                });
                actualizarIndicadores();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando embotellados:", err);
            }
        }

        async function crearEmbotellado(ev) {
            ev.preventDefault();
            const fecha = document.getElementById("embFecha").value;
            const contenedor_tipo = document.getElementById("embTipo").value;
            const contenedorValor = document.getElementById("embContenedor").value.trim();
            const botellas = parseInt(document.getElementById("embBotellas").value || "0", 10) || null;
            const lote = document.getElementById("embLote").value.trim();
            const nota = document.getElementById("embNota").value.trim();

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id) {
                alert("No encuentro ese contenedor.");
                return;
            }
            if (!botellas || botellas <= 0) {
                alert("Las botellas deben ser mayores que 0.");
                return;
            }

            // Volumen interno estimado para registrar el movimiento; 0.75 L por botella como referencia.
            const litros = Number((botellas * 0.75).toFixed(3));

            const body = {
                fecha,
                contenedor_tipo,
                contenedor_id,
                litros,
                botellas,
                lote,
                nota,
            };

            try {
                const res = await fetch("/api/embotellados", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el embotellado.");
                if (!ok) return;
                document.getElementById("formEmbotellado").reset();
                await Promise.all([cargarEmbotellados(), cargarBarricas(), cargarDepositos(), cargarMovimientos(), cargarResumen()]);
            } catch (err) {
                console.error("Error creando embotellado:", err);
            }
        }

        // ---------- Registros analíticos ----------
        async function crearRegistroAnalitico(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("regTipo").value;
            const contenedorValor = document.getElementById("regId").value.trim();
            const fecha_hora = document.getElementById("regFecha").value;
            const densidad = document.getElementById("regDensidad").value
                ? parseFloat(document.getElementById("regDensidad").value)
                : null;
            const temperatura_c = document.getElementById("regTemperatura").value
                ? parseFloat(document.getElementById("regTemperatura").value)
                : null;
            const nota_sensorial = document.getElementById("regNotaSensorial").value;
            const nota = document.getElementById("regNota").value;

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id || !fecha_hora) {
                alert("Indica un contenedor válido y la fecha/hora.");
                return;
            }

            const body = {
                contenedor_tipo,
                contenedor_id,
                fecha_hora,
                densidad,
                temperatura_c,
                nota_sensorial,
                nota,
            };

            try {
                const res = await fetch("/api/registros", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                document.getElementById("formAnalitico").reset();
                cargarResumen();
                alert("Registro analítico guardado.");
            } catch (err) {
                console.error("Error guardando registro analítico:", err);
                alert("Error al guardar el registro analítico.");
            }
        }

        async function cargarHistorialAnalitico() {
            const tipo = document.getElementById("histTipo").value;
            const valor = document.getElementById("histId").value.trim();
            const id = resolverContenedorId(tipo, valor);
            const tbody = document.getElementById("tablaRegistros");
            tbody.innerHTML = "";

            if (!id) {
                alert("Indica un contenedor válido (número o código).");
                return;
            }

            try {
                const datos = await obtenerHistorialCompleto(tipo, id);

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="4">No hay registros para este contenedor.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(r => {
                    const tr = document.createElement("tr");
                    const fecha = formatearFechaCorta(r.fecha || r.fecha_hora);
                    let evento = "";
                    let detalle = "";

                    if (r.categoria === "analitico") {
                        evento = "Registro analítico";
                        const partes = [];
                        if (r.densidad != null) partes.push(`Densidad: ${r.densidad}`);
                        if (r.temperatura_c != null) partes.push(`Temp: ${r.temperatura_c} °C`);
                        detalle = partes.join(" · ");
                    } else if (r.categoria === "movimiento") {
                        evento = `Movimiento: ${r.tipo || ""}`;
                        const origen = formatearUbicacionMovimiento(r.origen_tipo, r.origen_id);
                        const destino = formatearUbicacionMovimiento(r.destino_tipo, r.destino_id);
                        detalle = `${r.litros || 0} L · ${origen || "—"} → ${destino || "—"}`;
                    } else {
                        evento = "Evento";
                        detalle = "";
                    }
                    const notas = [];
                    if (r.nota_sensorial) {
                        notas.push(`Sensorial: ${r.nota_sensorial}`);
                    }
                    if (r.nota) {
                        const textoNota = r.categoria === "analitico" ? `Nota: ${r.nota}` : r.nota;
                        notas.push(textoNota);
                    }
                    const notaTexto = notas.join(" · ");

                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${evento}</td>
                        <td>${detalle}</td>
                        <td>${notaTexto}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando historial analítico:", err);
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="4">Error al cargar el historial.</td>';
                tbody.appendChild(tr);
            }
        }

        // ---------- Análisis Laboratorio ----------
        async function crearAnalisisLab(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("labTipoContenedor").value;
            const depositoValor = document.getElementById("labDeposito").value.trim();
            const contenedor_id = resolverContenedorId(contenedor_tipo, depositoValor);
            const fecha = document.getElementById("labFecha").value;
            const laboratorio = document.getElementById("labLaboratorio").value;
            const descripcion = document.getElementById("labDescripcion").value;
            const archivoInput = document.getElementById("labArchivo");
            const archivo = archivoInput.files[0];
            const mensaje = document.getElementById("labMensaje");

            if (!contenedor_id) {
                mensaje.textContent = "Indica un contenedor válido.";
                return;
            }
            if (!archivo) {
                mensaje.textContent = "Selecciona un PDF.";
                return;
            }
            if (archivo.type && archivo.type !== "application/pdf") {
                mensaje.textContent = "Solo se permiten PDF.";
                return;
            }

            try {
                mensaje.textContent = "Subiendo PDF...";
                const archivo_base64 = await leerArchivoBase64(archivo);
                const body = {
                    contenedor_id,
                    contenedor_tipo,
                    fecha,
                    laboratorio,
                    descripcion,
                    archivo_nombre: archivo.name,
                    archivo_base64,
                };
                const res = await fetch("/api/analisis-lab", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al subir el análisis.");
                if (!ok) {
                    mensaje.textContent = "No se pudo guardar.";
                    return;
                }
                document.getElementById("formAnalisisLab").reset();
                mensaje.textContent = "Análisis guardado correctamente.";
                await cargarAnalisisLab(filtroAnalisisDeposito);
                setTimeout(() => (mensaje.textContent = ""), 3000);
            } catch (err) {
                console.error("Error subiendo PDF:", err);
                mensaje.textContent = "Error al guardar el análisis.";
            }
        }

        async function cargarAnalisisLab(nuevoFiltro) {
            if (arguments.length > 0) {
                filtroAnalisisDeposito = nuevoFiltro;
            }
            const filtroActual = filtroAnalisisDeposito;
            mostrarSkeletonTabla("tablaAnalisisLab", 5);
            try {
                let url = "/api/analisis-lab";
                if (filtroActual && (filtroActual.id || filtroActual.tipo)) {
                    const params = new URLSearchParams();
                    if (filtroActual.id) params.set("contenedor_id", filtroActual.id);
                    if (filtroActual.tipo) params.set("tipo", filtroActual.tipo);
                    const qs = params.toString();
                    if (qs) {
                        url += `?${qs}`;
                    }
                }
                const res = await fetch(url);
                if (!res.ok) throw new Error();
                cacheAnalisisLab = await res.json();
                renderAnalisisLab();
            } catch (err) {
                console.error("Error cargando análisis:", err);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="5">No se pudieron cargar los análisis.</td></tr>';
                }
            }
        }

        function renderAnalisisLab() {
            const tbody = document.getElementById("tablaAnalisisLab");
            if (!tbody) return;
            tbody.innerHTML = "";
            if (!cacheAnalisisLab.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin análisis registrados todavía.</td>';
                tbody.appendChild(tr);
                return;
            }
            cacheAnalisisLab.forEach(reg => {
                const tr = document.createElement("tr");
                const fecha = reg.fecha ? formatearFechaCorta(reg.fecha) : "—";
                const tipoCont = reg.contenedor_tipo || "deposito";
                const contenedor =
                    formatearUbicacionMovimiento(tipoCont, reg.contenedor_id) ||
                    `${tipoCont} ${reg.contenedor_id}`;
                const laboratorio = reg.laboratorio || "—";
                const descripcion = reg.descripcion || "—";
                const archivo =
                    reg.archivo_url
                        ? `<a href="${reg.archivo_url}" target="_blank" rel="noopener">Descargar PDF</a>`
                        : "—";
                tr.innerHTML = `
                    <td>${fecha}</td>
                    <td>${contenedor}</td>
                    <td>${laboratorio}</td>
                    <td>${descripcion}</td>
                    <td>${archivo}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function aplicarFiltroAnalisisLab() {
            const valor = document.getElementById("labFiltroDeposito").value.trim();
            const tipoSelect = document.getElementById("labFiltroTipo").value;
            if (!valor && !tipoSelect) {
                await cargarAnalisisLab(null);
                return;
            }
            let filtro = null;
            if (valor) {
                let tipoCont = tipoSelect || "";
                let id = null;
                if (tipoCont) {
                    id = resolverContenedorId(tipoCont, valor);
                } else {
                    id = resolverContenedorId("deposito", valor);
                    tipoCont = id ? "deposito" : "";
                    if (!id) {
                        id = resolverContenedorId("mastelone", valor);
                        if (id) tipoCont = "mastelone";
                    }
                }
                if (!id) {
                    alert("No encuentro un contenedor con ese código/ID.");
                    return;
                }
                filtro = { id, tipo: tipoCont };
            } else if (tipoSelect) {
                filtro = { id: null, tipo: tipoSelect };
            }
            await cargarAnalisisLab(filtro);
        }

        async function limpiarFiltroAnalisisLab() {
            document.getElementById("labFiltroDeposito").value = "";
            document.getElementById("labFiltroTipo").value = "";
            await cargarAnalisisLab(null);
        }

function leerArchivoBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error("No se pudo leer el archivo"));
                reader.readAsDataURL(file);
            });
        }

        // ---------- Demo ligera de drag & drop de tanques/barricas ----------
        const tanques = [
            { id: "T101", tipo: "Tanque", vino: "Tempranillo", volumen: 8000, capacidad: 10000, estado: "FA", x: 80, y: 60 },
            { id: "B045", tipo: "Barrica", vino: "Crianza Lote 5", volumen: 225, capacidad: 225, estado: "Reposo", x: 320, y: 120 },
            { id: "T204", tipo: "Tanque", vino: "Garnacha", volumen: 5200, capacidad: 8000, estado: "FML", x: 180, y: 200 },
        ];
        let demoDrag = null;

        function renderDemoFlow() {
            const stage = document.getElementById("demoFlowStage");
            if (!stage) return;
            stage.innerHTML = "";
            tanques.forEach((nodo, idx) => {
                const el = document.createElement("div");
                el.className = "flow-node demo-flow-node";
                el.style.left = `${nodo.x}px`;
                el.style.top = `${nodo.y}px`;
                el.dataset.index = idx;
                el.innerHTML = `
                    <h4 style="margin:0 0 4px;">${nodo.id}</h4>
                    <div class="flow-node-subtitle">${nodo.tipo} · ${nodo.vino}</div>
                    <div class="flow-node-subtitle">Volumen ${nodo.volumen} / ${nodo.capacidad} L</div>
                    <div class="estado-pill estado-${(nodo.estado || "").toLowerCase()}" style="margin-top:6px;">${nodo.estado}</div>
                `;
                el.addEventListener("pointerdown", ev => startDemoDrag(ev, idx));
                stage.appendChild(el);
            });
        }

        function startDemoDrag(ev, idx) {
            const stage = document.getElementById("demoFlowStage");
            const nodeEl = ev.currentTarget;
            if (!stage || !nodeEl) return;
            const rect = stage.getBoundingClientRect();
            demoDrag = {
                idx,
                nodeEl,
                stage,
                pointerId: ev.pointerId,
                offsetX: ev.clientX - rect.left - tanques[idx].x,
                offsetY: ev.clientY - rect.top - tanques[idx].y,
            };
            nodeEl.setPointerCapture(ev.pointerId);
            nodeEl.classList.add("dragging");
            nodeEl.addEventListener("pointermove", moveDemoDrag);
            nodeEl.addEventListener("pointerup", endDemoDrag);
            nodeEl.addEventListener("pointercancel", endDemoDrag);
        }

        function moveDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { stage, nodeEl, idx, offsetX, offsetY } = demoDrag;
            const stageRect = stage.getBoundingClientRect();
            const nodeRect = nodeEl.getBoundingClientRect();
            let x = ev.clientX - stageRect.left - offsetX;
            let y = ev.clientY - stageRect.top - offsetY;
            const maxX = stageRect.width - nodeRect.width;
            const maxY = stageRect.height - nodeRect.height;
            x = Math.max(0, Math.min(maxX, x));
            y = Math.max(0, Math.min(maxY, y));
            tanques[idx].x = Math.round(x);
            tanques[idx].y = Math.round(y);
            nodeEl.style.left = `${tanques[idx].x}px`;
            nodeEl.style.top = `${tanques[idx].y}px`;
        }

        function endDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { nodeEl, pointerId } = demoDrag;
            try {
                nodeEl.releasePointerCapture(pointerId);
            } catch (e) {
                // noop
            }
            nodeEl.classList.remove("dragging");
            nodeEl.removeEventListener("pointermove", moveDemoDrag);
            nodeEl.removeEventListener("pointerup", endDemoDrag);
            nodeEl.removeEventListener("pointercancel", endDemoDrag);
            demoDrag = null;
        }

        // ---------- Inicialización ----------
        (async function init() {
            await cargarNodosGuardados();
            mostrarSeccion("bodega");
            await Promise.all([
                cargarResumen(),
                cargarDepositos(),
                cargarBarricas(),
                cargarEntradas(),
                cargarMovimientos(),
                cargarLimpieza(),
                cargarEnologicos(),
                cargarEmbotellados(),
                cargarAnalisisLab(),
            ]);
            renderDemoFlow();

            const campoFechaEntrada = document.getElementById("entradaFecha");
            if (campoFechaEntrada) {
                campoFechaEntrada.addEventListener("change", actualizarAnadaEntrada);
                actualizarAnadaEntrada();
            }
            const movTipoSelect = document.getElementById("movTipo");
            if (movTipoSelect) {
                movTipoSelect.addEventListener("change", actualizarCamposMovimiento);
                actualizarCamposMovimiento();
            }
        })();
    </script>
</body>
</html>
