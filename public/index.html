<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bodega serie -INDÓMITO-</title>

    <style>
        :root {
            --vino-oscuro: #140818;
            --vino: #783c7b;
            --magenta: #f3789c;
            --rose: #fff1f8;
            --arena: #f8f0ff;
            --oro: #f3c77b;
            --texto: #201024;
            --linea: rgba(255, 255, 255, 0.35);
            --accent: #c2a9ff;
            --gris-ligero: rgba(255,255,255,0.65);
        }

        * {
            box-sizing: border-box;
        }

body {
    margin: 0;
    padding: 0;
    font-family: "Inter", system-ui, -apple-system, Helvetica, Arial, sans-serif;
    background: radial-gradient(circle at 15% 20%, #2b1a36, #0b0511 55%);
    min-height: 100vh;
    color: var(--texto);
    position: relative;
}

body::before,
body::after {
    content: "";
    position: fixed;
    width: 520px;
    height: 520px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(195,168,255,0.25), transparent 70%);
    z-index: 0;
    filter: blur(18px);
}

body::before {
    top: -80px;
    right: -100px;
}

body::after {
    bottom: -200px;
    left: -120px;
}

        .topbar {
            width: 100%;
            background: transparent;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 5;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            backdrop-filter: none;
        }

        .topbar-left {
            display: flex;
            align-items: center;
            gap: 14px;
            min-width: 0;
            z-index: 2;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 2;
            margin-left: auto;
        }

        .topbar-hero {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 20px;
            border-radius: 28px;
            border: 1px solid rgba(255,255,255,0.38);
            width: 440px;
            height: 124px;
            min-width: 440px;
            min-height: 124px;
            max-width: 440px;
            max-height: 124px;
            box-sizing: border-box;
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
        }

        .hero-fecha {
            font-weight: 500;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            white-space: nowrap;
            font-size: 18px;
            opacity: 0.95;
            display: inline-flex;
            align-items: baseline;
            gap: 8px;
            color: rgba(255,255,255,0.98);
            text-shadow: 0 2px 6px rgba(40,10,30,0.25);
        }

        .hero-hora {
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: none;
            opacity: 0.75;
            color: rgba(255,255,255,0.92);
        }

        .hero-sep {
            display: none;
        }

        .hero-anada {
            position: relative;
            display: flex;
            align-items: center;
            padding: 0;
            border-radius: 999px;
            background: transparent !important;
            box-shadow: none;
        }

        .topbar-anada-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            border: 2px solid rgba(255,255,255,0.7);
            background: rgba(255,255,255,0.12) !important;
            color: rgba(20, 10, 28, 0.96);
            border-radius: 999px;
            padding: 12px 46px 12px 18px;
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 2.5px;
            cursor: pointer;
            line-height: 1;
            width: max-content;
            min-width: 0;
            font-size: 36px;
            text-transform: uppercase;
            text-shadow:
              0 2px 6px rgba(92, 14, 45, 0.22),
              0 1px 0 rgba(255,255,255,0.12);
            box-shadow: none !important;
            filter: none;
            backdrop-filter: none;
            transform: none;
        }

        .topbar-anada-select:focus {
            outline: none;
            box-shadow: none !important;
            border-color: rgba(255,255,255,0.65);
            transform: none;
        }

        .topbar-anada-select:hover {
            box-shadow: none !important;
            transform: none;
        }

        .topbar-anada-select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .hero-caret {
            position: absolute;
            right: 14px;
            pointer-events: none;
            font-size: 16px;
            opacity: 0.7;
            color: rgba(30, 14, 36, 0.8);
        }

        .topbar-hero-msg {
            font-size: 11px;
            color: rgba(255,255,255,0.75);
        }

        .topbar-hero-msg.error {
            color: #ffb3c7;
        }

        .user-chip {
            display: none;
        }

        .topbar-title {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            position: relative;
        }

        .topbar-title button {
            color: inherit;
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            border: 1px solid rgba(255,255,255,0.38);
            cursor: pointer;
            padding: 12px 20px;
            border-radius: 28px;
            transition: transform 0.18s ease, box-shadow 0.22s ease, background 0.2s ease;
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
            width: 440px;
            height: 124px;
            min-width: 440px;
            min-height: 124px;
            max-width: 440px;
            max-height: 124px;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }

        .topbar-title .microbrand {
            font-size: 18px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.75);
            margin-bottom: 4px;
            font-weight: 500;
            font-family: inherit;
        }

        .topbar-title button::before,
        .topbar-title button::after {
            display: none;
        }

        .topbar-title button:hover,
        .topbar-title button.open {
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
            transform: none;
        }

        .topbar-title .marca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 2.5px;
            text-transform: uppercase;
            font-size: 36px;
            color: #0b0b0b;
            background: rgba(255,255,255,0.12);
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 999px;
            padding: 10px 42px 10px 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-clip: padding-box;
-webkit-background-clip: padding-box;
            text-shadow:
              0 8px 18px rgba(92, 14, 45, 0.4),
              0 4px 10px rgba(92, 14, 45, 0.25),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 14px rgba(92, 14, 45, 0.35);
            box-shadow: none;
            filter: none;
            position: relative;
        }

        .topbar-title .marca::after {
            content: "▾";
            position: absolute;
            right: 16px;
            font-size: 16px;
            opacity: 0.7;
            color: rgba(30, 14, 36, 0.8);
        }

        .topbar-title .submarca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 6px;
            font-size: 20px;
            color: #1a1a1a;
            margin-top: 8px;
            text-shadow:
              0 6px 18px rgba(0,0,0,0.4),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 12px rgba(50, 0, 70, 0.45);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.32));
        }


        /* =====================
           Adaptación móvil
        ===================== */
        @media (max-width: 768px) {
            body {
                margin: 0;
            }


            .topbar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                padding: 12px;
                position: relative;
            }

            .topbar-left,
            .topbar-right {
                width: 100%;
                justify-content: center;
            }

            .topbar-title {
                width: 100%;
            }

            .topbar-title button {
                width: 100%;
                min-width: 0;
                padding: 14px 18px;
            }

            .topbar-hero {
                width: 100%;
                align-items: center;
            }

            .nav-dropdown-menu {
                position: relative;
                top: 8px;
                left: 0;
                right: 0;
                width: 100%;
                min-width: 0;
                box-shadow: 0 16px 40px rgba(0,0,0,0.35);
                border: 1px solid rgba(255,255,255,0.16);
                background: linear-gradient(145deg, rgba(20,10,30,0.92), rgba(8,4,16,0.9));
            }

            .content {
                padding: 12px;
            }

            .card {
                padding: 16px;
            }

            /* Botones de la toolbar de nodos en una sola línea (scroll horizontal si hace falta) */
            .flow-toolbar {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                overflow-x: auto;
            }

            .flow-toolbar-group {
                width: auto;
                flex-wrap: nowrap;
            }

            .flow-toolbar .btnPrimario,
            .flow-toolbar .btnSecundario {
                width: auto;
                justify-content: center;
            }

            /* Formularios más cómodos */
            form input,
            form select,
            form button,
            form textarea {
                width: 100%;
                box-sizing: border-box;
                font-size: 16px;
            }

            form .btnPrimario,
            form .btnSecundario {
                justify-content: center;
            }
            
            .nav-dropdown-menu a {
                font-size: 16px;
                padding: 12px 18px;
            }

            .copiloto-shell {
                padding: 18px;
            }

            .copiloto-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .copiloto-title-row {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
            }
            .copiloto-date {
                position: static;
                transform: none;
                width: 100%;
                justify-content: space-between;
                white-space: normal;
            }

            .copiloto-date {
                width: 100%;
                justify-content: space-between;
            }

            .copiloto-panel.wide {
                grid-column: auto;
            }

            .copiloto-actions {
                width: 100%;
                justify-content: flex-start;
            }

            .copiloto-header-side {
                width: 100%;
                align-items: stretch;
            }

            .copiloto-header-rules {
                width: 100%;
                max-width: none;
            }

            .copiloto-actions-grid {
                grid-template-columns: 1fr;
            }

            .cata-grid {
                grid-template-columns: 1fr;
            }
        }

@keyframes shimmer {
        0% { transform: translateX(-300%) rotate(12deg); opacity: 0; }
        20% { opacity: 1; }
        100% { transform: translateX(300%) rotate(12deg); opacity: 0; }
}

        .topbar-title button .caret {
            display: none;
        }

        .topbar-title button.open .caret {
            transform: none;
        }

.nav-dropdown-menu {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            display: none;
            flex-direction: column;
            background: rgba(8, 4, 15, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 18px;
            padding: 12px;
            min-width: 230px;
            width: 240px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.45);
            backdrop-filter: blur(18px);
            z-index: 20;
        }

.nav-dropdown-menu.visible {
            display: flex;
        }

.nav-dropdown-menu a {
            display: flex;
            align-items: center;
            color: #f9e5ff;
            padding: 10px 18px;
            border-radius: 999px;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.9;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.04);
            margin: 4px 0;
            width: 100%;
            min-width: 210px;
            justify-content: flex-start;
            box-sizing: border-box;
            min-height: 44px;
        }

.nav-dropdown-menu a:hover {
            background: rgba(255,255,255,0.12);
            opacity: 1;
        }

.nav-dropdown-menu a .emoji-barrica-lateral {
            position: relative;
            width: 44px;
            height: 30px;
            margin-right: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-1px);
        }

        .emoji-barrica-lateral span {
            position: absolute;
            display: block;
        }

        .emoji-barrica-lateral .sobrio-shadow {
            inset: auto 10px -8px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.25), transparent 70%);
            filter: blur(2px);
        }

        .emoji-barrica-lateral .sobrio-body {
            inset: 4px 8px;
            border-radius: 20px / 13px;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #c08342, #7e4a1f 70%);
            box-shadow:
                inset 0 0 8px rgba(0,0,0,0.4),
                0 3px 5px rgba(0,0,0,0.25);
        }

        .emoji-barrica-lateral .sobrio-body::before {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: inherit;
            border: 1px solid rgba(255,255,255,0.15);
            opacity: 0.8;
        }

        .emoji-barrica-lateral .sobrio-ring {
            left: 14px;
            right: 14px;
            height: 3px;
            border-radius: 3px;
            background: linear-gradient(90deg, #bfc2c5, #7c8086);
            box-shadow:
                inset 0 0 1px rgba(0,0,0,0.5),
                0 0 1px rgba(0,0,0,0.3);
        }

        .emoji-barrica-lateral .sobrio-ring.superior { top: 9px; }
        .emoji-barrica-lateral .sobrio-ring.inferior { top: 18px; }

        .emoji-barrica-lateral .sobrio-head {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #d19b5e, #8a5021);
            box-shadow: inset -2px -2px 3px rgba(0,0,0,0.35);
        }

        .emoji-barrica-lateral .sobrio-head.front { right: 3px; z-index: 2; }
        .emoji-barrica-lateral .sobrio-head.back {
            left: 3px;
            filter: brightness(0.85);
        }

.nav-barricas-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            width: 230px;
            box-sizing: border-box;
            height: 40px;
            padding-top: 8px;
            padding-bottom: 8px;
        }

.nav-barricas-icon {
            width: 30px;
            height: 30px;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.35));
            background: transparent;
            mix-blend-mode: multiply;
        }

.nav-dropdown-menu a.activo {
            background: linear-gradient(120deg, rgba(241,92,146,0.9), rgba(95,44,130,0.9));
            color: #fff;
            opacity: 1;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 6px 18px rgba(241, 92, 146, 0.35);
        }

.nav-dropdown-menu a .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .icon-barrica {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: linear-gradient(180deg, #c07b45, #7a3f1b);
            border: 2px solid #51260f;
            position: relative;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        }

        .icon-barrica::before,
        .icon-barrica::after {
            content: "";
            position: absolute;
            left: 2px;
            right: 2px;
            height: 2px;
            background: rgba(81,38,15,0.8);
            border-radius: 2px;
        }

        .icon-barrica::before { top: 4px; }
        .icon-barrica::after { bottom: 4px; }

.h1-emoji {
            font-size: var(--page-title-size);
            line-height: 1;
            display: inline-block;
            margin-right: 10px;
        }

        .h1-emoji-img {
            width: var(--page-title-size);
            height: var(--page-title-size);
            object-fit: contain;
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.35));
            mix-blend-mode: multiply;
            background: transparent;
        }

        .content {
            padding: 60px 70px 110px;
            min-height: 100vh;
            position: relative;
            z-index: 1;
            max-width: 1920px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .content {
                padding: 35px 24px 70px;
                max-width: 100%;
            }
        }

       :root {
           --page-title-size: 50px;
       }

       h1 {
           margin: 0 0 15px;
           font-size: var(--page-title-size);
           font-weight: 700;
           color: var(--vino-oscuro);
           letter-spacing: 0.4px;
       }

        h2 {
            color: var(--vino);
            margin-top: 0;
            letter-spacing: 0.2px;
        }

        .topbar h2 {
            color: #fff;
        }

        .card {
            background: rgba(255, 255, 255, 0.92);
            padding: 36px;
            border-radius: 30px;
            margin-bottom: 36px;
            box-shadow: 0 25px 60px rgba(11, 5, 21, 0.35);
            border: 1px solid rgba(255,255,255,0.45);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(12px);
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 20%, rgba(241,92,146,0.2), transparent 55%),
                        radial-gradient(circle at 80% 0%, rgba(95,44,130,0.16), transparent 60%);
            pointer-events: none;
        }

        .card > * {
            position: relative;
            z-index: 1;
        }

        .chart-card {
            margin-top: 25px;
            background: rgba(255,255,255,0.55);
            border-radius: 24px;
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.35);
            backdrop-filter: blur(8px);
        }

       .indicadores-grid {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
           gap: 18px;
           margin-top: 24px;
       }

        .indicador-card {
            background: rgba(255,255,255,0.85);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 10px 30px rgba(20,8,32,0.2);
        }

        .indicador-card h4 {
            margin: 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(47,31,59,0.8);
        }

        .indicador-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .indicador-label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
        }

        .indicador-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(47,31,59,0.14);
            background: rgba(255,255,255,0.7);
            color: rgba(47,31,59,0.84);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.03em;
            white-space: nowrap;
        }

        .indicador-card p {
            margin: 10px 0 4px;
            font-size: 32px;
            font-weight: 700;
            color: var(--vino-oscuro);
        }

        .indicador-card small {
            color: rgba(47,31,59,0.7);
            display: block;
            font-size: 12px;
        }

        .estado-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #fff;
            min-width: 48px;
            text-transform: uppercase;
        }

        .estado-fa { background: #d85c5c; }
        .estado-fml { background: #c47d21; }
        .estado-reposo { background: #8c6ff7; }
        .estado-limpio { background: #40a578; }
        .estado-vacio { background: #9ba1b0; }
        .estado-mantenimiento { background: #f0a500; }
        .estado-analitica { background: #ff7aa8; }

        .estado-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #fff;
            margin-top: 6px;
        }

        .estado-pill.mini {
            position: absolute;
            top: 8px;
            right: 0;
            font-size: 9px;
            padding: 3px 8px;
        }

        .plano-item .estado-pill.mini {
            right: 8px;
            top: 8px;
            padding: 3px 10px;
            letter-spacing: 0.06em;
            opacity: 0.92;
            backdrop-filter: blur(8px);
        }

        .acciones-rapidas {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 28px 0 10px;
        }

       .acciones-rapidas button {
           background: rgba(255,255,255,0.15);
           border: 1px solid rgba(255,255,255,0.4);
           padding: 10px 18px;
           border-radius: 999px;
           color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s;
        }

        .acciones-rapidas button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        section.card {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        section.card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .flow-toolbar {
            display: flex;
            flex-wrap: nowrap;
            gap: 12px;
            margin-bottom: 6px;
            padding-bottom: 0;
            align-items: center;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .flow-toolbar-group {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            align-items: center;
            white-space: nowrap;
        }

        /* Botones del mapa de nodos (más grandes y cómodos) */
        .flow-toolbar .btnPrimario,
        .flow-toolbar .btnSecundario {
            font-size: 13px;
            padding: 9px 14px;
            border-radius: 12px;
            min-height: 38px;
            flex: 0 0 auto;
        }

        .flow-toolbar .btnPrimario span,
        .flow-toolbar .btnPrimario img {
            vertical-align: middle;
        }

        .flow-zoom-controls {
            margin-left: auto;
        }

        .flow-toolbar .flow-zoom-btn {
            width: 38px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

	        .flow-toolbar .flow-zoom-label {
	            min-width: 70px;
	            text-align: center;
	            padding: 9px 12px;
	            font-weight: 800;
	        }

	        .flow-editor {
	            position: relative;
	            border: 1px dashed rgba(255,255,255,0.25);
	            border-radius: 24px;
	            background: rgba(8,4,15,0.5);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
            margin-top: 4px;
        }

        .flow-stage {
            position: relative;
            width: 5000px;
            height: 3000px;
            min-width: 1400px;
            min-height: 640px;
            overflow: hidden;
        }

        .flow-world {
            position: absolute;
            left: 0;
            top: 0;
            width: 5000px;
            height: 3000px;
            transform-origin: 0 0;
            transform: scale(1);
        }

        .demo-flow-stage {
            position: relative;
            min-height: 320px;
            border: 1px dashed rgba(255,255,255,0.25);
            border-radius: 18px;
            background: radial-gradient(circle at 12% 18%, rgba(255,255,255,0.05), transparent 55%),
                        radial-gradient(circle at 80% 8%, rgba(255,255,255,0.04), transparent 60%),
                        rgba(12,6,18,0.6);
            overflow: hidden;
            margin-top: 14px;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.25);
        }

        .demo-flow-node {
            min-width: 160px;
            padding: 10px 12px 14px;
            border-radius: 16px;
        }

        .flow-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: default;
            background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .flow-connections {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .flow-node {
            position: absolute;
            z-index: 3;
            min-width: 72px;
            background: rgba(40, 18, 52, 0.95);
            border-radius: 7px;
            box-shadow: 0 8px 14px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.08);
            padding: 4px 6px 24px;
            cursor: grab;
            color: #f5e9ff;
            text-transform: uppercase;
            font-weight: 400;
            letter-spacing: 0.3px;
            overflow: hidden;
            isolation: isolate;
        }

        .flow-node__extra {
            display: flex;
            flex-direction: column;
        }

        .flow-node__titleCompact {
            display: none;
        }

        .flow-node[data-state="compact"] .flow-node__titleCompact {
            display: inline-flex;
        }

        .flow-node[data-state="compact"] .flow-node__extra {
            display: none;
        }

        .flow-node[data-state="compact"] .fill-level,
        .flow-node[data-state="compact"] .flow-progress-ring {
            display: none;
        }

        .flow-node.node--warn {
            border-color: rgba(201, 140, 52, 0.75);
            box-shadow: 0 8px 14px rgba(0,0,0,0.35), 0 0 0 2px rgba(201, 140, 52, 0.25);
        }

        .flow-node.node--warn::after {
            content: "";
            position: absolute;
            top: 6px;
            right: 6px;
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: rgba(201, 140, 52, 0.95);
            box-shadow: 0 0 0 2px rgba(40, 18, 52, 0.9);
        }

        .flow-node.menu-open {
            overflow: visible;
        }

        .flow-node.dragging {
            cursor: grabbing;
            box-shadow: 0 25px 50px rgba(0,0,0,0.35);
        }

        .flow-node h4 {
            margin: 0;
            font-size: 14px;
            color: #f7f2ff;
            text-align: right;
            font-weight: 700;
        }

        .flow-node-subtitle {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 1px;
            text-align: right;
        }
        .flow-node-subtitle.flow-node-metodo {
            font-weight: 700;
        }

        .flow-node-metrics {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-top: 4px;
            font-size: 10px;
            text-transform: none;
            justify-content: flex-end;
        }

        .flow-chip {
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            letter-spacing: 0.2px;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .flow-node .fill-level {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 0%;
            background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
            mix-blend-mode: screen;
            transition: height 0.35s ease, background 0.3s ease;
            z-index: -1;
        }

        .flow-node .fill-level.red {
            background: linear-gradient(180deg, rgba(255,88,120,0.15), rgba(255,88,120,0.35));
        }

        .flow-node .fill-level.white {
            background: linear-gradient(180deg, rgba(255,236,200,0.2), rgba(255,236,200,0.45));
        }

        .flow-node .fill-level.rosado {
            background: linear-gradient(180deg, rgba(245,139,181,0.18), rgba(245,139,181,0.42));
        }

        .flow-node.temp-alert {
            box-shadow: 0 0 14px rgba(255,90,90,0.8), 0 0 0 1px rgba(255,90,90,0.45);
            border-color: rgba(255,90,90,0.6);
        }

        .flow-state-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 6px;
            font-size: 14px;
            line-height: 1.2;
            letter-spacing: 0.4px;
            font-weight: 700;
            text-transform: uppercase;
            color: #ffd89c;
        }

        .flow-progress-ring {
            position: absolute;
            inset: -6px;
            border-radius: 14px;
            pointer-events: none;
            z-index: -2;
            opacity: 0.8;
            -webkit-mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
            mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
        }

        .flow-node-icon {
            font-size: 15px;
        }

        .flow-tooltip {
            position: fixed;
            z-index: 9999;
            display: none;
            max-width: min(360px, calc(100vw - 24px));
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(18, 10, 30, 0.92);
            border: 1px solid rgba(255,255,255,0.16);
            box-shadow: 0 20px 45px rgba(0,0,0,0.45);
            color: rgba(255,255,255,0.92);
            font-size: 12px;
            line-height: 1.25;
            white-space: pre-line;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .grape-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.35), 0 1px 4px rgba(0,0,0,0.35);
            margin-left: 2px;
        }

        .grape-badge.red {
            background: radial-gradient(circle at 30% 30%, #ffb3c9, #d43c68 55%, #7a0f38 100%);
            color: #fff;
        }

        .grape-badge.white {
            background: radial-gradient(circle at 30% 30%, #fff7d1, #f9d66b 55%, #c99a2a 100%);
            color: #3a2a00;
        }

        .flow-node small {
            display: none;
        }

        .flow-node .flow-unit {
            display: inline-block;
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            font-size: 9px;
            margin-top: 4px;
            letter-spacing: 0.4px;
        }

        .flow-node .flow-node-controls {
            position: absolute;
            bottom: 6px;
            right: 6px;
            display: flex;
            gap: 4px;
        }

        .flow-node .flow-node-controls button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .flow-node .flow-node-controls button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .flow-node .flow-node-controls button.blue::before {
            background: #2f7df0;
        }

        .flow-node .flow-node-controls button.green::before {
            background: #4caf50;
        }

        .flow-node .flow-node-controls button.red::before {
            background: #f44336;
        }
        .flow-node .flow-node-controls button.blue::after {
            content: "";
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.9);
            inset: 0;
            margin: auto;
        }

        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }
        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }

        .flow-node .flow-node-controls button.red::after {
            content: "×";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 8px;
        }

        .flow-node .flow-node-controls button.menu::before {
            background: #8a93a4;
        }

        .flow-node .flow-node-controls button.menu::after {
            content: "⋯";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 10px;
            line-height: 1;
        }

        .flow-node .flow-node-menu {
            position: absolute;
            right: 4px;
            bottom: 22px;
            min-width: 150px;
            display: none;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(20, 12, 32, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 12px 24px rgba(0,0,0,0.35);
            z-index: 3;
        }

        .flow-node .flow-node-menu.visible {
            display: flex;
        }

        .flow-node .flow-node-menu button {
            width: 100%;
            border: none;
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-size: 12px;
            text-align: left;
            padding: 6px 8px;
            border-radius: 10px;
            cursor: pointer;
        }

        .flow-node .flow-node-menu button:hover {
            background: rgba(255,255,255,0.2);
        }

        .flow-node .flow-node-menu button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .flow-node .flow-node-controls button.conectando::before {
            box-shadow: 0 0 6px rgba(243,120,156,0.8);
        }

        .flow-node-body {
            width: 100%;
            align-items: flex-end;
            text-align: right;
            padding-right: 6px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .flow-node-subtitle.flow-source-badge {
            font-size: 10px;
            font-weight: 700;
            opacity: 0.88;
        }

        .flow-node-subtitle.flow-discrepancia {
            font-size: 10px;
            font-weight: 800;
            color: #ffcf83;
        }

        .flow-node-subtitle.flow-capacidad-alerta {
            font-size: 10px;
            font-weight: 800;
            color: #ffd77a;
        }


	        .flow-connector-line {
	            stroke: rgba(255,255,255,0.65);
	            stroke-width: 1.6;
	            fill: none;
	            marker-end: url(#arrowHead);
	        }

	        .flow-connector-label {
	            fill: rgba(255,255,255,0.85);
	            font-size: 11px;
	            font-family: "Inter", system-ui, sans-serif;
	            pointer-events: none;
	            text-shadow: 0 1px 4px rgba(0,0,0,0.55);
	        }

        .flow-node-info {
            margin-top: 16px;
            padding: 14px 18px;
            border-radius: 16px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.05);
            min-height: 80px;
            font-size: 14px;
        }

        .flow-helper {
            margin-top: 14px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        .flow-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding: 140px 20px 40px;
            z-index: 12000;
            overflow-y: auto;
        }

        .flow-modal.visible {
            display: flex;
        }

        .flow-modal-content {
            background: #fff;
            border-radius: 18px;
            padding: 18px 20px;
            max-width: 450px;
            width: min(450px, 94%);
            box-shadow: 0 30px 60px rgba(0,0,0,0.35);
        }

        .flow-modal-content form label {
            margin-top: 10px;
            display: block;
            font-weight: 500;
        }

        .flow-modal-content form input,
        .flow-modal-content form textarea,
        .flow-modal-content form select {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 14px;
        }

        .field-readonly {
            background: rgba(0,0,0,0.05);
            color: #5c5c5c;
            cursor: not-allowed;
        }

        .flow-modal-content form textarea {
            min-height: 70px;
        }

        .campo-info {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(0,0,0,0.04);
            border: 1px dashed rgba(0,0,0,0.12);
            font-size: 13px;
            color: #444;
        }

        #entradas.entrada-page {
            padding: 18px 18px 24px;
        }

        #entradas .entrada-form {
            display: grid;
            gap: 18px;
        }

        #entradas .entrada-block {
            position: relative;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.08);
            border-left: 4px solid rgba(95,44,130,0.35);
            border-radius: 18px;
            padding: 16px;
            display: grid;
            gap: 12px;
            box-shadow: 0 14px 30px rgba(20, 8, 32, 0.08);
        }

        #entradas .entrada-block--hero {
            border-left-color: rgba(95,44,130,0.7);
            background: radial-gradient(circle at 18% 20%, rgba(255, 235, 200, 0.22), transparent 45%),
                        linear-gradient(180deg, rgba(255, 255, 255, 0.96), #fff);
            overflow: hidden;
        }

        #entradas .entrada-block--hero::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(120deg, rgba(241,92,146,0.6), rgba(95,44,130,0.7));
        }

        #entradas .entrada-block--admin {
            border-left-color: rgba(193, 131, 66, 0.75);
            background: linear-gradient(180deg, rgba(255, 214, 153, 0.24), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--identidad {
            border-left-color: rgba(109, 132, 108, 0.7);
            background: linear-gradient(180deg, rgba(189, 206, 184, 0.2), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--fisica {
            border-left-color: rgba(122, 15, 56, 0.75);
            background: linear-gradient(180deg, rgba(122, 15, 56, 0.12), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--observaciones {
            border-left-color: rgba(125, 96, 166, 0.75);
            background: linear-gradient(180deg, rgba(155, 125, 210, 0.18), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        #entradas .entrada-title {
            margin: 0;
            font-size: var(--page-title-size);
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #7a0f38;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #entradas .entrada-title .h1-emoji {
            font-size: 1em;
        }

        #entradas .entrada-block-eyebrow,
        #entradas .entrada-block-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #6f685e;
            font-weight: 600;
        }

        #entradas .entrada-block-title {
            position: relative;
            padding-bottom: 2px;
        }

        #entradas .entrada-block-title::after {
            content: "";
            display: block;
            height: 1px;
            margin-top: 6px;
            background: linear-gradient(90deg, currentColor, transparent);
            opacity: 0.4;
        }

        #entradas .entrada-block--admin .entrada-block-title {
            color: #a46b2e;
        }

        #entradas .entrada-block--identidad .entrada-block-title {
            color: #5d6f5b;
        }

        #entradas .entrada-block--fisica .entrada-block-title {
            color: #7a0f38;
        }

        #entradas .entrada-block--observaciones .entrada-block-title {
            color: #6b4b87;
        }

        #entradas .entrada-block-subtitle {
            font-size: 12px;
            color: #7b756b;
        }

        #entradas .entrada-block--hero .entrada-block-subtitle {
            color: #7b4a6a;
            font-weight: 600;
        }

        #entradas .entrada-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(255,159,220,0.9), rgba(155,93,229,0.9));
            border: 1px solid rgba(255,255,255,0.55);
            color: #2b1736;
            font-size: 12px;
            font-weight: 700;
            box-shadow: 0 8px 18px rgba(95, 44, 130, 0.2);
        }

        #entradas .entrada-grid {
            display: grid;
            gap: 12px;
        }

        #entradas .entrada-grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        #entradas .entrada-grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        #entradas .entrada-grid-4 {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        #entradas .entrada-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6d675e;
            margin-bottom: 4px;
        }

        #entradas input,
        #entradas select,
        #entradas textarea {
            padding: 7px 10px;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.14);
            font-size: 14px;
            background: rgba(255,255,255,0.92);
            box-shadow: none;
        }

        #entradaRc {
            background: rgba(255, 245, 230, 0.9);
            border-color: rgba(193, 131, 66, 0.45);
            font-weight: 600;
            letter-spacing: 0.04em;
            box-shadow: inset 0 0 0 1px rgba(193, 131, 66, 0.12);
        }

        #entradas .btnSecundario {
            background: #f3f1ed;
            color: #3a342d;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: none;
        }

        #entradas textarea {
            min-height: 90px;
        }

        #entradas .entrada-check {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #6d675e;
        }

        #entradas .entrada-lineas {
            margin-top: 4px;
        }

        .entrada-procedencia-grid {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .entrada-procedencia-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6d675e;
            margin-bottom: 4px;
        }

        .entrada-procedencia-field--wide {
            grid-column: span 2;
        }

        .entrada-chip-oficial {
            display: inline-block;
            margin-left: 6px;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            background: linear-gradient(135deg, #ffd79c, #c07b45);
            color: #3a1f06;
            letter-spacing: 0.04em;
        }

        .entrada-procedencia-extra {
            border: 1px dashed rgba(0,0,0,0.12);
            border-radius: 12px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.7);
        }

        .entrada-procedencia-extra summary {
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            color: #5f594f;
        }

        .entrada-catastro-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        #entradas .entrada-catastro-actions .btnPrimario,
        #entradas .entrada-catastro-actions .btnSecundario {
            background: #f7f4ef;
            color: #3a342d;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: none;
        }

        #entradas .entrada-catastro-actions .btnPrimario:disabled,
        #entradas .entrada-catastro-actions .btnSecundario:disabled {
            opacity: 0.55;
        }

        .entrada-catastro-links {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
            margin-top: 6px;
            font-size: 12px;
        }

        .entrada-catastro-links a {
            color: #3a342d;
            text-decoration: underline;
        }

        .entrada-catastro-links a[aria-disabled="true"] {
            opacity: 0.5;
            pointer-events: none;
            text-decoration: none;
        }

        .entrada-plantillas {
            display: grid;
            gap: 6px;
            padding: 10px;
            border-radius: 12px;
            border: 1px dashed rgba(0,0,0,0.12);
            background: rgba(255,255,255,0.6);
        }

        .entrada-plantillas-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #6f685e;
            font-weight: 600;
        }

        .entrada-plantillas-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .entrada-hint {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .entrada-lectura-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .entrada-lectura-row input {
            flex: 1;
        }

        .entrada-lectura input {
            font-size: 19px;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #6c2b52;
        }

        #entradaKilosWrap {
            background: rgba(122, 15, 56, 0.06);
            border: 1px solid rgba(122, 15, 56, 0.15);
            border-radius: 12px;
            padding: 10px;
        }

        #entradaCajasWrap,
        #entradaTipoCajaWrap {
            background: rgba(122, 15, 56, 0.06);
            border: 1px solid rgba(122, 15, 56, 0.15);
            border-radius: 12px;
            padding: 10px;
        }

        #entradas .entrada-lectura {
            background: rgba(93, 47, 109, 0.06);
            border: 1px solid rgba(93, 47, 109, 0.15);
            border-radius: 12px;
            padding: 10px;
        }

        .entrada-unidad {
            font-size: 12px;
            color: #7b4a6a;
        }

        #entradaKilos {
            font-size: 20px;
            font-weight: 700;
            color: #7a0f38;
        }

        #entradaDensidad,
        #entradaTemperatura,
        #entradaPh,
        #entradaAcidezTotal {
            color: #5d2f6d;
        }

        .entrada-resumen-admin {
            margin-top: 10px;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 14px;
            padding: 8px 10px;
            background: #fffdf7;
        }

        .entrada-resumen-admin summary {
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            color: #5c554b;
        }

        .entrada-resumen-body {
            display: grid;
            gap: 8px;
            margin-top: 8px;
        }

        #entradaResumenAdminTexto {
            min-height: 130px;
            resize: vertical;
            font-family: "Courier New", monospace;
            font-size: 12px;
        }

        #entradas .entrada-actions {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 4px;
        }

        #entradas .entrada-actions .btnPrimario {
            min-width: 220px;
            background: linear-gradient(120deg, rgba(241,92,146,0.95), rgba(95,44,130,0.95));
            color: #fff7fd;
            border: 1px solid rgba(255,255,255,0.45);
            box-shadow: 0 18px 36px rgba(95, 44, 130, 0.3);
        }

        #entradas .entrada-actions .btnSecundario {
            opacity: 0.75;
        }

        #entradas .entrada-historial {
            margin-top: 26px;
            padding: 18px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.08);
            background: #f2f1ed;
        }

        #entradas .entrada-historial h2 {
            margin-top: 0;
            font-size: 16px;
            color: #6b2f5b;
        }

        #entradas .entrada-historial table {
            box-shadow: none;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.08);
        }

        #entradas .entrada-historial th {
            background: linear-gradient(90deg, rgba(241,92,146,0.12), rgba(95,44,130,0.08));
            color: #5b2a48;
        }

        #entradas .entrada-historial .small-btn {
            background: #e7e3dc !important;
            color: #4a443c !important;
            box-shadow: none !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
        }

        #entradas .entrada-historial tbody tr {
            transition: background 0.2s ease;
        }

        #entradas .entrada-historial tbody tr:hover {
            background: rgba(241, 92, 146, 0.08);
        }

        @media (max-width: 720px) {
            #entradas .entrada-block-header {
                align-items: flex-start;
            }

            .entrada-procedencia-field--wide {
                grid-column: span 1;
            }

            #entradas .entrada-actions .btnPrimario {
                width: 100%;
            }
        }

        .tabla-control-fermentacion table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-control-fermentacion th,
        .tabla-control-fermentacion td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-control-fermentacion input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-control-fermentacion select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
            background: #fff;
        }

        .tabla-control-fermentacion th:nth-child(1),
        .tabla-control-fermentacion td:nth-child(1) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(2),
        .tabla-control-fermentacion td:nth-child(2) {
            width: 80px;
        }

        .tabla-control-fermentacion th:nth-child(3),
        .tabla-control-fermentacion td:nth-child(3) {
            width: 60px;
        }

        .tabla-control-fermentacion th:nth-child(4),
        .tabla-control-fermentacion td:nth-child(4) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(5),
        .tabla-control-fermentacion td:nth-child(5) {
            width: 160px;
        }

        .tabla-control-fermentacion tbody tr:last-child td {
            border-bottom: none;
        }

        .tabla-formatos-embotellado table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-formatos-embotellado th,
        .tabla-formatos-embotellado td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-formatos-embotellado input,
        .tabla-formatos-embotellado select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-formatos-embotellado .tabla-formatos-resumen {
            margin-top: 6px;
            font-size: 12px;
            color: #666;
        }

        .flow-modal-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .skeleton-line,
        .skeleton-block {
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .skeleton-line::before,
        .skeleton-block::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            animation: shimmer 1.3s infinite;
        }

        .skeleton-line {
            height: 10px;
            margin: 6px 0;
        }

        .skeleton-block {
            height: 36px;
            margin: 10px 0;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .form-feedback {
            margin-top: 12px;
            font-size: 13px;
            min-height: 18px;
            color: rgba(32, 16, 36, 0.7);
        }

        .form-feedback.success {
            color: #2f8f5b;
        }

        .form-feedback.error {
            color: #d95070;
        }
        .movimientos-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .movimientos-form {
            flex: 1.2;
            min-width: 320px;
        }

        .tabla-movimientos {
            flex: 1.6;
            min-width: 440px;
            min-height: 520px;
            overflow-x: auto;
            overflow-y: visible;
        }

        .movimientos-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            min-width: 760px;
        }

        .movimientos-table th,
        .movimientos-table td {
            font-size: 12px;
            white-space: nowrap;
            padding: 8px;
        }


        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 22px;
            margin-top: 16px;
        }

        .chart-item {
            background: linear-gradient(160deg, rgba(255,255,255,0.95), rgba(241,92,146,0.15));
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--vino);
        }

        .app-alerts {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .toast {
            min-width: 220px;
            background: rgba(15, 7, 20, 0.85);
            color: #fff;
            padding: 12px 18px;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.35);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(20px);
            animation: toast-in 0.25s forwards;
        }

        .toast.success { background: rgba(64, 165, 120, 0.9); }
        .toast.error { background: rgba(217, 80, 112, 0.9); }

        @keyframes toast-in {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chart-bar-bg {
            width: 100%;
            height: 12px;
            border-radius: 12px;
            background: rgba(75,15,77,0.15);
            overflow: hidden;
        }

        .chart-bar {
            height: 100%;
            border-radius: 12px;
            background: linear-gradient(90deg, #f76fb0, #5f2c82);
            width: 20%;
            transition: width 0.4s ease;
        }

        .chart-item small {
            display: block;
            margin-top: 8px;
            color: #6e5e6e;
        }

        .copiloto-shell {
            margin-top: 0;
            padding: 26px;
            border-radius: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
            overflow: hidden;
        }

        .copiloto-shell::before {
            display: none;
        }

        .copiloto-header {
            position: relative;
            z-index: 1;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .copiloto-header-main {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: min(420px, 100%);
        }

        .copiloto-title-row {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .copiloto-title {
            font-size: var(--page-title-size);
            font-weight: 800;
            margin: 0;
            color: #1a0d22;
            justify-self: start;
        }

        .copiloto-date {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(26,13,34,0.7);
            padding: 10px 16px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            justify-self: center;
            white-space: nowrap;
        }

        .copiloto-campania {
            margin-left: 8px;
            padding: 4px 10px;
            border-left: 1px solid rgba(15,7,20,0.2);
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(126, 20, 56, 0.55), rgba(245, 162, 194, 0.35));
            color: rgba(255, 236, 244, 0.98);
            font-weight: 600;
            letter-spacing: 0.06em;
        }

        .copiloto-subtitle {
            margin: 6px 0 0;
            color: rgba(26,13,34,0.7);
            font-size: 14px;
        }

        .copiloto-chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .copiloto-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
            font-size: 12px;
            font-weight: 600;
            color: rgba(20,10,30,0.85);
        }

        .copiloto-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .copiloto-header-side {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            min-width: min(420px, 100%);
            max-width: min(560px, 100%);
        }

        .copiloto-header-rules {
            width: 100%;
        }

        .copiloto-header-rules .copiloto-config-wrap {
            margin-top: 0;
        }

        .copiloto-grid {
            position: relative;
            z-index: 1;
            margin-top: 18px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .copiloto-grid-superior {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 16px;
            align-items: stretch;
        }

        .copiloto-panel-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
            min-height: 0;
            overflow: auto;
        }

        .copiloto-panel {
            background: rgba(255,255,255,0.8);
            border-radius: 20px;
            padding: 18px;
            border: 1px solid rgba(95,44,130,0.12);
            box-shadow: 0 16px 40px rgba(15,7,20,0.12);
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 160px;
        }

        .copiloto-grid-superior .copiloto-panel {
            min-height: 260px;
            max-height: 360px;
        }

        .copiloto-panel.wide {
            grid-column: span 2;
        }

        .copiloto-panel--tools-flat {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            min-height: 0;
            gap: 0;
        }

        .copiloto-panel--tools-flat .copiloto-tools-card {
            margin-top: 0;
        }

        .copiloto-panel-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .copiloto-panel h3 {
            margin: 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.85);
        }

        .copiloto-panel-sub {
            margin: 4px 0 0;
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .copiloto-alerts,
        .copiloto-tareas,
        .copiloto-activity,
        .copiloto-live {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .copiloto-live-item {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.88);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .copiloto-live-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        .copiloto-live-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-live-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .copiloto-badge {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            padding: 3px 8px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
            color: rgba(20,10,30,0.85);
        }

        .copiloto-badge[data-estado="activo"] {
            background: rgba(255,203,120,0.45);
            border-color: rgba(255,203,120,0.7);
        }

        .copiloto-badge[data-estado="violento"] {
            background: rgba(255,143,143,0.45);
            border-color: rgba(255,143,143,0.7);
        }

        .copiloto-badge[data-estado="tranquilo"],
        .copiloto-badge[data-estado="equilibrado"] {
            background: rgba(130,205,170,0.4);
            border-color: rgba(130,205,170,0.7);
        }

        .copiloto-badge[data-estado="tenso"],
        .copiloto-badge[data-estado="inestable"] {
            background: rgba(255,199,143,0.5);
            border-color: rgba(255,199,143,0.7);
        }

        .copiloto-badge[data-estado="reductivo"],
        .copiloto-badge[data-estado="cerrado"] {
            background: rgba(188,196,255,0.45);
            border-color: rgba(188,196,255,0.7);
        }

        .copiloto-badge[data-origen="express"] {
            background: rgba(255,232,179,0.7);
            border-color: rgba(255,200,112,0.8);
        }

        .copiloto-badge[data-origen="control"] {
            background: rgba(200,230,255,0.7);
            border-color: rgba(150,200,255,0.8);
        }

        .copiloto-badge[data-origen="manual"] {
            background: rgba(220,220,220,0.6);
            border-color: rgba(190,190,190,0.8);
        }

        .copiloto-live-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-live-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .copiloto-action-express {
            background: #111;
            color: #fff;
            border-color: #111;
        }

        .copiloto-alert {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.85);
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }

        .copiloto-alert[data-level="alta"] {
            border-left: 4px solid rgba(217,80,112,0.9);
            background: linear-gradient(120deg, rgba(255, 230, 230, 0.8), rgba(255,255,255,0.9));
        }

        .copiloto-alert[data-level="media"] {
            border-left: 4px solid rgba(243,199,123,0.9);
            background: linear-gradient(120deg, rgba(255, 240, 215, 0.8), rgba(255,255,255,0.9));
        }

        .copiloto-alert[data-level="baja"] {
            border-left: 4px solid rgba(64,165,120,0.8);
        }

        .copiloto-alert-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .copiloto-alert-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-alert-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .copiloto-task {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(15,7,20,0.06);
            border: 1px solid rgba(15,7,20,0.08);
        }

        .copiloto-task small {
            color: rgba(40,18,52,0.6);
        }

        .copiloto-feed-item {
            padding: 12px 14px;
            border-radius: 18px;
            background: rgba(20,10,30,0.06);
            border: 1px dashed rgba(95,44,130,0.18);
        }

        .copiloto-activity-item {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.86);
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-activity-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px rgba(15,7,20,0.16);
        }

        .copiloto-activity-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .copiloto-activity-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
        }

        .copiloto-empty {
            padding: 14px;
            border-radius: 14px;
            text-align: center;
            font-size: 13px;
            color: rgba(40,18,52,0.6);
            background: rgba(255,255,255,0.7);
            border: 1px dashed rgba(95,44,130,0.18);
        }

        .copiloto-subpanel {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed rgba(95,44,130,0.2);
        }

        .copiloto-subpanel h4 {
            margin: 0 0 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-semaforo {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(15,7,20,0.06);
        }

        .copiloto-semaforo[data-level="mantener"] {
            background: rgba(140,215,185,0.45);
            border-color: rgba(100,190,155,0.65);
            color: rgba(24,78,60,0.9);
        }

        .copiloto-semaforo[data-level="observa"] {
            background: rgba(170,205,255,0.5);
            border-color: rgba(130,170,240,0.7);
            color: rgba(24,60,120,0.9);
        }

        .copiloto-semaforo[data-level="preparate"] {
            background: rgba(255,214,160,0.55);
            border-color: rgba(235,185,120,0.8);
            color: rgba(120,70,20,0.9);
        }

        .copiloto-semaforo[data-level="actua"] {
            background: rgba(255,170,170,0.6);
            border-color: rgba(235,130,130,0.85);
            color: rgba(120,30,30,0.9);
        }

        .copiloto-timeline-wrap {
            display: grid;
            grid-template-columns: minmax(240px, 280px) minmax(0, 1fr);
            gap: 18px;
            align-items: start;
        }

        .copiloto-timeline-side {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .copiloto-quicknote {
            display: grid;
            gap: 8px;
        }

        .copiloto-quicknote textarea {
            resize: vertical;
            min-height: 120px;
            line-height: 1.45;
        }

        .copiloto-note-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .copiloto-note-metrics {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .copiloto-note-metric {
            display: grid;
            gap: 4px;
        }

        .copiloto-note-chip {
            cursor: pointer;
        }

        .copiloto-note-status {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
            min-height: 16px;
        }

        .copiloto-note-status.success {
            color: rgba(10,122,0,0.9);
        }

        .copiloto-note-status.error {
            color: rgba(176,0,32,0.9);
        }

        .copiloto-tools-card { margin-top: 14px; border: 1px solid rgba(15,7,20,0.1); border-radius: 14px; padding: 10px 12px; background: rgba(255,255,255,0.72); }
        .copiloto-tools-title { margin: 0 0 8px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(40,18,52,0.72); }
        .copiloto-tools-header { display: grid; gap: 8px; grid-template-columns: minmax(0, 1fr); align-items: end; margin-bottom: 6px; }
        .copiloto-tools-select { display: grid; gap: 4px; }
        .copiloto-tools-alias-editor { display: grid; gap: 8px; grid-template-columns: minmax(0,1fr) auto auto; margin: 6px 0 4px; }
        .copiloto-tools-alias-editor input { min-height: 36px; }
        @media (min-width: 840px) {
            .copiloto-tools-header { grid-template-columns: minmax(0, 1fr) auto; }
            #copilotoToolsAliasBtn { min-width: 140px; }
        }
        @media (max-width: 640px) {
            .copiloto-tools-alias-editor { grid-template-columns: 1fr; }
        }
        .copiloto-tools-analytics { display: grid; gap: 8px; border: 1px dashed rgba(15,7,20,0.15); border-radius: 10px; padding: 8px; margin: 8px 0; background: rgba(255,255,255,0.66); }
        .copiloto-tool-module { border: 1px solid rgba(15,7,20,0.08); border-radius: 12px; background: rgba(255,255,255,0.86); margin-bottom: 8px; }
        .copiloto-tool-module > summary { cursor: pointer; padding: 8px 10px; font-weight: 700; font-size: 12px; color: rgba(35,13,47,0.9); list-style: none; }
        .copiloto-tool-body { padding: 0 10px 10px; display: grid; gap: 8px; }
        .copiloto-tool-row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
        .copiloto-tool-seg { display: inline-flex; gap: 6px; flex-wrap: wrap; }
        .copiloto-tool-seg button, .copiloto-tool-chip { margin-top: 0; padding: 6px 10px; border-radius: 999px; font-size: 12px; box-shadow: none; }
        .copiloto-tool-seg button[aria-pressed="true"] { background: rgba(95,44,130,0.2); border: 1px solid rgba(95,44,130,0.36); color: rgba(40,18,52,0.92); }
        .copiloto-tool-actions { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .copiloto-tool-check { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: rgba(40,18,52,0.78); }
        .copiloto-tool-check input { width: auto; margin: 0; }
        .copiloto-tool-result { font-size: 16px; font-weight: 800; color: rgba(26,13,34,0.95); }
        .copiloto-tool-meta, .copiloto-tool-note { font-size: 12px; color: rgba(40,18,52,0.7); min-height: 14px; }
        .copiloto-tool-note.error { color: rgba(176,0,32,0.9); }

        .copiloto-heatmap-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

        .copiloto-heatmap-head button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .copiloto-heatmap {
            display: grid;
            grid-template-columns: repeat(14, minmax(10px, 1fr));
            gap: 4px;
        }

        .copiloto-heatmap-cell {
            border-radius: 4px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(15,7,20,0.06);
            aspect-ratio: 1 / 1;
            padding: 0;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-heatmap-cell:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 14px rgba(15,7,20,0.16);
        }

        .copiloto-heatmap-cell.heat-1 {
            background: rgba(255,221,234,0.6);
            border-color: rgba(235,180,205,0.7);
        }

        .copiloto-heatmap-cell.heat-2 {
            background: rgba(238,180,210,0.7);
            border-color: rgba(215,150,190,0.75);
        }

        .copiloto-heatmap-cell.heat-3 {
            background: rgba(212,135,180,0.78);
            border-color: rgba(190,110,160,0.8);
        }

        .copiloto-heatmap-cell.heat-4 {
            background: rgba(180,90,150,0.88);
            border-color: rgba(150,60,120,0.9);
        }

        .copiloto-heatmap-cell.is-selected {
            box-shadow: 0 0 0 2px rgba(95,44,130,0.7);
        }

        .copiloto-timeline-head {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .copiloto-timeline-head h4 {
            margin: 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-timeline-sub {
            margin: 4px 0 0;
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .copiloto-timeline-filters {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
            margin-bottom: 12px;
            align-items: start;
            --filtro-alto: 40px;
            --filtro-label: 18px;
        }

        .copiloto-filter-group {
            display: grid;
            gap: 6px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.6);
            align-content: start;
            align-items: stretch;
            font-weight: 600;
            grid-template-rows: var(--filtro-label) auto;
        }

        .copiloto-filter-group label,
        .copiloto-filter-group span {
            line-height: 1.1;
            min-height: var(--filtro-label);
            display: inline-flex;
            align-items: center;
            font-weight: 600;
            font-size: 13px;
        }

        .copiloto-filter-group select,
        .copiloto-filter-group input {
            font-size: 13px;
            text-transform: none;
            letter-spacing: normal;
            height: var(--filtro-alto);
        }

        .copiloto-filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: var(--filtro-alto);
            align-items: center;
        }

        .copiloto-filter-chips .copiloto-chip {
            cursor: pointer;
            height: var(--filtro-alto);
            padding: 0 12px;
        }

        .copiloto-chip.is-active {
            background: rgba(95,44,130,0.16);
            border-color: rgba(95,44,130,0.35);
            color: rgba(56,20,88,0.95);
        }

        .copiloto-timeline {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .copiloto-timeline-item,
        .copiloto-timeline-card {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-timeline-item:hover,
        .copiloto-timeline-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(15,7,20,0.16);
        }

        .copiloto-timeline-day {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .copiloto-day-toggle {
            align-self: flex-start;
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(255,255,255,0.9);
            font-size: 12px;
            font-weight: 600;
            color: rgba(40,18,52,0.8);
            cursor: pointer;
        }

        .copiloto-timeline-day-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.55);
            margin-top: 6px;
        }

        .copiloto-card-top {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .copiloto-card-time {
            font-size: 18px;
            font-weight: 800;
            color: rgba(26,13,34,0.95);
            min-width: 64px;
        }

        .copiloto-card-main {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .copiloto-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-card-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-card-sub {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
        }

        .copiloto-card-note {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .copiloto-card-note.is-expanded {
            -webkit-line-clamp: initial;
        }

        .copiloto-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-top: 6px;
        }

        .copiloto-timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-timeline-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-timeline-detail {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
        }

        .copiloto-timeline-vars {
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .bitacora-indomita-layout {
            display: grid;
            grid-template-columns: minmax(280px, 340px) minmax(0, 1fr);
            gap: 18px;
            align-items: start;
        }

        .bitacora-libro-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .bitacora-libro-controls {
            display: flex;
            align-items: flex-end;
            gap: 12px;
            flex-wrap: wrap;
        }

        .bitacora-libro-select label {
            display: block;
            font-size: 12px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 4px;
        }

        .bitacora-libro-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .bitacora-libro-btn {
            border-radius: 999px;
            padding: 6px 12px;
            border: 1px solid rgba(132, 32, 64, 0.28);
            background: linear-gradient(180deg, rgba(255, 247, 251, 0.95), rgba(246, 233, 242, 0.95));
            color: #6c1231;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .bitacora-libro-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 14px rgba(132, 32, 64, 0.18);
        }

        .bitacora-readonly {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(198, 54, 91, 0.12);
            color: #8a1438;
            border: 1px solid rgba(198, 54, 91, 0.35);
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            letter-spacing: 0.02em;
        }

        .bitacora-resumen {
            font-size: 13px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .bitacora-panel {
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.9);
            padding: 14px;
        }

        .bitacora-panel h3 {
            margin-top: 0;
        }

        .bitacora-form {
            display: grid;
            gap: 10px;
        }

        .bitacora-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bitacora-row > div {
            flex: 1;
            min-width: 140px;
        }

        .bitacora-entry {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .bitacora-entry-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .bitacora-badge {
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(15,7,20,0.06);
        }

        .bitacora-entry-text {
            font-size: 13px;
            color: rgba(26,13,34,0.95);
            line-height: 1.45;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .bitacora-entry-text.is-expanded {
            -webkit-line-clamp: initial;
        }

        .bitacora-entry-links {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 12px;
        }

        .bitacora-entry-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

        .bitacora-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 120px;
        }

        .bitacora-plain {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 14px;
            line-height: 1.55;
            color: #111;
        }

        .bitacora-line {
            white-space: pre-wrap;
        }

        .bitacora-line--header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bitacora-line--ts {
            font-weight: 600;
            color: rgba(20, 8, 24, 0.75);
        }

        .bitacora-line--blank {
            height: 10px;
        }

        .bitacora-delete {
            margin-left: auto;
            background: none;
            border: none;
            padding: 0;
            font-size: 12px;
            font-weight: 600;
            color: #7c1b1b;
            cursor: pointer;
        }

        .bitacora-delete:hover {
            text-decoration: underline;
        }

        .bitacora-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            border: 1px solid rgba(15, 7, 20, 0.15);
        }

        .bitacora-tag--movimiento {
            color: #6e3d12;
            background: rgba(243, 199, 123, 0.25);
            border-color: rgba(243, 199, 123, 0.6);
        }

        .bitacora-tag--medicion {
            color: #3a1a62;
            background: rgba(194, 169, 255, 0.25);
            border-color: rgba(194, 169, 255, 0.65);
        }

        .bitacora-tag--entrada {
            color: #7a2041;
            background: rgba(243, 120, 156, 0.22);
            border-color: rgba(243, 120, 156, 0.65);
        }

        .bitacora-tag--accion {
            color: #2a2a2a;
            background: rgba(255, 255, 255, 0.65);
            border-color: rgba(15, 7, 20, 0.2);
        }

        .bitacora-tag--fermentacion {
            color: #3d1c52;
            background: rgba(155, 93, 229, 0.18);
            border-color: rgba(155, 93, 229, 0.6);
        }

        .bitacora-tag--adicion {
            color: #6a3d0d;
            background: rgba(243, 199, 123, 0.22);
            border-color: rgba(243, 199, 123, 0.6);
        }

        .bitacora-tag--trasvase {
            color: #0f4b4c;
            background: rgba(144, 242, 201, 0.2);
            border-color: rgba(144, 242, 201, 0.7);
        }

        .bitacora-tag--prensado {
            color: #4a2e12;
            background: rgba(255, 215, 156, 0.22);
            border-color: rgba(255, 215, 156, 0.7);
        }

        .bitacora-tag--descube {
            color: #3a2d4d;
            background: rgba(176, 123, 255, 0.18);
            border-color: rgba(176, 123, 255, 0.6);
        }

        .bitacora-tag--madera {
            color: #5a3c22;
            background: rgba(255, 215, 156, 0.22);
            border-color: rgba(255, 215, 156, 0.7);
        }

        .bitacora-tag--coupage {
            color: #0f4b4c;
            background: rgba(144, 242, 201, 0.25);
            border-color: rgba(144, 242, 201, 0.7);
        }

        .bitacora-tag--clarificacion {
            color: #2f3d52;
            background: rgba(176, 196, 255, 0.2);
            border-color: rgba(176, 196, 255, 0.6);
        }

        .bitacora-tag--embotellado {
            color: #0f3f5a;
            background: rgba(126, 226, 255, 0.22);
            border-color: rgba(126, 226, 255, 0.7);
        }

        .bitacora-tag--recuento {
            color: #3c2b2b;
            background: rgba(201, 201, 201, 0.35);
            border-color: rgba(201, 201, 201, 0.8);
        }

        .bitacora-tag--nota {
            color: #3d2d3f;
            background: rgba(220, 214, 222, 0.45);
            border-color: rgba(220, 214, 222, 0.9);
        }

        .bitacora-filters {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .bitacora-filters .bitacora-row {
            gap: 8px;
        }

        .bitacora-filters small {
            color: rgba(40,18,52,0.65);
        }

        .bitacora-footer {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 12px;
        }

        @media (max-width: 1200px) {
            .copiloto-grid-superior {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 980px) {
            .copiloto-grid {
                grid-template-columns: 1fr;
            }

            .copiloto-grid-superior {
                grid-template-columns: 1fr;
            }

            .copiloto-panel.wide {
                grid-column: span 1;
            }

            .copiloto-timeline-wrap {
                grid-template-columns: 1fr;
            }

            .copiloto-timeline-filters {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .bitacora-indomita-layout {
                grid-template-columns: 1fr;
            }

            .bitacora-filters {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 640px) {
            .copiloto-timeline-filters {
                grid-template-columns: 1fr;
            }
        }

        .copiloto-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .copiloto-actions-grid .btnPrimario,
        .copiloto-actions-grid .btnSecundario {
            min-height: 52px;
            padding: 14px 22px;
            font-size: 15px;
        }

        .copiloto-config-wrap {
            margin-top: 12px;
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px dashed rgba(95,44,130,0.2);
            background: rgba(255,255,255,0.6);
        }

        .copiloto-config-wrap summary {
            cursor: pointer;
            font-weight: 700;
            color: rgba(26,13,34,0.85);
            margin-bottom: 8px;
        }

        .copiloto-config {
            display: grid;
            gap: 12px;
            margin-top: 10px;
        }

        .copiloto-config-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .copiloto-config-row-temp {
            grid-template-columns: repeat(3, minmax(160px, 1fr));
        }

        .copiloto-config label {
            font-size: 11px;
        }

        .copiloto-config input {
            margin: 4px 0 0;
        }

        .copiloto-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(255,255,255,0.6);
            font-weight: 600;
            cursor: pointer;
        }

        .cata-section {
            margin-top: 32px;
        }

        .cata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .cata-card {
            background: rgba(255,255,255,0.88);
            border-radius: 20px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 16px 40px rgba(15,7,20,0.12);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cata-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .cata-card-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
        }

        .cata-card-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .cata-card-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .cata-history {
            font-size: 13px;
            color: rgba(26,13,34,0.7);
        }

        .cata-history summary {
            cursor: pointer;
            font-weight: 600;
        }

        .cata-history ul {
            padding-left: 18px;
            margin: 8px 0 0;
        }

        .cata-modal-content {
            max-width: 760px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
            background: rgba(255,255,255,0.95);
            border-radius: 22px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 10px 30px rgba(16,6,28,0.15);
        }

        th, td {
            padding: 13px;
            text-align: left;
        }

        th {
            border-bottom: 1px solid rgba(106,34,77,0.15);
            background: linear-gradient(90deg, rgba(95,44,130,0.15), rgba(241,92,146,0.15));
            font-weight: 600;
            color: var(--vino-oscuro);
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tbody tr:nth-child(even) {
            background: rgba(252,245,255,0.8);
        }

        tbody tr:hover {
            background-color: rgba(241, 92, 146, 0.08);
        }

        input, select {
            width: 100%;
            padding: 12px 14px;
            margin: 6px 0 14px;
            border-radius: 14px;
            border: 1px solid rgba(95,44,130,0.15);
            font-size: 14px;
            background: rgba(255, 255, 255, 0.85);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
            backdrop-filter: blur(4px);
        }

input:focus,
select:focus {
            outline: none;
            border-color: var(--magenta);
            box-shadow: 0 12px 25px rgba(241,92,146,0.2);
            transform: translateY(-1px);
        }

        button {
            padding: 12px 22px;
            border-radius: 14px;
            border: none;
            background: linear-gradient(120deg, #f76fb0, #5f2c82);
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            box-shadow: 0 15px 35px rgba(95, 44, 130, 0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 45px rgba(95, 44, 130, 0.4);
        }

        .small-btn {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 999px;
            background: rgba(95,44,130,0.15);
            color: var(--vino-oscuro);
            border: none;
            font-weight: 600;
            box-shadow: none;
        }

        .btnPrimario {
            width: fit-content;
        }

        .btnSecundario {
            background: transparent;
            color: var(--texto);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
        }

        .btnSecundario:hover {
            border-color: rgba(255, 255, 255, 0.7);
        }

        #herramientas .herramientas-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            margin-top: 14px;
        }

        #herramientas .herramienta-card {
            background: rgba(255, 255, 255, 0.78);
            border: 1px solid rgba(95, 44, 130, 0.12);
            border-radius: 18px;
            padding: 14px;
            box-shadow: 0 10px 24px rgba(18, 8, 30, 0.1);
        }

        #herramientas .herramienta-card h3 {
            margin: 0 0 8px;
            color: var(--vino-oscuro);
        }

        #herramientas .herramienta-row {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            align-items: end;
        }

        #herramientas .herramienta-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 6px;
        }

        #herramientas .herramienta-result {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(95,44,130,0.15);
            background: rgba(255,255,255,0.86);
            font-weight: 700;
            color: #281634;
        }

        #herramientas .herramienta-note {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(40, 18, 52, 0.74);
        }

        #herramientas .herramienta-status {
            min-height: 18px;
            margin-top: 8px;
            font-size: 12px;
            color: #2f7b4c;
            font-weight: 600;
        }

        #herramientas .herramienta-status.error {
            color: #a93d4e;
        }

        .btnActualizar {
            margin-bottom: 8px;
            background: var(--vino-oscuro);
            box-shadow: none;
        }

label {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: rgba(42,15,39,0.65);
}

.mensaje {
    font-size: 13px;
    color: var(--vino);
    min-height: 18px;
    margin-top: 4px;
}

.resaltado {
    animation: destello 1.5s ease;
}

@keyframes destello {
    0% { background-color: rgba(199, 144, 191, 0.3); }
    100% { background-color: transparent; }
}

        .filtros-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0 20px;
            background: rgba(255,255,255,0.65);
            padding: 22px;
            border-radius: 22px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 15px 40px rgba(17,7,30,0.12);
            backdrop-filter: blur(8px);
        }

        .filtros-movimientos > div {
            flex: 1;
            min-width: 160px;
        }

        .acciones-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
        }

        .grid-almacen {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            margin-top: 10px;
        }

        .grid-almacen > div {
            flex: 1;
            min-width: 280px;
        }

        .almacen-vino-stage {
            margin-top: 10px;
            border-radius: 18px;
            border: 1px solid rgba(86, 58, 39, 0.22);
            background:
                radial-gradient(circle at top right, rgba(189, 139, 93, 0.16), transparent 55%),
                linear-gradient(180deg, rgba(255, 249, 241, 0.72), rgba(246, 236, 224, 0.76));
            padding: 16px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 10px 24px rgba(33, 16, 10, 0.08);
        }

        #almacenVino.card {
            width: 100%;
            max-width: none;
        }

        .almacen-estanteria-desktop {
            display: grid;
            gap: 18px;
        }

        .almacen-estanteria-mobile {
            display: none;
        }

        .almacen-estante-row {
            position: relative;
            border-radius: 16px;
            border: 1px solid rgba(93, 64, 45, 0.22);
            background:
                linear-gradient(180deg, rgba(255, 247, 236, 0.78), rgba(235, 220, 201, 0.8));
            padding: 14px 12px 16px;
        }

        .almacen-estante-row::after {
            content: "";
            position: absolute;
            left: 12px;
            right: 12px;
            bottom: 8px;
            height: 10px;
            border-radius: 8px;
            background:
                linear-gradient(90deg, rgba(109, 72, 48, 0.88), rgba(157, 114, 82, 0.86), rgba(103, 69, 48, 0.88));
            box-shadow: 0 2px 8px rgba(52, 30, 18, 0.26);
            pointer-events: none;
        }

        .almacen-estante-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .almacen-estante-title {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(58, 33, 20, 0.84);
        }

        .almacen-estante-count {
            font-size: 12px;
            font-weight: 700;
            color: rgba(58, 33, 20, 0.72);
        }

        .almacen-estante-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
            align-items: stretch;
            gap: 12px;
            padding-bottom: 14px;
            overflow: visible;
        }

        .almacen-estante-items:empty::before {
            content: "Sin lotes en este estado.";
            display: inline-block;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px dashed rgba(93, 64, 45, 0.28);
            color: rgba(58, 33, 20, 0.65);
            font-size: 12px;
            background: rgba(255, 255, 255, 0.45);
        }

        .almacen-lote-crate {
            min-width: 0;
            max-width: none;
            border-radius: 14px;
            border: 1px solid rgba(99, 69, 50, 0.32);
            background:
                linear-gradient(180deg, rgba(73, 45, 36, 0.86), rgba(49, 30, 34, 0.94));
            color: #f7efe7;
            box-shadow: 0 8px 16px rgba(31, 16, 12, 0.22);
            padding: 10px 10px 9px;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 300px;
            grid-template-areas:
                "header stack"
                "vino stack"
                "kpis stack"
                "actions stack";
            gap: 8px 12px;
        }

        .almacen-lote-crate-header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            gap: 8px;
            align-items: center;
        }

        .almacen-lote-id {
            font-weight: 800;
            font-size: 14px;
            letter-spacing: 0.02em;
        }

        .almacen-lote-vino {
            grid-area: vino;
            font-size: 12px;
            color: rgba(244, 231, 220, 0.85);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .almacen-lote-kpis {
            grid-area: kpis;
            display: grid;
            gap: 4px;
            font-size: 12px;
            color: rgba(255, 245, 237, 0.94);
        }

        .almacen-lote-kpi strong {
            color: #fff;
        }

        .almacen-cajas-stack {
            grid-area: stack;
            align-self: stretch;
            align-content: center;
            display: grid;
            grid-template-columns: repeat(10, minmax(0, 1fr));
            gap: 4px;
            padding: 6px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.08);
            min-height: 92px;
        }

        .almacen-caja-chip {
            height: 9px;
            border-radius: 3px;
            background: linear-gradient(180deg, rgba(228, 178, 133, 0.95), rgba(164, 108, 72, 0.95));
            border: 1px solid rgba(80, 48, 27, 0.45);
        }

        .almacen-caja-chip.is-empty {
            background: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.18);
        }

        .almacen-lote-actions {
            grid-area: actions;
            display: inline-flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .almacen-vista-tecnica {
            margin-top: 12px;
            border-radius: 12px;
            border: 1px solid rgba(86, 58, 39, 0.2);
            background: rgba(255, 255, 255, 0.55);
            padding: 2px 8px;
        }

        .almacen-vista-tecnica > summary {
            cursor: pointer;
            font-weight: 700;
            color: rgba(56, 30, 22, 0.9);
            padding: 8px 2px;
        }

        .almacen-traza-btn {
            border-radius: 10px;
            border: 1px solid rgba(79, 17, 109, 0.25);
            background: rgba(255, 255, 255, 0.75);
            color: #2b1a2f;
            font-weight: 600;
            padding: 6px 10px;
            cursor: pointer;
        }

        .almacen-traza-btn:hover {
            border-color: rgba(79, 17, 109, 0.5);
            background: rgba(255, 255, 255, 0.92);
        }

        .almacen-traza-btn.is-active {
            border-color: rgba(79, 17, 109, 0.75);
            background: linear-gradient(135deg, rgba(248, 223, 245, 0.9), rgba(232, 211, 255, 0.9));
        }
        .almacen-lote-actions {
            display: inline-flex;
            gap: 6px;
            align-items: center;
        }
        .almacen-edit-btn {
            border-radius: 10px;
            border: 1px solid rgba(50, 50, 70, 0.22);
            background: rgba(255, 255, 255, 0.72);
            color: #2b1a2f;
            font-weight: 600;
            padding: 6px 10px;
            cursor: pointer;
        }
        .almacen-edit-btn:hover {
            border-color: rgba(50, 50, 70, 0.45);
            background: rgba(255, 255, 255, 0.9);
        }
        .almacen-acciones-rapidas {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 14px;
        }
        .almacen-traza-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr);
            gap: 16px;
            margin-top: 12px;
            align-items: start;
        }
        .almacen-traza-main {
            min-width: 0;
            padding-right: 0;
            border-right: none;
        }
        .almacen-traza-section {
            margin-top: 12px;
        }
        .almacen-traza-section:first-child {
            margin-top: 8px;
        }
        .almacen-traza-section-title {
            font-size: 13px;
            font-weight: 800;
            letter-spacing: 0.01em;
            color: rgba(43, 26, 47, 0.92);
            margin-bottom: 4px;
        }
        .almacen-traza-details {
            margin-top: 10px;
            border-radius: 12px;
            border: 1px solid rgba(47, 31, 59, 0.12);
            background: rgba(255, 255, 255, 0.52);
            padding: 2px 8px;
        }
        .almacen-traza-details > summary {
            cursor: pointer;
            font-weight: 700;
            color: rgba(43, 26, 47, 0.9);
            padding: 8px 2px;
        }
        .almacen-trazabilidad-panel {
            margin-top: 16px;
            border-radius: 16px;
            border: 1px solid rgba(47, 31, 59, 0.14);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.76), rgba(246, 236, 225, 0.66));
            padding: 14px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 8px 20px rgba(32, 18, 10, 0.1);
        }
        @media (max-width: 980px) {
            .almacen-traza-layout {
                grid-template-columns: 1fr;
            }
            .almacen-traza-main {
                padding-right: 0;
                border-right: none;
            }
        }
        .almacen-status-chip {
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            border: 1px solid rgba(255, 255, 255, 0.22);
            background: rgba(255, 255, 255, 0.06);
        }
        .almacen-status-chip.liberado { color: #6fe8a8; border-color: rgba(111, 232, 168, 0.45); }
        .almacen-status-chip.cuarentena { color: #ffd27f; border-color: rgba(255, 210, 127, 0.45); }
        .almacen-status-chip.bloqueado { color: #ff9b9b; border-color: rgba(255, 155, 155, 0.45); }

        @media (max-width: 960px) {
            .almacen-estanteria-desktop {
                display: none;
            }
            .almacen-estanteria-mobile {
                display: grid;
                gap: 10px;
            }
            .almacen-lote-mobile {
                border-radius: 12px;
                border: 1px solid rgba(86, 58, 39, 0.22);
                background: rgba(255, 255, 255, 0.76);
                padding: 10px;
                display: grid;
                gap: 6px;
            }
            .almacen-lote-mobile-head {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 8px;
            }
            .almacen-lote-mobile-name {
                font-weight: 800;
                color: rgba(56, 30, 22, 0.95);
            }
            .almacen-lote-mobile-kpi {
                font-size: 12px;
                color: rgba(56, 30, 22, 0.82);
            }
        }

        @media (max-width: 1240px) {
            .almacen-lote-crate {
                grid-template-columns: minmax(0, 1fr);
                grid-template-areas:
                    "header"
                    "vino"
                    "kpis"
                    "stack"
                    "actions";
            }
            .almacen-cajas-stack {
                min-height: 40px;
                grid-template-columns: repeat(8, minmax(0, 1fr));
            }
        }

        .almacen-modal {
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 16px;
            padding: 0;
            max-width: 520px;
            width: calc(100% - 24px);
            background: rgba(20, 16, 28, 0.92);
            color: #f4eefe;
        }
        .almacen-modal::backdrop {
            background: rgba(0, 0, 0, 0.45);
        }
        .almacen-modal-form {
            display: grid;
            gap: 8px;
            padding: 16px;
        }
        .almacen-modal-form label {
            margin-top: 2px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #cdbfde;
        }
        .almacen-modal-form input,
        .almacen-modal-form select,
        .almacen-modal-form textarea {
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            padding: 8px 10px;
        }
        .almacen-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }

        .plano-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 360px;
            gap: 18px;
            margin-top: 14px;
            align-items: start;
        }

        .plano-editor {
            position: relative;
            border: 1px solid rgba(255,255,255,0.16);
            border-radius: 28px;
            background: linear-gradient(180deg, rgba(8,4,15,0.62), rgba(8,4,15,0.48));
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
                        inset 0 0 50px rgba(0,0,0,0.35);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
        }

        .plano-editor.pan-activo {
            cursor: grab;
        }

        .plano-editor.pan-activo.panning {
            cursor: grabbing;
        }

        .plano-stage {
            position: relative;
            width: 2800px;
            height: 1600px;
            overflow: hidden;
        }

        .plano-canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 2800px;
            height: 1600px;
            transform-origin: 0 0;
            transform: scale(1);
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 24px;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(0deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                radial-gradient(circle at 18% 22%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 82% 70%, rgba(195,169,255,0.10), transparent 60%);
            background-size: 24px 24px, 24px 24px, 120px 120px, 120px 120px, auto, auto;
            background-color: rgba(12,6,22,0.62);
            box-shadow: inset 0 0 32px rgba(0,0,0,0.28);
            backdrop-filter: blur(6px);
        }

        .plano-zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 12px 0 8px;
        }

        .plano-zoom-controls .plano-zoom-btn,
        .plano-zoom-controls .plano-zoom-label {
            border-radius: 12px;
            min-height: 38px;
        }

        .plano-zoom-controls .plano-zoom-btn {
            width: 40px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

        .plano-zoom-controls .plano-zoom-label {
            flex: 1;
            font-weight: 850;
            text-align: center;
            padding: 9px 12px;
        }

        .plano-zoom-range {
            width: 100%;
            margin: 0 0 12px;
        }

        .plano-inspector-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .plano-inspector-actions .btnSecundario,
        .plano-inspector-actions .btnPrimario {
            padding: 9px 12px;
            border-radius: 14px;
            font-size: 12px;
        }

        .plano-item.seleccionado {
            box-shadow:
                0 26px 70px rgba(0,0,0,0.40),
                0 0 0 5px rgba(243,120,156,0.16),
                0 26px 92px var(--plano-card-glow, rgba(195,169,255,0.16));
            transform: translateY(-2px);
            border-color: var(--plano-accent);
        }

        .plano-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.08);
            background:
                radial-gradient(circle at 14% 18%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(195,169,255,0.10), transparent 60%),
                rgba(255,255,255,0.70);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.55);
        }

        .plano-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(47,31,59,0.12) 1px, transparent 1px),
                linear-gradient(90deg, rgba(47,31,59,0.12) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.35;
            pointer-events: none;
        }

        .plano-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .plano-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 14px rgba(0,0,0,0.20);
            border: 1px solid rgba(255,255,255,0.9);
            cursor: pointer;
            z-index: 1;
        }

        .plano-minimap-dot.deposito { background: rgba(79, 88, 104, 0.85); }
        .plano-minimap-dot.mastelone { background: rgba(139, 27, 43, 0.85); }
        .plano-minimap-dot.barrica { background: rgba(196, 138, 27, 0.90); }

        .plano-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.24), 0 0 0 6px rgba(243,120,156,0.14);
        }

        .plano-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(47,31,59,0.55);
            background: rgba(47,31,59,0.08);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.22);
            cursor: grab;
        }

        .plano-minimap-viewport:active {
            cursor: grabbing;
        }

        .plano-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(47,31,59,0.70);
        }

        .flow-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.14);
            background:
                radial-gradient(circle at 14% 18%, rgba(176,123,255,0.18), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(255,142,199,0.16), transparent 60%),
                rgba(12,7,20,0.72);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.30);
            touch-action: none;
        }

        .flow-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.10) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.10) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.28;
            pointer-events: none;
        }

        .flow-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .flow-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 8px 18px rgba(0,0,0,0.30);
            border: 1px solid rgba(255,255,255,0.75);
            cursor: pointer;
            z-index: 1;
        }

        .flow-minimap-dot.entrada { background: var(--flow-accent-entrada); }
        .flow-minimap-dot.fermentacion { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.estilo { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.deposito { background: var(--flow-accent-deposito); }
        .flow-minimap-dot.coupage { background: var(--flow-accent-coupage); }
        .flow-minimap-dot.barrica { background: var(--flow-accent-barrica); }
        .flow-minimap-dot.embotellado { background: var(--flow-accent-embotellado); }
        .flow-minimap-dot.almacen { background: var(--flow-accent-almacen); }
        .flow-minimap-dot.salida { background: var(--flow-accent-salida); }
        .flow-minimap-dot.prensado { background: var(--flow-accent-estilo); }

        .flow-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 12px 22px rgba(0,0,0,0.36), 0 0 0 6px rgba(243,120,156,0.16);
        }

        .flow-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(255,255,255,0.55);
            background: rgba(255,255,255,0.06);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.30);
            cursor: grab;
        }

        .flow-minimap-viewport:active {
            cursor: grabbing;
        }

        .flow-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255,255,255,0.68);
        }

        @media (max-width: 980px) {
            .plano-layout {
                grid-template-columns: 1fr;
            }

            .flow-inspector.plano-inspector {
                position: relative;
                top: auto;
                max-height: none;
            }
        }

.plano-item {
	    position: absolute;
	    width: 148px;
	    height: var(--plano-card-h, 176px);
	    padding: 10px 10px 10px 12px;
	    padding-right: 30px;
	    border-radius: 14px;
	    color: var(--texto);
	    font-size: 12px;
	    cursor: grab;
	    user-select: none;
	    box-shadow:
	      0 22px 54px rgba(6,2,10,0.36),
	      0 28px 92px var(--plano-card-glow, rgba(195,169,255,0.20));
	    transition: box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
	    display: flex;
	    flex-direction: column;
	    gap: 8px;
	    background: var(--plano-card-bg,
	      radial-gradient(circle at 22% 14%, rgba(243,120,156,0.06), transparent 55%),
	      radial-gradient(circle at 82% 78%, rgba(195,169,255,0.06), transparent 60%),
	      linear-gradient(180deg, rgba(255,255,255,0.94), rgba(255,255,255,0.86)));
	    border: 1px solid var(--plano-accent-soft);
	    border-top: 5px solid var(--plano-accent);
	    backdrop-filter: blur(10px) saturate(1.08);
	    align-items: stretch;
	    overflow: hidden;
      touch-action: none;
	    --plano-accent: rgba(143,151,168,0.95);
	    --plano-accent-soft: rgba(143,151,168,0.22);
	    --plano-accent-wash: rgba(143,151,168,0.16);
	    --plano-material: rgba(143,151,168,0.95);
	    --plano-material-wash: rgba(143,151,168,0.16);
}

.plano-item.deposito,
.plano-item.mastelone,
.plano-item.barrica {
      border-top: 0;
      padding-right: 38px;
}

.plano-item.barrica {
      border-radius: 58px / 38px;
      border: 1px solid rgba(88,54,24,0.45);
      background:
        radial-gradient(ellipse at 50% 45%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0.75) 46%, rgba(255,255,255,0) 58%),
        linear-gradient(
          180deg,
          transparent 0%,
          transparent 12%,
          rgba(62,36,16,0.55) 12%,
          rgba(62,36,16,0.55) 16%,
          transparent 16%,
          transparent 70%,
          rgba(62,36,16,0.55) 70%,
          rgba(62,36,16,0.55) 74%,
          transparent 74%,
          transparent 100%
        ),
        repeating-linear-gradient(90deg, rgba(88,54,24,0.20) 0 2px, rgba(255,255,255,0.10) 2px 8px),
        linear-gradient(90deg, #f0d7a2 0%, #c2812e 18%, #f7e4bf 50%, #b06e1d 82%, #f0d7a2 100%);
      box-shadow:
        inset 0 12px 22px rgba(255,255,255,0.16),
        inset 0 -18px 30px rgba(0,0,0,0.16);
}

.plano-item.deposito {
      border-radius: 24px;
      background:
        radial-gradient(ellipse at 50% 44%, rgba(255,255,255,0.88) 0%, rgba(255,255,255,0.88) 60%, rgba(255,255,255,0) 62%),
        radial-gradient(
          ellipse at 50% 7%,
          rgba(255,255,255,0.92) 0%,
          rgba(255,255,255,0.92) 22%,
          rgba(0,0,0,0.10) 23%,
          rgba(0,0,0,0.10) 28%,
          rgba(255,255,255,0) 29%
        ),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.03) 0 1px, rgba(255,255,255,0.06) 1px 3px),
        linear-gradient(
          90deg,
          rgba(255,255,255,0.92) 0%,
          var(--plano-material-wash) 18%,
          rgba(255,255,255,0.97) 50%,
          rgba(0,0,0,0.10) 84%,
          rgba(255,255,255,0.88) 100%
        ),
        linear-gradient(180deg, rgba(255,255,255,0.22), rgba(0,0,0,0.06));
}

.plano-item.mastelone {
      border-radius: 24px 24px 18px 18px;
      background:
        radial-gradient(ellipse at 50% 44%, rgba(255,255,255,0.86) 0%, rgba(255,255,255,0.86) 58%, rgba(255,255,255,0) 60%),
        radial-gradient(ellipse at 50% 11%, rgba(20,8,24,0.38) 0%, rgba(20,8,24,0.38) 18%, rgba(20,8,24,0.0) 19%),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.04) 0 1px, rgba(255,255,255,0.06) 1px 4px),
        linear-gradient(180deg, rgba(255,255,255,0.22), rgba(0,0,0,0.08)),
        linear-gradient(180deg, var(--plano-accent-wash), rgba(0,0,0,0.05));
}

.plano-item.barrica::before,
.plano-item.deposito::before,
.plano-item.mastelone::before {
      opacity: 0.16;
}

.plano-item::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    background:
      radial-gradient(circle at 18% 12%, var(--plano-accent) 0%, transparent 56%),
      radial-gradient(circle at 92% 86%, var(--plano-accent) 0%, transparent 60%),
      radial-gradient(circle at 10% 92%, var(--plano-material) 0%, transparent 56%),
      linear-gradient(180deg, var(--plano-accent-wash) 0%, rgba(255,255,255,0) 52%);
    opacity: 0.28;
    filter: saturate(1.28);
}

.plano-item.barrica::before {
    opacity: 1;
    background:
      radial-gradient(ellipse at 6% 50%, rgba(0,0,0,0.28) 0%, rgba(0,0,0,0.18) 20%, rgba(0,0,0,0.02) 24%, transparent 26%),
      radial-gradient(ellipse at 94% 50%, rgba(0,0,0,0.28) 0%, rgba(0,0,0,0.18) 20%, rgba(0,0,0,0.02) 24%, transparent 26%),
      linear-gradient(180deg, transparent 0%, rgba(255,255,255,0.12) 12%, transparent 22%, transparent 78%, rgba(0,0,0,0.12) 88%, transparent 100%);
    filter: none;
}

.plano-item.barrica::after {
    box-shadow:
      inset 0 0 0 1px rgba(0,0,0,0.18),
      inset 0 -22px 40px rgba(0,0,0,0.14),
      inset 0 8px 12px rgba(255,255,255,0.10);
}

.plano-item::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,0.55),
      inset 0 1px 0 rgba(255,255,255,0.55),
      inset 0 0 0 1px rgba(0,0,0,0.08),
      inset 0 0 0 1px var(--plano-accent-soft),
      inset 0 -26px 44px rgba(0,0,0,0.04),
      inset 0 -24px 46px var(--plano-accent-wash);
    opacity: 0.9;
}

.plano-item:not(.arrastrando):hover {
    transform: translateY(-2px);
    box-shadow:
      0 30px 82px rgba(0,0,0,0.42),
      0 30px 110px var(--plano-card-glow, rgba(195,169,255,0.26));
    border-color: var(--plano-accent-soft);
}

.plano-item.arrastrando {
    opacity: 0.9;
    cursor: grabbing;
    box-shadow: 0 35px 70px rgba(0,0,0,0.45);
}

.plano-card-header {
	    display: flex;
	    flex-direction: column;
	    align-items: flex-start;
	    font-size: 12px;
	    text-transform: none;
	    letter-spacing: 0.02em;
	    font-weight: 850;
	    color: var(--vino-oscuro);
	    text-align: left;
	    gap: 6px;
	    width: 100%;
	    word-break: break-word;
	    position: relative;
	    padding-top: 0;
	    padding-right: 40px;
}

.plano-card-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
}

.plano-card-pct {
      margin-left: auto;
      padding: 2px 8px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.86), rgba(255,255,255,0.60)),
        radial-gradient(circle at 28% 22%, var(--plano-accent-wash), rgba(255,255,255,0));
      border: 1px solid var(--plano-accent-soft);
      box-shadow:
        0 10px 18px rgba(0,0,0,0.10),
        inset 0 1px 0 rgba(255,255,255,0.82);
      color: rgba(18, 12, 28, 0.88);
      font-size: 10px;
      font-weight: 950;
      letter-spacing: 0.02em;
      line-height: 1.2;
      white-space: nowrap;
}

.plano-card-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--plano-wine-dot, var(--plano-accent));
      box-shadow:
        0 10px 20px rgba(0,0,0,0.22),
        0 0 0 3px rgba(255,255,255,0.62);
      flex: 0 0 auto;
}

.plano-card-code {
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.02em;
      color: rgba(18, 12, 28, 0.96);
      white-space: nowrap;
      word-break: normal;
}

.plano-card-header small {
	    font-size: 9px;
	    color: rgba(47,31,59,0.72);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.82), rgba(255,255,255,0.56)),
        radial-gradient(circle at 18% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      border: 1px solid var(--plano-accent-soft);
      white-space: nowrap;
}

.plano-card-material-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--plano-material);
      box-shadow:
        0 8px 14px rgba(0,0,0,0.16),
        0 0 0 2px rgba(255,255,255,0.62);
      flex: 0 0 auto;
}

.plano-card-body {
	    display: flex;
	    flex-direction: column;
	    gap: 10px;
	    width: 100%;
	    flex: 1;
}

.plano-card-visual {
      display: grid;
      grid-template-columns: 1fr;
      align-items: start;
      gap: 8px;
      width: 100%;
}

.plano-card-icon {
      width: 44px;
      height: 60px;
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.75),
        inset 0 -14px 18px rgba(0,0,0,0.08);
      background:
        radial-gradient(circle at 30% 22%, rgba(255,255,255,0.85), transparent 48%),
        linear-gradient(180deg, rgba(255,255,255,0.82), rgba(255,255,255,0.32));
}

.plano-item.barrica .plano-card-icon {
      border-radius: 26px / 18px;
      border: 2px solid rgba(120,74,29,0.55);
      background:
        radial-gradient(circle at 30% 18%, rgba(255,255,255,0.55), transparent 48%),
        repeating-linear-gradient(90deg,
          rgba(88,54,24,0.18) 0 2px,
          rgba(255,255,255,0.10) 2px 4px),
        linear-gradient(90deg, #f0d79b 0%, #c4913f 18%, #f6e2b5 48%, #b47820 78%, #f0d79b 100%);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.16),
        inset 0 10px 14px rgba(255,255,255,0.22),
        inset 0 -16px 20px rgba(0,0,0,0.14);
}

.plano-item.barrica .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 6px;
      right: 6px;
      top: 14px;
      height: 3px;
      border-radius: 999px;
      background: rgba(70,42,18,0.40);
      box-shadow:
        0 14px 0 rgba(70,42,18,0.34),
        0 28px 0 rgba(70,42,18,0.34);
      opacity: 0.95;
}

.plano-item.barrica .plano-card-icon::after {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 78% 18%, rgba(255,255,255,0.55), transparent 44%),
        radial-gradient(circle at 40% 88%, rgba(0,0,0,0.20), transparent 56%);
      opacity: 0.8;
}

.plano-item.deposito .plano-card-icon {
      border-radius: 18px;
      border: 2px solid rgba(86,96,114,0.35);
      background:
        radial-gradient(circle at 52% 60%, rgba(0,0,0,0.14) 0 2px, transparent 3px),
        radial-gradient(circle at 28% 16%, rgba(255,255,255,0.92), transparent 44%),
        linear-gradient(90deg,
          rgba(255,255,255,0.90) 0%,
          var(--plano-material-wash) 18%,
          rgba(255,255,255,0.96) 50%,
          rgba(0,0,0,0.10) 84%,
          rgba(255,255,255,0.86) 100%),
        linear-gradient(180deg, rgba(255,255,255,0.34), rgba(0,0,0,0.06));
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.85),
        inset 0 -16px 20px rgba(0,0,0,0.10);
}

.plano-item.deposito .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 5px;
      right: 5px;
      top: 6px;
      height: 12px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.90), rgba(255,255,255,0.18)),
        radial-gradient(circle at 35% 35%, var(--plano-material-wash), transparent 58%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.95),
        inset 0 -1px 0 rgba(0,0,0,0.12);
      opacity: 0.96;
}

.plano-item.deposito .plano-card-icon::after {
      content: "";
      position: absolute;
      left: 7px;
      right: 7px;
      bottom: 4px;
      height: 16px;
      border-radius: 0 0 18px 18px;
      clip-path: polygon(0 0, 100% 0, 66% 100%, 34% 100%);
      background:
        linear-gradient(90deg,
          rgba(255,255,255,0.90) 0%,
          var(--plano-material-wash) 22%,
          rgba(255,255,255,0.94) 52%,
          rgba(0,0,0,0.12) 86%,
          rgba(255,255,255,0.84) 100%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.85),
        0 10px 18px rgba(0,0,0,0.10);
      opacity: 0.95;
}

.plano-item.mastelone .plano-card-icon {
      border-radius: 18px 18px 16px 16px;
      border: 2px solid rgba(123,27,71,0.38);
      background:
        radial-gradient(circle at 50% 28%, rgba(0,0,0,0.18) 0 8px, transparent 9px),
        radial-gradient(circle at 30% 18%, rgba(255,255,255,0.68), transparent 48%),
        linear-gradient(180deg, var(--plano-accent-wash), rgba(0,0,0,0.04) 54%),
        linear-gradient(180deg, rgba(255,255,255,0.18), rgba(0,0,0,0.10));
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.70),
        inset 0 -16px 20px rgba(0,0,0,0.14);
}

.plano-item.mastelone .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 5px;
      right: 5px;
      top: 6px;
      height: 12px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,255,255,0.12)),
        radial-gradient(circle at 40% 45%, var(--plano-accent-wash), transparent 62%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.78),
        inset 0 -1px 0 rgba(0,0,0,0.16);
      opacity: 0.96;
}

.plano-item.mastelone .plano-card-icon::after {
      content: "";
      position: absolute;
      left: 7px;
      right: 7px;
      top: 11px;
      height: 10px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 50% 50%, rgba(20, 8, 24, 0.75), rgba(20,8,24,0.35));
      opacity: 0.9;
}

.plano-card-barrel {
	    width: 40px;
	    height: 52px;
	    border-radius: 26px / 18px;
	    border: 2px solid rgba(139,92,64,0.4);
	    position: relative;
	    display: flex;
	    align-items: center;
	    justify-content: center;
	    font-weight: 700;
	    flex-shrink: 0;
	    box-shadow: inset 0 -4px 0 rgba(0,0,0,0.08);
}

.plano-card-barrel span {
	    font-size: 11px;
	    letter-spacing: 0.06em;
}

.plano-card-barrel.deposito {
    background: linear-gradient(180deg, #e5e8ee, #b6bdc9);
    color: #3f4653;
    border-color: rgba(111,121,138,0.5);
}

.plano-card-barrel.mastelone {
    background: linear-gradient(180deg, #e9b2c0, #a3223c);
    color: #5a0f1f;
    border-color: rgba(163,34,60,0.55);
}

.plano-card-barrel.barrica {
    background: linear-gradient(180deg, #f3d48b, #c08c32);
    color: #5d3a0f;
    border-color: rgba(184,128,34,0.6);
}

.plano-card-barrel::before,
.plano-card-barrel::after {
    content: "";
    position: absolute;
    left: 7px;
    right: 7px;
    height: 2px;
    background: rgba(0,0,0,0.15);
    border-radius: 999px;
}

.plano-card-barrel::before {
    top: 10px;
}

.plano-card-barrel::after {
    bottom: 10px;
}

.plano-card-info {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    flex: 1;
    text-align: left;
    width: 100%;
}

.plano-card-info small {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: rgba(47,31,59,0.6);
}

.plano-card-info strong {
	    font-size: 11px;
	    font-variant-numeric: tabular-nums;
	    display: block;
	    color: var(--vino-oscuro);
}

.plano-card-extra {
	    font-size: 9px;
	    color: rgba(47,31,59,0.78);
	    text-align: left;
	    width: 100%;
      display: grid;
      gap: 2px;
      margin-top: auto;
}

.plano-card-extra-line {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
}

.plano-card-extra-line.primary {
      white-space: normal;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
}

.plano-card-anada {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--plano-accent-soft);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.86), rgba(255,255,255,0.66)),
        radial-gradient(circle at 22% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      font-size: 9px;
      font-weight: 850;
      letter-spacing: 0.02em;
      color: rgba(47,31,59,0.82);
      width: fit-content;
}

.plano-card-vacio {
      border: 1px solid rgba(0,0,0,0.10);
      box-shadow:
        0 10px 22px rgba(6,2,10,0.14),
        inset 0 1px 0 rgba(255,255,255,0.28);
      margin-top: 2px;
      width: fit-content;
      cursor: default;
}

.plano-card-vacio.estado-vacio {
      background: linear-gradient(180deg, #a9b1bf, #8f97a8);
}

.plano-card-uvas {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: stretch;
      line-height: 1.15;
      margin-top: 2px;
}

.plano-card-uva-chip {
      display: inline-flex;
      align-items: flex-start;
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid var(--plano-accent-soft);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.92), rgba(255,255,255,0.70)),
        radial-gradient(circle at 22% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      color: rgba(18, 12, 28, 0.94);
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.01em;
      width: 100%;
      max-width: 100%;
      white-space: normal;
      overflow: visible;
      text-overflow: initial;
      word-break: break-word;
      line-height: 1.15;
}

.plano-card-progress {
	    position: absolute;
	    top: 10px;
	    right: 8px;
	    width: 18px;
	    height: calc(100% - 20px);
	    background:
	      linear-gradient(180deg, rgba(255,255,255,0.66), rgba(255,255,255,0.34)),
	      radial-gradient(circle at 30% 18%, var(--plano-accent-wash), rgba(255,255,255,0));
	    border-radius: 999px;
	    overflow: hidden;
	    display: flex;
	    align-items: flex-end;
	    justify-content: center;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.70),
        inset 0 0 0 1px var(--plano-accent-soft);
}

.plano-card-progress-bar {
    width: 100%;
    border-radius: 999px;
    transition: height 0.3s ease;
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,0.22),
      inset 0 -10px 18px rgba(0,0,0,0.10);
}

.plano-card-progress span {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%) rotate(-90deg);
      transform-origin: center;
      font-size: 9px;
      font-weight: 950;
      letter-spacing: 0.02em;
      color: rgba(18, 12, 28, 0.80);
      text-shadow: 0 1px 0 rgba(255,255,255,0.70);
      pointer-events: none;
      user-select: none;
}

        #planoMensaje {
            margin-top: 14px;
            color: rgba(255,255,255,0.85);
            font-size: 14px;
        }

	        .plano-placeholder {
	            position: absolute;
	            top: 50%;
	            left: 50%;
	            transform: translate(-50%, -50%);
	            color: rgba(255,255,255,0.7);
	            font-size: 14px;
	        }

	        /* =====================
	           UI Refresh (especial: mapa de nodos)
	        ===================== */
	        :root {
	            --ui-focus: rgba(243,120,156,0.55);
	            --flow-surface: rgba(112, 112, 120, 0.94);
	            --flow-surface-2: rgba(128, 128, 136, 0.96);
	            --flow-border: rgba(255,255,255,0.14);
	            --flow-border-2: rgba(255,255,255,0.22);
	            --flow-text: rgba(255,255,255,0.92);
	            --flow-muted: rgba(255,255,255,0.68);
	            --flow-grid-dot: rgba(255,255,255,0.03);
	            --flow-grid-dot-strong: rgba(255,255,255,0.06);
	            --flow-accent-entrada: #ff8ec7;
	            --flow-accent-estilo: #b07bff;
	            --flow-accent-deposito: #f3c77b;
	            --flow-accent-barrica: #c2a9ff;
	            --flow-accent-coupage: #90f2c9;
	            --flow-accent-embotellado: #7ee2ff;
	            --flow-accent-almacen: #c2c9ff;
	            --flow-accent-salida: #ff7aa8;
	            --c-entrada: #ff2d55;
	            --c-proceso: #7a2cff;
	            --c-deposito: #00e6b8;
	            --c-barrica: #ffc233;
	            --c-embot: #59c6ff;
	            --c-almacen: #b4ff3b;
	            --c-salida: #ff2a2a;
	            --state-fa: #00ff9a;
	            --state-fml: #2ffbff;
	            --state-crianza: #ffc233;
	            --edge-entrada: rgba(255, 172, 207, 0.96);
	            --edge-proceso: rgba(197, 185, 255, 0.96);
	            --edge-deposito: rgba(162, 245, 215, 0.96);
	            --edge-barrica: rgba(255, 224, 165, 0.96);
	            --edge-embot: rgba(165, 228, 255, 0.96);
	            --edge-almacen: rgba(205, 234, 255, 0.96);
	            --edge-salida: rgba(255, 179, 179, 0.96);
	            --edge-vino-red: rgba(255, 156, 184, 0.98);
	            --edge-vino-white: rgba(255, 232, 176, 0.98);
	            --edge-vino-rosado: rgba(255, 194, 210, 0.98);
	            --state-uso: var(--flow-text);
	            --state-vacio: var(--flow-muted);
	        }

	        :focus-visible {
	            outline: 2px solid var(--ui-focus);
	            outline-offset: 3px;
	        }

	        #flujo .flow-toolbar {
	            position: sticky;
	            top: 86px;
	            z-index: 6;
	            display: flex;
	            flex-wrap: wrap;
	            align-items: center;
	            align-content: flex-start;
	            gap: 10px;
	            padding: 14px;
	            border-radius: 22px;
	            background: rgba(255,255,255,0.78);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 18px 45px rgba(0,0,0,0.22);
	            backdrop-filter: blur(14px);
	            overflow: visible;
	        }

	        #flujo .flow-toolbar-group {
	            display: inline-flex;
	            flex-wrap: wrap;
	            align-items: center;
	            gap: 8px;
	            max-width: 100%;
	            padding: 6px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.40);
	            border: 1px solid rgba(0,0,0,0.06);
	            white-space: normal;
	        }

	        #flujo .flow-toolbar-group button {
	            margin-top: 0;
	        }

	        #flujo .flow-toolbar .btnPrimario,
	        #flujo .flow-toolbar .btnSecundario {
	            border-radius: 999px;
	            padding: 10px 14px;
	            min-height: 40px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            gap: 8px;
	            white-space: nowrap;
	        }

	        #flujo .flow-toolbar .btnSecundario {
	            background: rgba(255,255,255,0.55);
	            border-color: rgba(0,0,0,0.10);
	        }

        #flujo .flow-toolbar .btnSecundario:hover {
            border-color: rgba(0,0,0,0.18);
        }

	        #flujo .flow-toolbar .flow-btn-danger {
	            border-color: rgba(196, 45, 45, 0.52);
	            color: rgba(128, 24, 24, 0.96);
	            background: rgba(255, 236, 236, 0.76);
	        }

	        #flujo .flow-toolbar .flow-btn-danger:hover {
	            border-color: rgba(196, 45, 45, 0.72);
	            background: rgba(255, 225, 225, 0.92);
	        }

	        #flujo .flow-zoom-controls {
	            margin-left: 0;
	        }

        .flow-warning-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid rgba(160, 30, 45, 0.35);
            background: rgba(255, 224, 224, 0.85);
            color: rgba(86, 16, 28, 0.92);
            font-weight: 800;
            font-size: 12px;
            cursor: pointer;
        }

        .flow-warning-chip.is-hidden {
            display: none;
        }

        .flow-side {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .flow-warnings-panel {
            display: none;
        }

        .flow-warnings-panel.is-visible {
            display: block;
        }

        .flow-warning-list {
            display: grid;
            gap: 10px;
        }

        .flow-warning-item {
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid rgba(160, 30, 45, 0.18);
            background: rgba(255, 235, 235, 0.9);
            font-size: 12px;
            color: rgba(74, 14, 24, 0.88);
            cursor: pointer;
        }

        .flow-warning-item strong {
            display: block;
            font-size: 12px;
            font-weight: 800;
            margin-bottom: 4px;
        }

        .flow-warning-debug {
            margin-top: 2px;
            font-size: 11px;
            color: rgba(74, 14, 24, 0.7);
            word-break: break-word;
        }

        .flow-warning-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .flow-warning-actions button {
            border: 1px solid rgba(0,0,0,0.08);
            background: rgba(255,255,255,0.8);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .flow-timeline-item {
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid rgba(42, 26, 62, 0.12);
            background: rgba(255,255,255,0.78);
            color: rgba(40, 20, 58, 0.9);
            font-size: 12px;
        }

        .flow-timeline-item strong {
            display: block;
            font-size: 12px;
            font-weight: 800;
            margin-bottom: 4px;
        }

        .flow-timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 6px;
            font-size: 11px;
            color: rgba(40, 20, 58, 0.7);
        }

        .flow-timeline-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .flow-timeline-actions button {
            border: 1px solid rgba(0,0,0,0.08);
            background: rgba(255,255,255,0.85);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .flow-warnings-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: rgba(60, 12, 20, 0.85);
            margin-bottom: 10px;
        }

        .flow-warnings-toggle input {
            width: 36px;
            height: 20px;
            appearance: none;
            background: rgba(0,0,0,0.12);
            border-radius: 999px;
            position: relative;
            outline: none;
            cursor: pointer;
        }

        .flow-warnings-toggle input::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: transform 0.18s ease;
        }

        .flow-warnings-toggle input:checked {
            background: rgba(203, 44, 78, 0.55);
        }

        .flow-warnings-toggle input:checked::after {
            transform: translateX(16px);
        }

        .flow-movement-error {
            margin-top: 6px;
            font-size: 12px;
            color: #a1242f;
        }

        .flow-node.is-warning-highlight {
            box-shadow: 0 0 0 3px rgba(255, 110, 140, 0.55), 0 18px 40px rgba(0,0,0,0.25);
        }

        .flow-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 360px;
	            gap: 18px;
	            margin-top: 14px;
	            align-items: start;
	        }

	        #flujo .flow-helper {
	            margin-top: 16px;
	            padding: 12px 14px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.60);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 14px 35px rgba(0,0,0,0.14);
	        }

	        #flujo .flow-helper p {
	            margin: 0;
	            color: rgba(47,31,59,0.78);
	        }

	        .flow-inspector {
	            position: sticky;
	            top: 126px;
	            max-height: calc(100vh - 156px);
	            overflow: auto;
	            margin-top: 0;
	            border-radius: 24px;
	            padding: 16px;
	            background: rgba(255,255,255,0.88);
	            border: 1px solid rgba(255,255,255,0.65);
	            box-shadow: 0 22px 60px rgba(11, 5, 21, 0.22);
	        }

	        .flow-inspector .flow-inspector-header {
	            display: flex;
	            gap: 12px;
	            align-items: center;
	            margin-bottom: 14px;
	        }

	        .flow-inspector .flow-inspector-icon {
	            width: 44px;
	            height: 44px;
	            border-radius: 16px;
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            background: radial-gradient(circle at 25% 20%, rgba(255, 230, 180, 0.6), transparent 45%),
	                        linear-gradient(135deg, rgba(243,199,123,0.85), rgba(243,120,156,0.75), rgba(155,93,229,0.75));
	            box-shadow: 0 18px 40px rgba(0,0,0,0.2);
	            color: #140818;
	            font-weight: 900;
	        }

	        .flow-inspector .flow-inspector-title {
	            font-weight: 800;
	            font-size: 14px;
	            color: var(--vino-oscuro);
	            letter-spacing: 0.02em;
	        }

	        .flow-inspector .flow-inspector-sub {
	            margin-top: 2px;
	            font-size: 12px;
	            color: rgba(47,31,59,0.68);
	        }

	        .flow-inspector .flow-inspector-tags {
	            display: flex;
	            flex-wrap: wrap;
	            gap: 8px;
	            margin: 10px 0 14px;
	        }

	        .flow-inspector .flow-tag {
	            display: inline-flex;
	            align-items: center;
	            padding: 6px 10px;
	            border-radius: 999px;
	            border: 1px solid rgba(0,0,0,0.08);
	            background: rgba(255,255,255,0.65);
	            font-size: 11px;
	            font-weight: 700;
	            letter-spacing: 0.02em;
	            color: rgba(47,31,59,0.82);
	        }

	        .flow-inspector .flow-tag.warn {
	            border-color: rgba(155,86,20,0.35);
	            background: rgba(255,237,214,0.9);
	            color: rgba(103,56,14,0.95);
	        }

	        .flow-inspector .flow-inspector-fields {
	            display: grid;
	            gap: 10px;
	            margin: 0;
	        }

	        .flow-inspector .flow-field {
	            display: grid;
	            grid-template-columns: 1fr 1fr;
	            gap: 10px;
	            padding: 10px 12px;
	            border-radius: 16px;
	            background: rgba(255,255,255,0.68);
	            border: 1px solid rgba(0,0,0,0.06);
	        }

	        .flow-inspector .flow-field dt {
	            margin: 0;
	            font-size: 11px;
	            font-weight: 800;
	            text-transform: uppercase;
	            letter-spacing: 0.09em;
	            color: rgba(47,31,59,0.55);
	        }

		        .flow-inspector .flow-field dd {
		            margin: 0;
		            font-size: 12px;
		            font-weight: 650;
		            color: rgba(47,31,59,0.88);
		            text-align: right;
		            display: -webkit-box;
		            -webkit-box-orient: vertical;
		            -webkit-line-clamp: 6;
		            overflow: hidden;
		            white-space: pre-line;
		            word-break: break-word;
		        }

	        #flujo .flow-editor {
	            border: 1px solid rgba(255,255,255,0.16);
	            border-radius: 28px;
	            background: linear-gradient(180deg, rgba(118,116,124,0.92), rgba(104,102,110,0.82));
	            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
	                        inset 0 0 50px rgba(0,0,0,0.35);
	            overflow: auto;
	        }

	        #flujo .flow-stage {
	            min-width: 1400px;
	        }

	        #flujo .flow-world {
	            background-color: var(--flow-surface);
	            background-image:
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot) 1.25px, transparent 0),
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot-strong) 1.35px, transparent 0),
	                radial-gradient(circle at 18% 18%, rgba(243,120,156,0.04), transparent 50%),
	                radial-gradient(circle at 70% 10%, rgba(195,169,255,0.04), transparent 55%),
	                radial-gradient(circle at 82% 72%, rgba(243,199,123,0.03), transparent 55%);
	            background-size: 28px 28px, 112px 112px, auto, auto, auto;
	            background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
	        }

	        #flujo .flow-canvas {
	            background: transparent;
	            z-index: 2;
	        }

	        #flowCanvas[data-mode="connecting"] {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node:not([data-state="compact"]):not(.is-connect-source):hover {
	            border-color: rgba(116,245,162,0.55);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45), 0 0 0 6px rgba(116,245,162,0.10);
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node[data-state="compact"]:not(.is-connect-source):hover {
	            border-color: rgba(116,245,162,0.4);
	        }

	        #flujo .flow-edge {
	            pointer-events: visibleStroke;
	            --edge-color: rgba(255,255,255,0.78);
	        }

	        #flujo .flow-connector-outline {
	            stroke: color-mix(in srgb, var(--edge-color) 52%, rgba(255,255,255,0.45));
	            stroke-width: 4.4;
	            stroke-opacity: 0.38;
	            stroke-linecap: round;
	            stroke-linejoin: round;
	            fill: none;
	            pointer-events: none;
	            transition: stroke-opacity 140ms ease, stroke-width 140ms ease;
	        }

	        #flujo .flow-connector-line {
	            stroke: var(--edge-color);
	            stroke-width: 2.5;
	            stroke-opacity: 0.88;
	            stroke-linecap: round;
	            stroke-linejoin: round;
	            filter: none;
	            mix-blend-mode: normal;
	            pointer-events: none;
	            transition: stroke 140ms ease, stroke-width 140ms ease, stroke-opacity 140ms ease;
	        }

	        #flujo .flow-edge[data-kind="entrada"] { --edge-color: var(--edge-entrada); }
	        #flujo .flow-edge[data-kind="proceso"] { --edge-color: var(--edge-proceso); }
	        #flujo .flow-edge[data-kind="deposito"] { --edge-color: var(--edge-deposito); }
	        #flujo .flow-edge[data-kind="barrica"] { --edge-color: var(--edge-barrica); }
	        #flujo .flow-edge[data-kind="embotellado"] { --edge-color: var(--edge-embot); }
	        #flujo .flow-edge[data-kind="almacen"] { --edge-color: var(--edge-almacen); }
	        #flujo .flow-edge[data-kind="salida"] { --edge-color: var(--edge-salida); }

	        #flujo .flow-edge[data-variety="garnacha"] { --edge-color: var(--edge-entrada); }
	        #flujo .flow-edge[data-variety="tempranillo"] { --edge-color: var(--edge-proceso); }
	        #flujo .flow-edge[data-variety="tinto-fino"] { --edge-color: var(--edge-proceso); }
	        #flujo .flow-edge[data-variety="malvar"] { --edge-color: var(--edge-deposito); }
	        #flujo .flow-edge[data-vino="red"] { --edge-color: var(--edge-vino-red); }
	        #flujo .flow-edge[data-vino="white"] { --edge-color: var(--edge-vino-white); }
	        #flujo .flow-edge[data-vino="rosado"] { --edge-color: var(--edge-vino-rosado); }

	        #flujo .flow-edge.is-related .flow-connector-line {
	            stroke-width: 3.2;
	            stroke-opacity: 1;
	            filter: none;
	        }

	        #flujo .flow-edge.is-cap-clipped .flow-connector-line {
	            stroke-width: 3.4;
	            stroke-opacity: 1;
	            stroke-dasharray: 6 4;
	        }

	        #flujo .flow-edge.is-cap-clipped .flow-connector-outline {
	            stroke-opacity: 0.48;
	            stroke-width: 5;
	        }

	        #flujo .flow-edge.is-dim .flow-connector-line {
	            stroke-opacity: 0.22;
	            stroke-width: 1.9;
	            filter: none;
	        }

	        #flujo .flow-edge.is-dim .flow-connector-outline {
	            stroke-opacity: 0.14;
	            stroke-width: 3.8;
	        }

	        #flujo .flow-edge:hover .flow-connector-line,
	        #flujo .flow-edge.is-highlight .flow-connector-line {
	            stroke-width: 3.2;
	            stroke-opacity: 1;
	            filter: none;
	        }

	        #flujo .flow-edge.is-related .flow-connector-outline,
	        #flujo .flow-edge:hover .flow-connector-outline,
	        #flujo .flow-edge.is-highlight .flow-connector-outline {
	            stroke-width: 4.8;
	            stroke-opacity: 0.42;
	        }

	        #flujo .flow-connector-hit {
	            stroke: transparent;
	            stroke-width: 12;
	            fill: none;
	            pointer-events: stroke;
	        }

	        #flujo .flow-connector-label {
	            opacity: 0;
	            transform: translateY(-2px);
	            transition: opacity 140ms ease, transform 140ms ease;
	            transition-delay: 0ms;
	            pointer-events: none;
	        }

	        #flujo .flow-edge:hover .flow-connector-label {
	            opacity: 1;
	            transform: translateY(0);
	            transition-delay: 120ms;
	        }

	        #flujo .flow-edge.is-highlight .flow-connector-label {
	            opacity: 1;
	            transform: translateY(0);
	            transition-delay: 0ms;
	        }

	        #flujo .flow-connector-label text {
	            font-size: 10.5px;
	            font-weight: 600;
	            letter-spacing: 0.01em;
	            fill: rgba(255,255,255,0.7);
	        }

	        #flujo .flow-connector-label rect {
	            fill: rgba(0,0,0,0.18);
	            stroke: rgba(255,255,255,0.06);
	        }

	        #flujo .flow-edge:hover .flow-connector-label rect {
	            stroke: rgba(255,255,255,0.14);
	        }

	        #flujo .flow-edge.is-cap-clipped .flow-connector-label rect {
	            stroke: rgba(255, 210, 132, 0.55);
	        }

	        #flujo .flow-edge[data-vino="red"]:hover .flow-connector-label rect {
	            stroke: color-mix(in srgb, var(--edge-vino-red) 44%, transparent);
	        }

	        #flujo .flow-edge[data-vino="white"]:hover .flow-connector-label rect {
	            stroke: color-mix(in srgb, var(--edge-vino-white) 44%, transparent);
	        }

	        #flujo .flow-edge[data-vino="rosado"]:hover .flow-connector-label rect {
	            stroke: color-mix(in srgb, var(--edge-vino-rosado) 44%, transparent);
	        }

        #flujo .flow-node:not([data-state="compact"]) {
            min-width: 120px;
            padding: 6px 6px 30px;
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(34, 20, 52, 0.92), rgba(19, 10, 30, 0.82));
            border: 1px solid var(--flow-border);
            box-shadow: 0 16px 36px rgba(0,0,0,0.36);
            backdrop-filter: blur(10px);
            color: var(--flow-text);
            text-transform: none;
            letter-spacing: 0.2px;
        }

	        #flujo .flow-node:not([data-state="compact"])::after {
	            content: "";
	            position: absolute;
	            left: 8px;
	            right: 8px;
	            top: 6px;
	            height: 2px;
	            border-radius: 999px;
	            background: var(--flow-accent, rgba(255,255,255,0.25));
	            opacity: 0.95;
	        }

	        #flujo .flow-node[data-tipo="entrada"] { --flow-accent: var(--flow-accent-entrada); }
	        #flujo .flow-node[data-tipo="estilo"] { --flow-accent: var(--flow-accent-estilo); }
	        #flujo .flow-node[data-tipo="deposito"] { --flow-accent: var(--flow-accent-deposito); }
	        #flujo .flow-node[data-tipo="barrica"] { --flow-accent: var(--flow-accent-barrica); }
	        #flujo .flow-node[data-tipo="coupage"] { --flow-accent: var(--flow-accent-coupage); }
	        #flujo .flow-node[data-tipo="embotellado"] { --flow-accent: var(--flow-accent-embotellado); }
	        #flujo .flow-node[data-tipo="almacen"] { --flow-accent: var(--flow-accent-almacen); }
	        #flujo .flow-node[data-tipo="salida"] { --flow-accent: var(--flow-accent-salida); }
	        #flujo .flow-node[data-kind="entrada"] { --node-accent: var(--c-entrada); }
	        #flujo .flow-node[data-kind="proceso"] { --node-accent: var(--c-proceso); }
	        #flujo .flow-node[data-kind="deposito"] { --node-accent: var(--c-deposito); }
	        #flujo .flow-node[data-kind="barrica"] { --node-accent: var(--c-barrica); }
	        #flujo .flow-node[data-kind="embotellado"] { --node-accent: var(--c-embot); }
	        #flujo .flow-node[data-kind="almacen"] { --node-accent: var(--c-almacen); }
	        #flujo .flow-node[data-kind="salida"] { --node-accent: var(--c-salida); }

	        /* Depósitos: matizar el acento según el color real del vino */
	        #flujo .flow-node[data-tipo="deposito"][data-vino="red"] { --flow-accent: #d43c68; }
	        #flujo .flow-node[data-tipo="deposito"][data-vino="rosado"] { --flow-accent: #f58bb5; }

	        #flujo .flow-node:not([data-state="compact"]):hover {
	            border-color: var(--flow-border-2);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45);
	        }

	        #flujo .flow-node:not([data-state="compact"]).is-selected {
	            border-color: rgba(243,120,156,0.55);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(243,120,156,0.12);
	        }

	        #flujo .flow-node:not([data-state="compact"]).is-connect-source {
	            border-color: rgba(195,169,255,0.65);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(195,169,255,0.12);
	        }

	        #flujo .flow-node[data-state="compact"] {
	            min-height: 30px;
	            height: 30px;
	            padding: 0 12px;
	            display: inline-flex;
	            align-items: center;
	            width: max-content;
	            max-width: 260px;
	            border-radius: 10px;
	            --node-accent: var(--flow-accent);
	            background: color-mix(in srgb, var(--node-accent) 22%, rgba(18,18,26,0.86));
	            border: 1px solid rgba(255,255,255,0.12);
	            border-color: color-mix(in srgb, var(--node-accent) 55%, rgba(255,255,255,0.12));
	            box-shadow:
	                0 10px 20px rgba(0,0,0,0.28),
	                0 0 12px color-mix(in srgb, var(--node-accent) 28%, transparent);
	            backdrop-filter: none;
	            color: var(--flow-text);
	            text-transform: none;
	            letter-spacing: 0.01em;
	        }

	        #flujo .flow-node[data-state="compact"]::before {
	            content: none;
	        }

	        #flujo .flow-node[data-state="compact"]::after {
	            content: none;
	        }

	        #flujo .flow-node[data-state="compact"] .flow-node__titleCompact {
	            display: inline-flex;
	            align-items: center;
	            gap: 8px;
	            font-size: 13px;
	            font-weight: 650;
	            letter-spacing: 0.01em;
	            color: var(--flow-text);
	            opacity: 0.92;
	            white-space: nowrap;
	            overflow: hidden;
	            text-overflow: ellipsis;
	            max-width: 260px;
	        }

	        #flujo .flow-node[data-state="compact"][data-role="SOURCE"] .flow-node__titleCompact {
	            opacity: 0.88;
	        }

	        #flujo .flow-node__sep {
	            opacity: 0.45;
	        }

	        #flujo .flow-node__state {
	            font-weight: 700;
	            letter-spacing: 0.02em;
	            font-variant-caps: all-small-caps;
	        }
	        #flujo .flow-node__state[data-state="FA"] {
	            color: var(--state-fa);
	        }
	        #flujo .flow-node__state[data-state="FML"] {
	            color: var(--state-fml);
	        }
	        #flujo .flow-node__state[data-state="CRIANZA"] {
	            color: var(--state-crianza);
	        }
        #flujo .flow-node__state[data-state="USO"] {
            color: var(--state-uso);
        }
        #flujo .flow-node__state[data-state="EN USO"] {
            color: var(--state-uso);
        }
	        #flujo .flow-node__state[data-state="VACIO"] {
	            color: var(--state-vacio);
	            opacity: 0.9;
	        }

	        #flujo .flow-node[data-state="compact"][data-empty="true"] {
	            opacity: 0.62;
	            background: rgba(20,20,28,0.72);
	            box-shadow: none;
	        }

	        #flujo .flow-node[data-state="compact"][data-empty="true"]::before {
	            opacity: 0.4;
	        }

	        #flujo .flow-node[data-state="compact"]:hover {
	            border-color: rgba(255,255,255,0.12);
	            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.14);
	        }

	        #flujo .flow-node[data-state="compact"].is-selected {
	            border-color: rgba(255,255,255,0.2);
	            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.22);
	        }

        #flujo .flow-node[data-state="compact"].is-connect-source {
            border-color: rgba(255,255,255,0.2);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.22);
        }

        #flujo .flow-node.is-related {
            outline: 1px solid rgba(255,255,255,0.18);
            outline-offset: -1px;
        }

        #flujo .flow-node.is-dim {
            opacity: 0.55;
        }

        #flujo .flow-node.is-dim.is-selected,
        #flujo .flow-node.is-dim.is-connect-source {
            opacity: 1;
        }

	        #flujo .flow-node-header {
	            display: flex;
	            align-items: center;
	            gap: 6px;
	            margin: 3px 0 6px;
	        }

	        #flujo .flow-node-icon {
	            width: 20px;
	            height: 20px;
	            border-radius: 10px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            background: rgba(255,255,255,0.10);
	            border: 1px solid rgba(255,255,255,0.12);
	            box-shadow: 0 10px 20px rgba(0,0,0,0.22);
	            font-size: 13px;
	        }

        #flujo .flow-node h4 {
            font-size: 9px;
            margin: 0;
            font-weight: 850;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            text-align: left;
        }

        #flujo .flow-node-body {
            padding-right: 0;
            align-items: flex-start;
            text-align: left;
            gap: 3px;
        }

        #flujo .flow-node-subtitle {
            font-size: 10px;
            color: rgba(255,255,255,0.78);
            text-align: left;
            line-height: 1.25;
            max-width: 100%;
        }
        #flujo .flow-node .flow-entry-variedad {
            font-size: 12.5px;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            margin-bottom: 4px;
            line-height: 1.25;
        }
        #flujo .flow-node .flow-entry-metrics {
            margin-top: 2px;
            margin-bottom: 4px;
        }
        #flujo .flow-node .flow-entry-kilos {
            font-weight: 600;
            color: rgba(255,255,255,0.88);
            margin-top: 6px;
            line-height: 1.25;
        }
        #flujo .flow-node .flow-entry-fecha {
            font-size: 9.5px;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
            line-height: 1.25;
        }
        #flujo .flow-node-subtitle.flow-node-metodo {
            font-weight: 700;
            font-size: 12px;
        }

        #flujo .flow-node-subtitle.flow-subtitle-variedad {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 4;
            overflow: hidden;
            white-space: pre-line;
        }
        #flujo .flow-node[data-tipo="estilo"] .flow-subtitle-variedad {
            -webkit-line-clamp: unset;
            overflow: visible;
            white-space: pre-line;
        }

        #flujo .flow-node .flow-unit {
            padding: 1px 4px;
            border-radius: 999px;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(255,255,255,0.14);
            color: rgba(255,255,255,0.92);
            font-size: 8px;
            letter-spacing: 0.04em;
        }

        #flujo .flow-node .flow-node-controls {
            bottom: 8px;
            right: 8px;
            gap: 5px;
        }

        #flujo .flow-node .flow-node-controls button {
            width: 20px;
            height: 20px;
            border-radius: 9px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.10);
            margin: 0;
            padding: 0;
            box-shadow: 0 10px 18px rgba(0,0,0,0.24);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        #flujo .flow-node .flow-node-controls button:hover {
            transform: translateY(-1px);
            border-color: rgba(255,255,255,0.22);
            box-shadow: 0 18px 34px rgba(0,0,0,0.32);
        }

        #flujo .flow-node .flow-node-controls button::before {
            display: none;
        }

        #flujo .flow-node .flow-node-controls button.blue {
            background: linear-gradient(180deg, rgba(109,168,255,0.30), rgba(109,168,255,0.10));
        }

        #flujo .flow-node .flow-node-controls button.green {
            background: linear-gradient(180deg, rgba(116,245,162,0.26), rgba(116,245,162,0.10));
        }

        #flujo .flow-node .flow-node-controls button.red {
            background: linear-gradient(180deg, rgba(255,122,122,0.28), rgba(255,122,122,0.10));
        }

        #flujo .flow-node .flow-node-controls button.blue::after {
            content: "✎";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.green::after {
            content: "⟶";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.red::after {
            content: "✕";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.menu {
            background: linear-gradient(180deg, rgba(154,165,185,0.28), rgba(154,165,185,0.12));
        }

        #flujo .flow-node .flow-node-controls button.menu::after {
            content: "⋯";
            font-size: 14px;
            color: rgba(255,255,255,0.95);
            line-height: 1;
        }

        #flujo .flow-node .flow-node-controls button.conectando {
            outline: 2px solid rgba(243,120,156,0.55);
            outline-offset: 2px;
        }

        #flujo .flow-node.menu-open {
            overflow: visible;
        }

        #flujo .flow-node .flow-node-menu {
            right: 8px;
            bottom: 36px;
            min-width: 170px;
        }

        #flowModal.flow-modal {
            background: rgba(4, 2, 8, 0.62);
            backdrop-filter: blur(10px);
            padding: 140px 20px 40px;
        }

	        #flowModal .flow-modal-content {
	            border-radius: 24px;
	            border: 1px solid rgba(255,255,255,0.65);
	            background: rgba(255,255,255,0.94);
	            box-shadow: 0 40px 90px rgba(0,0,0,0.55);
	            max-height: calc(100vh - 160px);
	            overflow: auto;
	        }

	        #flowModalTitulo {
	            margin: 4px 0 14px;
	            font-size: 18px;
	            letter-spacing: 0.02em;
	        }

	        #flowModal .flow-modal-content form label {
	            margin-top: 12px;
	            display: block;
	            font-weight: 800;
	            font-size: 12px;
	            letter-spacing: 0.08em;
	            text-transform: uppercase;
	            color: rgba(47,31,59,0.65);
	        }

	        #flowModal .field-required {
	            color: #c03a59;
	            font-weight: 900;
	        }

	        #flowModal .field-inline-error {
	            display: none;
	            margin-top: 4px;
	            font-size: 12px;
	            color: #b42318;
	            font-weight: 600;
	        }

	        #flowModal .field-inline-error.visible {
	            display: block;
	        }

	        #flowModal .flow-modal-content form input,
	        #flowModal .flow-modal-content form textarea,
	        #flowModal .flow-modal-content form select {
	            border-radius: 14px;
	            border: 1px solid rgba(95,44,130,0.18);
	            background: rgba(255,255,255,0.88);
	            transition: border-color 0.2s, box-shadow 0.2s;
	        }

	        #flowModal .flow-modal-content form input:focus,
	        #flowModal .flow-modal-content form textarea:focus,
	        #flowModal .flow-modal-content form select:focus {
	            outline: none;
	            border-color: rgba(243,120,156,0.75);
	            box-shadow: 0 0 0 4px rgba(243,120,156,0.18);
	        }

	        #flowModal .flow-modal-actions {
	            position: sticky;
	            bottom: -10px;
	            background: rgba(255,255,255,0.94);
	            padding: 14px 0 2px;
	            margin-top: 18px;
	            border-top: 1px solid rgba(0,0,0,0.06);
	        }

	        @media (max-width: 1100px) {
	            #flujo .flow-toolbar {
	                position: static;
	                top: auto;
	            }
	            .flow-layout {
	                grid-template-columns: 1fr;
	            }
	            .flow-inspector {
	                position: relative;
	                top: auto;
	                max-height: none;
	            }
	        }

	        @media (prefers-reduced-motion: reduce) {
	            *, *::before, *::after {
	                animation-duration: 0.01ms !important;
	                animation-iteration-count: 1 !important;
	                transition-duration: 0.01ms !important;
	                scroll-behavior: auto !important;
	            }
	        }
	    </style>
	    <style id="modernUiTheme"></style>
    <!-- Librerías para exportar PDF de la tabla de control -->
    <!-- Integridad eliminada por fallo SRI; pendiente fijar hash correcto o self-host -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js" referrerpolicy="no-referrer"></script>
</head>
<script type="module" src="/js/app.js"></script>


<body>
    <div id="appAlerts" class="app-alerts"></div>
    <!-- Top navigation -->
    <div class="topbar">
        <div class="topbar-left">
            <div class="topbar-title">
                <button type="button" id="navToggle">
                    <span class="microbrand">MicroCellerStudio</span>
                    <span class="marca" id="marcaTexto">Bodega VegaLuna</span>
                    <span class="submarca" id="submarcaTexto"></span>
                    <span class="caret">▼</span>
                </button>
                <div class="nav-dropdown-menu" id="navMenu">
                    <a href="#" data-section="bodega" data-keywords="inicio home dashboard bodega copiloto" onclick="cerrarNavMenu(); mostrarSeccion('bodega')">🏠 Copiloto</a>
                    <a href="#" data-section="entradas" data-keywords="uva entrada vendimia kilos" onclick="cerrarNavMenu(); mostrarSeccion('entradas')">🍇 Entradas de uva</a>
                    <a href="#" data-section="depositos" data-keywords="deposito depositos tanque mastelone mastelones" onclick="cerrarNavMenu(); mostrarSeccion('depositos')">🛢 Depósitos</a>
	                    <a href="#" data-section="barricas" data-keywords="barrica barricas crianza madera maderas roble" onclick="cerrarNavMenu(); mostrarSeccion('barricas')" class="nav-barricas-link">
	                        <img src="/barricas.png" alt="Maderas" class="nav-barricas-icon" />
	                        Maderas
	                    </a>
                    <a href="#" data-section="plano" data-keywords="plano mapa bodega ubicacion" onclick="cerrarNavMenu(); mostrarSeccion('plano')">🗺 Plano bodega</a>
                    <a href="#" data-section="flujo" data-keywords="flujo nodos mapa nodos" onclick="cerrarNavMenu(); mostrarSeccion('flujo')">🔗 Mapa de nodos</a>
                    <a href="#" data-section="herramientas" data-keywords="herramientas calculadora enologia metabisulfito conversion" onclick="cerrarNavMenu(); mostrarSeccion('herramientas')">🧮 Herramientas</a>
                    <a href="#" data-section="bitacora" data-keywords="bitacora cuaderno notas diario vino" onclick="cerrarNavMenu(); mostrarSeccion('bitacora')">📕 Bitácora</a>
                    <a href="#" data-section="embotellado" data-keywords="embotellado botellas botella lote" onclick="cerrarNavMenu(); mostrarSeccion('embotellado')">🍾 Embotellado</a>
                    <a href="#" data-section="almacenVino" data-keywords="almacen vino botellas stock" onclick="cerrarNavMenu(); mostrarSeccion('almacenVino')">🍷 Almacén vino</a>
                    <a href="#" data-section="enologicos" data-keywords="enologicos aditivos productos sulfuroso" onclick="cerrarNavMenu(); mostrarSeccion('enologicos')">🧪 Productos enológicos</a>
                    <a href="#" data-section="analiticos" data-keywords="analiticos analitica registros" onclick="cerrarNavMenu(); mostrarSeccion('analiticos')">📊 Registros analíticos</a>
                    <a href="#" data-section="limpieza" data-keywords="limpieza almacen productos limpieza" onclick="cerrarNavMenu(); mostrarSeccion('limpieza')">🧽 Almacén limpieza</a>
                    <a href="#" id="navLogout" data-keywords="logout salir cerrar sesion">🚪 Cerrar sesión</a>
                </div>
            </div>
        </div>
        <div class="topbar-right">
            <div class="topbar-hero" role="group" aria-label="Fecha y añada activa">
                <div class="hero-fecha">
                    <span id="topbarFecha">—</span>
                    <span class="hero-hora" id="topbarHora">—</span>
                </div>
                <span class="hero-sep" aria-hidden="true"></span>
                <div class="hero-anada">
                    <select id="topbarAnada" class="topbar-anada-select" aria-label="Seleccionar añada"></select>
                    <span class="hero-caret" aria-hidden="true">▾</span>
                </div>
            </div>
            <div id="topbarAnadaMsg" class="topbar-hero-msg" aria-live="polite"></div>
            <button type="button" class="user-chip" id="userBadge" title="Usuario activo">—</button>
        </div>
    </div>

    <div id="flowTooltip" class="flow-tooltip" role="tooltip"></div>

    <!-- Contenido principal -->
    <div class="content">

        <!-- SECCIÓN BODEGA (RESUMEN GENERAL) -->
        <section id="bodega" class="card visible">
            <div class="copiloto-shell">
                <div class="copiloto-header">
                    <div class="copiloto-header-main">
                        <div class="copiloto-title-row">
                            <h2 class="copiloto-title"><span class="h1-emoji">🏠</span>Copiloto de bodega</h2>
                        </div>
                        <p class="copiloto-subtitle">Cabina de mando diaria para saber qué está vivo y qué pide atención.</p>
                        <div class="copiloto-chips">
                            <span class="copiloto-chip" id="copilotoFermentaciones">Fermentaciones activas: —</span>
                            <span class="copiloto-chip" id="copilotoCrianza">Contenedores en crianza: —</span>
                            <span class="copiloto-chip" id="copilotoPendientes">0 alertas activas</span>
                            <span class="copiloto-chip" id="copilotoEstado">Estado: calibrando</span>
                            <span class="copiloto-chip" id="copilotoActualizado">Última lectura: —</span>
                        </div>
                    </div>
                    <div class="copiloto-header-side">
                        <div class="copiloto-actions">
                            <button type="button" class="btnSecundario" id="copilotoToggleExpert">Modo experto: OFF</button>
                            <button type="button" class="btnSecundario" id="copilotoToggleNotif">Notificaciones: OFF</button>
                            <button type="button" class="btnPrimario" id="copilotoRefresh">Actualizar ahora</button>
                        </div>
                        <div class="copiloto-header-rules">
                            <details class="copiloto-config-wrap">
                                <summary>Reglas del copiloto</summary>
                                <form id="copilotoConfig" class="copiloto-config">
                                    <div class="copiloto-config-row">
                                        <div>
                                            <label>Horas sin bajar densidad</label>
                                            <input type="number" id="copilotoParadaHoras" min="1" step="1">
                                        </div>
                                        <div>
                                            <label>Delta densidad mínimo</label>
                                            <input type="number" id="copilotoParadaDelta" min="0" step="0.1">
                                        </div>
                                    </div>
                                    <div class="copiloto-config-row copiloto-config-row-temp">
                                        <div>
                                            <label>Temp max tinto (°C)</label>
                                            <input type="number" id="copilotoTempTinto" min="0" step="0.1">
                                        </div>
                                        <div>
                                            <label>Temp max blanco (°C)</label>
                                            <input type="number" id="copilotoTempBlanco" min="0" step="0.1">
                                        </div>
                                        <div>
                                            <label>Temp max rosado (°C)</label>
                                            <input type="number" id="copilotoTempRosado" min="0" step="0.1">
                                        </div>
                                    </div>
                                    <div class="copiloto-config-row">
                                        <div>
                                            <label>Horas sin movimiento</label>
                                            <input type="number" id="copilotoOxidacionHoras" min="1" step="1">
                                        </div>
                                        <div>
                                            <label>Llenado mínimo (%)</label>
                                            <input type="number" id="copilotoOxidacionLlenado" min="10" max="100" step="1">
                                        </div>
                                    </div>
                                    <div class="copiloto-config-row">
                                        <div>
                                            <label>Horas sin analítica</label>
                                            <input type="number" id="copilotoAnaliticaHoras" min="1" step="1">
                                        </div>
                                        <div>
                                            <label>Auto refresco (min)</label>
                                            <input type="number" id="copilotoRefreshMin" min="1" step="1">
                                        </div>
                                    </div>
                                    <button type="button" class="btnSecundario" id="copilotoGuardar">Guardar reglas</button>
                                </form>
                            </details>
                        </div>
                    </div>
                </div>
                <div class="copiloto-grid">
                    <div class="copiloto-grid-superior">
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Lo que está vivo</h3>
                                    <p class="copiloto-panel-sub">Depósitos en fermentación y crianzas activas.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoVivo" class="copiloto-live">
                                    <div class="copiloto-empty">Sin contenedores activos todavía.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Atención / Alertas</h3>
                                    <p class="copiloto-panel-sub">Prioriza lo urgente sin ruido.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoAlertas" class="copiloto-alerts">
                                    <div class="copiloto-empty">Sin alertas todavía.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Acción inmediata</h3>
                                    <p class="copiloto-panel-sub">Lo siguiente que toca hacer ahora.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoTareas" class="copiloto-tareas">
                                    <div class="copiloto-empty">Sin tareas pendientes.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Última actividad</h3>
                                    <p class="copiloto-panel-sub">Últimos eventos de Express, Control y notas.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoActividad" class="copiloto-activity">
                                    <div class="copiloto-empty">Sin actividad reciente.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="copiloto-panel wide copiloto-panel--tools-flat">
                        <div class="copiloto-tools-card" id="copilotoToolsCard">
                            <h4 class="copiloto-tools-title">Herramientas</h4>
                            <div class="copiloto-tools-header">
                                <div class="copiloto-tools-select">
                                    <label for="copilotoToolsContainer">Contenedor</label>
                                    <select id="copilotoToolsContainer" data-tools-container>
                                        <option value="">(Selecciona depósito/barrica)</option>
                                    </select>
                                </div>
                                <div class="copiloto-tools-select">
                                    <label>&nbsp;</label>
                                    <button type="button" class="btnSecundario" id="copilotoToolsAliasBtn">Editar alias</button>
                                </div>
                            </div>
                            <div class="copiloto-tools-alias-editor" id="copilotoToolsAliasEditor" hidden>
                                <input type="text" id="copilotoToolsAliasInput" placeholder="Alias de esta añada (ej. Blanco)">
                                <button type="button" class="btnPrimario" id="copilotoToolsAliasSave">Guardar</button>
                                <button type="button" class="btnSecundario" id="copilotoToolsAliasCancel">Cancelar</button>
                            </div>
                            <div class="copiloto-tool-note">Los depósitos/barricas son activos globales de la bodega. El alias es por añada.</div>
                            <div class="copiloto-tool-note" data-tools-volume>Volumen actual: — L</div>
                            <div class="copiloto-tool-note" data-tools-warning></div>
                            <details class="copiloto-tool-module">
                                <summary>Analítica actual (opcional)</summary>
                                <div class="copiloto-tool-body copiloto-tools-analytics" data-tools-analytics>
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>SO₂ libre (mg/L)</label>
                                            <input type="text" inputmode="decimal" data-ana-so2_libre placeholder="Ej. 18">
                                        </div>
                                        <div>
                                            <label>pH</label>
                                            <input type="text" inputmode="decimal" data-ana-ph placeholder="Ej. 3,20">
                                        </div>
                                    </div>
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>TA (g/L)</label>
                                            <input type="text" inputmode="decimal" data-ana-ta placeholder="Ej. 5,2">
                                        </div>
                                        <div>
                                            <label>Temp (°C)</label>
                                            <input type="text" inputmode="decimal" data-ana-temp placeholder="Ej. 16">
                                        </div>
                                    </div>
                                    <div>
                                        <label>Densidad</label>
                                        <input type="text" inputmode="decimal" data-ana-densidad placeholder="Ej. 1010">
                                    </div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Sulfitado (objetivo SO₂ libre)</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-seg" data-sulf-producto>
                                        <button type="button" class="btnSecundario" data-producto="mosto" aria-pressed="false">Mosto</button>
                                        <button type="button" class="btnSecundario" data-producto="vino" aria-pressed="true">Vino</button>
                                    </div>
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>Objetivo SO₂ libre (mg/L)</label>
                                            <input type="text" inputmode="decimal" data-sulf-objetivo value="30">
                                        </div>
                                        <div>
                                            <label>SO₂ libre actual (mg/L)</label>
                                            <input type="text" inputmode="decimal" data-sulf-actual placeholder="Obligatorio">
                                        </div>
                                    </div>
                                    <label class="copiloto-tool-check"><input type="checkbox" data-sulf-fino> Modo fino (usar pH como checklist)</label>
                                    <div data-sulf-ph-wrap hidden>
                                        <label>pH (solo checklist)</label>
                                        <input type="text" inputmode="decimal" data-sulf-ph placeholder="Ej. 3,20">
                                    </div>
                                    <label class="copiloto-tool-check"><input type="checkbox" data-sulf-update-ana> Guardar SO₂ actual en [ANALITICA]</label>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-sulf-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-sulf-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-sulf-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-sulf-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-sulf-note></div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Tartárico (subir TA)</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>Incremento TA (g/L)</label>
                                            <input type="text" inputmode="decimal" data-tart-inc placeholder="Ej. 1,0">
                                        </div>
                                        <div>
                                            <label>TA actual (opcional)</label>
                                            <input type="text" inputmode="decimal" data-tart-actual placeholder="Ej. 4,5">
                                        </div>
                                    </div>
                                    <div>
                                        <label>TA objetivo (opcional)</label>
                                        <input type="text" inputmode="decimal" data-tart-objetivo placeholder="Ej. 5,5">
                                    </div>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-tart-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-tart-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-tart-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-tart-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-tart-note>Aviso: hacer prueba en laboratorio si el ajuste es grande.</div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Nutrientes (levaduras)</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>Producto</label>
                                            <select data-nut-prod></select>
                                        </div>
                                        <div>
                                            <label>Dosis (g/hL)</label>
                                            <input type="text" inputmode="decimal" data-nut-dose>
                                        </div>
                                    </div>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-nut-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-nut-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-nut-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-nut-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-nut-note></div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Bentonita / clarificante</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>Producto</label>
                                            <select data-ben-prod></select>
                                        </div>
                                        <div>
                                            <label>Dosis (g/hL)</label>
                                            <input type="text" inputmode="decimal" data-ben-dose>
                                        </div>
                                    </div>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-ben-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-ben-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-ben-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-ben-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-ben-note></div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Ácido cítrico</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-seg" data-cit-mode>
                                        <button type="button" class="btnSecundario" data-mode="limpieza" aria-pressed="true">Limpieza</button>
                                        <button type="button" class="btnSecundario" data-mode="vino" aria-pressed="false">En vino (avanzado)</button>
                                    </div>
                                    <div data-cit-block="limpieza">
                                        <div class="copiloto-tool-row">
                                            <div>
                                                <label>Concentración (g/L)</label>
                                                <input type="text" inputmode="decimal" data-cit-conc value="5">
                                            </div>
                                            <div>
                                                <label>Litros de solución</label>
                                                <input type="text" inputmode="decimal" data-cit-sol-l placeholder="Ej. 20">
                                            </div>
                                        </div>
                                    </div>
                                    <div data-cit-block="vino" hidden>
                                        <div>
                                            <label>Incremento en vino (g/L)</label>
                                            <input type="text" inputmode="decimal" data-cit-inc placeholder="Ej. 0,3">
                                        </div>
                                        <label class="copiloto-tool-check"><input type="checkbox" data-cit-risk> Entiendo el riesgo de uso en vino</label>
                                    </div>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-cit-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-cit-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-cit-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-cit-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-cit-note></div>
                                </div>
                            </details>
                            <details class="copiloto-tool-module">
                                <summary>Soluciones madre</summary>
                                <div class="copiloto-tool-body">
                                    <div class="copiloto-tool-row">
                                        <div>
                                            <label>Producto</label>
                                            <select data-sol-prod>
                                                <option value="Metabisulfito">Metabisulfito</option>
                                                <option value="Tartárico">Tartárico</option>
                                                <option value="Bentonita">Bentonita</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label>Concentración (g/L)</label>
                                            <input type="text" inputmode="decimal" data-sol-gl placeholder="Ej. 100">
                                        </div>
                                    </div>
                                    <div>
                                        <label>Litros de solución a preparar</label>
                                        <input type="text" inputmode="decimal" data-sol-litros placeholder="Ej. 10">
                                    </div>
                                    <div class="copiloto-tool-actions">
                                        <button type="button" class="btnPrimario" data-sol-calc>Calcular</button>
                                        <button type="button" class="btnSecundario" data-sol-copy>Copiar</button>
                                        <button type="button" class="btnSecundario" data-sol-save>Guardar en notas</button>
                                    </div>
                                    <div class="copiloto-tool-result" data-sol-result>Echar: —</div>
                                    <div class="copiloto-tool-note" data-sol-note></div>
                                </div>
                            </details>
                        </div>
                    </div>
                    <div class="copiloto-panel wide">
                        <div class="copiloto-panel-head">
                            <div>
                                <h3>Notas y actividad</h3>
                                <p class="copiloto-panel-sub">Aquí no hay postureo: queda lo que pasó.</p>
                            </div>
                        </div>
                        <div class="copiloto-timeline-wrap">
                            <div class="copiloto-timeline-side">
                                <div class="copiloto-subpanel">
                                    <h4>Quick Note</h4>
                                    <div class="copiloto-quicknote">
                                        <label>Contenedor</label>
                                        <select id="copilotoNotaContenedor">
                                            <option value="">(Selecciona contenedor)</option>
                                        </select>
                                        <div class="copiloto-note-metrics">
                                            <div class="copiloto-note-metric">
                                                <label for="copilotoNotaDensidad">Densidad</label>
                                                <input id="copilotoNotaDensidad" type="text" inputmode="decimal" placeholder="Ej. 1010">
                                            </div>
                                            <div class="copiloto-note-metric">
                                                <label for="copilotoNotaTemperatura">Temperatura</label>
                                                <input id="copilotoNotaTemperatura" type="text" inputmode="decimal" placeholder="Ej. 16">
                                            </div>
                                        </div>
                                        <label>Nota rápida</label>
                                        <textarea id="copilotoNotaTexto" rows="4" placeholder="Escribe lo que el vino te está diciendo. Sin adornos."></textarea>
                                        <div class="copiloto-note-chips" id="copilotoNotaChips">
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Normal">Normal</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Nariz cerrada">Nariz cerrada</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Reducción">Reducción</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Volátil">Volátil</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Tenso">Tenso</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Fluido">Fluido</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Duda">Duda</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Acción mañana">Acción mañana</button>
                                        </div>
                                        <button type="button" class="btnPrimario" id="copilotoNotaGuardar">Guardar nota</button>
                                        <div class="copiloto-note-status" id="copilotoNotaStatus"></div>
                                    </div>
                                </div>
                                <div class="copiloto-subpanel">
                                    <h4>Actividad reciente</h4>
                                    <div class="copiloto-heatmap-head">
                                        <span id="copilotoHeatmapLabel">Últimos 56 días</span>
                                        <button type="button" class="btnSecundario" id="copilotoHeatmapClear">Quitar filtro</button>
                                    </div>
                                    <div id="copilotoHeatmap" class="copiloto-heatmap"></div>
                                </div>
                            </div>
                            <div>
                                <div class="copiloto-timeline-head">
                                    <div>
                                        <h4>La vida del vino</h4>
                                        <p class="copiloto-timeline-sub">Diario técnico, sin filtros.</p>
                                    </div>
                                    <span id="copilotoTimelineInfo">Últimos eventos</span>
                                </div>
                                <div class="copiloto-timeline-filters">
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineContenedor">Contenedor</label>
                                        <select id="copilotoTimelineContenedor">
                                            <option value="">Todos</option>
                                        </select>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <span>Origen</span>
                                        <div class="copiloto-filter-chips" id="copilotoTimelineOrigen">
                                            <button type="button" class="copiloto-chip is-active" data-origen="todos">Todos</button>
                                            <button type="button" class="copiloto-chip" data-origen="express">Express</button>
                                            <button type="button" class="copiloto-chip" data-origen="control">Control</button>
                                            <button type="button" class="copiloto-chip" data-origen="manual">Manual</button>
                                        </div>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineAccion">Acción</label>
                                        <select id="copilotoTimelineAccion">
                                            <option value="">Todas</option>
                                        </select>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineBuscar">Buscar</label>
                                        <input type="text" id="copilotoTimelineBuscar" placeholder="Buscar en notas, acción o contenedor">
                                    </div>
                                </div>
                                <div id="copilotoTimeline" class="copiloto-timeline">
                                    <div class="copiloto-empty">Sin eventos todavía.</div>
                                </div>
                                <div class="copiloto-card-actions" id="copilotoTimelineFooter" style="display:none;">
                                    <span id="copilotoTimelineCount"></span>
                                    <button type="button" class="btnSecundario" id="copilotoTimelineMas">Cargar más</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-card" style="margin-top:18px;">
                <h2>Gráficos rápidos</h2>
                <div class="chart-grid">
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Kilos de uva</span>
                            <span id="chartKilosValue">0 kg</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartKilosBar"></div>
                        </div>
                        <small>Total registrado en entradas</small>
                    </div>
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Litros en bodega</span>
                            <span id="chartLitrosValue">0 L</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartLitrosBar"></div>
                        </div>
                        <small id="chartLitrosDetalle">Depósitos, mastelones y barricas</small>
                    </div>
                </div>
            </div>

            <div class="indicadores-grid" style="margin-top:20px;">
                <div class="indicador-card">
                    <h4 class="indicador-head">
                        <span class="indicador-label">🛢 Depósitos</span>
                        <span class="indicador-count" id="indicadorDepositosCount">--</span>
                    </h4>
                    <p id="indicadorDepositosPrincipal">--</p>
                    <small id="indicadorDepositosDetalle">Calculando ocupación...</small>
                    <small id="indicadorDepositosExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 class="indicador-head">
                        <span class="indicador-label"><span style="color:#c94458;">🪣</span> Mastelones</span>
                        <span class="indicador-count" id="indicadorMastelonesCount">--</span>
                    </h4>
                    <p id="indicadorMastelonesPrincipal">--</p>
                    <small id="indicadorMastelonesDetalle">Calculando ocupación...</small>
                    <small id="indicadorMastelonesExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 class="indicador-head">
                        <span class="indicador-label">
                            <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                            Barricas
                        </span>
                        <span class="indicador-count" id="indicadorBarricasCount">--</span>
                    </h4>
                    <p id="indicadorBarricasPrincipal">--</p>
                    <small id="indicadorBarricasDetalle">Calculando ocupación...</small>
                    <small id="indicadorBarricasExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 class="indicador-head">
                        <span class="indicador-label">🍾 Embotellado</span>
                        <span class="indicador-count" id="indicadorEmbotelladosCount">--</span>
                    </h4>
                    <p id="indicadorEmbotelladosPrincipal">--</p>
                    <small id="indicadorEmbotelladosDetalle">Sin registros</small>
                </div>
            </div>

            <div class="card" style="margin-top:24px;">
                <h2>Aprovechamiento por añada</h2>
                <p>Relación entre los kilos de uva registrados y los litros actuales por cada añada.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Añada</th>
                            <th>Kilos de uva</th>
                            <th>Litros actuales</th>
                            <th>Aprovechamiento</th>
                        </tr>
                    </thead>
                    <tbody id="tablaAprovechamiento">
                        <tr><td colspan="4">Cargando...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
        <!-- SECCIÓN HERRAMIENTAS -->
        <section id="herramientas" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧮</span>Herramientas</h1>
            <p>Cálculo rápido enológico para trabajo diario. Todo en local.</p>
            <div class="herramientas-grid">
                <article class="herramienta-card">
                    <h3>Metabisulfito potásico</h3>
                    <p style="margin:0 0 10px; font-size:13px; opacity:0.84;">Calcula gramos necesarios para subir SO2 objetivo.</p>
                    <div class="herramienta-row">
                        <div>
                            <label for="herrVolumenL">Volumen (L)</label>
                            <input type="number" id="herrVolumenL" min="0" step="0.01" inputmode="decimal" placeholder="Ej. 1000">
                        </div>
                        <div>
                            <label for="herrDeltaMgL">Incremento objetivo (mg/L)</label>
                            <input type="number" id="herrDeltaMgL" min="0" step="0.01" inputmode="decimal" placeholder="Ej. 10">
                        </div>
                    </div>
                    <div class="herramienta-actions">
                        <button type="button" class="btnPrimario" id="herrCalcularMetaBtn">Calcular</button>
                        <button type="button" class="btnSecundario" id="herrCopiarMetaBtn">Copiar resultado</button>
                    </div>
                    <div class="herramienta-result" id="herrMetaResultado">Resultado: —</div>
                    <div class="herramienta-note">En 1000 L, +1 mg/L ≈ 1,75 g de meta.</div>
                    <div class="herramienta-note">Estimación teórica; el SO2 libre final depende del consumo.</div>
                    <div class="herramienta-status" id="herrMetaStatus"></div>
                </article>

                <article class="herramienta-card">
                    <h3>Conversor rápido</h3>
                    <p style="margin:0 0 10px; font-size:13px; opacity:0.84;">Relación directa: 1 g/hL = 10 mg/L.</p>
                    <div class="herramienta-row">
                        <div>
                            <label for="herrGhlInput">g/hL</label>
                            <input type="number" id="herrGhlInput" min="0" step="0.01" inputmode="decimal" placeholder="Ej. 5">
                        </div>
                        <div>
                            <label for="herrMgLInput">mg/L</label>
                            <input type="number" id="herrMgLInput" min="0" step="0.01" inputmode="decimal" placeholder="Ej. 50">
                        </div>
                    </div>
                    <div class="herramienta-actions">
                        <button type="button" class="btnPrimario" id="herrConvertirGhlBtn">g/hL → mg/L</button>
                        <button type="button" class="btnPrimario" id="herrConvertirMgLBtn">mg/L → g/hL</button>
                    </div>
                    <div class="herramienta-actions">
                        <button type="button" class="btnSecundario" data-ghl-ejemplo="5">Ejemplo: 5 g/hL</button>
                        <button type="button" class="btnSecundario" data-mgl-ejemplo="30">Ejemplo: 30 mg/L</button>
                    </div>
                    <div class="herramienta-result" id="herrConversorResultado">Resultado: —</div>
                    <div class="herramienta-status" id="herrConversorStatus"></div>
                </article>
            </div>
        </section>
        <!-- SECCIÓN FLUJO -->
        <section id="flujo" class="card" style="display:none;">
	            <h1><span class="h1-emoji">🗺</span>Mapa de nodos de vinificación</h1>
	            <p>Diseña visualmente el recorrido de cada partida: arrastra nodos, conéctalos y edita la información con doble clic.</p>
		            <div class="flow-toolbar">
	                <div class="flow-toolbar-group">
	                    <button class="btnPrimario" type="button" onclick="crearNodoManual('entrada')">🍇 Entrada de uva</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('estilo')">⚗️ Elaboración</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('deposito')">🛢 Depósito</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('coupage')">🧪 Coupage / Blend</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('barrica')">
                        <span style="display:inline-flex; align-items:center; gap:6px;">
                          <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                          Crianza
                        </span>
                    </button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('embotellado')">🍾 Embotellado</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('almacen')">📦 Almacén</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('salida')">🚛 Salida</button>
                </div>
	                <div class="flow-toolbar-group">
	                    <button id="flowToggleExpandBtn" class="btnSecundario" type="button" onclick="toggleExpandirTodosFlow()" disabled>Expandir todo</button>
	                </div>
		                <div class="flow-toolbar-group">
		                    <button class="btnSecundario" type="button" onclick="exportarNodosComoImagen()">Exportar imagen</button>
		                </div>
		                <div class="flow-toolbar-group">
		                </div>
	                <div class="flow-toolbar-group">
                        <button id="flowWarningsChip" class="flow-warning-chip is-hidden" type="button" onclick="toggleFlowWarningsPanel()" aria-label="Ver avisos del mapa">
                            ⚠️ <span id="flowWarningsCount">0</span>
                        </button>
                        <button class="btnSecundario" type="button" onclick="toggleFlowTimelinePanel()">Últimos cambios</button>
                        <button class="btnSecundario" type="button" onclick="toggleFlowBackupsPanel()">Restaurar mapa</button>
		                </div>
		                <div class="flow-toolbar-group flow-zoom-controls">
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(-1)" title="Alejar" aria-label="Alejar">−</button>
		                    <button class="btnSecundario flow-zoom-label" id="flowZoomLabel" type="button" onclick="resetZoomMapaFlujo()" title="Reset zoom" aria-label="Reset zoom">100%</button>
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(1)" title="Acercar" aria-label="Acercar">+</button>
		                </div>
	                <div class="flow-toolbar-group">
	                    <button class="btnSecundario flow-btn-danger" type="button" onclick="resetMapaFlujoLocal()">Limpiar mapa</button>
	                </div>
		            </div>
		            <div class="flow-layout">
		                <div class="flow-editor" id="flowEditor">
		                    <div class="flow-stage" id="flowStage">
		                        <div class="flow-world" id="flowWorld">
		                            <svg id="flowConnections" class="flow-connections">
	                                <defs>
	                                    <marker id="arrowHead" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
	                                        <path d="M0,0 L0,6 L6,3 z" fill="rgba(255,255,255,0.7)" />
	                                    </marker>
	                                </defs>
	                                <g id="flowConnectionsLayer"></g>
	                            </svg>
	                            <div id="flowCanvas" class="flow-canvas"></div>
		                        </div>
		                    </div>
		                </div>
		                <div class="flow-side">
                          <aside id="flowNodeInfo" class="flow-node-info flow-inspector">Selecciona un nodo para ver los detalles.</aside>
                          <aside id="flowWarningsPanel" class="flow-node-info flow-inspector flow-warnings-panel">
                              <div class="flow-inspector-header">
                                  <div class="flow-inspector-icon">⚠️</div>
                                  <div>
                                      <div class="flow-inspector-title">Avisos del mapa</div>
                              <div class="flow-inspector-sub">Revisa inconsistencias del ledger.</div>
                          </div>
                      </div>
                              <label class="flow-warnings-toggle">
                                  <input type="checkbox" id="flowWarningsDebugToggle" aria-label="Debug warnings" />
                                  Debug warnings
                              </label>
                              <button class="btnSecundario" type="button" onclick="copiarDiagnosticoFlow()" style="margin-bottom:10px;">Copiar diagnóstico</button>
                              <div id="flowWarningsList" class="flow-warning-list"></div>
                          </aside>
                          <aside id="flowBackupsPanel" class="flow-node-info flow-inspector flow-warnings-panel">
                              <div class="flow-inspector-header">
                                  <div class="flow-inspector-icon">🗂️</div>
                                  <div>
                                      <div class="flow-inspector-title">Restaurar mapa</div>
                                      <div class="flow-inspector-sub">Elige un backup reciente.</div>
                                  </div>
                              </div>
                              <div id="flowBackupsList" class="flow-warning-list"></div>
                          </aside>
                          <aside id="flowTimelinePanel" class="flow-node-info flow-inspector flow-warnings-panel">
                              <div class="flow-inspector-header">
                                  <div class="flow-inspector-icon">🧭</div>
                                  <div>
                                      <div class="flow-inspector-title">Últimos cambios del mapa</div>
                                      <div class="flow-inspector-sub">Quién, cuándo y qué cambió.</div>
                                  </div>
                              </div>
                              <div id="flowTimelineSnapshot" class="flow-inspector-sub" style="margin-bottom:10px;">Snapshot: —</div>
                              <div style="display:flex; gap:8px; margin-bottom:10px;">
                                  <button class="btnSecundario" type="button" onclick="cargarFlowTimelinePanel(true)">Actualizar</button>
                              </div>
                              <div id="flowTimelineList" class="flow-warning-list"></div>
                          </aside>
                        </div>
	            </div>
	            <div class="flow-helper">
	                <p>Doble clic en un nodo para editarlo. Pulsa “Conectar” en un nodo y luego haz clic sobre el destino para crear el hilo. Puedes arrastrar los nodos a cualquier punto del lienzo.</p>
	            </div>

            <div class="chart-card" style="margin-top:18px;">
                <h3 style="margin-top:0;">Demo rápida: arrastra tanques y barricas</h3>
                <p style="margin:6px 0 12px;">Usa el array <code>tanques</code> y esta zona sandbox para probar drag & drop ligero sin tocar el mapa principal.</p>
	                <div id="demoFlowStage" class="demo-flow-stage"></div>
	            </div>
	        </section>
        <div id="flowModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowModalTitulo">Editar nodo</h3>
                <form id="flowModalForm"></form>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarFlowModal()">Cancelar</button>
                    <button type="button" class="btnSecundario" id="flowCleanBtn" onclick="abrirLimpiezaNodoDesdeModal()">Limpieza</button>
                    <button type="button" class="btnSecundario" onclick="eliminarNodoActivo()">Eliminar</button>
                    <button type="button" class="btnPrimario" onclick="guardarNodoDesdeModal()">Guardar</button>
                </div>
            </div>
        </div>
        <div id="flowCleanModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowCleanTitulo">Limpieza de nodo</h3>
                <p id="flowCleanDetalle" style="margin:10px 0 0; font-size:13px; opacity:0.85;"></p>
                <label style="display:flex; align-items:center; gap:8px; margin-top:12px; font-size:13px;">
                    <input type="checkbox" id="flowCleanCheck" />
                    Entiendo que esto deja el contenedor vacío pero mantiene toda la historia en Bitácora.
                </label>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarLimpiezaNodo()">Cancelar</button>
                    <button type="button" class="btnPrimario" id="flowCleanConfirm" onclick="confirmarLimpiezaNodo()" disabled>Confirmar</button>
                </div>
            </div>
        </div>
        <div id="flowMovementModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar movimiento</h3>
                <form id="flowMovementForm">
                    <label for="flowMovementAmount">Cantidad (L)</label>
                    <input type="number" id="flowMovementAmount" step="0.01" min="0" inputmode="decimal" />
                    <div id="flowMovementError" class="flow-movement-error" aria-live="polite"></div>
                </form>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarFlowMovementModal()">Cancelar</button>
                    <button type="button" class="btnPrimario" onclick="guardarMovimientoFlowDesdeModal()">Guardar</button>
                </div>
            </div>
        </div>
        <!-- SECCIÓN ENTRADAS DE UVA -->
        <section id="entradas" class="card entrada-page" style="display:none;">
            <form id="formEntradaUva" class="entrada-form" onsubmit="crearEntradaUva(event)">
                <div class="entrada-block entrada-block--hero">
                    <div class="entrada-block-header">
                        <div>
                            <div class="entrada-block-eyebrow">Cabecera técnica</div>
                            <h1 class="entrada-title"><span class="h1-emoji">🍇</span>Entrada de uva</h1>
                            <div class="entrada-block-subtitle" id="entradaFechaLectura">Fecha —</div>
                        </div>
                        <span class="entrada-chip" id="entradaChipAnada">Vendimia —</span>
                    </div>
                    <div class="entrada-grid entrada-grid-2">
                        <div class="entrada-field">
                            <label>Fecha y hora</label>
                            <input type="datetime-local" id="entradaFecha" required>
                            <input type="hidden" id="entradaAnada">
                        </div>
                        <div id="entradaVariedadWrap" class="entrada-field">
                            <label>Variedad</label>
                            <input type="text" id="entradaVariedad" required>
                        </div>
                    </div>

                    <label class="entrada-check">
                        <input type="checkbox" id="entradaMixto">
                        Remolque mixto
                    </label>

                    <div id="entradaModoKilosWrap" class="entrada-field" style="display:none;">
                        <label>Modo de kilos</label>
                        <select id="entradaModoKilos">
                            <option value="total">Kilos totales</option>
                            <option value="por_variedad">Kilos por variedad</option>
                        </select>
                    </div>

                    <div id="entradaLineasWrap" class="entrada-lineas" style="display:none;">
                        <div id="entradaLineas" style="display:grid; gap:8px;"></div>
                        <button type="button" class="btnSecundario" id="btnEntradaAgregarLinea" style="margin-top:8px;">
                            + Añadir variedad
                        </button>
                        <div id="entradaResumenLineas" style="font-size:12px; opacity:0.7; margin-top:6px;"></div>
                    </div>
                </div>

                <div id="entradaProcedenciaAdmin" class="entrada-block entrada-block--admin">
                    <div class="entrada-block-title">Procedencia · Datos oficiales</div>
                    <div class="entrada-block-subtitle">Información para trazabilidad y administración</div>
                    <div class="entrada-procedencia-grid">
                        <div class="entrada-procedencia-field entrada-procedencia-field--wide">
                            <label>Referencia Catastral <span class="entrada-chip-oficial">OFICIAL</span></label>
                            <input type="text" id="entradaRc" placeholder="20 caracteres" autocomplete="off">
                            <div class="entrada-hint" id="entradaRcAviso"></div>
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Provincia</label>
                            <input type="text" id="entradaProvincia" placeholder="Provincia">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Municipio</label>
                            <input type="text" id="entradaMunicipio" placeholder="Municipio">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Polígono</label>
                            <input type="text" id="entradaPoligono" placeholder="Polígono">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Parcela</label>
                            <input type="text" id="entradaParcelaCat" placeholder="Parcela">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Recinto (opcional)</label>
                            <input type="text" id="entradaRecinto" placeholder="Recinto">
                        </div>
                    </div>

                    <div class="entrada-catastro-actions">
                        <div class="entrada-hint" id="entradaCatastroHint">Faltan datos para abrir Catastro.</div>
                    </div>
                    <div class="entrada-catastro-links">
                        <a id="entradaCatastroLinkRc" href="#" target="_blank" rel="noopener" aria-disabled="true">Abrir enlace RC</a>
                        <a id="entradaCatastroLinkParcela" href="#" target="_blank" rel="noopener" aria-disabled="true">Abrir enlace Parcela</a>
                    </div>

                    <div class="entrada-plantillas">
                        <div class="entrada-plantillas-title">Acciones rápidas</div>
                        <label>Cargar procedencia</label>
                        <select id="entradaPlantillaSelect">
                            <option value="">(Sin plantilla)</option>
                        </select>
                        <div class="entrada-plantillas-actions">
                            <button type="button" class="btnSecundario" id="btnAplicarPlantilla">Cargar procedencia</button>
                            <button type="button" class="btnSecundario" id="btnGuardarPlantilla">Guardar como plantilla</button>
                        </div>
                    </div>
                </div>

                <div class="entrada-block entrada-block--identidad">
                    <div class="entrada-block-title">Identidad del viñedo</div>
                    <div class="entrada-block-subtitle">Información humana y agronómica</div>
                    <div class="entrada-grid entrada-grid-2">
                        <div class="entrada-field">
                            <label>Nombre de parcela (interno)</label>
                            <input type="text" id="entradaParcela" placeholder="Ej: La Ladera, Barranco Norte">
                        </div>
                        <div class="entrada-field">
                            <label>Viticultor / Proveedor</label>
                            <input type="text" id="entradaViticultor" placeholder="Nombre del viticultor o proveedor">
                        </div>
                        <div class="entrada-field">
                            <label>Tipo de suelo</label>
                            <input type="text" id="entradaSuelo" placeholder="Arcilloso, calizo...">
                        </div>
                        <div class="entrada-field">
                            <label>Años de la vid</label>
                            <input type="number" id="entradaAnosVid" min="0" placeholder="Edad aproximada">
                        </div>
                    </div>

                    <details class="entrada-procedencia-extra">
                        <summary>Datos extra de proveedor (opcional)</summary>
                        <label>NIF/CIF</label>
                        <input type="text" id="entradaViticultorNif" placeholder="NIF/CIF">
                        <label>Teléfono</label>
                        <input type="text" id="entradaViticultorTelefono" placeholder="Teléfono">
                        <label>Email</label>
                        <input type="email" id="entradaViticultorEmail" placeholder="email@dominio.com">
                    </details>
                </div>

                <div class="entrada-block entrada-block--fisica">
                    <div class="entrada-block-title">Entrada física de uva</div>
                    <div class="entrada-block-subtitle">Lecturas y cantidades de recepción</div>
                    <div class="entrada-grid entrada-grid-3">
                        <div id="entradaKilosWrap" class="entrada-field">
                            <label>Kilos</label>
                            <input type="number" id="entradaKilos" required>
                        </div>
                        <div id="entradaCajasWrap" class="entrada-field">
                            <label>Cajas</label>
                            <input type="number" id="entradaCajas" min="1" step="1" required>
                        </div>
                        <div id="entradaTipoCajaWrap" class="entrada-field">
                            <label>Tipo de caja</label>
                            <select id="entradaTipoCaja">
                                <option value="">(Opcional)</option>
                                <option value="10">10</option>
                                <option value="12">12</option>
                                <option value="15">15</option>
                                <option value="18">18</option>
                                <option value="Otro">Otro</option>
                            </select>
                        </div>
                    </div>
                    <div class="entrada-grid entrada-grid-4">
                        <div class="entrada-field entrada-lectura">
                            <label>Densidad</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaDensidad" step="0.001" placeholder="1.050">
                                <span class="entrada-unidad">g/mL</span>
                            </div>
                        </div>
                        <div class="entrada-field entrada-lectura">
                            <label>Temperatura</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaTemperatura" step="0.1" placeholder="18.5">
                                <span class="entrada-unidad">°C</span>
                            </div>
                        </div>
                        <div class="entrada-field entrada-lectura">
                            <label>pH</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaPh" step="0.01" placeholder="3.25">
                                <span class="entrada-unidad">pH</span>
                            </div>
                        </div>
                        <div class="entrada-field entrada-lectura">
                            <label>Acidez total</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaAcidezTotal" step="0.01" placeholder="6.20">
                                <span class="entrada-unidad">g/L</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="entrada-block entrada-block--observaciones">
                    <div class="entrada-block-title">Observaciones y resumen</div>
                    <div class="entrada-block-subtitle">Notas y copia para administración</div>
                    <label>Observaciones</label>
                    <textarea id="entradaObservaciones" placeholder="Notas para administración, incidencias, detalles..."></textarea>

                    <details id="entradaResumenAdmin" class="entrada-resumen-admin">
                        <summary>Resumen para Administración</summary>
                        <div class="entrada-resumen-body">
                            <button type="button" class="btnPrimario" id="btnCopiarResumenEntrada">Copiar</button>
                            <textarea id="entradaResumenAdminTexto" readonly></textarea>
                        </div>
                    </details>
                </div>

                <div class="entrada-actions">
                    <button type="submit" class="btnPrimario" id="btnGuardarEntrada">Registrar entrada</button>
                    <button type="button" class="btnSecundario" id="btnCancelarEdicionEntrada" style="display:none;" onclick="cancelarEdicionEntrada()">Cancelar edición</button>
                </div>
                <div class="form-feedback" id="feedbackEntradaUva"></div>
            </form>

            <div class="entrada-historial">
                <h2>Historial</h2>
                <table>
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Fecha</th>
                            <th>Añada</th>
                            <th>Variedad</th>
                            <th>Viticultor</th>
                            <th>Tipo de suelo</th>
                            <th>Parcela (interno)</th>
                            <th>Años de la vid</th>
                            <th>Kilos</th>
                            <th>Cajas</th>
                            <th>Densidad</th>
                            <th>Temp (°C)</th>
                            <th>pH</th>
                            <th>Acidez</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody id="tablaEntradas"></tbody>
                </table>
                <h2 style="margin-top:24px;">Resumen por parcela (interno)</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Parcela</th>
                            <th>Viajes</th>
                            <th>Kilos</th>
                            <th>Última fecha</th>
                            <th>Hora de entrada</th>
                        </tr>
                    </thead>
                    <tbody id="tablaResumenParcelas"></tbody>
                </table>
            </div>
        </section>

        <!-- SECCIÓN DEPÓSITOS -->
        <section id="depositos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🛢</span>Depósitos</h1>
            <p>Registro de depósitos con su capacidad, tipo y material. La variedad y los litros asignados se actualizan automáticamente cuando un nodo se conecta al depósito.</p>

<table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Nombre de depósito</th>
        <th>Capacidad (L)</th>
        <th>Tipo</th>
        <th>Material</th>
        <th>Variedad asignada</th>
        <th>Volumen transferido</th>
        <th>Acciones</th>
        <th>Bitácora</th>
        <th>Borrar</th>
      </tr>
    </thead>
    <tbody id="tablaDepositos"></tbody>
</table>

<h2 style="margin-top:40px;">Nuevo depósito</h2>

<form id="formDeposito" onsubmit="crearDeposito(event)">
  <div style="display:flex; gap:20px; flex-wrap:wrap;">
    <div style="flex:1;">
      <label>Nombre de depósito</label>
      <input type="text" id="depCodigo" required>
    </div>
    <div style="flex:1;">
      <label>Capacidad (L)</label>
      <input type="number" id="depCapacidad" min="0" step="0.1" required>
    </div>
    <div style="flex:1;">
      <label>Tipo</label>
      <select id="depTipo" required>
        <option value="">Selecciona tipo</option>
        <option value="Siempre lleno">Siempre lleno</option>
        <option value="Cerrado">Cerrado</option>
        <option value="Mastelone">Mastelone</option>
        <option value="Ánfora">Ánfora</option>
        <option value="Foudre">Foudre</option>
        <option value="Barrica">Barrica</option>
        <option value="Damajuana">Damajuana</option>
      </select>
    </div>
    <div style="flex:1;">
      <label>Material</label>
      <select id="depMaterial" required>
        <option value="">Selecciona material</option>
        <option value="Inox">Inox</option>
        <option value="Fibra de vidrio">Fibra de vidrio</option>
        <option value="Cemento">Cemento</option>
        <option value="Barro">Barro</option>
        <option value="Madera">Madera</option>
        <option value="Cristal">Cristal</option>
        <option value="Plástico alimentario">Plástico alimentario</option>
      </select>
    </div>
  </div>
  <button type="submit" class="btnPrimario">Crear depósito</button>
  <div class="form-feedback" id="feedbackDepositos"></div>
</form>

            <div class="cata-section">
                <h2>Hoja de cata sensorial</h2>
                <p>Registra la evolución sensorial de cada depósito y deja huella para decidir el próximo paso.</p>
                <div id="cataGrid" class="cata-grid"></div>
            </div>
        </section>

        <div id="modalDeposito" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar depósito</h3>
                <form id="formEditarDeposito" onsubmit="guardarEdicionDeposito(event)">
                    <label>Nombre de depósito</label>
                    <input type="text" id="depCodigoEdit" required>

                    <label>Capacidad (L)</label>
                    <input type="number" id="depCapacidadEdit" min="0" step="0.1" required>

                    <label>Volumen actual (L)</label>
                    <input type="number" id="depVolumenEdit" min="0" step="0.1" required>

                    <label>Tipo</label>
                    <select id="depTipoEdit" required></select>

                    <label>Material</label>
                    <select id="depMaterialEdit" required></select>

                    <label>Estado</label>
                    <select id="depEstadoEdit" required></select>

                    <p style="margin-top:10px; font-size:13px; opacity:0.7;">
                        Variedad asignada: <strong id="depVariedadInfo">—</strong>
                    </p>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalDeposito()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cambios</button>
                    </div>
                    <div class="form-feedback" id="feedbackEditarDeposito"></div>
                </form>
                <div id="bitacoraSlotDeposito" style="margin-top:12px;"></div>
            </div>
        </div>

        <div id="modalCata" class="flow-modal">
            <div class="flow-modal-content cata-modal-content">
                <h3>Hoja de cata sensorial</h3>
                <p id="cataContenedorInfo" style="margin-top:6px; font-size:13px; opacity:0.7;"></p>
                <form id="formCata" onsubmit="guardarCata(event)">
                    <input type="hidden" id="cataTipo">
                    <input type="hidden" id="cataId">

                    <label>Fecha y hora</label>
                    <input type="datetime-local" id="cataFecha" required>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Vista</label>
                            <textarea id="cataVista" rows="2" placeholder="Color, limpidez, brillo..."></textarea>
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Nariz</label>
                            <textarea id="cataNariz" rows="2" placeholder="Aromas, intensidad, evolución..."></textarea>
                        </div>
                    </div>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Boca</label>
                            <textarea id="cataBoca" rows="2" placeholder="Ataque, volumen, tanino, acidez..."></textarea>
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Equilibrio</label>
                            <textarea id="cataEquilibrio" rows="2" placeholder="Equilibrio global, persistencia..."></textarea>
                        </div>
                    </div>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Defectos / alertas</label>
                            <input type="text" id="cataDefectos" placeholder="Oxidación, VA, reducción...">
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Intensidad</label>
                            <select id="cataIntensidad">
                                <option value="">Selecciona intensidad</option>
                                <option value="baja">Baja</option>
                                <option value="media">Media</option>
                                <option value="alta">Alta</option>
                            </select>
                        </div>
                    </div>

                    <label>Nota general</label>
                    <textarea id="cataNota" rows="3" placeholder="Conclusión, próximos pasos, decisiones..."></textarea>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalCata()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cata</button>
                    </div>
                    <div class="form-feedback" id="feedbackCata"></div>
                </form>
            </div>
        </div>
        <div id="modalBarrica" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar barrica</h3>
                <form id="formEditarBarrica" onsubmit="guardarEdicionBarrica(event)">
                    <input type="hidden" id="barEditId">

                    <label>Código</label>
                    <input type="text" id="barEditCodigo" required>

                    <label>Capacidad (L)</label>
                    <input type="number" id="barEditCapacidad" min="1" step="0.1" required>

                    <label>Volumen actual (L)</label>
                    <input type="number" id="barEditVolumen" min="0" step="0.1" required>

                    <label>Tipo de roble</label>
                    <input type="text" id="barEditTipoRoble" placeholder="Francés, americano...">

                    <label>Tostado</label>
                    <input type="text" id="barEditTostado" placeholder="Ligero, medio, fuerte...">

                    <label>Marca</label>
                    <input type="text" id="barEditMarca" placeholder="Tonelería / proveedor">

                    <label>Año barrica</label>
                    <input type="number" id="barEditAnio" min="1900" max="2100" placeholder="2020">

                    <label>Añada</label>
                    <input type="number" id="barEditVinoAnio" min="1900" max="2100" placeholder="2024">

                    <label>Tipo de vino</label>
                    <input type="text" id="barEditVinoTipo" placeholder="Vino tinto, blanco o rosado">

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalBarrica()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cambios</button>
                    </div>
                    <div class="form-feedback" id="feedbackEditarBarrica"></div>
                </form>
            </div>
        </div>
        <div id="modalUsoProducto" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="usoProductoTitulo">Registrar uso</h3>
                <p id="usoProductoInfo" style="margin-top:6px; font-size:13px; opacity:0.75;"></p>
                <form id="formUsoProducto" onsubmit="guardarUsoProducto(event)">
                    <label>Cantidad a usar</label>
                    <input type="number" id="usoProductoCantidad" min="0.01" step="0.01" required>

                    <label>Tipo de destino</label>
                    <select id="usoProductoDestinoTipo" onchange="actualizarOpcionesDestinoUsoProducto()">
                        <option value="">Sin destino</option>
                        <option value="deposito">Depósito</option>
                        <option value="barrica">Barrica</option>
                        <option value="mastelone">Mastelone</option>
                    </select>

                    <label>Contenedor destino</label>
                    <select id="usoProductoDestinoId" disabled>
                        <option value="">Selecciona contenedor</option>
                    </select>

                    <label>Nota (opcional)</label>
                    <input type="text" id="usoProductoNota" placeholder="Motivo / detalle">

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalUsoProducto()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar consumo</button>
                    </div>
                    <div class="form-feedback" id="feedbackUsoProducto"></div>
                </form>
            </div>
        </div>

        <!-- SECCIÓN ALMACÉN LIMPIEZA -->
        <section id="limpieza" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧽</span>Almacén de limpieza</h1>
            <p>Control de stock y consumo de productos de limpieza con trazabilidad por lote.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaLimpieza"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formLimpieza" onsubmit="crearProductoLimpieza(event)">
                        <label>Producto</label>
                        <input type="text" id="limNombre" required>

                        <label>Lote</label>
                        <input type="text" id="limLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="limCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="limUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="limNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN PRODUCTOS ENOLÓGICOS -->
        <section id="enologicos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧪</span>Productos enológicos</h1>
            <p>Registro de aditivos y productos empleados en la elaboración del vino.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEnologicos"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formEnologicos" onsubmit="crearProductoEnologico(event)">
                        <label>Producto</label>
                        <input type="text" id="enoNombre" required>

                        <label>Lote</label>
                        <input type="text" id="enoLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="enoCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="enoUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="enoNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN EMBOTELLADO -->
        <section id="embotellado" class="card" style="display:none;">
            <h1><span class="h1-emoji">🍾</span>Registro de embotellado</h1>
            <p>Documenta cada lote embotellado con trazabilidad completa.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Historial</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Origen</th>
                                <th>Botellas</th>
                                <th>Formatos</th>
                                <th>Lote</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEmbotellados"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar embotellado</h2>
                    <form id="formEmbotellado" onsubmit="crearEmbotellado(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="embFecha">

                        <label>Tipo contenedor</label>
                        <select id="embTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor (ID o código)</label>
                        <input type="text" id="embContenedor" placeholder="Ej. A1 o 3" required>

                        <label>Formato botella (si es único)</label>
                        <select id="embFormato">
                            <option value="Split 0,187 L">Split 0,187 L</option>
                            <option value="Demi 0,375 L">Demi 0,375 L</option>
                            <option value="Borgoña 0,75 L" selected>Borgoña 0,75 L</option>
                            <option value="Bordelesa 0,75 L">Bordelesa 0,75 L</option>
                            <option value="Magnum 1,5 L">Magnum 1,5 L</option>
                            <option value="Doble Magnum 3 L">Doble Magnum 3 L</option>
                            <option value="Jeroboam 3 L">Jeroboam 3 L</option>
                            <option value="Rehoboam 4,5 L">Rehoboam 4,5 L</option>
                            <option value="Methuselah 6 L">Methuselah 6 L</option>
                            <option value="Salmanazar 9 L">Salmanazar 9 L</option>
                            <option value="Balthazar 12 L">Balthazar 12 L</option>
                            <option value="Nebuchadnezzar 15 L">Nebuchadnezzar 15 L</option>
                        </select>

                        <label>Botellas (total)</label>
                        <input type="number" id="embBotellas" min="0" step="1" required>

                        <label>Formatos mixtos (opcional)</label>
                        <div id="embFormatosWrapper" class="tabla-formatos-embotellado"></div>
                        <small id="embFormatosHint" style="display:block; margin-top:6px; color:#666;">Si añades formatos mixtos, el total se calcula solo.</small>

                        <label>Lote embotellado</label>
                        <input type="text" id="embLote" placeholder="Nombre comercial del lote" required>

                        <label>Nota</label>
                        <input type="text" id="embNota">

                        <button class="btnPrimario">Registrar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN ALMACÉN VINO -->
        <section id="almacenVino" class="card" style="display:none;">
            <h1><span class="h1-emoji">🍷</span>Almacén de vino embotellado</h1>
            <p>Vista de estantería por lotes y estado, con trazabilidad completa de entradas y salidas.</p>

            <div class="almacen-vino-stage">
                <h2 style="margin-top:0;">Estantería de lotes</h2>
                <div id="almacenEstanteriaDesktop" class="almacen-estanteria-desktop"></div>
                <div id="almacenEstanteriaMobile" class="almacen-estanteria-mobile"></div>
                <details class="almacen-vista-tecnica">
                    <summary><strong>Vista técnica (tabla)</strong></summary>
                    <table>
                        <thead>
                            <tr>
                                <th>Lote ID</th>
                                <th>Añada</th>
                                <th>Partida / vino</th>
                                <th>Formato</th>
                                <th>Stock</th>
                                <th>Entradas / salidas / mermas</th>
                                <th>Estado</th>
                                <th>Traza / acción</th>
                            </tr>
                        </thead>
                        <tbody id="tablaAlmacenVino"></tbody>
                    </table>
                </details>
            </div>
            <div class="almacen-acciones-rapidas">
                <button type="button" class="small-btn" onclick="abrirModalAccionAlmacen('SALIDA')">Registrar movimiento</button>
            </div>
            <div id="almacenTrazabilidadPanel" class="almacen-trazabilidad-panel">
                Selecciona un lote para ver su trazabilidad (origen de embotellado y movimientos de almacén).
            </div>
            <dialog id="almacenAccionModal" class="almacen-modal">
                <form method="dialog" id="formAlmacenAccionModal" class="almacen-modal-form">
                    <h3 id="almacenAccionTitulo">Registrar movimiento</h3>
                    <label>Lote</label>
                    <select id="almAccLote"></select>
                    <label>Tipo</label>
                    <select id="almAccTipo">
                        <option value="SALIDA">Salida</option>
                        <option value="MERMA">Merma</option>
                        <option value="AJUSTE">Ajuste</option>
                    </select>
                    <label id="almAccBotellasLabel">Botellas</label>
                    <input id="almAccBotellas" type="number" min="1" step="1" placeholder="Ej. 120">
                    <label id="almAccClienteLabel">Cliente (solo salida)</label>
                    <input id="almAccCliente" type="text" placeholder="Cliente / distribuidor">
                    <label>Documento (número, opcional)</label>
                    <input id="almAccDocNumero" type="text" placeholder="Ej. ALB-2026-0012">
                    <label>Tipo documento</label>
                    <select id="almAccDocTipo">
                        <option value="ALBARAN_SALIDA">Albarán salida</option>
                        <option value="FACTURA">Factura</option>
                        <option value="OTRO">Otro</option>
                    </select>
                    <label>Nota / motivo (obligatorio en ajuste)</label>
                    <textarea id="almAccNota" rows="3" placeholder="Comentario o motivo del ajuste"></textarea>
                    <div class="almacen-modal-actions">
                        <button type="button" class="small-btn" onclick="cerrarModalAccionAlmacen()">Cancelar</button>
                        <button type="submit" class="small-btn">Guardar</button>
                    </div>
                </form>
            </dialog>
            <dialog id="almacenEditarLoteModal" class="almacen-modal">
                <form method="dialog" id="formAlmacenEditarLoteModal" class="almacen-modal-form">
                    <h3>Editar lote</h3>
                    <label>Lote</label>
                    <input id="almEditLoteId" type="text" readonly>
                    <label>Nombre del lote</label>
                    <input id="almEditNombre" type="text" placeholder="Nombre del lote">
                    <label>Botellas por caja</label>
                    <select id="almEditCajaUnidades">
                        <option value="3">3 botellas</option>
                        <option value="6">6 botellas</option>
                        <option value="12">12 botellas</option>
                    </select>
                    <div id="almEditStockWrap">
                        <label>Stock actual (botellas)</label>
                        <input id="almEditStock" type="number" min="0" step="1" placeholder="Ej. 120">
                    </div>
                    <p id="almEditAyuda" style="margin:0; font-size:12px; color:#cdbfde;"></p>
                    <div class="almacen-modal-actions">
                        <button type="button" class="small-btn" onclick="cerrarModalEditarLoteAlmacen()">Cancelar</button>
                        <button type="submit" class="small-btn">Guardar</button>
                    </div>
                </form>
            </dialog>
        </section>

        <!-- SECCIÓN PLANO BODEGA -->
        <section id="plano" class="card" style="display:none;">
            <h1><span class="h1-emoji">🗺</span>Plano de la bodega</h1>
            <p>Arrastra para colocar, haz clic para ver el desglose, y usa el zoom para navegar por toda la bodega.</p>

            <div class="plano-layout">
                <div class="plano-editor" id="planoEditor" aria-label="Plano de la bodega (lienzo)">
                    <div class="plano-stage" id="planoStage">
                        <div class="plano-canvas" id="planoCanvas">
                            <div class="plano-placeholder">Añade depósitos, mastelones o barricas para empezar</div>
                        </div>
                    </div>
                </div>
                <aside id="planoInfo" class="flow-inspector plano-inspector">Cargando inspector…</aside>
            </div>
            <p id="planoMensaje">Añade depósitos, mastelones o barricas para empezar.</p>
        </section>
        <!-- SECCIÓN BARRICAS -->
        <section id="barricas" class="card" style="display:none;">
            <h1 style="display:flex; align-items:center; gap:10px;">
                <img src="/barricas.png" alt="Maderas" class="h1-emoji h1-emoji-img">
                Maderas
            </h1>
            <p>Control de maderas y litros dentro.</p>

            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Código</th>
                        <th>Capacidad&nbsp;(L)</th>
                        <th>Roble / tostado</th>
                        <th>Marca</th>
                        <th>Año barrica</th>
                        <th>Añada</th>
                        <th>Tipo de vino</th>
                        <th>Volumen actual (L)</th>
                        <th>Acciones</th>
                        <th>Bitácora</th>
                        <th>Borrar</th>
                    </tr>
                </thead>
                <tbody id="tablaBarricas"></tbody>
            </table>

            <h2 style="margin-top:40px;">Nueva madera</h2>

            <form id="formBarrica" onsubmit="crearBarrica(event)">
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <div style="flex:1;">
                        <label>Código</label>
                        <input type="text" id="barCodigo" required>
                    </div>
                    <div style="flex:1;">
                        <label>Capacidad&nbsp;(L)</label>
                        <input type="number" id="barCapacidad" required>
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de roble</label>
                        <input type="text" id="barTipo" placeholder="Francés, americano…">
                    </div>
                    <div style="flex:1;">
                        <label>Tostado</label>
                        <input type="text" id="barTostado" placeholder="Ligero, medio, fuerte…">
                    </div>
                    <div style="flex:1;">
                        <label>Marca</label>
                        <input type="text" id="barMarca" placeholder="Coperage, proveedor…">
                    </div>
                    <div style="flex:1;">
                        <label>Año</label>
                        <input type="number" id="barAnio" min="1900" max="2100" placeholder="2020">
                    </div>
                    <div style="flex:1;">
                        <label>Añada</label>
                        <input type="number" id="barVinoAnio" min="1900" max="2100" placeholder="2023">
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de vino</label>
                        <select id="barVinoTipo">
                            <option value="">Selecciona</option>
                            <option value="Vino tinto">Vino tinto</option>
                            <option value="Vino blanco">Vino blanco</option>
                            <option value="Vino rosado">Vino rosado / Clarete</option>
                        </select>
                    </div>
                </div>

                <button>Crear barrica</button>
            </form>

            <div class="cata-section">
                <h2>Hoja de cata sensorial</h2>
                <p>Seguimiento sensorial por barrica para anticipar decisiones de crianza.</p>
                <div id="cataGridBarricas" class="cata-grid"></div>
            </div>
        </section>

        <!-- SECCIÓN REGISTROS ANALÍTICOS -->
        <section id="analiticos" class="card" style="display:none;">
            <h1><span class="h1-emoji">📊</span>Registros analíticos</h1>
            <p>Densidad, temperatura, etc. por depósito, mastelone o barrica.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo registro</h2>

                    <form id="formAnalitico" onsubmit="crearRegistroAnalitico(event)">
                        <label>Tipo contenedor</label>
                        <select id="regTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor</label>
                        <input type="text" id="regId" placeholder="Ej. 3 o A1" required>

                        <label>Fecha y hora</label>
                        <input type="datetime-local" id="regFecha" required>

                        <label>Densidad</label>
                        <input type="number" id="regDensidad" step="0.1">

                        <label>Temperatura (°C)</label>
                        <input type="number" id="regTemperatura" step="0.1">

                        <label>Nota sensorial</label>
                        <input type="text" id="regNotaSensorial" placeholder="Ej. frutos rojos, especias">

                        <label>Nota</label>
                        <input type="text" id="regNota">

                        <button>Guardar registro</button>
                        <div id="regMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.2; min-width:260px;">
                    <h2>Historial por contenedor</h2>

                    <div style="display:flex; gap:10px; align-items:flex-end;">
                        <div style="flex:1;">
                            <label>Tipo</label>
                            <select id="histTipo">
                                <option value="deposito">Depósito</option>
                                <option value="mastelone">Mastelone</option>
                                <option value="barrica">Barrica</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label>Contenedor</label>
                            <input type="text" id="histId" placeholder="Ej. 5 o B1">
                        </div>
                        <div>
                            <button class="small-btn" onclick="cargarHistorialAnalitico()">Ver</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Evento</th>
                                <th>Detalle</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaRegistros"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCIÓN BITÁCORA -->
        <section id="bitacora" class="card" style="display:none;">
            <h1 style="margin-top:0;"><span class="h1-emoji">📕</span>Bitácora</h1>
            <div class="bitacora-libro-bar">
                <div class="bitacora-libro-controls">
                    <div class="bitacora-libro-select">
                        <label for="bitacoraLibroSelect">Libro / Añada</label>
                        <select id="bitacoraLibroSelect"></select>
                    </div>
                    <div class="bitacora-libro-actions">
                        <button type="button" class="bitacora-libro-btn" id="bitacoraLibroActiva">Añada activa</button>
                        <button type="button" class="bitacora-libro-btn" id="bitacoraLibroAnterior">Añada anterior</button>
                        <button type="button" class="bitacora-libro-btn" id="bitacoraLibroDescargarPdf">Descargar PDF</button>
                    </div>
                </div>
                <div class="bitacora-libro-meta">
                    <span id="bitacoraSoloLectura" class="bitacora-readonly" style="display:none;"></span>
                </div>
            </div>
            <div id="bitacoraResumen" class="bitacora-resumen"></div>
            <div style="margin-bottom:10px;">
                <label for="bitacoraBuscar">Buscar</label>
                <input type="search" id="bitacoraBuscar" placeholder="Buscar en el texto">
            </div>
            <div id="bitacoraEstado" style="opacity:0.7; font-size:13px; margin-top:6px;"></div>
            <div id="bitacoraTexto" class="bitacora-plain" style="margin-top:12px;"></div>
        </section>

    </div> <!-- fin .content -->

  <script>
// ---- Mostrar secciones del menú lateral ---
function mostrarSeccion(id) {
  const secciones = document.querySelectorAll("section.card, section#bitacora");
  secciones.forEach(sec => {
    const esObjetivo = sec.id === id;
    if (esObjetivo) {
      sec.style.display = "block";
      requestAnimationFrame(() => sec.classList.add("visible"));
      if (id === "plano") {
        requestAnimationFrame(() => {
          inicializarPlanoBodegaUI();
          renderPlano();
        });
      }
      if (id === "flujo") {
        requestAnimationFrame(() => {
          aplicarLayoutFlow({ mantenerCentro: true });
          renderFlowConnections();
          programarActualizacionMinimapFlow();
        });
      }
      if (id === "almacenVino") {
        requestAnimationFrame(() => {
          cargarAlmacenVino();
        });
      }
    } else if (sec.classList.contains("visible")) {
      sec.classList.remove("visible");
      setTimeout(() => {
        sec.style.display = "none";
      }, 250);
    } else {
      sec.style.display = "none";
    }
  });
  const links = document.querySelectorAll("[data-section]");
  links.forEach(link => {
    link.classList.toggle("activo", link.dataset.section === id);
  });
}
let cacheEntradas = [];
let cacheDepositos = [];
let cacheBarricas  = [];
let cacheMastelones = [];
let cacheMovimientos = [];
let cacheLimpieza = [];
let cacheEnologicos = [];
let cacheEmbotellados = [];
let cacheAlmacenVino = [];
let almacenVinoLoteSeleccionado = null;
let cacheAlmacenVinoTrazasVirtuales = new Map();
let almacenAccionTipoActual = "SALIDA";
let almacenLoteEditandoId = null;
let cacheAnalisisLab = [];
let cacheCatas = [];
let depositoEditando = null;
let barricaEditando = null;
let usoProductoContexto = null;
let temporizadorGuardadoFlujo = null;
const RETARDO_GUARDADO_FLUJO = 600;

const COPILOTO_TOOLS_ANALITICA_KEYS = ["so2_libre", "ph", "ta", "temp", "densidad"];
const COPILOTO_TOOLS_NUTRIENTES = [
  { id: "dap", nombre: "DAP", dosis_g_hL: 20, max_g_hL: 30, nota: "Aporta nitrógeno asimilable." },
  { id: "complejo", nombre: "Nutriente complejo", dosis_g_hL: 30, max_g_hL: 40, nota: "Soporte de fermentación." },
];
const COPILOTO_TOOLS_BENTONITA = [
  { id: "bentonita_na", nombre: "Bentonita sódica", dosis_g_hL: 60, max_g_hL: 120, nota: "Hidratación previa recomendada." },
  { id: "proteico", nombre: "Clarificante proteico", dosis_g_hL: 15, max_g_hL: 30, nota: "Ajustar con prueba previa." },
];

const CopilotoToolsCore = {
  toNumberEs(x) {
    if (x == null) return null;
    if (typeof x === "number") return Number.isFinite(x) ? x : null;
    let raw = String(x).trim();
    if (!raw) return null;
    raw = raw.replace(/\s+/g, "");
    if (raw.includes(",") && raw.includes(".")) {
      if (raw.lastIndexOf(",") > raw.lastIndexOf(".")) {
        raw = raw.replace(/\./g, "").replace(",", ".");
      } else {
        raw = raw.replace(/,/g, "");
      }
    } else {
      raw = raw.replace(",", ".");
    }
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  },
  calcMeta(volumeL, deltaMgL) {
    if (!Number.isFinite(volumeL) || !Number.isFinite(deltaMgL) || volumeL <= 0 || deltaMgL <= 0) return null;
    return (volumeL * deltaMgL) / 1000 / 0.57;
  },
  ghL_to_mgL(x) {
    if (!Number.isFinite(x) || x < 0) return null;
    return x * 10;
  },
  mgL_to_ghL(x) {
    if (!Number.isFinite(x) || x < 0) return null;
    return x / 10;
  },
  format1(x) {
    if (!Number.isFinite(x)) return "—";
    return Number(x).toLocaleString("es-ES", { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  },
  formatFechaOperacion(date = new Date()) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    const h = String(date.getHours()).padStart(2, "0");
    const mi = String(date.getMinutes()).padStart(2, "0");
    return `${y}-${m}-${d} ${h}:${mi}`;
  },
  formatG(value, modo = "normal") {
    if (!Number.isFinite(value)) return "—";
    if (modo === "tartarico" && Math.abs(value) >= 50) {
      return Math.round(value).toLocaleString("es-ES", { maximumFractionDigits: 0 });
    }
    return Number(value).toLocaleString("es-ES", { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  },
  getContainerList() {
    // Preferimos la misma fuente del Copiloto (incluye volumen vivo del nodo cuando aplica).
    if (typeof obtenerContenedoresCopiloto === "function") {
      const base = obtenerContenedoresCopiloto();
      if (Array.isArray(base) && base.length) {
        return base
          .map(item => {
            const tipo = (item.tipo || "").toString().toLowerCase();
            const id = Number(item.id);
            const codigo = (item.codigo || "").toString().trim() || `#${id}`;
            const alias = (item.alias || "").toString().trim();
            const volumenRaw = item.volumen ?? item.litros_actuales ?? 0;
            const volumenNum = this.toNumberEs(volumenRaw);
            return {
              key: `${tipo}:${id}`,
              tipo,
              id,
              codigo,
              alias,
              etiqueta: formatContainerLabel({ id, codigo, alias, tipo }, { tipo }),
              volumen_l: Number.isFinite(volumenNum) ? volumenNum : 0,
            };
          })
          .sort((a, b) => a.etiqueta.localeCompare(b.etiqueta, "es", { sensitivity: "base" }));
      }
    }

    const lista = [];
    const add = (tipo, item) => {
      if (!item?.id) return;
      const id = Number(item.id);
      const codigo = (item.codigo || "").toString().trim() || `#${id}`;
      const alias = (item.alias || "").toString().trim();
      const volumenRaw = item.litros_actuales ?? item.volumen ?? 0;
      const volumenNum = this.toNumberEs(volumenRaw);
      lista.push({
        key: `${tipo}:${id}`,
        tipo,
        id,
        codigo,
        alias,
        etiqueta: formatContainerLabel({ id, codigo, alias, tipo }, { tipo }),
        volumen_l: Number.isFinite(volumenNum) ? volumenNum : 0,
      });
    };
    (cacheDepositos || []).forEach(d => add("deposito", d));
    (cacheMastelones || []).forEach(m => add("mastelone", m));
    (cacheBarricas || []).forEach(b => add("barrica", b));
    return lista.sort((a, b) => a.etiqueta.localeCompare(b.etiqueta, "es", { sensitivity: "base" }));
  },
  getContainerVolume(containerKey) {
    const found = this.getContainerList().find(item => item.key === containerKey);
    return found ? found.volumen_l : 0;
  },
  parseAnalyticsFromNotes(notesText) {
    const history = [];
    const raw = (notesText || "").toString();
    const regex = /\[ANALITICA\]([\s\S]*?)\[\/ANALITICA\]/gi;
    let match;
    while ((match = regex.exec(raw))) {
      const block = {};
      const lines = (match[1] || "").split(/\r?\n/);
      lines.forEach(line => {
        const clean = line.trim();
        if (!clean || !clean.includes("=")) return;
        const [kRaw, ...rest] = clean.split("=");
        const key = kRaw.trim().toLowerCase();
        if (!["fecha", ...COPILOTO_TOOLS_ANALITICA_KEYS].includes(key)) return;
        const value = rest.join("=").trim();
        if (key === "fecha") {
          block.fecha = value;
          return;
        }
        const parsed = this.toNumberEs(value);
        if (parsed != null) block[key] = parsed;
      });
      history.push(block);
    }
    return {
      history,
      lastAnalytics: history.length ? history[history.length - 1] : null,
    };
  },
  parseAnalyticsFromNotesList(notas) {
    const lista = Array.isArray(notas) ? notas : [];
    const history = [];
    for (const nota of lista) {
      const parsed = this.parseAnalyticsFromNotes(nota?.texto || "");
      if (Array.isArray(parsed.history) && parsed.history.length) {
        history.push(...parsed.history);
      }
    }
    return {
      history,
      lastAnalytics: history.length ? history[history.length - 1] : null,
    };
  },
  appendOperationToNotes(notesText, opBlock) {
    const base = (notesText || "").toString().trim();
    const op = (opBlock || "").toString().trim();
    if (!op) return base;
    if (!base) return op;
    return `${base}\n\n${op}`;
  },
  async copyToClipboard(text) {
    const value = String(text ?? "").trim();
    if (!value) return false;
    try {
      if (navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(value);
        return true;
      }
    } catch (_err) {}
    try {
      const ta = document.createElement("textarea");
      ta.value = value;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return Boolean(ok);
    } catch (_err) {
      return false;
    }
  },
};

function initCopilotoHerramientas() {
  const root = document.getElementById("copilotoToolsCard");
  if (!root) return;

  const selectCont = root.querySelector("[data-tools-container]");
  const btnAlias = document.getElementById("copilotoToolsAliasBtn");
  const aliasEditor = document.getElementById("copilotoToolsAliasEditor");
  const aliasInput = document.getElementById("copilotoToolsAliasInput");
  const aliasSaveBtn = document.getElementById("copilotoToolsAliasSave");
  const aliasCancelBtn = document.getElementById("copilotoToolsAliasCancel");
  const volumeEl = root.querySelector("[data-tools-volume]");
  const warnEl = root.querySelector("[data-tools-warning]");
  const anaInputs = {
    so2_libre: root.querySelector("[data-ana-so2_libre]"),
    ph: root.querySelector("[data-ana-ph]"),
    ta: root.querySelector("[data-ana-ta]"),
    temp: root.querySelector("[data-ana-temp]"),
    densidad: root.querySelector("[data-ana-densidad]"),
  };
  const state = {
    selected: null,
    notas: [],
    lastOps: {},
    citMode: "limpieza",
    sulfProducto: "vino",
  };

  const updateWarning = (txt, isError = false) => {
    if (!warnEl) return;
    warnEl.textContent = txt || "";
    warnEl.classList.toggle("error", Boolean(isError));
  };

  const getContainer = () => state.selected;
  const getContainerOrWarn = () => {
    const cont = getContainer();
    if (!cont) {
      updateWarning("Selecciona un depósito o barrica.", true);
      return null;
    }
    if (!Number.isFinite(cont.volumen_l) || cont.volumen_l <= 0) {
      updateWarning("Contenedor sin volumen (según ledger).", true);
      return null;
    }
    return cont;
  };

  const readAnalyticsForm = () => {
    const out = {};
    COPILOTO_TOOLS_ANALITICA_KEYS.forEach(key => {
      const n = CopilotoToolsCore.toNumberEs(anaInputs[key]?.value);
      if (n != null) out[key] = n;
    });
    return out;
  };

  const writeAnalyticsForm = data => {
    COPILOTO_TOOLS_ANALITICA_KEYS.forEach(key => {
      const input = anaInputs[key];
      if (!input) return;
      const value = data && Number.isFinite(data[key]) ? data[key] : null;
      input.value = value == null ? "" : String(value).replace(".", ",");
    });
  };

  const buildAnaliticaBlock = fields => {
    const validKeys = COPILOTO_TOOLS_ANALITICA_KEYS.filter(k => Number.isFinite(fields?.[k]));
    if (!validKeys.length) return "";
    const lines = [
      "[ANALITICA]",
      `fecha=${CopilotoToolsCore.formatFechaOperacion()}`,
      ...validKeys.map(k => `${k}=${fields[k]}`),
      "[/ANALITICA]",
    ];
    return lines.join("\n");
  };

  const buildOperacionBlock = op => {
    const lines = [
      "[OPERACION]",
      `fecha=${CopilotoToolsCore.formatFechaOperacion()}`,
      `tipo=${op.tipo}`,
      `producto=${op.producto}`,
      `deposito=${op.deposito}`,
      `volumen_l=${op.volumen_l}`,
      `objetivo=${op.objetivo}`,
      `resultado=Echar ${op.gramos_txt} g`,
      "[/OPERACION]",
    ];
    return lines.join("\n");
  };

  const fetchNotas = async cont => {
    if (!cont) return [];
    try {
      const res = await fetch(`/api/notas?contenedor_tipo=${encodeURIComponent(cont.tipo)}&contenedor_id=${cont.id}&limit=200`);
      if (!res.ok) return [];
      const data = await res.json().catch(() => ({}));
      return Array.isArray(data?.notas) ? data.notas : [];
    } catch (_err) {
      return [];
    }
  };

  const guardarEnNotas = async (op, extraAnalytics = null) => {
    const cont = getContainerOrWarn();
    if (!cont) return false;
    if (!op || !Number.isFinite(op.gramos)) {
      updateWarning("Calcula antes de guardar en notas.", true);
      return false;
    }
    const analyticsForm = readAnalyticsForm();
    const analyticsData = { ...analyticsForm, ...(extraAnalytics || {}) };
    const analiticaBlock = buildAnaliticaBlock(analyticsData);
    const operacionBlock = buildOperacionBlock({
      tipo: op.tipo,
      producto: op.producto,
      deposito: cont.codigo,
      volumen_l: Number(cont.volumen_l),
      objetivo: op.objetivo,
      gramos_txt: op.gramos_txt,
    });
    const texto = CopilotoToolsCore.appendOperationToNotes(analiticaBlock, operacionBlock);
    try {
      const res = await fetch("/api/notas", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contenedor_tipo: cont.tipo,
          contenedor_id: cont.id,
          fecha: new Date().toISOString(),
          texto,
        }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        updateWarning(data?.error || "No se pudo guardar la operación.", true);
        return false;
      }
      updateWarning("Operación guardada en notas.", false);
      state.notas = await fetchNotas(cont);
      const parsed = CopilotoToolsCore.parseAnalyticsFromNotesList(state.notas);
      writeAnalyticsForm(parsed.lastAnalytics || null);
      if (typeof actualizarCopiloto === "function") actualizarCopiloto(true);
      return true;
    } catch (_err) {
      updateWarning("No se pudo guardar la operación.", true);
      return false;
    }
  };

  const poblarContenedores = () => {
    if (!selectCont) return;
    const list = CopilotoToolsCore.getContainerList();
    const prev = selectCont.value;
    selectCont.innerHTML = "";
    const ph = document.createElement("option");
    ph.value = "";
    ph.textContent = "(Selecciona depósito/barrica)";
    selectCont.appendChild(ph);
    list.forEach(cont => {
      const opt = document.createElement("option");
      opt.value = cont.key;
      opt.textContent = cont.etiqueta;
      selectCont.appendChild(opt);
    });
    if (prev && list.some(c => c.key === prev)) {
      selectCont.value = prev;
    } else if (list.length) {
      selectCont.value = list[0].key;
    }
  };

  const cerrarAliasEditor = () => {
    if (aliasEditor) aliasEditor.hidden = true;
    if (aliasInput) aliasInput.value = "";
  };

  const guardarAliasContenedor = async () => {
    const cont = getContainer();
    if (!cont) {
      updateWarning("Selecciona un contenedor antes de editar alias.", true);
      return;
    }
    const campaniaId = obtenerCampaniaActivaCliente();
    const alias = (aliasInput?.value || "").toString().trim();
    try {
      if (alias) {
        const res = await fetch("/api/containers/alias", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            campania_id: campaniaId,
            container_type: cont.tipo === "barrica" ? "barrica" : "deposito",
            container_id: cont.id,
            alias,
          }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          updateWarning(data?.error || "No se pudo guardar el alias.", true);
          return;
        }
      } else {
        const aliasesRes = await fetch(`/api/containers/aliases?campania_id=${encodeURIComponent(campaniaId)}`);
        const aliasesData = await aliasesRes.json().catch(() => ({}));
        if (aliasesRes.ok) {
          const tipoAlias = cont.tipo === "barrica" ? "barrica" : "deposito";
          const encontrado = (aliasesData.aliases || []).find(
            item =>
              item.container_type === tipoAlias &&
              Number(item.container_id) === Number(cont.id)
          );
          if (encontrado?.id) {
            await fetch(`/api/containers/alias/${encontrado.id}`, { method: "DELETE" });
          }
        }
      }
      await Promise.all([cargarDepositos(), cargarBarricas()]);
      poblarContenedores();
      if (selectCont) selectCont.value = cont.key;
      await refrescarContenedorSeleccionado();
      cerrarAliasEditor();
      updateWarning("Alias guardado para esta añada.", false);
    } catch (_err) {
      updateWarning("No se pudo guardar el alias.", true);
    }
  };

  const refrescarContenedorSeleccionado = async () => {
    cerrarAliasEditor();
    const key = selectCont?.value || "";
    const found = CopilotoToolsCore.getContainerList().find(c => c.key === key) || null;
    state.selected = found;
    if (!found) {
      if (volumeEl) volumeEl.textContent = "Volumen actual: — L";
      updateWarning("Selecciona un depósito o barrica para calcular.", true);
      writeAnalyticsForm(null);
      return;
    }
    const volTxt = CopilotoToolsCore.format1(found.volumen_l);
    if (volumeEl) volumeEl.textContent = `Volumen actual: ${volTxt} L`;
    if (found.volumen_l <= 0) {
      updateWarning("Contenedor sin volumen (según ledger).", true);
    } else {
      updateWarning("", false);
    }
    state.notas = await fetchNotas(found);
    const parsed = CopilotoToolsCore.parseAnalyticsFromNotesList(state.notas);
    writeAnalyticsForm(parsed.lastAnalytics || null);
    const sulfActual = root.querySelector("[data-sulf-actual]");
    if (sulfActual && parsed.lastAnalytics && Number.isFinite(parsed.lastAnalytics.so2_libre)) {
      sulfActual.value = String(parsed.lastAnalytics.so2_libre).replace(".", ",");
    }
  };

  const bindSelectCatalogo = (selectorProducto, selectorDosis, catalogo) => {
    const select = root.querySelector(selectorProducto);
    const input = root.querySelector(selectorDosis);
    if (!select || !input) return;
    select.innerHTML = "";
    catalogo.forEach(item => {
      const opt = document.createElement("option");
      opt.value = item.id;
      opt.textContent = item.nombre;
      select.appendChild(opt);
    });
    const syncDose = () => {
      const selected = catalogo.find(item => item.id === select.value) || catalogo[0];
      if (!selected) return;
      if (!input.value.trim()) input.value = String(selected.dosis_g_hL).replace(".", ",");
    };
    select.addEventListener("change", () => {
      const selected = catalogo.find(item => item.id === select.value) || catalogo[0];
      if (selected) input.value = String(selected.dosis_g_hL).replace(".", ",");
    });
    syncDose();
  };

  const setResult = (name, grams, note = "") => {
    const out = root.querySelector(`[data-${name}-result]`);
    const noteEl = root.querySelector(`[data-${name}-note]`);
    if (out) out.textContent = `Echar: ${grams} g`;
    if (noteEl) {
      noteEl.textContent = note || "";
      noteEl.classList.remove("error");
    }
  };

  const setError = (name, msg) => {
    const out = root.querySelector(`[data-${name}-result]`);
    const noteEl = root.querySelector(`[data-${name}-note]`);
    if (out) out.textContent = "Echar: —";
    if (noteEl) {
      noteEl.textContent = msg;
      noteEl.classList.add("error");
    }
  };

  const calcSulfitado = () => {
    const cont = getContainerOrWarn();
    if (!cont) {
      setError("sulf", "Selecciona contenedor con volumen.");
      return null;
    }
    const objetivo = CopilotoToolsCore.toNumberEs(root.querySelector("[data-sulf-objetivo]")?.value);
    const actual = CopilotoToolsCore.toNumberEs(root.querySelector("[data-sulf-actual]")?.value);
    const modoFino = Boolean(root.querySelector("[data-sulf-fino]")?.checked);
    const ph = CopilotoToolsCore.toNumberEs(root.querySelector("[data-sulf-ph]")?.value);
    if (!Number.isFinite(objetivo) || !Number.isFinite(actual) || objetivo <= 0 || actual < 0) {
      setError("sulf", "Introduce volumen y ΔSO₂.");
      return null;
    }
    if (modoFino && (!Number.isFinite(ph) || ph <= 0)) {
      setError("sulf", "En modo fino el pH es obligatorio.");
      return null;
    }
    const delta = objetivo - actual;
    const gramos = delta <= 0 ? 0 : CopilotoToolsCore.calcMeta(cont.volumen_l, delta) || 0;
    const gramosTxt = CopilotoToolsCore.formatG(gramos);
    const producto = state.sulfProducto === "mosto" ? "Mosto" : "Vino";
    const extra = Number.isFinite(ph) ? ` · pH=${CopilotoToolsCore.format1(ph)}` : "";
    const note = delta <= 0
      ? "Ya estás en objetivo o por encima. No añadir."
      : `${cont.codigo} · Vol ${CopilotoToolsCore.format1(cont.volumen_l)} L · Δ ${CopilotoToolsCore.format1(delta)} mg/L${extra}`;
    setResult("sulf", gramosTxt, note);
    const op = {
      tipo: "Sulfitado",
      producto: "Metabisulfito potásico (57%)",
      objetivo: `SO2_libre ${CopilotoToolsCore.format1(objetivo)}`,
      gramos,
      gramos_txt: gramosTxt,
      copyText: `${cont.codigo} | Sulfitado: echar ${gramosTxt} g metabisulfito (Vol ${CopilotoToolsCore.format1(cont.volumen_l)} L) para subir SO2 libre de ${CopilotoToolsCore.format1(actual)} a ${CopilotoToolsCore.format1(objetivo)} mg/L.${extra ? ` ${extra.trim()}` : ""}`,
      extraAnalytics: root.querySelector("[data-sulf-update-ana]")?.checked && Number.isFinite(actual) ? { so2_libre: actual } : null,
    };
    state.lastOps.sulf = op;
    return op;
  };

  const calcTartarico = () => {
    const cont = getContainerOrWarn();
    if (!cont) {
      setError("tart", "Selecciona contenedor con volumen.");
      return null;
    }
    const incInput = CopilotoToolsCore.toNumberEs(root.querySelector("[data-tart-inc]")?.value);
    const actual = CopilotoToolsCore.toNumberEs(root.querySelector("[data-tart-actual]")?.value);
    const objetivo = CopilotoToolsCore.toNumberEs(root.querySelector("[data-tart-objetivo]")?.value);
    const incremento = Number.isFinite(actual) && Number.isFinite(objetivo) ? (objetivo - actual) : incInput;
    if (!Number.isFinite(incremento) || incremento <= 0) {
      setError("tart", "Introduce incremento TA válido (>0).");
      return null;
    }
    const gramos = cont.volumen_l * incremento;
    const gramosTxt = CopilotoToolsCore.formatG(gramos, "tartarico");
    const objetivoTxt = Number.isFinite(actual) && Number.isFinite(objetivo)
      ? `TA ${CopilotoToolsCore.format1(actual)}→${CopilotoToolsCore.format1(objetivo)} g/L`
      : `+${CopilotoToolsCore.format1(incremento)} g/L`;
    setResult("tart", gramosTxt, "Aviso: hacer prueba en laboratorio si es ajuste grande.");
    const op = {
      tipo: "Tartárico",
      producto: "Ácido tartárico",
      objetivo: objetivoTxt,
      gramos,
      gramos_txt: gramosTxt,
      copyText: `${cont.codigo} | Tartárico: echar ${gramosTxt} g (Vol ${CopilotoToolsCore.format1(cont.volumen_l)} L) para ${objetivoTxt}.`,
    };
    state.lastOps.tart = op;
    return op;
  };

  const calcCatalogo = (name, catalogo, selectorProducto, selectorDosis, tipo, productoFallback) => {
    const cont = getContainerOrWarn();
    if (!cont) {
      setError(name, "Selecciona contenedor con volumen.");
      return null;
    }
    const select = root.querySelector(selectorProducto);
    const doseInput = root.querySelector(selectorDosis);
    const selected = catalogo.find(item => item.id === select?.value) || catalogo[0];
    const dosis = CopilotoToolsCore.toNumberEs(doseInput?.value);
    if (!selected || !Number.isFinite(dosis) || dosis <= 0) {
      setError(name, "Introduce dosis válida.");
      return null;
    }
    const gramos = (cont.volumen_l / 100) * dosis;
    const gramosTxt = CopilotoToolsCore.formatG(gramos);
    let note = selected.nota || "";
    if (Number.isFinite(selected.max_g_hL) && dosis > selected.max_g_hL) {
      note = `Dosis por encima del máximo recomendado (${selected.max_g_hL} g/hL).`;
    }
    setResult(name, gramosTxt, note);
    const op = {
      tipo,
      producto: selected.nombre || productoFallback,
      objetivo: `Dosis ${CopilotoToolsCore.format1(dosis)} g/hL`,
      gramos,
      gramos_txt: gramosTxt,
      copyText: `${cont.codigo} | ${tipo}: echar ${gramosTxt} g de ${selected.nombre} (Vol ${CopilotoToolsCore.format1(cont.volumen_l)} L) con dosis ${CopilotoToolsCore.format1(dosis)} g/hL.`,
    };
    state.lastOps[name] = op;
    return op;
  };

  const applyCitMode = mode => {
    state.citMode = mode === "vino" ? "vino" : "limpieza";
    root.querySelectorAll("[data-cit-mode] [data-mode]").forEach(btn => {
      btn.setAttribute("aria-pressed", btn.dataset.mode === state.citMode ? "true" : "false");
    });
    root.querySelectorAll("[data-cit-block]").forEach(block => {
      block.hidden = block.dataset.citBlock !== state.citMode;
    });
  };

  const calcCitrico = () => {
    const cont = getContainerOrWarn();
    if (!cont) {
      setError("cit", "Selecciona contenedor con volumen.");
      return null;
    }
    if (state.citMode === "limpieza") {
      const conc = CopilotoToolsCore.toNumberEs(root.querySelector("[data-cit-conc]")?.value);
      const litrosSol = CopilotoToolsCore.toNumberEs(root.querySelector("[data-cit-sol-l]")?.value);
      if (!Number.isFinite(conc) || !Number.isFinite(litrosSol) || conc <= 0 || litrosSol <= 0) {
        setError("cit", "Introduce concentración y litros de solución.");
        return null;
      }
      const gramos = conc * litrosSol;
      const gramosTxt = CopilotoToolsCore.formatG(gramos);
      setResult("cit", gramosTxt, "Modo limpieza recomendado.");
      const op = {
        tipo: "Ácido cítrico",
        producto: "Ácido cítrico",
        objetivo: `Limpieza ${CopilotoToolsCore.format1(litrosSol)} L a ${CopilotoToolsCore.format1(conc)} g/L`,
        gramos,
        gramos_txt: gramosTxt,
        copyText: `${cont.codigo} | Ácido cítrico (limpieza): echar ${gramosTxt} g para ${CopilotoToolsCore.format1(litrosSol)} L de solución a ${CopilotoToolsCore.format1(conc)} g/L.`,
      };
      state.lastOps.cit = op;
      return op;
    }
    const confirm = Boolean(root.querySelector("[data-cit-risk]")?.checked);
    const inc = CopilotoToolsCore.toNumberEs(root.querySelector("[data-cit-inc]")?.value);
    if (!confirm) {
      setError("cit", "Confirma el riesgo para usar ácido cítrico en vino.");
      return null;
    }
    if (!Number.isFinite(inc) || inc <= 0) {
      setError("cit", "Introduce incremento en vino (g/L).");
      return null;
    }
    const gramos = cont.volumen_l * inc;
    const gramosTxt = CopilotoToolsCore.formatG(gramos);
    setResult("cit", gramosTxt, "Modo avanzado activado.");
    const op = {
      tipo: "Ácido cítrico",
      producto: "Ácido cítrico",
      objetivo: `En vino +${CopilotoToolsCore.format1(inc)} g/L`,
      gramos,
      gramos_txt: gramosTxt,
      copyText: `${cont.codigo} | Ácido cítrico (vino): echar ${gramosTxt} g (Vol ${CopilotoToolsCore.format1(cont.volumen_l)} L) para +${CopilotoToolsCore.format1(inc)} g/L.`,
    };
    state.lastOps.cit = op;
    return op;
  };

  const calcSolucion = () => {
    const cont = getContainerOrWarn();
    if (!cont) {
      setError("sol", "Selecciona contenedor con volumen.");
      return null;
    }
    const producto = (root.querySelector("[data-sol-prod]")?.value || "Producto").trim();
    const gL = CopilotoToolsCore.toNumberEs(root.querySelector("[data-sol-gl]")?.value);
    const litros = CopilotoToolsCore.toNumberEs(root.querySelector("[data-sol-litros]")?.value);
    if (!Number.isFinite(gL) || !Number.isFinite(litros) || gL <= 0 || litros <= 0) {
      setError("sol", "Introduce concentración y litros de solución.");
      return null;
    }
    const gramos = gL * litros;
    const gramosTxt = CopilotoToolsCore.formatG(gramos);
    setResult("sol", gramosTxt, "");
    const op = {
      tipo: "Solución madre",
      producto,
      objetivo: `${CopilotoToolsCore.format1(gL)} g/L · ${CopilotoToolsCore.format1(litros)} L`,
      gramos,
      gramos_txt: gramosTxt,
      copyText: `${cont.codigo} | Solución madre ${producto}: echar ${gramosTxt} g para ${CopilotoToolsCore.format1(litros)} L a ${CopilotoToolsCore.format1(gL)} g/L.`,
    };
    state.lastOps.sol = op;
    return op;
  };

  const wireModule = (name, calcFn) => {
    const btnCalc = root.querySelector(`[data-${name}-calc]`);
    const btnCopy = root.querySelector(`[data-${name}-copy]`);
    const btnSave = root.querySelector(`[data-${name}-save]`);
    if (btnCalc) btnCalc.addEventListener("click", calcFn);
    if (btnCopy) {
      btnCopy.addEventListener("click", async () => {
        const op = state.lastOps[name] || calcFn();
        if (!op) return;
        const ok = await CopilotoToolsCore.copyToClipboard(op.copyText);
        const note = root.querySelector(`[data-${name}-note]`);
        if (note) {
          note.textContent = ok ? "Copiado." : "No se pudo copiar.";
          note.classList.toggle("error", !ok);
        }
      });
    }
    if (btnSave) {
      btnSave.addEventListener("click", async () => {
        const op = state.lastOps[name] || calcFn();
        if (!op) return;
        const extraAnalytics = name === "sulf" ? (op.extraAnalytics || null) : null;
        await guardarEnNotas(op, extraAnalytics);
      });
    }
  };

  poblarContenedores();
  bindSelectCatalogo("[data-nut-prod]", "[data-nut-dose]", COPILOTO_TOOLS_NUTRIENTES);
  bindSelectCatalogo("[data-ben-prod]", "[data-ben-dose]", COPILOTO_TOOLS_BENTONITA);
  applyCitMode("limpieza");

  if (selectCont) {
    selectCont.addEventListener("change", () => {
      refrescarContenedorSeleccionado();
    });
  }
  if (btnAlias) {
    btnAlias.addEventListener("click", () => {
      const cont = getContainer();
      if (!cont) {
        updateWarning("Selecciona un contenedor antes de editar alias.", true);
        return;
      }
      if (aliasEditor) aliasEditor.hidden = false;
      if (aliasInput) {
        aliasInput.value = (cont.alias || "").toString();
        aliasInput.focus();
        aliasInput.select();
      }
    });
  }
  if (aliasCancelBtn) {
    aliasCancelBtn.addEventListener("click", cerrarAliasEditor);
  }
  if (aliasSaveBtn) {
    aliasSaveBtn.addEventListener("click", guardarAliasContenedor);
  }
  if (aliasInput) {
    aliasInput.addEventListener("keydown", ev => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        guardarAliasContenedor();
      }
      if (ev.key === "Escape") {
        ev.preventDefault();
        cerrarAliasEditor();
      }
    });
  }
  root.querySelectorAll("[data-sulf-producto] [data-producto]").forEach(btn => {
    btn.addEventListener("click", () => {
      state.sulfProducto = btn.dataset.producto === "mosto" ? "mosto" : "vino";
      root.querySelectorAll("[data-sulf-producto] [data-producto]").forEach(item => {
        item.setAttribute("aria-pressed", item === btn ? "true" : "false");
      });
      const note = root.querySelector("[data-sulf-note]");
      if (note) {
        note.textContent = state.sulfProducto === "mosto"
          ? "Mosto consume SO₂ con facilidad. Verifica SO₂ libre tras 6–12 h."
          : "En vino, el SO₂ libre final depende de pH y consumo.";
      }
    });
  });

  const chkFino = root.querySelector("[data-sulf-fino]");
  if (chkFino) {
    chkFino.addEventListener("change", () => {
      const wrap = root.querySelector("[data-sulf-ph-wrap]");
      if (wrap) wrap.hidden = !chkFino.checked;
    });
  }

  root.querySelectorAll("[data-cit-mode] [data-mode]").forEach(btn => {
    btn.addEventListener("click", () => applyCitMode(btn.dataset.mode));
  });

  wireModule("sulf", calcSulfitado);
  wireModule("tart", calcTartarico);
  wireModule("nut", () => calcCatalogo("nut", COPILOTO_TOOLS_NUTRIENTES, "[data-nut-prod]", "[data-nut-dose]", "Nutrientes", "Nutriente"));
  wireModule("ben", () => calcCatalogo("ben", COPILOTO_TOOLS_BENTONITA, "[data-ben-prod]", "[data-ben-dose]", "Bentonita", "Bentonita"));
  wireModule("cit", calcCitrico);
  wireModule("sol", calcSolucion);

  refrescarContenedorSeleccionado();
}

function parseNumeroSeguro(value) {
  if (value == null) return NaN;
  const normalized = String(value).trim().replace(",", ".");
  if (!normalized) return NaN;
  const parsed = Number(normalized);
  return Number.isFinite(parsed) ? parsed : NaN;
}

function formatearNumero(valor, decimales = 2) {
  if (!Number.isFinite(valor)) return "—";
  return valor.toLocaleString("es-ES", {
    minimumFractionDigits: 0,
    maximumFractionDigits: decimales,
  });
}

function calcularMetabisulfitoGramos(volumenL, deltaMgL) {
  if (!Number.isFinite(volumenL) || !Number.isFinite(deltaMgL)) return NaN;
  if (volumenL <= 0 || deltaMgL <= 0) return NaN;
  return (volumenL * deltaMgL) / 1000 / 0.57;
}

function convertirGhlAMgL(ghl) {
  if (!Number.isFinite(ghl) || ghl < 0) return NaN;
  return ghl * 10;
}

function convertirMgLAGhl(mgl) {
  if (!Number.isFinite(mgl) || mgl < 0) return NaN;
  return mgl / 10;
}

function setHerramientaStatus(id, texto, isError = false) {
  const el = document.getElementById(id);
  if (!el) return;
  el.textContent = texto || "";
  el.classList.toggle("error", Boolean(isError));
}

function calcularHerramientaMeta() {
  const volumen = parseNumeroSeguro(document.getElementById("herrVolumenL")?.value);
  const delta = parseNumeroSeguro(document.getElementById("herrDeltaMgL")?.value);
  const target = document.getElementById("herrMetaResultado");
  if (!target) return;

  const gramos = calcularMetabisulfitoGramos(volumen, delta);
  if (!Number.isFinite(gramos)) {
    target.textContent = "Resultado: —";
    setHerramientaStatus("herrMetaStatus", "Revisa volumen y objetivo (deben ser mayores que 0).", true);
    return;
  }

  target.textContent = `Resultado: ${formatearNumero(gramos, 2)} g de metabisulfito potásico`;
  setHerramientaStatus("herrMetaStatus", "Cálculo actualizado.");
}

async function copiarResultadoMeta() {
  const texto = document.getElementById("herrMetaResultado")?.textContent || "";
  if (!texto || texto === "Resultado: —") {
    setHerramientaStatus("herrMetaStatus", "Primero calcula un resultado válido.", true);
    return;
  }
  try {
    await navigator.clipboard.writeText(texto);
    setHerramientaStatus("herrMetaStatus", "Resultado copiado.");
  } catch (_err) {
    setHerramientaStatus("herrMetaStatus", "No se pudo copiar al portapapeles.", true);
  }
}

function convertirDesdeGhl() {
  const ghl = parseNumeroSeguro(document.getElementById("herrGhlInput")?.value);
  const mgL = convertirGhlAMgL(ghl);
  const target = document.getElementById("herrConversorResultado");
  if (!target) return;
  if (!Number.isFinite(mgL)) {
    target.textContent = "Resultado: —";
    setHerramientaStatus("herrConversorStatus", "Introduce g/hL válido (>= 0).", true);
    return;
  }
  target.textContent = `Resultado: ${formatearNumero(ghl, 2)} g/hL = ${formatearNumero(mgL, 2)} mg/L`;
  setHerramientaStatus("herrConversorStatus", "Conversión actualizada.");
}

function convertirDesdeMgL() {
  const mgL = parseNumeroSeguro(document.getElementById("herrMgLInput")?.value);
  const ghl = convertirMgLAGhl(mgL);
  const target = document.getElementById("herrConversorResultado");
  if (!target) return;
  if (!Number.isFinite(ghl)) {
    target.textContent = "Resultado: —";
    setHerramientaStatus("herrConversorStatus", "Introduce mg/L válido (>= 0).", true);
    return;
  }
  target.textContent = `Resultado: ${formatearNumero(mgL, 2)} mg/L = ${formatearNumero(ghl, 2)} g/hL`;
  setHerramientaStatus("herrConversorStatus", "Conversión actualizada.");
}

function initHerramientasUI() {
  const btnMeta = document.getElementById("herrCalcularMetaBtn");
  const btnCopiar = document.getElementById("herrCopiarMetaBtn");
  const btnGhl = document.getElementById("herrConvertirGhlBtn");
  const btnMgL = document.getElementById("herrConvertirMgLBtn");

  if (btnMeta) btnMeta.addEventListener("click", calcularHerramientaMeta);
  if (btnCopiar) btnCopiar.addEventListener("click", copiarResultadoMeta);
  if (btnGhl) btnGhl.addEventListener("click", convertirDesdeGhl);
  if (btnMgL) btnMgL.addEventListener("click", convertirDesdeMgL);

  document.querySelectorAll("[data-ghl-ejemplo]").forEach(btn => {
    btn.addEventListener("click", () => {
      const value = parseNumeroSeguro(btn.dataset.ghlEjemplo);
      const input = document.getElementById("herrGhlInput");
      if (input && Number.isFinite(value)) {
        input.value = String(value);
        convertirDesdeGhl();
      }
    });
  });

  document.querySelectorAll("[data-mgl-ejemplo]").forEach(btn => {
    btn.addEventListener("click", () => {
      const value = parseNumeroSeguro(btn.dataset.mglEjemplo);
      const input = document.getElementById("herrMgLInput");
      if (input && Number.isFinite(value)) {
        input.value = String(value);
        convertirDesdeMgL();
      }
    });
  });
}

const TITULOS_DINAMICOS = {
  estilo: nodo => {
    if (!Array.isArray(flujoNodos)) return null;
    const estilos = flujoNodos.filter(n => n?.tipo === "estilo");
    const id = normalizarIdNodo(nodo);
    const idx = estilos.findIndex(n => normalizarIdNodo(n) === id);
    if (idx >= 0) return `Elaboración ${idx + 1}`;
    return "Elaboración";
  },
  deposito: nodo => {
    const nombre = nodo?.datos?.codigo || "Depósito";
    const fase = nodo?.datos?.fase;
    // Mostramos la fase en el badge coloreado, no en el título, para evitar duplicados.
    return nombre;
  },
  barrica: nodo => {
    const datos = nodo?.datos || {};
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const id = datos.contenedor_id || datos.id_ref;
    const info = id ? obtenerInfoContenedor(tipoCont, id) : null;
    const codigo = (info?.codigo || datos.codigo || "").toString().trim();
    if (!codigo) return null;
    return `${codigo} CRIANZA`;
  },
};
const COPILOTO_DEFAULT_CONFIG = {
  paradaHoras: 24,
  paradaDelta: 1,
  tempMax: { tinto: 28, blanco: 20, rosado: 22, default: 26 },
  oxidacionHoras: 36,
  oxidacionMinLlenado: 85,
  proteccionHoras: 12,
  analiticaHoras: 48,
  refreshMin: 5,
  modoExperto: false,
  notificaciones: false,
};
const COPILOTO_STORAGE_KEY = "copiloto_config_v1";
const COPILOTO_STATE_KEY = "copiloto_state_v1";
const COPILOTO_ANALITICOS_TTL_MS = 5 * 60 * 1000;
const COPILOTO_EVENTOS_TTL_MS = 90 * 1000;
const COPILOTO_EVENTOS_LIMIT = 200;
const COPILOTO_SEMAFORO_HORAS = 48;
const COPILOTO_TIMELINE_LIMIT = 200;
const COPILOTO_TIMELINE_STEP = 40;
const COPILOTO_TIMELINE_INIT = 60;
const COPILOTO_HEATMAP_DIAS = 56;
const COPILOTO_SNOOZE_HOURS = 12;
const COPILOTO_DONE_DAYS = 7;
let copilotoConfig = null;
let copilotoState = null;
const copilotoAnaliticosCache = new Map();
const copilotoAnaliticosTs = new Map();
let copilotoEventosCache = [];
let copilotoEventosTs = 0;
let copilotoAutoTimer = null;
let copilotoUpdateTimer = null;
let copilotoEnProgreso = false;
let copilotoFiltroDia = null;
let copilotoTimelineVisible = COPILOTO_TIMELINE_INIT;
let copilotoTimelineExpandAll = false;
let copilotoTimelineBusquedaTimer = null;
const copilotoTimelineFiltros = {
  contenedor: "",
  origen: "todos",
  accion: "",
  buscar: "",
};
const CAMPOS_PRIORITARIOS_MODAL = ["fecha_creacion", "fecha", "fecha_operacion"];
const CAMPOS_CARGA_NUMERICOS = ["kilos", "litros", "litros_directos", "volumen"];
const CAMPOS_CARGA_TEXTO = ["variedad", "anada"];
const CAMPOS_CARGA_METRICAS = ["densidad", "temperatura", "ph", "acidez_total"];
const TIPOS_CONTENEDOR_FLUJO = new Set(["deposito", "barrica", "coupage"]);
const VARIEDADES_BLANCAS = [
  "blanco",
  "malvar",
  "airen",
  "airén",
  "verdejo",
  "albariño",
  "albarino",
  "macabeo",
  "viura",
  "godello",
  "palomino",
  "parellada",
  "xarel·lo",
  "xarello",
  "moscatel",
  "moscat",
  "gewurztraminer",
  "gewürztraminer",
  "riesling",
  "viognier",
  "chardonnay",
  "sauvignon",
  "treixadura",
  "garnacha blanca",
  "albillo",
  "colombard",
  "gruner",
  "gruener",
  "grüner",
  "viosinho",
  "pedro ximenez",
  "pedro ximénez",
  "trebbiano",
  "pinot blanc",
  "pinot bianco",
  "marsanne",
  "roussanne",
  "chenin",
  "palomino",
  "godello",
  "loureira",
  "doña blanca",
  "dona blanca",
  "malvasia",
  "malvasía",
];
let VARIEDADES_BLANCAS_SET = null;
function obtenerNodoPorId(idBuscado) {
  const idNorm = normalizarIdNodo(idBuscado);
  return flujoNodos.find(n => normalizarIdNodo(n.id) === idNorm) || null;
}
function actualizarTituloNodo(nodo) {
  if (!nodo) return;
  const config = FLOW_NODE_TYPES[nodo.tipo];
  const generador = TITULOS_DINAMICOS[nodo.tipo];
  if (generador) {
    const titulo = generador(nodo);
    if (titulo) {
      nodo.titulo = titulo;
      return;
    }
  }
  nodo.titulo = config ? config.label : nodo.titulo || "Nodo";
}

function ordenarCamposParaModal(campos) {
  const originales = [...(campos || [])];
  const prioridad = CAMPOS_PRIORITARIOS_MODAL.map(id =>
    originales.find(campo => campo.id === id)
  ).filter(Boolean);
  const resto = originales.filter(campo => !CAMPOS_PRIORITARIOS_MODAL.includes(campo.id));
  return [...prioridad, ...resto];
}

function normalizarFechaSoloDia(valor) {
  if (!valor) return "";
  const txt = String(valor).trim();
  const match = txt.match(/^(\d{4}-\d{2}-\d{2})/);
  if (match) return match[1];
  const fecha = new Date(txt);
  if (Number.isNaN(fecha.getTime())) return "";
  const pad = n => String(n).padStart(2, "0");
  return `${fecha.getFullYear()}-${pad(fecha.getMonth() + 1)}-${pad(fecha.getDate())}`;
}

function asegurarFechaCreacionNodo(nodo) {
  if (!nodo || nodo.tipo === "entrada") return;
  nodo.datos = nodo.datos || {};
  const actual = normalizarFechaSoloDia(nodo.datos.fecha_creacion);
  if (actual) {
    nodo.datos.fecha_creacion = actual;
    return;
  }
  const base =
    normalizarFechaSoloDia(nodo.datos.fecha_operacion) ||
    normalizarFechaSoloDia(nodo.datos.fecha) ||
    new Date().toISOString().slice(0, 10);
  nodo.datos.fecha_creacion = base;
}

function obtenerValorCampoVisual(nodo, campo) {
  if (!nodo || !campo) return "";

  const role = obtenerRolNodo(nodo);
  if (role === "SOURCE") {
    if (campo.id === "fecha") {
      return obtenerFechaEntradaDesdeNodo(nodo);
    }
    if (campo.id === "kilos") {
      const kilos = obtenerKilosEntradaDesdeNodo(nodo);
      return kilos != null ? `${Number(kilos.toFixed(0))} kg` : "";
    }
    if (campo.id === "variedad") {
      return obtenerVariedadVisibleNodo(nodo);
    }
    if (campo.id === "densidad") {
      const dens = obtenerDensidadEntradaDesdeNodo(nodo);
      return dens != null ? formatearDensidad(dens) : "";
    }
    if (campo.id === "temperatura") {
      const temp = obtenerTemperaturaEntradaDesdeNodo(nodo);
      return temp != null ? `${Number(temp).toFixed(1)} °C` : "";
    }
    if (campo.id === "ph") {
      const ph = obtenerPhEntradaDesdeNodo(nodo);
      return ph != null ? Number(ph).toFixed(2) : "";
    }
    if (campo.id === "acidez_total") {
      const acidez = obtenerAcidezTotalEntradaDesdeNodo(nodo);
      return acidez != null ? `${Number(acidez).toFixed(2)} g/L` : "";
    }
  }

  if (campo.id === "capacidad" && nodo.tipo === "deposito") {
    const capacidadBase =
      nodo.datos?.capacidad ??
      nodo.datos?.capacidad_l ??
      (nodo.datos?.capacidad_hl != null ? nodo.datos.capacidad_hl * 100 : null);
    const volumenBase = obtenerVolumenActualNodo(nodo);
    const capNum = capacidadBase != null ? Number(capacidadBase) : NaN;
    const volNum = volumenBase != null ? Number(volumenBase) : NaN;
    const capTxt = Number.isFinite(capNum) ? formatearVolumenPlano(capNum) : "";
    const volTxt = Number.isFinite(volNum) && volNum > 0 ? formatearVolumenPlano(volNum) : "";
    const partes = [];
    if (capTxt) partes.push(capTxt);
    if (volTxt) partes.push(`Volumen: ${volTxt}`);
    const combinado = partes.join(" | ");
    if (combinado) return combinado;
  }

  if (campo.id === "variedad") {
    const texto = obtenerVariedadVisibleNodo(nodo);
    if (texto) return texto;
  }
  if (nodo.tipo === "almacen" && campo.id === "botellas_resultantes") {
    const botellas = obtenerBotellasDisponiblesPredecesoresAlmacen(nodo);
    const etiqueta = botellas === 1 ? "botella" : "botellas";
    return `${botellas.toLocaleString("es-ES")} ${etiqueta}`;
  }
  if (nodo.tipo === "almacen" && campo.id === "cajas_resultantes") {
    const botellas = obtenerBotellasDisponiblesPredecesoresAlmacen(nodo);
    const tamCaja = obtenerTamanoCaja(nodo.datos?.caja_botellas || "6 botellas");
    const cajas = Math.floor(botellas / tamCaja);
    const etiqueta = cajas === 1 ? "caja" : "cajas";
    return `${cajas.toLocaleString("es-ES")} ${etiqueta} (${tamCaja} botellas/caja)`;
  }
  if (nodo.tipo === "salida" && campo.id === "botellas_totales") {
    const cajasRaw = normalizarNumero(nodo.datos?.cajas_cantidad);
    const cajas = Number.isFinite(cajasRaw) && cajasRaw > 0 ? Math.floor(cajasRaw) : 0;
    const tamCaja = obtenerTamanoCaja(nodo.datos?.cajas_tipo || "6 botellas");
    const total = cajas * tamCaja;
    const etiqueta = total === 1 ? "botella" : "botellas";
    return `${total.toLocaleString("es-ES")} ${etiqueta}`;
  }

  const valor = nodo.datos ? nodo.datos[campo.id] : "";
  if (valor === undefined || valor === null || valor === "") return "";
  if (campo.id === "fecha" || campo.id === "fecha_operacion" || campo.id === "fecha_creacion") {
    return formatearFechaCorta(valor);
  }
  if (campo.id === "densidad") {
    return formatearDensidad(valor);
  }
  if (campo.id === "temperatura") {
    const num = normalizarNumero(valor);
    return num != null ? `${num.toFixed(1)} °C` : "";
  }
  if (campo.id === "ph") {
    const num = normalizarNumero(valor);
    return num != null ? num.toFixed(2) : "";
  }
  if (campo.id === "acidez_total") {
    const num = normalizarNumero(valor);
    return num != null ? `${num.toFixed(2)} g/L` : "";
  }
  if (campo.id === "litros_resultantes" || campo.id === "merma_abs") {
    const num = normalizarNumero(valor);
    return num != null ? formatearVolumenPlano(num) : "";
  }
  if (campo.id === "estado_vino") {
    if (String(valor).toLowerCase() === ESTADO_PERSONALIZADO) {
      const texto = nodo.datos?.estado_vino_texto || "";
      return texto || "Personalizado";
    }
    const encontrado = ESTADOS_VINO.find(item => item.value === String(valor).toLowerCase());
    return encontrado ? encontrado.label : valor;
  }
  return valor;
}

function esMetodoPrensado(metodo) {
  return (metodo || "").toLowerCase() === "prensado";
}

function esMetodoSangrado(metodo) {
  return (metodo || "").toLowerCase() === "sangrado";
}

function esNodoSangrado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "estilo") {
    return esMetodoSangrado(nodo.datos?.metodo);
  }
  return false;
}

function esNodoPrensado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "prensado") return true;
  if (nodo.tipo === "estilo") {
    const metodo = (nodo.datos?.metodo || "").toLowerCase();
    return metodo === "prensado" || metodo === "sangrado";
  }
  return false;
}

function esNodoConversor(nodo) {
  return esNodoPrensado(nodo) || esNodoSangrado(nodo);
}

	function obtenerPredecesores(id) {
	  const idNorm = normalizarIdNodo(id);
	  return flujoNodos.filter(n =>
	    (n.targets || []).some(targetId => normalizarIdNodo(targetId) === idNorm)
	  );
	}

	function obtenerUnidadNodo(nodo, memo = new Map()) {
	  if (!nodo) return "kilos";
	  // Los contenedores se gestionan siempre en volumen (capacidad/volumen) aunque reciban kilos.
	  if (
	    nodo.tipo === "deposito" ||
	    nodo.tipo === "barrica" ||
	    nodo.tipo === "almacen" ||
	    nodo.tipo === "coupage"
	  ) {
	    return "litros";
	  }
	  const clave = nodo.id || nodo;
	  // Evitar recursión infinita si hay ciclos
	  if (memo.get("visitando")?.has(clave)) return "kilos";
	  if (memo.has(clave)) return memo.get(clave);
  const visitando = memo.get("visitando") || new Set();
  visitando.add(clave);
  memo.set("visitando", visitando);
  let unidad = esNodoConversor(nodo) ? "litros" : "kilos";
  if (unidad === "kilos") {
    const padres = obtenerPredecesores(nodo.id);
    if (padres.some(pre => obtenerUnidadNodo(pre, memo) === "litros")) {
      unidad = "litros";
    }
  }
  memo.set(clave, unidad);
  visitando.delete(clave);
  return unidad;
}

function obtenerUnidadEntrante(nodo) {
  if (!nodo) return "kilos";
  const padres = obtenerPredecesores(nodo.id);
  if (!padres.length) return "kilos";
  return padres.some(pre => obtenerUnidadNodo(pre) === "litros") ? "litros" : "kilos";
}

function obtenerUnidadDisponible(origen) {
  return obtenerUnidadNodo(origen);
}

function obtenerUnidadVisual(nodo) {
  return nodo?.tipo === "entrada" ? "Kg" : "Volumen";
}

function obtenerRolNodo(nodo) {
  if (!nodo) return "PROCESS";
  if ((nodo.tipo || "").toString().toLowerCase() === "entrada") return "SOURCE";
  if (nodo.role) return nodo.role;
  return mapearRolPorTipo(nodo.tipo);
}

const NODOS_SIN_VOLUMEN = new Set(["embotellado", "almacen", "salida"]);

function esNodoProcesoSinVolumen(nodo) {
  if (!nodo) return false;
  return NODOS_SIN_VOLUMEN.has(nodo.tipo);
}

function limpiarVolumenNodoProceso(nodo) {
  if (!nodo || !esNodoProcesoSinVolumen(nodo)) return;
  if (!nodo.datos || typeof nodo.datos !== "object") return;
  ["volumen", "kilos", "litros", "litros_directos", "litros_blend"].forEach(key => {
    if (key in nodo.datos) delete nodo.datos[key];
  });
}

const FLOW_SCHEMA_VERSION = 2;
const FLOW_CORE_LOCKED = true;
const FLOW_SANITIZE_KEYS = [
  "volumen",
  "volume",
  "currentVolume",
  "current_volume_l",
  "kilos",
  "litros",
  "litros_directos",
  "litros_blend",
  "stock",
  "fill",
  "variedad",
  "variedadBase",
  "vino",
  "vino_tipo",
  "tipoColor",
  "aportes",
];

let flowMovements = [];
let flowEdges = [];
let flowCompositions = [];
let flowSchemaVersion = FLOW_SCHEMA_VERSION;
let flowBalances = new Map();
let flowCompositionMap = new Map();
let flowWarnings = [];
let flowWarningNodes = new Set();
let flowBalancesDirty = true;
let flowCompositionsDirty = true;
let flowCoreWarnings = [];
let flowCoreMigrated = false;
let flowWarningsDebug = false;
let flowMovementEditingId = null;
let flowTimelineSyncInit = false;
let flowTimelineRefreshTimer = null;

// =========================
// FLOW_CORE (único bloque)
// =========================
const FLOW_CORE = (() => {
  const version = FLOW_SCHEMA_VERSION;
  const containerWhitelist = new Set([
    "name",
    "containerId",
    "id_ref",
    "codigo",
    "contenedor_id",
    "contenedor_tipo",
    "capacity_l",
    "capacidad",
    "capacidad_hl",
    "notes",
    "type",
    "role",
    "fase",
    "estado",
    "estado_vino",
    "estado_vino_texto",
    "asignaciones",
  ]);
  const sourceWhitelist = new Set([
    "name",
    "entradaId",
    "entryId",
    "type",
    "role",
    "distribucion",
    "reparto_manual",
  ]);

  const isFiniteNumber = val => Number.isFinite(val);
  const toNumberSafe = val => {
    if (val === undefined || val === null || val === "") return null;
    const num = Number(val);
    return Number.isFinite(num) ? num : null;
  };
  const clamp0 = val => (Number.isFinite(val) ? Math.max(0, val) : 0);

  const roleFromType = tipo => {
    const t = String(tipo || "").toLowerCase();
    if (!t) return "PROCESS";
    if (t === "entrada") return "SOURCE";
    if (t === "deposito" || t === "barrica") return "CONTAINER";
    return "PROCESS";
  };

  const normalizeInput = raw => {
    if (!raw) return { schemaVersion: 1, nodes: [], edges: [], movements: [], compositions: [] };
    if (Array.isArray(raw)) {
      return { schemaVersion: 1, nodes: raw, edges: [], movements: [], compositions: [] };
    }
    return {
      schemaVersion: Number(raw.schemaVersion) || 1,
      nodes: Array.isArray(raw.nodes) ? raw.nodes : [],
      edges: Array.isArray(raw.edges) ? raw.edges : [],
      movements: Array.isArray(raw.movements) ? raw.movements : [],
      compositions: Array.isArray(raw.compositions) ? raw.compositions : [],
    };
  };

  const normalizeEdges = (edges = [], nodes = []) => {
    const ids = new Set(nodes.map(n => String(n?.id)).filter(Boolean));
    return (Array.isArray(edges) ? edges : [])
      .map(e => ({
        from: e?.from ?? e?.source ?? e?.origen ?? e?.fromNodeId ?? null,
        to: e?.to ?? e?.target ?? e?.destino ?? e?.toNodeId ?? null,
      }))
      .filter(e => e.from != null && e.to != null)
      .map(e => ({ from: String(e.from), to: String(e.to) }))
      .filter(e => ids.has(e.from) && ids.has(e.to));
  };

  const buildEdgesFromTargets = (nodes = []) => {
    const edges = [];
    nodes.forEach(n => {
      const from = n?.id != null ? String(n.id) : "";
      if (!from || !Array.isArray(n.targets)) return;
      n.targets.forEach(t => {
        const to = t != null ? String(t) : "";
        if (!to) return;
        edges.push({ from, to });
      });
    });
    return normalizeEdges(edges, nodes);
  };

  const applyEdgesTargets = (nodes = [], edges = []) => {
    const mapa = new Map();
    nodes.forEach(n => {
      if (!n || n.id == null) return;
      mapa.set(String(n.id), []);
    });
    edges.forEach(e => {
      if (!mapa.has(e.from)) return;
      mapa.get(e.from).push(e.to);
    });
    nodes.forEach(n => {
      const id = n?.id != null ? String(n.id) : "";
      if (!id) return;
      const targets = mapa.get(id) || [];
      n.targets = Array.from(new Set(targets));
    });
  };

  const sanitizeNode = nodo => {
    if (!nodo || typeof nodo !== "object") return nodo;
    const role = nodo.role || roleFromType(nodo.tipo);
    const datos = nodo.datos && typeof nodo.datos === "object" ? { ...nodo.datos } : {};
    FLOW_SANITIZE_KEYS.forEach(k => {
      if (k in datos) delete datos[k];
    });
    if (role === "SOURCE") {
      const entradaId =
        datos.entradaId ??
        datos.entryId ??
        datos.entrada_id ??
        datos.id_ref ??
        null;
      const limpio = {
        ...nodo,
        role: "SOURCE",
        datos: {
          name: datos.name || datos.nombre || nodo.titulo || "",
          entradaId,
          entryId: entradaId,
          type: datos.type || "entrada",
          role: "SOURCE",
        },
      };
      Object.keys(limpio.datos).forEach(k => {
        if (!sourceWhitelist.has(k)) delete limpio.datos[k];
      });
      return limpio;
    }
    if (role === "PROCESS") {
      Object.keys(datos).forEach(k => {
        if (typeof datos[k] === "number") delete datos[k];
      });
      return { ...nodo, role: "PROCESS", datos };
    }
    if (role === "CONTAINER") {
      const capacity =
        normalizarNumero(datos.capacity_l) ??
        normalizarNumero(datos.capacidad_l) ??
        normalizarNumero(datos.capacidad) ??
        (datos.capacidad_hl != null ? normalizarNumero(datos.capacidad_hl * 100) : null);
      const containerId = datos.containerId ?? datos.id_ref ?? datos.contenedor_id ?? null;
      const limpio = {
        ...nodo,
        role: "CONTAINER",
        datos: {
          name: datos.name || datos.nombre || datos.codigo || nodo.titulo || "",
          containerId,
          id_ref: datos.id_ref ?? containerId ?? null,
          codigo: datos.codigo ?? null,
          contenedor_id: datos.contenedor_id ?? containerId ?? null,
          contenedor_tipo: datos.contenedor_tipo ?? null,
          capacity_l: capacity != null ? Number(capacity) : null,
          capacidad: datos.capacidad ?? null,
          capacidad_hl: datos.capacidad_hl ?? null,
          notes: datos.notes || datos.notas || "",
          type: datos.type || datos.contenedor_tipo || datos.tipo || nodo.tipo,
          role: "CONTAINER",
          fase: datos.fase ?? null,
          estado: datos.estado ?? null,
          estado_vino: datos.estado_vino ?? null,
          estado_vino_texto: datos.estado_vino_texto ?? null,
          asignaciones: datos.asignaciones || {},
        },
      };
      Object.keys(limpio.datos).forEach(k => {
        if (!containerWhitelist.has(k)) delete limpio.datos[k];
      });
      return limpio;
    }
    return { ...nodo, role: role || "PROCESS", datos };
  };

  const extractLegacyVolume = nodo => {
    if (!nodo || typeof nodo !== "object") return null;
    const datos = nodo.datos || {};
    const vol =
      toNumberSafe(datos.volumen) ??
      toNumberSafe(datos.litros_directos) ??
      toNumberSafe(datos.litros) ??
      toNumberSafe(datos.kilos);
    return vol != null && vol > 0 ? Number(vol) : null;
  };

  const warningMessageFor = type => {
    if (type === "invalid_movement") return "Movimiento malformado (se ignora).";
    if (type === "invalid_amount") return "Movimiento con cantidad inválida (se ignora).";
    if (type === "unknown_node") return "Movimiento con nodo inexistente (se ignora).";
    if (type === "negative_balance") return "Balance negativo en contenedor (se ajusta a 0).";
    if (type === "invalid_composition") return "Composición malformada (se ignora).";
    if (type === "invalid_unit") return "Composición con unidad inválida (se ignora).";
    if (type === "invalid_breakdown") return "Composición sin desglose válido (se ignora).";
    if (type === "invalid_breakdown_value") return "Composición con valor inválido en desglose.";
    if (type === "invalid_breakdown_sum") return "Composición con suma de desglose incoherente.";
    if (type === "invalid_ref") return "Composición con referencia inválida.";
    if (type === "invalid_compositions") return "Composiciones inválidas (se normaliza).";
    if (type === "missing_ref") return "Referencia inexistente en composición.";
    if (type === "bad_edge_ref") return "Arista con referencia inválida (se ignora).";
    if (type === "unknown_role") return "Nodo sin rol definido (se asigna por tipo).";
    if (type === "negative_composition") return "Composición negativa detectada.";
    if (type === "non_container_ref") return "Movimiento apunta a nodo que no es contenedor.";
    return "Aviso del ledger.";
  };

  const buildWarning = ({
    type,
    msg,
    origin,
    nodeId = null,
    movementId = null,
    compositionId = null,
    raw = null,
  }) => ({
    type,
    msg: msg || warningMessageFor(type),
    origin: origin || "",
    nodeId: nodeId != null ? String(nodeId) : null,
    movementId: movementId != null ? String(movementId) : null,
    compositionId: compositionId != null ? String(compositionId) : null,
    raw: raw != null ? raw : undefined,
  });

  const dedupeMovements = movs => {
    const seen = new Set();
    return movs.filter(m => {
      const id = m?.id || "";
      if (!id) return true;
      if (seen.has(id)) return false;
      seen.add(id);
      return true;
    });
  };

  const dedupeCompositions = comps => {
    const seen = new Set();
    return comps.filter(c => {
      const id = c?.id || "";
      if (!id) return true;
      if (seen.has(id)) return false;
      seen.add(id);
      return true;
    });
  };

  const normalizeMovements = (movs = [], nodes = []) => {
    const warnings = [];
    const ids = new Set(nodes.map(n => String(n?.id)).filter(Boolean));
    const limpios = [];
    (Array.isArray(movs) ? movs : []).forEach((m, idx) => {
      const originBase = `validateFlow:movements[${idx}]`;
      if (!m || typeof m !== "object") {
        warnings.push(
          buildWarning({
            type: "invalid_movement",
            origin: originBase,
            raw: { movement: m },
          })
        );
        return;
      }
      const amount = toNumberSafe(m.amount_l);
      if (!isFiniteNumber(amount) || amount <= 0) {
        warnings.push(
          buildWarning({
            type: "invalid_amount",
            movementId: m?.id || "",
            origin: `${originBase}:amount_l`,
            raw: { amount_l: m?.amount_l },
          })
        );
        return;
      }
      const fromId = m.fromNodeId != null ? String(m.fromNodeId) : null;
      const toId = m.toNodeId != null ? String(m.toNodeId) : null;
      if (fromId && !ids.has(fromId)) {
        warnings.push(
          buildWarning({
            type: "unknown_node",
            nodeId: fromId,
            movementId: m?.id || "",
            origin: `${originBase}:fromNodeId`,
            raw: { fromNodeId: m?.fromNodeId },
          })
        );
        return;
      }
      if (toId && !ids.has(toId)) {
        warnings.push(
          buildWarning({
            type: "unknown_node",
            nodeId: toId,
            movementId: m?.id || "",
            origin: `${originBase}:toNodeId`,
            raw: { toNodeId: m?.toNodeId },
          })
        );
        return;
      }
      limpios.push({
        id: m.id || `mov-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        fromNodeId: fromId,
        toNodeId: toId,
        amount_l: Number(amount),
        ts: m.ts || new Date().toISOString(),
        kind: m.kind || "AJUSTE",
      });
    });
    return { movements: dedupeMovements(limpios), warnings };
  };

  const normalizeCompositions = (comps = [], nodes = []) => {
    const warnings = [];
    const roleById = new Map();
    (Array.isArray(nodes) ? nodes : []).forEach(n => {
      const id = n?.id != null ? String(n.id) : "";
      if (!id) return;
      roleById.set(id, n?.role || roleFromType(n.tipo));
    });
    const limpios = [];
    (Array.isArray(comps) ? comps : []).forEach((c, idx) => {
      const originBase = `validateFlow:compositions[${idx}]`;
      if (!c || typeof c !== "object") {
        warnings.push(
          buildWarning({
            type: "invalid_composition",
            origin: originBase,
            raw: { composition: c },
          })
        );
        return;
      }
      const unit = (c.unit || "").toLowerCase();
      if (!["kg", "l"].includes(unit)) {
        warnings.push(
          buildWarning({
            type: "invalid_unit",
            compositionId: c?.id || "",
            origin: `${originBase}:unit`,
            raw: { unit: c?.unit },
          })
        );
        return;
      }
      const amount = toNumberSafe(c.amount);
      if (!isFiniteNumber(amount) || amount <= 0) {
        warnings.push(
          buildWarning({
            type: "invalid_amount",
            compositionId: c?.id || "",
            origin: `${originBase}:amount`,
            raw: { amount: c?.amount },
          })
        );
        return;
      }
      const breakdown = c.breakdown && typeof c.breakdown === "object" ? c.breakdown : null;
      if (!breakdown) {
        warnings.push(
          buildWarning({
            type: "invalid_breakdown",
            compositionId: c?.id || "",
            origin: `${originBase}:breakdown`,
            raw: { breakdown: c?.breakdown },
          })
        );
        return;
      }
      const limpioBreak = {};
      let suma = 0;
      Object.entries(breakdown).forEach(([variedad, valor]) => {
        const valNum = toNumberSafe(valor);
        if (!isFiniteNumber(valNum) || valNum <= 0) {
          warnings.push(
            buildWarning({
              type: "invalid_breakdown_value",
              compositionId: c?.id || "",
              origin: `${originBase}:breakdown:${variedad}`,
              raw: { variedad, valor },
            })
          );
          return;
        }
        limpioBreak[variedad] = Number(valNum);
        suma += Number(valNum);
      });
      if (!(suma > 0)) {
        warnings.push(
          buildWarning({
            type: "invalid_breakdown_sum",
            compositionId: c?.id || "",
            origin: `${originBase}:breakdown`,
            raw: { sum: suma, amount },
          })
        );
        return;
      }
      const tol = Math.max(0.01, amount * 0.005);
      if (Math.abs(suma - amount) > tol) {
        warnings.push(
          buildWarning({
            type: "invalid_breakdown_sum",
            compositionId: c?.id || "",
            origin: `${originBase}:breakdown_sum`,
            raw: { sum: Number(suma.toFixed(3)), amount },
          })
        );
      }

      const fromRef = c.fromRef || null;
      const toRef = c.toRef || null;
      const fromType = fromRef?.type || null;
      const toType = toRef?.type || null;
      const fromId = fromRef?.id != null ? String(fromRef.id) : null;
      const toId = toRef?.id != null ? String(toRef.id) : null;

      if (fromType && !["ENTRADA", "CONTAINER", "PROCESS"].includes(fromType)) {
        warnings.push(
          buildWarning({
            type: "invalid_ref",
            compositionId: c?.id || "",
            origin: `${originBase}:fromRef`,
            raw: { fromRef },
          })
        );
      }
      if (toType && !["PROCESS", "CONTAINER"].includes(toType)) {
        warnings.push(
          buildWarning({
            type: "invalid_ref",
            compositionId: c?.id || "",
            origin: `${originBase}:toRef`,
            raw: { toRef },
          })
        );
      }
      if (fromType === "CONTAINER" || fromType === "PROCESS") {
        if (!fromId || !roleById.has(fromId)) {
          warnings.push(
            buildWarning({
              type: "missing_ref",
              compositionId: c?.id || "",
              origin: `${originBase}:fromRef`,
              nodeId: fromId,
              raw: { fromRef },
            })
          );
          return;
        }
      }
      if (toType === "CONTAINER" || toType === "PROCESS") {
        if (!toId || !roleById.has(toId)) {
          warnings.push(
            buildWarning({
              type: "missing_ref",
              compositionId: c?.id || "",
              origin: `${originBase}:toRef`,
              nodeId: toId,
              raw: { toRef },
            })
          );
          return;
        }
      }

      limpios.push({
        id: c.id || `comp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        kind: c.kind || "CORRECCION",
        fromRef: fromRef ? { type: fromType, id: fromId } : null,
        toRef: toRef ? { type: toType, id: toId } : null,
        amount: Number(amount),
        unit,
        breakdown: limpioBreak,
        ts: c.ts || new Date().toISOString(),
      });
    });
    return { compositions: dedupeCompositions(limpios), warnings };
  };

  const sanitizeFlow = raw => {
    const base = normalizeInput(raw);
    const warnings = [];
    const rawNodes = Array.isArray(base.nodes) ? base.nodes : [];
    let movements = Array.isArray(base.movements) ? base.movements : [];
    let compositions = Array.isArray(base.compositions) ? base.compositions : [];
    let migrated = false;

    if (raw && !Array.isArray(raw.nodes) && !Array.isArray(raw)) {
      warnings.push(
        buildWarning({
          type: "invalid_nodes",
          origin: "validateFlow:nodes",
          raw: { nodes: raw?.nodes },
        })
      );
    }
    if (raw && !Array.isArray(raw.edges) && !Array.isArray(raw)) {
      warnings.push(
        buildWarning({
          type: "invalid_edges",
          origin: "validateFlow:edges",
          raw: { edges: raw?.edges },
        })
      );
    }
    if (raw && !Array.isArray(raw.movements) && !Array.isArray(raw)) {
      warnings.push(
        buildWarning({
          type: "invalid_movements",
          origin: "validateFlow:movements",
          raw: { movements: raw?.movements },
        })
      );
    }
    if (raw && !Array.isArray(raw.compositions) && !Array.isArray(raw)) {
      warnings.push(
        buildWarning({
          type: "invalid_compositions",
          origin: "validateFlow:compositions",
          raw: { compositions: raw?.compositions },
        })
      );
    }

    if ((base.schemaVersion || 1) < version) {
      const ajustes = [];
      rawNodes.forEach(n => {
        const role = roleFromType(n?.tipo);
        if (role !== "CONTAINER") return;
        const vol = extractLegacyVolume(n);
        if (!isFiniteNumber(vol) || !(vol > 0)) return;
        if (!n?.id) return;
        ajustes.push({
          id: `aj-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          fromNodeId: null,
          toNodeId: n.id,
          amount_l: Number(vol),
          ts: new Date().toISOString(),
          kind: "AJUSTE",
        });
      });
      if (ajustes.length) movements = [...movements, ...ajustes];
      migrated = true;
    }

    let nodes = rawNodes.map((nodo, idx) => {
      const limpio = sanitizeNode(nodo);
      if (!nodo?.role) {
        warnings.push(
          buildWarning({
            type: "unknown_role",
            origin: `validateFlow:nodes[${idx}]:role`,
            nodeId: nodo?.id,
            raw: { role: nodo?.role, tipo: nodo?.tipo },
          })
        );
      }
      return limpio;
    });
    nodes.forEach(n => {
      if (!n) return;
      n.role = n.role || roleFromType(n.tipo);
    });

    // Edge warnings antes de filtrar
    const ids = new Set(nodes.map(n => String(n?.id)).filter(Boolean));
    (Array.isArray(base.edges) ? base.edges : []).forEach((e, idx) => {
      const from = e?.from ?? e?.source ?? e?.origen ?? e?.fromNodeId ?? null;
      const to = e?.to ?? e?.target ?? e?.destino ?? e?.toNodeId ?? null;
      const fromId = from != null ? String(from) : "";
      const toId = to != null ? String(to) : "";
      if (!fromId || !toId || !ids.has(fromId) || !ids.has(toId)) {
        warnings.push(
          buildWarning({
            type: "bad_edge_ref",
            origin: `validateFlow:edges[${idx}]`,
            raw: { edge: e },
          })
        );
      }
    });

    let edges = normalizeEdges(base.edges, nodes);
    if (!edges.length) edges = buildEdgesFromTargets(nodes);
    applyEdgesTargets(nodes, edges);

    const movRes = normalizeMovements(movements, nodes);
    movements = movRes.movements;
    warnings.push(...movRes.warnings);

    const compRes = normalizeCompositions(compositions, nodes);
    compositions = compRes.compositions;
    warnings.push(...compRes.warnings);

    return {
      flow: { schemaVersion: version, nodes, edges, movements, compositions },
      warnings,
      migrated,
    };
  };

  const validateFlow = raw => {
    const { flow, warnings, migrated } = sanitizeFlow(raw);
    return { warnings, normalizedFlow: flow, migrated };
  };

  const computeBalances = (nodes = [], movements = []) => {
    const balances = new Map();
    const warnings = [];
    const roleById = new Map();
    (Array.isArray(nodes) ? nodes : []).forEach(n => {
      const id = n?.id != null ? String(n.id) : "";
      if (!id) return;
      const role = n?.role || roleFromType(n.tipo);
      roleById.set(id, role);
      if (role === "CONTAINER") balances.set(id, 0);
    });
    (Array.isArray(movements) ? movements : []).forEach((m, idx) => {
      const originBase = `computeBalances:movements[${idx}]`;
      const amount = toNumberSafe(m?.amount_l);
      if (!isFiniteNumber(amount) || amount <= 0) {
        warnings.push(
          buildWarning({
            type: "invalid_amount",
            movementId: m?.id || "",
            origin: `${originBase}:amount_l`,
            raw: { amount_l: m?.amount_l },
          })
        );
        return;
      }
      const fromId = m?.fromNodeId != null ? String(m.fromNodeId) : null;
      const toId = m?.toNodeId != null ? String(m.toNodeId) : null;
      if (fromId && !roleById.has(fromId)) {
        warnings.push(
          buildWarning({
            type: "unknown_node",
            nodeId: fromId,
            movementId: m?.id || "",
            origin: `${originBase}:fromNodeId`,
            raw: { fromNodeId: m?.fromNodeId },
          })
        );
      }
      if (toId && !roleById.has(toId)) {
        warnings.push(
          buildWarning({
            type: "unknown_node",
            nodeId: toId,
            movementId: m?.id || "",
            origin: `${originBase}:toNodeId`,
            raw: { toNodeId: m?.toNodeId },
          })
        );
      }
      if (toId && roleById.has(toId) && roleById.get(toId) !== "CONTAINER") {
        warnings.push(
          buildWarning({
            type: "non_container_ref",
            nodeId: toId,
            movementId: m?.id || "",
            origin: `${originBase}:toNodeId`,
            raw: { toNodeId: m?.toNodeId },
          })
        );
      }
      if (fromId && roleById.has(fromId) && roleById.get(fromId) !== "CONTAINER") {
        warnings.push(
          buildWarning({
            type: "non_container_ref",
            nodeId: fromId,
            movementId: m?.id || "",
            origin: `${originBase}:fromNodeId`,
            raw: { fromNodeId: m?.fromNodeId },
          })
        );
      }
      if (toId && roleById.get(toId) === "CONTAINER") {
        const actual = balances.get(toId) || 0;
        balances.set(toId, actual + amount);
      }
      if (fromId && roleById.get(fromId) === "CONTAINER") {
        const nuevo = (balances.get(fromId) || 0) - amount;
        if (nuevo < 0) {
          warnings.push(
            buildWarning({
              type: "negative_balance",
              nodeId: fromId,
              movementId: m?.id || "",
              origin: `computeBalances:node:${fromId}:negative_balance`,
              raw: { balance_before: balances.get(fromId) || 0, amount_l: amount },
            })
          );
          balances.set(fromId, 0);
        } else {
          balances.set(fromId, nuevo);
        }
      }
    });
    return { balances, warnings };
  };

  const computeCompositions = (nodes = [], compositions = []) => {
    const warnings = [];
    const roleById = new Map();
    (Array.isArray(nodes) ? nodes : []).forEach(n => {
      const id = n?.id != null ? String(n.id) : "";
      if (!id) return;
      roleById.set(id, n?.role || roleFromType(n.tipo));
    });

    const compMap = new Map();
    const applyBreakdown = (key, breakdown, signo) => {
      if (!key) return;
      if (!compMap.has(key)) compMap.set(key, { total: 0, breakdown: {} });
      const entry = compMap.get(key);
      Object.entries(breakdown || {}).forEach(([variedad, valor]) => {
        const valNum = toNumberSafe(valor);
        if (!isFiniteNumber(valNum) || valNum <= 0) return;
        entry.breakdown[variedad] = (entry.breakdown[variedad] || 0) + signo * valNum;
        entry.total += signo * valNum;
      });
    };

    (Array.isArray(compositions) ? compositions : []).forEach((c, idx) => {
      const originBase = `computeCompositions:compositions[${idx}]`;
      if (!c || typeof c !== "object") {
        warnings.push(
          buildWarning({
            type: "invalid_composition",
            origin: originBase,
            raw: { composition: c },
          })
        );
        return;
      }
      const unit = (c.unit || "").toLowerCase();
      if (!["kg", "l"].includes(unit)) {
        warnings.push(
          buildWarning({
            type: "invalid_unit",
            compositionId: c?.id || "",
            origin: `${originBase}:unit`,
            raw: { unit: c?.unit },
          })
        );
        return;
      }
      const amount = toNumberSafe(c.amount);
      if (!isFiniteNumber(amount) || amount <= 0) {
        warnings.push(
          buildWarning({
            type: "invalid_amount",
            compositionId: c?.id || "",
            origin: `${originBase}:amount`,
            raw: { amount: c?.amount },
          })
        );
        return;
      }
      const breakdown = c.breakdown && typeof c.breakdown === "object" ? c.breakdown : null;
      if (!breakdown) {
        warnings.push(
          buildWarning({
            type: "invalid_breakdown",
            compositionId: c?.id || "",
            origin: `${originBase}:breakdown`,
            raw: { breakdown: c?.breakdown },
          })
        );
        return;
      }

      const fromRef = c.fromRef || null;
      const toRef = c.toRef || null;
      const fromType = fromRef?.type || null;
      const toType = toRef?.type || null;
      const fromId = fromRef?.id != null ? String(fromRef.id) : null;
      const toId = toRef?.id != null ? String(toRef.id) : null;

      if (fromType === "CONTAINER" || fromType === "PROCESS") {
        if (!fromId || !roleById.has(fromId)) {
          warnings.push(
            buildWarning({
              type: "missing_ref",
              compositionId: c?.id || "",
              origin: `${originBase}:fromRef`,
              nodeId: fromId,
              raw: { fromRef },
            })
          );
          return;
        }
      }
      if (toType === "CONTAINER" || toType === "PROCESS") {
        if (!toId || !roleById.has(toId)) {
          warnings.push(
            buildWarning({
              type: "missing_ref",
              compositionId: c?.id || "",
              origin: `${originBase}:toRef`,
              nodeId: toId,
              raw: { toRef },
            })
          );
          return;
        }
      }

      if (fromType === "CONTAINER" || fromType === "PROCESS") {
        applyBreakdown(`${fromType}:${fromId}`, breakdown, -1);
      }
      if (toType === "CONTAINER" || toType === "PROCESS") {
        applyBreakdown(`${toType}:${toId}`, breakdown, +1);
      }
    });

    // Normalizar negativos residuales (warning)
    compMap.forEach((entry, key) => {
      if (entry.total < -0.0001) {
        warnings.push(
          buildWarning({
            type: "negative_composition",
            origin: `computeCompositions:${key}`,
            raw: { total: entry.total },
          })
        );
      }
    });

    return { compositions: compMap, warnings };
  };

  return {
    version,
    sanitizeKeys: FLOW_SANITIZE_KEYS,
    isFiniteNumber,
    toNumberSafe,
    clamp0,
    roleFromType,
    sanitizeFlow,
    validateFlow,
    computeBalances,
    computeCompositions,
    normalizeInput,
    normalizeMovements,
    normalizeCompositions,
    normalizeEdges,
    buildEdgesFromTargets,
    applyEdgesTargets,
    sanitizeNode,
  };
})();

function isFiniteNumber(val) {
  return FLOW_CORE.isFiniteNumber(val);
}
function toNumberSafe(val) {
  return FLOW_CORE.toNumberSafe(val);
}
function clamp0(val) {
  return FLOW_CORE.clamp0(val);
}

function mapearRolPorTipo(tipo) {
  return FLOW_CORE.roleFromType(tipo);
}

function asignarRolNodo(nodo) {
  if (!nodo || typeof nodo !== "object") return nodo;
  nodo.role = nodo.role || mapearRolPorTipo(nodo.tipo);
  return nodo;
}

function sanitizarNodoParaLedger(nodo) {
  return FLOW_CORE.sanitizeNode(nodo);
}

function sanitizarMovimientos(movimientos = [], nodes = []) {
  return FLOW_CORE.normalizeMovements(movimientos, nodes).movements;
}

function sanitizarComposiciones(composiciones = [], nodes = []) {
  return FLOW_CORE.normalizeCompositions(composiciones, nodes).compositions;
}

function sanitizeFlow(flow) {
  return FLOW_CORE.sanitizeFlow(flow);
}

function validateFlow(flow) {
  return FLOW_CORE.validateFlow(flow);
}

function computeBalances(nodes = [], movements = []) {
  return FLOW_CORE.computeBalances(nodes, movements);
}

function computeCompositions(nodes = [], compositions = []) {
  return FLOW_CORE.computeCompositions(nodes, compositions);
}

function recalcularBalancesFlow() {
  const resultado = computeBalances(flujoNodos, flowMovements);
  const compRes = computeCompositions(flujoNodos, flowCompositions);
  flowBalances = resultado.balances;
  flowCompositionMap = compRes.compositions;
  const baseWarnings = Array.isArray(flowCoreWarnings) ? flowCoreWarnings : [];
  const calcWarnings = Array.isArray(resultado.warnings) ? resultado.warnings : [];
  const compWarnings = Array.isArray(compRes.warnings) ? compRes.warnings : [];
  const extraWarnings = generarWarningsEntradasFaltantes();
  flowWarnings = [...baseWarnings, ...calcWarnings, ...compWarnings, ...extraWarnings];
  flowBalancesDirty = false;
  flowCompositionsDirty = false;
  actualizarFlowWarningsUI();
}

function obtenerBalanceNodo(id) {
  if (flowBalancesDirty) recalcularBalancesFlow();
  const key = id != null ? String(id) : "";
  return key ? flowBalances.get(key) ?? null : null;
}

function obtenerEntradaIdDesdeNodo(nodo) {
  if (!nodo) return null;
  const datos = nodo.datos || {};
  const id = datos.entradaId ?? datos.entryId ?? datos.entrada_id ?? datos.id_ref ?? null;
  if (id == null || id === "") return null;
  return Number.isFinite(Number(id)) ? Number(id) : String(id);
}

function obtenerEntradaRealDesdeNodo(nodo) {
  const entradaId = obtenerEntradaIdDesdeNodo(nodo);
  if (!entradaId || !Array.isArray(cacheEntradas)) return null;
  return cacheEntradas.find(e => String(e.id) === String(entradaId)) || null;
}

function obtenerKilosEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return null;
  const kilos =
    normalizarNumero(entrada.kilos) ??
    normalizarNumero(entrada.kilos_total) ??
    normalizarNumero(entrada.total_kilos) ??
    normalizarNumero(entrada.kilos_uva) ??
    normalizarNumero(entrada.peso) ??
    normalizarNumero(entrada.kg);
  return kilos != null ? kilos : null;
}

function obtenerDensidadEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return null;
  return normalizarNumero(entrada.densidad);
}

function obtenerTemperaturaEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return null;
  return normalizarNumero(entrada.temperatura);
}

function obtenerPhEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return null;
  return normalizarNumero(entrada.ph);
}

function obtenerAcidezTotalEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return null;
  return normalizarNumero(entrada.acidez_total);
}

function obtenerFechaEntradaDesdeNodo(nodo) {
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (entrada) {
    const fechaEntrada =
      entrada.fecha ||
      entrada.fecha_entrada ||
      entrada.fecha_recepcion ||
      entrada.fecha_registro ||
      "";
    if (fechaEntrada) return formatearFechaCorta(fechaEntrada);
  }
  const fechaFallback =
    nodo?.datos?.fecha_entrada_bodega ||
    nodo?.datos?.fecha_entrada ||
    "";
  return fechaFallback ? formatearFechaCorta(fechaFallback) : "";
}

function generarWarningsEntradasFaltantes() {
  const warnings = [];
  (Array.isArray(flujoNodos) ? flujoNodos : []).forEach((nodo, idx) => {
    const role = obtenerRolNodo(nodo);
    if (role !== "SOURCE") return;
    const entradaId = obtenerEntradaIdDesdeNodo(nodo);
    if (!entradaId) {
      warnings.push(
        {
          type: "missing_ref",
          msg: "Nodo de entrada sin ID de entrada.",
          origin: `validateFlow:nodes[${idx}]:entradaId`,
          nodeId: nodo?.id,
          raw: { entradaId },
        }
      );
      return;
    }
    const entrada = obtenerEntradaRealDesdeNodo(nodo);
    if (!entrada) {
      warnings.push(
        {
          type: "missing_ref",
          msg: "Entrada no encontrada en el sistema.",
          origin: `validateFlow:nodes[${idx}]:entradaId`,
          nodeId: nodo?.id,
          raw: { entradaId },
        }
      );
    }
  });
  return warnings;
}

function mensajeWarning(w) {
  if (!w) return "Inconsistencia detectada.";
  if (w.msg) return w.msg;
  if (w.type === "invalid_amount") return "Movimiento con cantidad inválida (se ignora).";
  if (w.type === "negative_balance") return "Balance negativo en contenedor (se ajusta a 0).";
  if (w.type === "unknown_node") return "Movimiento con nodo inexistente (se ignora).";
  if (w.type === "invalid_movement") return "Movimiento malformado (se ignora).";
  if (w.type === "invalid_composition") return "Composición malformada (se ignora).";
  if (w.type === "invalid_unit") return "Composición con unidad inválida (se ignora).";
  if (w.type === "invalid_breakdown") return "Composición sin desglose válido (se ignora).";
  if (w.type === "invalid_breakdown_value") return "Composición con valor inválido en desglose.";
  if (w.type === "invalid_breakdown_sum") return "Composición con suma de desglose incoherente.";
  if (w.type === "invalid_ref") return "Composición con referencia inválida.";
  if (w.type === "invalid_compositions") return "Composiciones inválidas (se normaliza).";
  if (w.type === "missing_ref") return "Referencia inexistente en composición.";
  if (w.type === "bad_edge_ref") return "Arista con referencia inválida (se ignora).";
  if (w.type === "unknown_role") return "Nodo sin rol definido (se asigna por tipo).";
  if (w.type === "negative_composition") return "Composición negativa detectada.";
  if (w.type === "non_container_ref") return "Movimiento apunta a nodo que no es contenedor.";
  return "Aviso del ledger.";
}

function actualizarFlowWarningsUI() {
  const chip = document.getElementById("flowWarningsChip");
  const countEl = document.getElementById("flowWarningsCount");
  if (!chip || !countEl) return;
  const count = Array.isArray(flowWarnings) ? flowWarnings.length : 0;
  countEl.textContent = String(count);
  chip.classList.toggle("is-hidden", count === 0);
  flowWarningNodes = new Set(
    (flowWarnings || []).map(w => (w?.nodeId != null ? String(w.nodeId) : null)).filter(Boolean)
  );
  renderFlowWarningsPanel();
}

function renderFlowWarningsPanel() {
  const panel = document.getElementById("flowWarningsPanel");
  const list = document.getElementById("flowWarningsList");
  if (!panel || !list) return;
  const warnings = Array.isArray(flowWarnings) ? flowWarnings : [];
  list.innerHTML = "";
  if (!warnings.length) {
    panel.classList.remove("is-visible");
    return;
  }
  const debug = flowWarningsDebug === true;
  const rawToString = raw => {
    if (raw == null) return "";
    try {
      return JSON.stringify(raw);
    } catch (_err) {
      return String(raw);
    }
  };
  warnings.forEach(w => {
    const item = document.createElement("div");
    item.className = "flow-warning-item";
    const nodeTxt = w.nodeId ? `Nodo: ${w.nodeId}` : "Nodo: —";
    const movTxt = w.movementId ? `Movimiento: ${w.movementId}` : "Movimiento: —";
    const originTxt = w.origin ? `Origen: ${w.origin}` : "Origen: —";
    const rawTxt = w.raw != null ? `Raw: ${rawToString(w.raw)}` : "";
    const acciones = w.type === "invalid_amount" && w.movementId
      ? `<div class="flow-warning-actions">
          <button type="button" data-action="edit">Editar</button>
          <button type="button" data-action="delete">Eliminar</button>
        </div>`
      : "";
    item.innerHTML = `
      <strong>${mensajeWarning(w)}</strong>
      <div>${nodeTxt}</div>
      <div>${movTxt}</div>
      ${debug ? `<div class="flow-warning-debug">${originTxt}</div>` : ""}
      ${debug && rawTxt ? `<div class="flow-warning-debug">${rawTxt}</div>` : ""}
      ${acciones}
    `;
    item.addEventListener("click", () => {
      if (w.nodeId) {
        resaltarNodoTemporal(w.nodeId);
      }
    });
    if (w.type === "invalid_amount" && w.movementId) {
      const btnEdit = item.querySelector("button[data-action='edit']");
      const btnDelete = item.querySelector("button[data-action='delete']");
      if (btnEdit) {
        btnEdit.addEventListener("click", ev => {
          ev.stopPropagation();
          abrirFlowMovementModal(w.movementId);
        });
      }
      if (btnDelete) {
        btnDelete.addEventListener("click", ev => {
          ev.stopPropagation();
          eliminarMovimientoFlow(w.movementId);
        });
      }
    }
    list.appendChild(item);
  });
}

function toggleFlowWarningsPanel() {
  const panel = document.getElementById("flowWarningsPanel");
  if (!panel) return;
  panel.classList.toggle("is-visible");
}

function cargarFlowWarningsDebug() {
  try {
    const raw = localStorage.getItem("flowWarningsDebug");
    flowWarningsDebug = raw === "1";
  } catch (_err) {
    flowWarningsDebug = false;
  }
  const toggle = document.getElementById("flowWarningsDebugToggle");
  if (toggle) {
    toggle.checked = flowWarningsDebug === true;
  }
}

function setFlowWarningsDebug(valor) {
  flowWarningsDebug = Boolean(valor);
  try {
    localStorage.setItem("flowWarningsDebug", flowWarningsDebug ? "1" : "0");
  } catch (_err) {
    // noop
  }
  renderFlowWarningsPanel();
}

function validarAmountLitros(valor) {
  const num = Number(valor);
  if (!Number.isFinite(num) || num <= 0) {
    return { ok: false, msg: "La cantidad debe ser un número mayor que 0." };
  }
  return { ok: true, value: num };
}

function buscarMovimientoFlowPorId(id) {
  if (!id) return null;
  return (flowMovements || []).find(m => String(m?.id) === String(id)) || null;
}

function crearMovimientoFlow({ fromNodeId = null, toNodeId = null, amount_l, kind = "AJUSTE", ts = null } = {}) {
  const val = validarAmountLitros(amount_l);
  if (!val.ok) {
    mostrarAviso(val.msg, "error");
    return { ok: false, error: val.msg };
  }
  const movimiento = {
    id: `mov-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    fromNodeId: fromNodeId != null ? String(fromNodeId) : null,
    toNodeId: toNodeId != null ? String(toNodeId) : null,
    amount_l: Number(val.value.toFixed(2)),
    kind,
    ts: ts || new Date().toISOString(),
  };
  flowMovements = Array.isArray(flowMovements) ? flowMovements : [];
  flowMovements.push(movimiento);
  guardarEstadoNodos();
  flowBalancesDirty = true;
  recalcularBalancesFlow();
  renderFlowNodes();
  return { ok: true, movimiento };
}

function abrirFlowMovementModal(movementId) {
  const movimiento = buscarMovimientoFlowPorId(movementId);
  if (!movimiento) {
    mostrarAviso("No se encontró el movimiento.", "error");
    return;
  }
  flowMovementEditingId = String(movimiento.id);
  const modal = document.getElementById("flowMovementModal");
  const input = document.getElementById("flowMovementAmount");
  const error = document.getElementById("flowMovementError");
  if (input) {
    input.value = movimiento.amount_l != null ? String(movimiento.amount_l) : "";
    setTimeout(() => input.focus(), 0);
  }
  if (error) error.textContent = "";
  if (modal) modal.classList.add("visible");
}

function cerrarFlowMovementModal() {
  flowMovementEditingId = null;
  const modal = document.getElementById("flowMovementModal");
  if (modal) modal.classList.remove("visible");
}

function guardarMovimientoFlowDesdeModal() {
  const input = document.getElementById("flowMovementAmount");
  const error = document.getElementById("flowMovementError");
  if (!input) return;
  const val = validarAmountLitros(input.value);
  if (!val.ok) {
    if (error) error.textContent = val.msg;
    input.focus();
    return;
  }
  const movimiento = buscarMovimientoFlowPorId(flowMovementEditingId);
  if (!movimiento) {
    if (error) error.textContent = "No se encontró el movimiento.";
    return;
  }
  movimiento.amount_l = Number(val.value.toFixed(2));
  guardarEstadoNodos();
  flowBalancesDirty = true;
  recalcularBalancesFlow();
  renderFlowNodes();
  cerrarFlowMovementModal();
  mostrarAviso("Movimiento actualizado.", "success");
}

function eliminarMovimientoFlow(movementId) {
  if (!movementId) return;
  const ok = confirm("¿Eliminar este movimiento inválido? Esta acción no se puede deshacer.");
  if (!ok) return;
  const prevLen = flowMovements.length;
  flowMovements = (flowMovements || []).filter(m => String(m?.id) !== String(movementId));
  if (flowMovements.length === prevLen) {
    mostrarAviso("No se encontró el movimiento.", "error");
    return;
  }
  guardarEstadoNodos();
  flowBalancesDirty = true;
  recalcularBalancesFlow();
  renderFlowNodes();
  mostrarAviso("Movimiento eliminado.", "success");
}

async function toggleFlowBackupsPanel() {
  const panel = document.getElementById("flowBackupsPanel");
  if (!panel) return;
  const isVisible = panel.classList.toggle("is-visible");
  if (isVisible) {
    await cargarFlowBackups();
  }
}

async function cargarFlowBackups() {
  const list = document.getElementById("flowBackupsList");
  if (!list) return;
  list.innerHTML = "<div class='flow-inspector-sub'>Cargando backups...</div>";
  try {
    const res = await fetch("/api/flujo/backups");
    if (!res.ok) throw new Error("Error cargando backups");
    const data = await res.json();
    const backups = Array.isArray(data.backups) ? data.backups : [];
    list.innerHTML = "";
    if (!backups.length) {
      list.innerHTML = "<div class='flow-inspector-sub'>No hay backups disponibles.</div>";
      return;
    }
    backups.forEach((b, idx) => {
      const item = document.createElement("div");
      item.className = "flow-warning-item";
      const fecha = formatearFechaBackup(b.created_at);
      const etiqueta = idx === 0 ? "Último" : "Snapshot";
      item.innerHTML = `
        <strong>${etiqueta} · ${fecha}</strong>
        <div>ID: ${b.id}</div>
      `;
      item.addEventListener("click", () => restaurarSnapshotPorId(b.id, fecha));
      list.appendChild(item);
    });
  } catch (err) {
    console.error("Error cargando backups:", err);
    list.innerHTML = `
      <div class='flow-inspector-sub'>No se pudieron cargar los backups.</div>
      <button type="button" class="btnSecundario" id="flowRestoreLatestBtn">Restaurar último mapa</button>
    `;
    const btn = document.getElementById("flowRestoreLatestBtn");
    if (btn) btn.addEventListener("click", restaurarSnapshotUltimo);
  }
}

function formatearFechaBackup(fechaIso) {
  if (!fechaIso) return "Sin fecha";
  const d = new Date(fechaIso.replace(" ", "T"));
  if (Number.isNaN(d.getTime())) return fechaIso;
  return d.toLocaleString("es-ES", { day: "2-digit", month: "2-digit", hour: "2-digit", minute: "2-digit" });
}

async function restaurarSnapshotPorId(backupId, fechaTxt = "") {
  const ok = confirm(`Vas a restaurar el snapshot de: ${fechaTxt || backupId}. ¿Continuar?`);
  if (!ok) return;
  try {
    const res = await fetch("/api/flujo/restore", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(backupId ? { backup_id: backupId } : {}),
    });
    if (!res.ok) {
      mostrarAviso("No se pudo restaurar el snapshot.", "error");
      return;
    }
    const data = await res.json();
    const raw = data.flow ?? data.nodos ?? data;
    const normalizado = migrarSnapshotLegacy(raw);
    flujoNodos = normalizado.nodes;
    flowMovements = normalizado.movements;
    flowEdges = normalizado.edges || [];
    flowCompositions = normalizado.compositions || [];
    flowSchemaVersion = normalizado.schemaVersion;
    flowCompositionsDirty = true;
    flowBalancesDirty = true;
    normalizarFlujoNodos();
    recalcularBalancesFlow();
    renderFlowNodes();
    guardarEstadoNodos();
    registrarMapaNodosEvento({
      resumen: `Restaurar mapa · ${fechaTxt || "snapshot"}`,
      detalle: `Se restauró un snapshot del mapa de nodos (${fechaTxt || "sin fecha"}).`,
      contenedores: [],
      meta: { accion: "mapa_nodos", evento: "restaurar_mapa", backup_id: backupId || null },
      noteType: "accion",
      tipoEvento: "nota",
    });
    mostrarAviso("Snapshot restaurado correctamente.", "success");
  } catch (err) {
    console.error("Error restaurando snapshot:", err);
    mostrarAviso("No se pudo restaurar el snapshot.", "error");
  }
}

function restaurarSnapshotUltimo() {
  restaurarSnapshotPorId(null, "Último snapshot");
}

function resolverNodoEventoMapa(evento) {
  const meta = evento?.meta || {};
  const candidatos = [
    meta.destino_nodo,
    meta.nodo_id,
    meta.origen_nodo,
  ];
  for (const cand of candidatos) {
    const id = normalizarIdNodo(cand);
    if (!id) continue;
    if (buscarNodoPorId(id)) return id;
  }
  return "";
}

function formatearFechaEventoMapa(valor) {
  const ms = parseFechaMs(valor);
  if (!ms) return "sin fecha";
  const fecha = new Date(ms);
  const abs = fecha.toLocaleString("es-ES", {
    day: "2-digit",
    month: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
  const rel = formatearTiempoRelativo(ms);
  return `${abs} · ${rel}`;
}

function obtenerUltimoSnapshotTexto(backups = []) {
  const lista = Array.isArray(backups) ? backups : [];
  if (!lista.length) return "Snapshot: sin backups";
  const primero = lista[0] || {};
  const fecha = formatearFechaBackup(primero.created_at || "");
  return `Snapshot: último válido ${fecha}`;
}

function renderFlowTimelinePanel(eventos = [], snapshotTxt = "") {
  const list = document.getElementById("flowTimelineList");
  const snapshot = document.getElementById("flowTimelineSnapshot");
  if (!list || !snapshot) return;
  snapshot.textContent = snapshotTxt || "Snapshot: —";
  list.innerHTML = "";
  const items = Array.isArray(eventos) ? eventos : [];
  if (!items.length) {
    list.innerHTML = "<div class='flow-inspector-sub'>Aún no hay cambios de mapa registrados.</div>";
    return;
  }
  items.forEach(evt => {
    const item = document.createElement("div");
    item.className = "flow-timeline-item";
    const resumen = (evt.resumen || "Cambio de mapa").toString();
    const fechaTxt = formatearFechaEventoMapa(evt.fecha_hora);
    const meta = evt.meta || {};
    const detalle =
      meta?.evento === "conexion" || meta?.evento === "desconexion"
        ? `${meta.origen || "Origen"} → ${meta.destino || "Destino"}`
        : (evt.detalle || "").toString().split("\n")[0];
    const nodoCentrar = resolverNodoEventoMapa(evt);
    item.innerHTML = `
      <strong>${resumen}</strong>
      ${detalle ? `<div>${detalle}</div>` : ""}
      <div class="flow-timeline-meta">
        <span>${fechaTxt}</span>
        <span>Usuario actual</span>
      </div>
      <div class="flow-timeline-actions">
        <button type="button" data-action="center" ${nodoCentrar ? "" : "disabled"}>Centrar nodo</button>
      </div>
    `;
    const btnCenter = item.querySelector("button[data-action='center']");
    if (btnCenter && nodoCentrar) {
      btnCenter.addEventListener("click", ev => {
        ev.stopPropagation();
        resaltarNodoTemporal(nodoCentrar);
      });
    }
    list.appendChild(item);
  });
}

async function cargarFlowTimelinePanel(forzar = false) {
  const panel = document.getElementById("flowTimelinePanel");
  const list = document.getElementById("flowTimelineList");
  if (!panel || !list) return;
  if (!forzar && !panel.classList.contains("is-visible")) return;
  list.innerHTML = "<div class='flow-inspector-sub'>Cargando cambios del mapa...</div>";
  try {
    const [resEventos, resBackups] = await Promise.all([
      fetch("/api/eventos?scope=contenedor&limit=120"),
      fetch("/api/flujo/backups"),
    ]);
    let eventos = [];
    let snapshotTxt = "Snapshot: sin backups";
    if (resEventos.ok) {
      const dataEventos = await resEventos.json().catch(() => ({}));
      const listaEventos = Array.isArray(dataEventos.eventos) ? dataEventos.eventos : [];
      eventos = listaEventos
        .filter(evt => {
          const meta = evt?.meta || {};
          return evt?.origen === "control" && meta?.accion === "mapa_nodos";
        })
        .slice(0, 25);
    }
    if (resBackups.ok) {
      const dataBackups = await resBackups.json().catch(() => ({}));
      snapshotTxt = obtenerUltimoSnapshotTexto(dataBackups.backups);
    }
    renderFlowTimelinePanel(eventos, snapshotTxt);
  } catch (err) {
    console.error("No se pudo cargar timeline de mapa:", err);
    list.innerHTML = "<div class='flow-inspector-sub'>No se pudieron cargar los cambios del mapa.</div>";
  }
}

function programarActualizacionFlowTimeline() {
  if (flowTimelineRefreshTimer) {
    clearTimeout(flowTimelineRefreshTimer);
  }
  flowTimelineRefreshTimer = setTimeout(() => {
    flowTimelineRefreshTimer = null;
    cargarFlowTimelinePanel();
  }, 250);
}

function toggleFlowTimelinePanel() {
  const panel = document.getElementById("flowTimelinePanel");
  if (!panel) return;
  const visible = panel.classList.toggle("is-visible");
  if (visible) {
    cargarFlowTimelinePanel(true);
  }
}

function resaltarNodoTemporal(nodeId) {
  const id = nodeId != null ? String(nodeId) : "";
  if (!id) return;
  const nodo = obtenerNodoPorId(id);
  if (!nodo) return;
  centrarNodoFlowEnVista(nodo);
  const canvas = document.getElementById("flowCanvas");
  const el = canvas ? canvas.querySelector(`.flow-node[data-id="${CSS.escape(id)}"]`) : null;
  if (!el) return;
  el.classList.add("is-warning-highlight");
  setTimeout(() => el.classList.remove("is-warning-highlight"), 2000);
}

async function copiarDiagnosticoFlow() {
  const now = new Date().toISOString();
  const lines = [];
  lines.push(`[flow][diag] ${now}`);
  lines.push(
    `schemaVersion=${flowSchemaVersion} nodes=${flujoNodos.length} edges=${flowEdges.length} movements=${flowMovements.length} warnings=${flowWarnings.length}`
  );
  const rawToString = raw => {
    if (raw == null) return "";
    try {
      return JSON.stringify(raw);
    } catch (_err) {
      return String(raw);
    }
  };
  flowWarnings.forEach(w => {
    const msg = mensajeWarning(w);
    const nodeTxt = w.nodeId ? `nodeId=${w.nodeId}` : "";
    const movTxt = w.movementId ? `movementId=${w.movementId}` : "";
    const originTxt = w.origin ? `origin=${w.origin}` : "";
    const rawTxt = w.raw != null ? `raw=${rawToString(w.raw)}` : "";
    lines.push(
      `- ${w.type} ${nodeTxt} ${movTxt} ${originTxt} ${msg} ${rawTxt}`.trim()
    );
  });
  const texto = lines.join("\n");
  try {
    await navigator.clipboard.writeText(texto);
    mostrarAviso("Diagnóstico copiado.", "success");
  } catch (err) {
    try {
      const ta = document.createElement("textarea");
      ta.value = texto;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      mostrarAviso("Diagnóstico copiado.", "success");
    } catch (e) {
      mostrarAviso("No se pudo copiar el diagnóstico.", "error");
    }
  }
}

function normalizarFlowSnapshot(raw) {
  return FLOW_CORE.normalizeInput(raw);
}

function migrarSnapshotLegacy(raw) {
  const { warnings, normalizedFlow, migrated } = validateFlow(raw);
  flowCoreWarnings = Array.isArray(warnings) ? warnings : [];
  flowCoreMigrated = Boolean(migrated);
  return normalizedFlow;
}

function movimientosUnicos(movs = []) {
  const seen = new Set();
  return movs.filter(m => {
    const id = m?.id || "";
    if (!id) return true;
    if (seen.has(id)) return false;
    seen.add(id);
    return true;
  });
}

function normalizarEdges(edges = [], nodes = []) {
  const ids = new Set(nodes.map(n => String(n?.id)));
  return (Array.isArray(edges) ? edges : [])
    .map(e => ({
      from: e.from ?? e.source ?? e.origen ?? e.fromNodeId ?? null,
      to: e.to ?? e.target ?? e.destino ?? e.toNodeId ?? null,
    }))
    .filter(e => e.from != null && e.to != null)
    .map(e => ({ from: String(e.from), to: String(e.to) }))
    .filter(e => ids.has(e.from) && ids.has(e.to));
}

function construirEdgesDesdeTargets(nodes = []) {
  const edges = [];
  nodes.forEach(n => {
    const from = n?.id != null ? String(n.id) : "";
    if (!from || !Array.isArray(n.targets)) return;
    n.targets.forEach(t => {
      const to = t != null ? String(t) : "";
      if (!to) return;
      edges.push({ from, to });
    });
  });
  return normalizarEdges(edges, nodes);
}

function aplicarEdgesEnTargets(nodes = [], edges = []) {
  const mapa = new Map();
  nodes.forEach(n => {
    if (!n || n.id == null) return;
    mapa.set(String(n.id), []);
  });
  edges.forEach(e => {
    if (!mapa.has(e.from)) return;
    mapa.get(e.from).push(e.to);
  });
  nodes.forEach(n => {
    const id = n?.id != null ? String(n.id) : "";
    if (!id) return;
    const targets = mapa.get(id) || [];
    n.targets = Array.from(new Set(targets));
  });
}

function hidratarNodosContenedor(nodes = []) {
  nodes.forEach(n => {
    if (!n || n.tipo === "entrada") return;
    const role = mapearRolPorTipo(n.tipo);
    if (role !== "CONTAINER") return;
    n.datos = n.datos || {};
    if (n.tipo === "deposito") {
      if (n.datos.containerId != null && n.datos.id_ref == null) {
        n.datos.id_ref = n.datos.containerId;
      }
      if (n.datos.name && !n.datos.codigo) n.datos.codigo = n.datos.name;
      if (n.datos.capacity_l != null && n.datos.capacidad_l == null) {
        n.datos.capacidad_l = n.datos.capacity_l;
      }
    }
    if (n.tipo === "barrica") {
      if (n.datos.containerId != null && n.datos.contenedor_id == null) {
        n.datos.contenedor_id = n.datos.containerId;
      }
      if (n.datos.type && !n.datos.contenedor_tipo) n.datos.contenedor_tipo = n.datos.type;
      if (n.datos.name && !n.datos.codigo) n.datos.codigo = n.datos.name;
      if (n.datos.capacity_l != null && n.datos.capacidad_l == null) {
        n.datos.capacidad_l = n.datos.capacity_l;
      }
    }
  });
}

function sanitizarFlowParaGuardar() {
  const raw = {
    schemaVersion: FLOW_SCHEMA_VERSION,
    nodes: Array.isArray(flujoNodos) ? flujoNodos : [],
    edges: Array.isArray(flowEdges) ? flowEdges : [],
    movements: Array.isArray(flowMovements) ? flowMovements : [],
    compositions: Array.isArray(flowCompositions) ? flowCompositions : [],
  };
  const { flow, warnings } = sanitizeFlow(raw);
  if (Array.isArray(warnings)) {
    flowCoreWarnings = warnings;
  }
  return flow;
}

function sanitizeFlowForSave() {
  return sanitizarFlowParaGuardar();
}

function getVolumenFromDatos(datos) {
  if (!datos || typeof datos !== "object") return null;
  const volumen = normalizarNumero(datos.volumen);
  if (volumen != null) return volumen;
  const kilos = normalizarNumero(datos.kilos);
  const litros = normalizarNumero(
    datos.litros_directos != null ? datos.litros_directos : datos.litros
  );
  if (kilos != null) return kilos;
  if (litros != null) return litros;
  return null;
}

function getVolumenFromNodo(nodo) {
  if (!nodo) return null;
  return getVolumenFromDatos(nodo.datos || {});
}

function obtenerCantidadEnUnidad(fuente, _unidad) {
  const volumen = getVolumenFromDatos(fuente);
  return Number.isFinite(volumen) ? volumen : 0;
}

function normalizarCargaSegunUnidad(carga, _unidad) {
  if (!carga) return null;
  const base = getVolumenFromDatos(carga);
  carga.volumen = base != null ? Number(base.toFixed(4)) : null;
  return carga;
}

function setVolumenRegistro(registro, valor) {
  if (!registro) return;
  const num = normalizarNumero(valor);
  if (num == null) {
    registro.volumen = null;
    registro.litros = null;
    registro.kilos = null;
    return;
  }
  const final = Number(num.toFixed(2));
  registro.volumen = final;
  registro.litros = final;
  registro.kilos = null;
}

function asegurarAsignacionRegistro(destino, origenId, volumenPorDefecto = null) {
  destino.datos = destino.datos || {};
  destino.datos.asignaciones = destino.datos.asignaciones || {};
  const key = origenId.toString();
  const existente = destino.datos.asignaciones[key];
  if (!existente) {
    destino.datos.asignaciones[key] = {
      volumen: null,
      litros: null,
      kilos: null,
      __manual: false,
    };
  } else {
    if (existente.volumen == null && volumenPorDefecto != null) {
      setVolumenRegistro(existente, volumenPorDefecto);
    }
  }
  const registro = destino.datos.asignaciones[key];
  if (registro.volumen == null && volumenPorDefecto != null) {
    setVolumenRegistro(registro, volumenPorDefecto);
  }
  return registro;
}

function normalizarIdNodo(nodo) {
  if (!nodo) return "";
  if (typeof nodo === "string" || typeof nodo === "number") return String(nodo);
  return nodo.id != null ? String(nodo.id) : "";
}

function buscarNodoPorId(id) {
  const idNorm = normalizarIdNodo(id);
  if (!idNorm) return null;
  return flujoNodos.find(n => normalizarIdNodo(n) === idNorm) || null;
}

function normalizarFlujoNodos() {
  if (!Array.isArray(flujoNodos)) {
    flujoNodos = [];
    return;
  }
  const idsValidos = new Set();
  flujoNodos.forEach(n => {
    if (!n) return;
    const idNorm = normalizarIdNodo(n);
    if (idNorm) {
      n.id = idNorm;
      idsValidos.add(idNorm);
    }
    const x = Number(n.x);
    const y = Number(n.y);
    if (Number.isFinite(x)) n.x = x;
    if (Number.isFinite(y)) n.y = y;
    if (!Number.isFinite(n.x)) n.x = 60;
    if (!Number.isFinite(n.y)) n.y = 60;
    if (!n.tipo) n.tipo = "entrada";
    if (!n.datos || typeof n.datos !== "object") n.datos = {};
    asegurarFechaCreacionNodo(n);
    if (!Array.isArray(n.targets)) n.targets = [];
    n.targets = Array.from(
      new Set(n.targets.map(t => normalizarIdNodo(t)).filter(Boolean))
    );
    if (idNorm) {
      n.targets = n.targets.filter(t => t !== idNorm);
    }
  });
  flujoNodos.forEach(n => {
    if (!n || !Array.isArray(n.targets)) return;
    n.targets = n.targets.filter(t => idsValidos.has(t));
  });
}

	function esAncestro(posibleAncestroId, nodoId, visitados = new Set()) {
	  const ancestroId = normalizarIdNodo(posibleAncestroId);
	  const nodoNorm = normalizarIdNodo(nodoId);
	  if (!ancestroId || !nodoNorm) return false;
	  if (ancestroId === nodoNorm) return true;
	  if (visitados.has(nodoNorm)) return false;
	  visitados.add(nodoNorm);
	  const padres = obtenerPredecesores(nodoNorm);
	  return padres.some(pre => esAncestro(ancestroId, pre.id, visitados));
	}

function limpiarAsignacionesOrfanas(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo) || !nodo.datos?.asignaciones) return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.asignaciones).forEach(key => {
    if (!clavesPermitidas.has(key)) {
      delete nodo.datos.asignaciones[key];
    }
  });
  limpiarAportesOrfanos(nodo);
  actualizarVariedadDesdeAportes(nodo);
}

function limpiarAportesOrfanos(nodo) {
  if (!nodo || !nodo.datos?.aportes || typeof nodo.datos.aportes !== "object") return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.aportes).forEach(key => {
    if (!clavesPermitidas.has(String(key))) {
      delete nodo.datos.aportes[key];
    }
  });
}

function limpiarCargaNodo(nodo) {
  if (!nodo || !nodo.datos) return;
  CAMPOS_CARGA_NUMERICOS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = 0;
    }
  });
  CAMPOS_CARGA_METRICAS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  CAMPOS_CARGA_TEXTO.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  if ("variedadBase" in nodo.datos) {
    nodo.datos.variedadBase = "";
  }
  if ("vino_tipo" in nodo.datos) {
    nodo.datos.vino_tipo = "";
  }
  if ("vino" in nodo.datos) {
    nodo.datos.vino = "";
  }
  if ("tipoColor" in nodo.datos) {
    nodo.datos.tipoColor = "";
  }
  if ("distribucion" in nodo.datos) {
    nodo.datos.distribucion = {};
  }
  if ("reparto_manual" in nodo.datos) {
    nodo.datos.reparto_manual = false;
  }
  Object.keys(nodo.datos).forEach(key => {
    if (key.startsWith("preview")) {
      delete nodo.datos[key];
    }
  });
  if ("aportes" in nodo.datos) {
    nodo.datos.aportes = {};
  }
  if ("asignaciones" in nodo.datos) {
    nodo.datos.asignaciones = {};
  }
  if ("composicionVariedades" in nodo.datos) {
    nodo.datos.composicionVariedades = [];
  }
}

function obtenerTextoVariedadColor(nodo) {
  if (!nodo) return [];
  const desglose = obtenerDesgloseVariedadesNodo(nodo);
  if (!desglose || !desglose.breakdown) return [];
  return Object.keys(desglose.breakdown);
}

function obtenerColorVino(nodo) {
  if (!nodo) return "";
  const role = obtenerRolNodo(nodo);
  if (role === "CONTAINER") {
    const balance = obtenerBalanceNodo(nodo.id);
    if (Number.isFinite(balance) && balance <= 0) return "";
  }
  const desglose = obtenerDesgloseVariedadesNodo(nodo);
  if (desglose && desglose.breakdown) {
    let blancas = 0;
    let tintas = 0;
    Object.entries(desglose.breakdown).forEach(([nombre, valor]) => {
      const nom = normalizarTextoUva(nombre);
      if (!nom || esVariedadGenerica(nom)) return;
      const val = normalizarNumero(valor);
      if (!(val > 0)) return;
      if (esVariedadBlanca(nom)) blancas += val;
      else tintas += val;
    });
    const total = blancas + tintas;
    if (total > 0) {
      if (blancas > 0 && tintas > 0) {
        const ratioBlancas = blancas / total;
        if (ratioBlancas > 0.55) return "white";
        if (ratioBlancas < 0.45) return "red";
        return "rosado";
      }
      return blancas > 0 ? "white" : "red";
    }
  }
  return "";
}

function obtenerColorEmojiVino(colorVino) {
  if (colorVino === "white") return "#f7c859";
  if (colorVino === "rosado") return "#f58bb5";
  return "#d43c68";
}

function obtenerEstadoVisual(nodo) {
  if (!nodo || !nodo.datos) return null;
  const faseRaw = (nodo.datos.fase || "").toString().trim();
  const estadoRaw = (nodo.datos.estado || "").toString().trim();
  if (!faseRaw && !estadoRaw) return null;
  const colorVino = obtenerColorVino(nodo);
  const colorTexto = colorVino === "white" ? "#f7c859" : "#d43c68";

  if (faseRaw) {
    const faseNorm = faseRaw.toLowerCase();
    const infoFase = obtenerInfoEstadoDeposito ? obtenerInfoEstadoDeposito(faseNorm) : null;
    if (infoFase && (infoFase.id === faseNorm || faseNorm === "vacio")) {
      return { id: infoFase.id, label: infoFase.label, color: colorTexto };
    }
    return { id: faseNorm, label: faseRaw.toUpperCase(), color: colorTexto };
  }

  const estadoNorm = estadoRaw.toLowerCase();
  const info = obtenerInfoEstadoDeposito ? obtenerInfoEstadoDeposito(estadoNorm) : null;
  if (info) {
    return { id: info.id, label: info.label, color: colorTexto };
  }
  return { id: estadoNorm, label: estadoRaw.toUpperCase(), color: colorTexto };
}

function normalizarTextoUva(str) {
  if (!str) return "";
  return str
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
}

	function esVariedadBlanca(textoNormalizado) {
	  if (!textoNormalizado) return false;
	  if (textoNormalizado.includes("blanc") || textoNormalizado.includes("white") || textoNormalizado.includes("bianco")) {
	    return true;
	  }
  if (!VARIEDADES_BLANCAS_SET) {
    VARIEDADES_BLANCAS_SET = new Set(
      VARIEDADES_BLANCAS.map(nombre => normalizarTextoUva(nombre))
    );
  }
  const tokens = textoNormalizado.split(/[^a-z]+/).filter(Boolean);
  if (tokens.some(tok => VARIEDADES_BLANCAS_SET.has(tok))) return true;
  return Array.from(VARIEDADES_BLANCAS_SET).some(nombre => textoNormalizado.includes(nombre));
	}

function calcularOcupacionNodo(nodo, volumenVisual = null) {
  if (!nodo) return null;
  if (esNodoProcesoSinVolumen(nodo)) return null;
  const datos = nodo.datos || {};
	  const capacidad =
	    normalizarNumero(datos.capacidad) ??
	    normalizarNumero(datos.capacidad_l) ??
	    (datos.capacidad_hl != null ? normalizarNumero(datos.capacidad_hl * 100) : null);
	  if (capacidad == null || !(capacidad > 0)) return null;
	  const volumenBase =
	    volumenVisual != null ? volumenVisual : obtenerVolumenRestanteNodo(nodo);
	  if (volumenBase == null) return null;
	  return Math.max(0, Math.min(1, volumenBase / capacidad));
	}

function rellenarDatosEntradaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "entrada") return;
  const idRef = nodo.datos?.entradaId ?? nodo.datos?.id_ref;
  if (!idRef) return;
  nodo.datos = nodo.datos || {};
  nodo.datos.entradaId = idRef;
  nodo.datos.entryId = idRef;
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return;
  const fechaEntrada =
    entrada.fecha ||
    entrada.fecha_entrada ||
    entrada.fecha_recepcion ||
    entrada.fecha_registro ||
    "";
  if (fechaEntrada) {
    const fechaIso = normalizarFechaSoloDia(fechaEntrada);
    if (fechaIso) {
      nodo.datos.fecha_entrada_bodega = fechaIso;
      nodo.datos.fecha = fechaIso;
    }
  }
}

function sincronizarFechaEntradaNodo(nodo) {
  if (!nodo || nodo.tipo !== "entrada") return;
  const entrada = obtenerEntradaRealDesdeNodo(nodo);
  if (!entrada) return;
  const fechaEntrada =
    entrada.fecha ||
    entrada.fecha_entrada ||
    entrada.fecha_recepcion ||
    entrada.fecha_registro ||
    "";
  const fechaIso = normalizarFechaSoloDia(fechaEntrada);
  if (!fechaIso) return;
  nodo.datos = nodo.datos || {};
  nodo.datos.fecha_entrada_bodega = fechaIso;
  nodo.datos.fecha = fechaIso;
}

function obtenerTemperaturaNodo(nodo) {
  if (!nodo) return null;
  if (obtenerRolNodo(nodo) === "SOURCE") {
    const temp = obtenerTemperaturaEntradaDesdeNodo(nodo);
    return temp != null ? temp : null;
  }
  if (normalizarNumero(nodo.datos?.temperatura) != null) {
    return normalizarNumero(nodo.datos.temperatura);
  }
  if (Array.isArray(nodo.datos?.control) && nodo.datos.control.length) {
    const ultimo = nodo.datos.control[nodo.datos.control.length - 1];
    if (normalizarNumero(ultimo?.temperatura) != null) {
      return normalizarNumero(ultimo.temperatura);
    }
  }
  return null;
}

function calcularProgresoBarrica(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  if (!inicioStr) return null;
  const inicio = parsearFechaValor(inicioStr);
  if (!inicio) return null;
  const ahora = new Date();

  const fin = finStr ? parsearFechaValor(finStr) : null;
  let msTotal = 0;
  if (fin) {
    msTotal = fin.getTime() - inicio.getTime();
  } else {
    const mesesObjetivo = normalizarNumero(finStr) || 12; // fallback si guardaron meses como número
    msTotal = mesesObjetivo * 30 * 24 * 60 * 60 * 1000;
  }
  if (!(msTotal > 0)) return null;

  const transcurrido = Math.max(0, ahora.getTime() - inicio.getTime());
  return Math.max(0, Math.min(1, transcurrido / msTotal));
}

function obtenerTooltipCrianza(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return "";
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  const inicio = inicioStr ? parsearFechaValor(inicioStr) : null;
  if (!inicio) {
    return 'Crianza\nDefine "Fecha operación" (inicio).';
  }

  const formatearFechaTooltip = date => {
    if (!date) return "—";
    const d = new Date(date);
    if (isNaN(d.getTime())) return "—";
    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = d.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  };

  const finDate = finStr ? parsearFechaValor(finStr) : null;
  let fin = finDate;
  let finEsEstimado = false;
  if (!finDate) {
    const meses = normalizarNumero(finStr);
    if (meses != null && meses > 0) {
      fin = new Date(inicio.getTime() + meses * 30 * 24 * 60 * 60 * 1000);
      finEsEstimado = true;
    }
  }

  if (!fin) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      'Define "Fin previsto de la crianza" para ver el avance.',
    ].join("\n");
  }

  const ahora = new Date();
  const msTotal = fin.getTime() - inicio.getTime();
  if (!(msTotal > 0)) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      `Fin: ${formatearFechaTooltip(fin)}`,
      "Revisa fechas: el fin debe ser posterior al inicio.",
    ].join("\n");
  }

  const msDia = 24 * 60 * 60 * 1000;
  const transcurridoMs = ahora.getTime() - inicio.getTime();
  const restanteMs = fin.getTime() - ahora.getTime();
  const pct = Math.max(0, Math.min(1, transcurridoMs / msTotal));
  const diasTotal = Math.max(1, Math.round(msTotal / msDia));
  const diasTrans = Math.max(0, Math.round(Math.max(0, transcurridoMs) / msDia));
  const diasRest = Math.max(0, Math.round(Math.max(0, restanteMs) / msDia));

  const lineas = [
    `Crianza: ${Math.round(pct * 100)}%`,
    `Inicio: ${formatearFechaTooltip(inicio)}`,
    `Fin: ${formatearFechaTooltip(fin)}${finEsEstimado ? " (estimado)" : ""}`,
    `Transcurrido: ${Math.min(diasTrans, diasTotal)}/${diasTotal} días`,
  ];
  if (restanteMs >= 0) {
    lineas.push(`Restan: ${diasRest} días`);
  } else {
    lineas.push(`Finalizada hace: ${Math.abs(Math.round(restanteMs / msDia))} días`);
  }
  return lineas.join("\n");
}

function obtenerTooltipEmbotellado(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return "";
  const formatos = nodo.datos?.formatos_botella;
  return construirDetalleFormatosBotella(formatos);
}

function getFlowTooltipEl() {
  return document.getElementById("flowTooltip");
}

function posicionarFlowTooltip(clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip || tip.style.display === "none") return;
  const padding = 12;
  const offset = 14;
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth || document.documentElement.clientWidth || 0;
  const vh = window.innerHeight || document.documentElement.clientHeight || 0;

  let x = clientX + offset;
  let y = clientY + offset;
  if (x + rect.width + padding > vw) x = Math.max(padding, clientX - rect.width - offset);
  if (y + rect.height + padding > vh) y = Math.max(padding, clientY - rect.height - offset);

  tip.style.left = `${Math.round(x)}px`;
  tip.style.top = `${Math.round(y)}px`;
}

function mostrarFlowTooltip(texto, clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  if (!texto) {
    tip.style.display = "none";
    return;
  }
  tip.textContent = texto;
  tip.style.display = "block";
  posicionarFlowTooltip(clientX, clientY);
}

function ocultarFlowTooltip() {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  tip.style.display = "none";
}

function limpiarNodosSinEntradas() {
  flujoNodos.forEach(nodo => {
    if (nodo.tipo === "entrada") return;
    const predecesores = obtenerPredecesores(nodo.id);
    if (!predecesores.length) {
      const tieneSalidas = Array.isArray(nodo.targets) && nodo.targets.length > 0;
      if (tieneSalidas) return;
      limpiarCargaNodo(nodo);
      if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
        actualizarVariedadDesdeAportes(nodo);
      }
    }
  });
}

function construirCargaDesdeDatos(datos = {}) {
  const carga = {};
  if (datos.variedad) carga.variedad = datos.variedad;
  if (datos.anada) carga.anada = datos.anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  if (datos.fecha_operacion) carga.fecha_operacion = datos.fecha_operacion;
  const volumen = getVolumenFromDatos(datos);
  if (volumen != null) carga.volumen = volumen;
  const densidad = normalizarNumero(datos.densidad);
  if (densidad != null) carga.densidad = densidad;
  const temperatura = normalizarNumero(datos.temperatura);
  if (temperatura != null) carga.temperatura = temperatura;
  const ph = normalizarNumero(datos.ph);
  if (ph != null) carga.ph = ph;
  const acidezTotal = normalizarNumero(datos.acidez_total);
  if (acidezTotal != null) carga.acidez_total = acidezTotal;
  return Object.keys(carga).length ? carga : null;
}

function obtenerCargaLedgerBasica(nodo) {
  if (!nodo) return null;
  const role = mapearRolPorTipo(nodo.tipo);
  if (role === "CONTAINER") {
    const balance = obtenerBalanceNodo(nodo.id);
    if (!Number.isFinite(balance)) return null;
    return { volumen: Number(balance.toFixed(2)) };
  }
  if (role === "SOURCE") {
    const entrada = obtenerEntradaRealDesdeNodo(nodo);
    return entrada ? construirCargaDesdeDatos(entrada) : null;
  }
  return null;
}

function obtenerLitrosDisponiblesPredecesoresLedger(nodo) {
  if (!nodo || !nodo.id) return 0;
  const padres = obtenerPredecesores(nodo.id);
  return padres.reduce((acc, pre) => {
    const vol = calcularVolumenNodoPorFlujo(pre);
    return acc + (Number.isFinite(vol) ? vol : 0);
  }, 0);
}

function obtenerBotellasNodoEmbotellado(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return 0;
  const resumen = calcularResumenFormatosBotella(nodo);
  if (Number.isFinite(resumen.totalBotellas) && resumen.totalBotellas > 0) {
    return Math.floor(resumen.totalBotellas);
  }
  const botellasRaw = normalizarNumero(nodo.datos?.botellas || nodo.datos?.botellas_resultantes);
  if (Number.isFinite(botellasRaw) && botellasRaw > 0) {
    return Math.floor(botellasRaw);
  }
  const volBotella = VOLUMEN_BOTELLA_L[nodo.datos?.botella] || 0;
  const litrosDisponibles = obtenerLitrosDisponiblesPredecesoresLedger(nodo);
  if (volBotella > 0 && Number.isFinite(litrosDisponibles) && litrosDisponibles > 0) {
    return Math.floor(litrosDisponibles / volBotella);
  }
  return 0;
}

function obtenerBotellasDisponiblesPredecesoresAlmacen(nodo) {
  if (!nodo || !nodo.id) return 0;
  const padres = obtenerPredecesores(nodo.id);
  return padres.reduce((acc, pre) => acc + obtenerBotellasNodoEmbotellado(pre), 0);
}

function obtenerTamanoCaja(valor) {
  const match = String(valor || "").match(/(\d+)/);
  const tam = match ? Number(match[1]) : NaN;
  return Number.isFinite(tam) && tam > 0 ? tam : 6;
}

function actualizarResumenCajasAlmacen(nodo) {
  if (!nodo || nodo.tipo !== "almacen") return;
  nodo.datos = nodo.datos || {};
  const selectCaja = document.getElementById("flowField-caja_botellas");
  const displayBotellas = document.getElementById("flowField-botellas_resultantes-display");
  const displayCajas = document.getElementById("flowField-cajas_resultantes-display");
  const hiddenBotellas = document.getElementById("flowField-botellas_resultantes");
  const hiddenCajas = document.getElementById("flowField-cajas_resultantes");

  let cajaValor = selectCaja ? selectCaja.value : (nodo.datos.caja_botellas || "");
  if (!cajaValor) cajaValor = "6 botellas";
  const tamCaja = obtenerTamanoCaja(cajaValor);
  const botellas = obtenerBotellasDisponiblesPredecesoresAlmacen(nodo);
  const cajas = Math.floor(botellas / tamCaja);

  nodo.datos.caja_botellas = cajaValor;
  nodo.datos.botellas_resultantes = botellas;
  nodo.datos.cajas_resultantes = cajas;

  if (displayBotellas) {
    const etiqueta = botellas === 1 ? "botella" : "botellas";
    displayBotellas.textContent = `${botellas.toLocaleString("es-ES")} ${etiqueta}`;
  }
  if (displayCajas) {
    const etiqueta = cajas === 1 ? "caja" : "cajas";
    displayCajas.textContent = `${cajas.toLocaleString("es-ES")} ${etiqueta} (${tamCaja} botellas/caja)`;
  }
  if (hiddenBotellas) hiddenBotellas.value = String(botellas);
  if (hiddenCajas) hiddenCajas.value = String(cajas);
}

function actualizarBotellasTotalesSalida(nodo) {
  if (!nodo || nodo.tipo !== "salida") return;
  nodo.datos = nodo.datos || {};
  const inputCajas = document.getElementById("flowField-cajas_cantidad");
  const selectTipo = document.getElementById("flowField-cajas_tipo");
  const displayTotal = document.getElementById("flowField-botellas_totales-display");
  const hiddenTotal = document.getElementById("flowField-botellas_totales");

  const cajasRaw = inputCajas ? inputCajas.value : nodo.datos.cajas_cantidad;
  const cajasNum = normalizarNumero(cajasRaw);
  const cajas = Number.isFinite(cajasNum) && cajasNum > 0 ? Math.floor(cajasNum) : 0;
  const tipoCaja = (selectTipo ? selectTipo.value : nodo.datos.cajas_tipo) || "6 botellas";
  const tamCaja = obtenerTamanoCaja(tipoCaja);
  const totalBotellas = cajas * tamCaja;

  nodo.datos.botellas_totales = totalBotellas;

  if (displayTotal) {
    const etiqueta = totalBotellas === 1 ? "botella" : "botellas";
    displayTotal.textContent = `${totalBotellas.toLocaleString("es-ES")} ${etiqueta}`;
  }
  if (hiddenTotal) {
    hiddenTotal.value = String(totalBotellas);
  }
}

function buscarNodoAguasArriba(inicioNodo, predicado) {
  if (!inicioNodo || typeof predicado !== "function") return null;
  const visitados = new Set();
  const cola = [...obtenerPredecesores(inicioNodo.id)];
  while (cola.length) {
    const actual = cola.shift();
    const idNorm = normalizarIdNodo(actual);
    if (!actual || !idNorm || visitados.has(idNorm)) continue;
    visitados.add(idNorm);
    if (predicado(actual)) return actual;
    const padres = obtenerPredecesores(actual.id);
    padres.forEach(pre => {
      const preNorm = normalizarIdNodo(pre);
      if (pre && preNorm && !visitados.has(preNorm)) {
        cola.push(pre);
      }
    });
  }
  return null;
}

function obtenerResumenSalidaNodo(nodoSalida) {
  const datos = nodoSalida?.datos || {};
  const embotellado = buscarNodoAguasArriba(nodoSalida, n => n?.tipo === "embotellado");
  const variedad =
    obtenerVariedadVisibleNodo(nodoSalida) ||
    obtenerVariedadVisibleNodo(embotellado) ||
    "";
  const nombreVino = obtenerNombreVinoVisibleNodo(nodoSalida);
  const cajasRaw = normalizarNumero(datos.cajas_cantidad);
  const cajas = Number.isFinite(cajasRaw) && cajasRaw > 0 ? Math.floor(cajasRaw) : 0;
  const tipoCaja = (datos.cajas_tipo || "6 botellas").toString().trim();
  const tamCaja = obtenerTamanoCaja(tipoCaja);
  const totalBotellas = cajas > 0 ? cajas * tamCaja : 0;
  return {
    variedad,
    nombreVino,
    cajas,
    tipoCaja,
    totalBotellas,
  };
}

function obtenerNombreVinoDesdeDatosNodo(nodo) {
  const datos = nodo?.datos || {};
  return (
    datos.nombre_vino ||
    datos.nombre_blend ||
    datos.nombre ||
    datos.vino ||
    ""
  )
    .toString()
    .trim();
}

function obtenerNombreVinoVisibleNodo(nodo) {
  if (!nodo) return "";
  const directo = obtenerNombreVinoDesdeDatosNodo(nodo);
  if (directo) return directo;
  if (nodo.tipo === "embotellado") return "";
  const embotellado = buscarNodoAguasArriba(nodo, pre => pre?.tipo === "embotellado");
  const desdeEmbotellado = obtenerNombreVinoDesdeDatosNodo(embotellado);
  if (desdeEmbotellado) return desdeEmbotellado;
  const generico = buscarNodoAguasArriba(
    nodo,
    pre => Boolean(obtenerNombreVinoDesdeDatosNodo(pre))
  );
  return obtenerNombreVinoDesdeDatosNodo(generico);
}

function obtenerCargaParaSembrar(origen) {
  if (!origen) return null;
  const visitados = new Set();
  const cola = [origen];
  while (cola.length) {
    const actual = cola.shift();
    if (!actual || visitados.has(actual.id)) continue;
    visitados.add(actual.id);
	    if (actual.tipo === "entrada" && obtenerEntradaIdDesdeNodo(actual)) {
	      intentarPoblarNodoEntrada(actual, true);
	    }
	    if (actual.tipo === "deposito" && actual.datos?.id_ref) {
	      intentarPoblarNodoDeposito(actual, true);
	    }
    let carga = obtenerCargaLedgerBasica(actual);
    if (!carga) {
      carga = construirCargaDesdeDatos(actual.datos);
    }
    if (carga) return carga;
    const padres = obtenerPredecesores(actual.id);
    padres.forEach(pre => {
      if (pre && !visitados.has(pre.id)) {
        cola.push(pre);
      }
    });
  }
  return null;
}

function sembrarDatosIniciales(origen, destino) {
  if (!origen || !destino) return;
  if (destino.tipo === "deposito") return;
  const carga = obtenerCargaParaSembrar(origen);
  if (!carga) return;
  aplicarCargaProcesoSinDuplicar(destino, origen.id, carga);
  guardarEstadoNodos();
}

function obtenerComposicionLedgerNodo(nodo) {
  if (!nodo) return null;
  if (flowCompositionsDirty) recalcularBalancesFlow();
  const role = obtenerRolNodo(nodo);
  if (role !== "PROCESS" && role !== "CONTAINER") return null;
  const key = `${role}:${normalizarIdNodo(nodo)}`;
  return flowCompositionMap.get(key) || null;
}

function normalizarBreakdownVariedades(breakdown = {}) {
  const limpio = {};
  let total = 0;
  Object.entries(breakdown || {}).forEach(([nombre, valor]) => {
    const nom = (nombre || "").toString().trim();
    if (!nom || esVariedadGenerica(nom)) return;
    const val = normalizarNumero(valor);
    if (!(val > 0)) return;
    limpio[nom] = (limpio[nom] || 0) + val;
    total += val;
  });
  if (!(total > 0)) return null;
  return { breakdown: limpio, total };
}

function construirBreakdownEntrada(entrada) {
  if (!entrada) return null;
  const lista =
    entrada.composicionVariedades ||
    entrada.composicion_variedades ||
    entrada.lineas ||
    entrada.variedades ||
    [];
  if (Array.isArray(lista) && lista.length) {
    const breakdown = {};
    lista.forEach(item => {
      const nombre = (item?.nombre || item?.variedad || "").toString().trim();
      if (!nombre || esVariedadGenerica(nombre)) return;
      const valor =
        normalizarNumero(item?.kilos) ??
        normalizarNumero(item?.kg) ??
        normalizarNumero(item?.cantidad) ??
        normalizarNumero(item?.peso) ??
        normalizarNumero(item?.cajas) ??
        normalizarNumero(item?.porcentaje) ??
        normalizarNumero(item?.pct);
      if (!(valor > 0)) return;
      breakdown[nombre] = (breakdown[nombre] || 0) + valor;
    });
    return normalizarBreakdownVariedades(breakdown);
  }
  if (typeof entrada.observaciones === "string" && entrada.observaciones.includes("LINEAS_JSON=")) {
    const lineaJson = entrada.observaciones
      .split(/\r?\n/)
      .find((linea) => String(linea).startsWith("LINEAS_JSON="));
    if (lineaJson) {
      try {
        const parsed = JSON.parse(lineaJson.replace("LINEAS_JSON=", ""));
        if (Array.isArray(parsed) && parsed.length) {
          return construirBreakdownEntrada({ ...entrada, lineas: parsed, observaciones: null });
        }
      } catch (_err) {
        // noop
      }
    }
  }
  if (entrada.variedad) {
    const nombre = entrada.variedad.toString().trim();
    if (!nombre || esVariedadGenerica(nombre)) return null;
    return { breakdown: { [nombre]: 1 }, total: 1 };
  }
  return null;
}

function obtenerDesgloseVariedadesNodo(nodo, visitados = new Set()) {
  if (!nodo) return null;
  const idNorm = normalizarIdNodo(nodo);
  if (idNorm && visitados.has(idNorm)) return null;
  if (idNorm) visitados.add(idNorm);
  const role = obtenerRolNodo(nodo);
  if (role === "SOURCE") {
    const entrada = obtenerEntradaRealDesdeNodo(nodo);
    return construirBreakdownEntrada(entrada);
  }
  if (role === "PROCESS" || role === "CONTAINER") {
    const comp = obtenerComposicionLedgerNodo(nodo);
    if (comp && comp.breakdown) {
      return normalizarBreakdownVariedades(comp.breakdown);
    }
    const lista =
      nodo?.datos?.composicionVariedades || nodo?.datos?.composicion_variedades || [];
    if (Array.isArray(lista) && lista.length) {
      const breakdown = {};
      lista.forEach(item => {
        const nombre = (item?.nombre || item?.variedad || "").toString().trim();
        if (!nombre || esVariedadGenerica(nombre)) return;
        const pct = normalizarNumero(
          item?.porcentaje ?? item?.pct ?? item?.percent ?? item?.porciento
        );
        if (!(pct > 0)) return;
        breakdown[nombre] = (breakdown[nombre] || 0) + pct;
      });
      if (Object.keys(breakdown).length) {
        return { breakdown, total: 100 };
      }
    }
    // Fallback: composición inferida para mostrar (a partir de predecesores)
    const padres = obtenerPredecesores(nodo.id);
    if (Array.isArray(padres) && padres.length) {
      const breakdown = {};
      padres.forEach(pre => {
        const desg = obtenerDesgloseVariedadesNodo(pre, visitados);
        if (!desg || !desg.breakdown || !(desg.total > 0)) return;
        const volumenTransferido = calcularVolumenTransferido(pre, nodo, new Map(), new Set());
        if (!Number.isFinite(volumenTransferido) || volumenTransferido <= 0) return;
        Object.entries(desg.breakdown).forEach(([nombre, valor]) => {
          if (!nombre || esVariedadGenerica(nombre)) return;
          const val = normalizarNumero(valor);
          if (!(val > 0)) return;
          const aporte = (val / desg.total) * volumenTransferido;
          breakdown[nombre] = (breakdown[nombre] || 0) + aporte;
        });
      });
      const normalizado = normalizarBreakdownVariedades(breakdown);
      if (normalizado) return normalizado;
    }
    return null;
  }
  return null;
}

function formatearComposicionDesdeBreakdown(desglose) {
  if (!desglose || !desglose.breakdown || !(desglose.total > 0)) return "";
  return Object.entries(desglose.breakdown)
    .sort((a, b) => (b[1] || 0) - (a[1] || 0))
    .map(([nombre, valor]) => {
      const pct = (valor / desglose.total) * 100;
      return `${formatearPctVariedad(pct)} ${nombre}`;
    })
    .join("\n");
}

function obtenerVariedadVisibleNodo(nodo) {
  if (!nodo) return "";
  const desglose = obtenerDesgloseVariedadesNodo(nodo);
  const texto = formatearComposicionDesdeBreakdown(desglose);
  if (texto) return texto;
  const role = obtenerRolNodo(nodo);
  if (role === "SOURCE") {
    const entradaId = obtenerEntradaIdDesdeNodo(nodo);
    if (entradaId && Array.isArray(cacheEntradas) && cacheEntradas.length) {
      return "Entrada no encontrada";
    }
  }
  return "";
}

function limpiarTextoVariedad(variedad) {
  if (!variedad) return "";
  return variedad
    .split("·")
    .map(part => part.replace(/\s*\d+(\.\d+)?%/g, "").trim())
    .filter(Boolean)
    .join(" · ");
}

function obtenerHistoricoNodo(nodo) {
  if (!nodo) return null;
  const datos = nodo.datos || {};
  const valor =
    normalizarNumero(datos.historico) ??
    normalizarNumero(datos.hist) ??
    normalizarNumero(datos.historico_l) ??
    normalizarNumero(datos.historico_litros) ??
    normalizarNumero(datos.litros_historico) ??
    normalizarNumero(datos.historico_volumen);
  if (Number.isFinite(valor)) return valor;
  if (nodo.tipo !== "deposito" && nodo.tipo !== "barrica") return null;
  const padres = obtenerPredecesores(nodo.id);
  if (!Array.isArray(padres) || !padres.length) return null;
  let total = 0;
  padres.forEach(pre => {
    const vol = calcularVolumenTransferido(pre, nodo, new Map(), new Set());
    if (Number.isFinite(vol) && vol > 0) total += vol;
  });
  return total > 0 ? total : null;
}

// Helper para sumar variedades ponderadas (admite listas con porcentajes)
function agregarVariedadAPeso(mix, texto, peso) {
  if (!mix || !texto) return;
  const pesoBase = Number.isFinite(Number(peso)) && Number(peso) > 0 ? Number(peso) : 1;
  const partes = texto
    .split(/[\/·,]/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) return;
  const items = partes.map(p => {
    const m = p.match(/^(.*?)(?:\s+(\d+(?:[.,]\d+)?)%?)?$/);
    return {
      nombre: m && m[1] ? m[1].trim() : p,
      pct: m && m[2] ? Number(String(m[2]).replace(",", ".")) : null,
    };
  });
  const conPct = items.filter(i => Number.isFinite(i.pct) && i.pct > 0);
  if (conPct.length) {
    conPct.forEach(i => {
      const nombre = limpiarTextoVariedad(i.nombre);
      if (!nombre || esVariedadGenerica(nombre)) return;
      const aporte = pesoBase * (i.pct / 100);
      mix.set(nombre, (mix.get(nombre) || 0) + aporte);
    });
    return;
  }
  const reparto = pesoBase / items.length;
  items.forEach(i => {
    const nombre = limpiarTextoVariedad(i.nombre);
    if (!nombre || esVariedadGenerica(nombre)) return;
    mix.set(nombre, (mix.get(nombre) || 0) + reparto);
  });
}

function mixToArray(mix, total) {
  if (!mix || !mix.size) return [];
  const entradas = Array.from(mix.entries());
  const sumatoria = total && total > 0 ? total : entradas.reduce((a, [, v]) => a + v, 0);
  const base = sumatoria > 0 ? sumatoria : entradas.length;
  const ordenadas = entradas.sort((a, b) => {
    if (sumatoria <= 0) return a[0].localeCompare(b[0]);
    return b[1] - a[1];
  });
  return ordenadas.map(([nombre, cantidad]) => {
    const peso = sumatoria > 0 ? cantidad : 1;
    const pct = base > 0 ? (peso / base) * 100 : 0;
    return { nombre, porcentaje: pct };
  });
}

function formatearPctVariedad(valor) {
  if (!Number.isFinite(valor)) return "0%";
  const num = Number(valor);
  if (!(num >= 0)) return "0%";
  if (num >= 99.95 && num <= 100.05) return "100%";
  return `${num.toFixed(1)}%`;
}

function formatearResumenVariedades(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = item.nombre || item.variedad || "";
      const pct = formatearPctVariedad(
        Number.isFinite(item.porcentaje) ? item.porcentaje : Number(item.pct)
      );
      return nombre ? `${pct} ${nombre}` : "";
    })
    .filter(Boolean)
    .join("/");
}

function guardarComposicionEnNodo(_nodo, mix, total) {
  return mixToArray(mix, total);
}

function calcularComposicionVariedades(nodo, visitados = new Set()) {
  const mix = new Map();
  if (!nodo) return { total: 0, mix };
  const key = nodo.id || nodo;
  if (visitados.has(key)) return { total: 0, mix };
  visitados.add(key);
  const desglose = obtenerDesgloseVariedadesNodo(nodo);
  if (!desglose) return { total: 0, mix };
  Object.entries(desglose.breakdown || {}).forEach(([nombre, valor]) => {
    if (!nombre || esVariedadGenerica(nombre)) return;
    const val = normalizarNumero(valor);
    if (!(val > 0)) return;
    mix.set(nombre, val);
  });
  return { total: desglose.total || 0, mix };
}

function formatearComposicionVariedades(mix, total) {
  const composicion = mixToArray(mix, total);
  if (!composicion.length) return "";
  return composicion.map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`).join("/");
}

function normalizarFormatosBotellaLista(formatos) {
  if (!Array.isArray(formatos)) return [];
  return formatos
    .map(item => {
      if (!item) return null;
      const formato = (item.formato || item.tipo || item.botella || "").toString().trim();
      const botellasRaw = normalizarNumero(item.botellas);
      const botellas = Number.isFinite(botellasRaw)
        ? Math.max(0, Math.floor(botellasRaw))
        : 0;
      if (!formato || !(botellas > 0)) return null;
      const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
      const litros = volBotella > 0 ? botellas * volBotella : 0;
      return { formato, botellas, litros };
    })
    .filter(Boolean);
}

function calcularResumenFormatosBotellaDesdeLista(formatos) {
  const lista = normalizarFormatosBotellaLista(formatos);
  let totalBotellas = 0;
  let totalLitros = 0;
  lista.forEach(item => {
    totalBotellas += item.botellas;
    totalLitros += item.litros;
  });
  return {
    totalBotellas,
    totalLitros,
    formatosActivos: lista.length,
    lista,
  };
}

function construirDetalleFormatosBotella(formatos) {
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  if (!resumen.lista.length) return "";
  const lineas = ["Formatos:"];
  resumen.lista.forEach(item => {
    const etiqueta = item.botellas === 1 ? "botella" : "botellas";
    const litrosTxt = item.litros > 0 ? ` (${item.litros.toFixed(2)} L)` : "";
    lineas.push(
      `${item.formato}: ${item.botellas.toLocaleString("es-ES")} ${etiqueta}${litrosTxt}`
    );
  });
  if (resumen.totalBotellas > 0) {
    const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
    const litrosTotal = resumen.totalLitros > 0 ? ` · ${resumen.totalLitros.toFixed(2)} L` : "";
    lineas.push(`Total: ${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${litrosTotal}`);
  }
  return lineas.join("\n");
}

function formatearResumenFormatosEmbotellado(formatos) {
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  if (!resumen.lista.length) return "";
  return resumen.lista
    .map(item => `${item.botellas.toLocaleString("es-ES")}×${item.formato}`)
    .join(" · ");
}

function calcularResumenFormatosBotella(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") {
    return { totalBotellas: 0, totalLitros: 0, formatosActivos: 0 };
  }
  const formatos = Array.isArray(nodo.datos?.formatos_botella)
    ? nodo.datos.formatos_botella
    : [];
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  return {
    totalBotellas: resumen.totalBotellas,
    totalLitros: resumen.totalLitros,
    formatosActivos: resumen.formatosActivos,
  };
}

function obtenerVolumenNumericoNodo(nodo) {
  if (!nodo) return null;
  if (esNodoProcesoSinVolumen(nodo)) return null;
  const valorVisual = obtenerVolumenVisualNodo(nodo);
  const volumen = valorVisual != null ? valorVisual : obtenerVolumenActualNodo(nodo);
  return Number.isFinite(volumen) ? Number(volumen) : null;
}

const UMBRAL_DISCREPANCIA_VOLUMEN_L = 0.5;

function obtenerDiagnosticoVolumenContenedor(nodo) {
  if (!nodo || (nodo.tipo !== "deposito" && nodo.tipo !== "barrica")) return null;
  const info =
    nodo.tipo === "deposito"
      ? resolverInfoDepositoDesdeNodo(nodo)
      : resolverInfoBarricaDesdeNodo(nodo);
  const balance = obtenerBalanceNodo(nodo.id);
  const volumenMapa = Number.isFinite(balance) ? Number(balance) : obtenerVolumenNumericoNodo(nodo);
  const volumenFichaRaw = info ? normalizarNumero(info.litros_actuales ?? info.volumen) : null;
  const volumenFicha = Number.isFinite(volumenFichaRaw) ? Number(volumenFichaRaw) : null;
  const fuente = Number.isFinite(volumenMapa) ? "mapa" : "ficha";
  const delta =
    Number.isFinite(volumenMapa) && Number.isFinite(volumenFicha)
      ? Number((volumenMapa - volumenFicha).toFixed(2))
      : null;
  const discrepancia = delta != null ? Math.abs(delta) > UMBRAL_DISCREPANCIA_VOLUMEN_L : false;
  return {
    fuente,
    volumenMapa: Number.isFinite(volumenMapa) ? Number(volumenMapa) : null,
    volumenFicha,
    delta,
    discrepancia,
  };
}

function esNodoProcesoHistorico(nodo) {
  if (!nodo) return false;
  return nodo.tipo === "estilo" || nodo.tipo === "prensado" || nodo.tipo === "fermentacion";
}

function obtenerTextoVolumenNodo(nodo) {
  if (!nodo) return "";
  if (esNodoProcesoSinVolumen(nodo) && nodo.tipo !== "embotellado" && nodo.tipo !== "almacen") return "—";
  const valor = obtenerVolumenNumericoNodo(nodo);

  if (nodo.tipo === "embotellado") {
    const resumen = calcularResumenFormatosBotella(nodo);
    if (resumen.totalBotellas > 0) {
      const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
      const sufijo = resumen.formatosActivos > 1 ? " (mixto)" : "";
      return `${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${sufijo}`;
    }
    const litros = normalizarNumero(valor);
    const volBotella = VOLUMEN_BOTELLA_L[nodo.datos?.botella] || 0;
    const litrosDisponibles = obtenerLitrosDisponiblesPredecesoresLedger(nodo);
    const litrosBase =
      litros != null ? litros : Number.isFinite(litrosDisponibles) ? litrosDisponibles : null;
    if (volBotella > 0 && litrosBase != null) {
      const botellas = Math.floor(litrosBase / volBotella);
      const etiqueta = botellas === 1 ? "botella" : "botellas";
      return `${botellas.toLocaleString("es-ES")} ${etiqueta}`;
    }
    return "Botellas —";
  }

  if (nodo.tipo === "estilo") {
    const base = calcularVolumenNodoPorFlujoBase(nodo);
    if (!Number.isFinite(base)) return "—";
    const final = calcularVolumenNodoPorFlujo(nodo);
    const baseTxt = Number(base.toFixed(0));
    const finalTxt = Number((Number.isFinite(final) ? final : base).toFixed(0));
    return `${baseTxt} L/${finalTxt}L-m`;
  }

  if (nodo.tipo === "almacen") {
    const botellas = obtenerBotellasDisponiblesPredecesoresAlmacen(nodo);
    const tamCaja = obtenerTamanoCaja(nodo.datos?.caja_botellas || "6 botellas");
    const cajas = Math.floor(botellas / tamCaja);
    const etiqueta = cajas === 1 ? "caja" : "cajas";
    return `${cajas.toLocaleString("es-ES")} ${etiqueta}`;
  }

  const capBase =
    normalizarNumero(nodo.datos?.capacidad) ??
    normalizarNumero(nodo.datos?.capacidad_l) ??
    (nodo.datos?.capacidad_hl != null
      ? normalizarNumero(nodo.datos.capacidad_hl * 100)
      : null);

  const redondear = v => (Number.isFinite(v) ? Number(v.toFixed(0)) : null);
  const cap = redondear(capBase);
  let cont = redondear(valor);

  if (nodo.tipo === "entrada") {
    const entrada = obtenerEntradaRealDesdeNodo(nodo);
    const entradaId = obtenerEntradaIdDesdeNodo(nodo);
    if (!entrada && entradaId && Array.isArray(cacheEntradas) && cacheEntradas.length) {
      return "Entrada no encontrada";
    }
    const kilosEntrada = obtenerKilosEntradaDesdeNodo(nodo);
    const kilosVisual =
      Number.isFinite(kilosEntrada) ? kilosEntrada : Number.isFinite(cont) ? cont : null;
    if (kilosVisual != null) return `${Number(kilosVisual.toFixed(0))} kg`;
    return "— kg";
  }

  if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
    if (cont == null) cont = 0;
    let capFinal = cap;
    if (capFinal == null) {
      const info =
        nodo.tipo === "deposito"
          ? resolverInfoDepositoDesdeNodo(nodo)
          : resolverInfoBarricaDesdeNodo(nodo);
      if (info) {
        capFinal =
          normalizarNumero(info.capacidad_l) ??
          (info.capacidad_hl != null ? normalizarNumero(info.capacidad_hl * 100) : null);
      }
    }
    const capHlRaw = capFinal != null ? capFinal / 100 : null;
    const capHl =
      Number.isFinite(capHlRaw) ? (Number.isInteger(capHlRaw) ? capHlRaw : Number(capHlRaw.toFixed(1))) : null;
    if (capHl != null) return `${cont} L/${capHl}hl`;
    return `${cont} L`;
  }
  if (cont != null) {
    return `${cont} L`;
  }
  return "Pendiente de volumen";
}

function describirNodoOrigen(origen) {
  if (!origen) return "Nodo";
  const base = origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
  const variedad = obtenerVariedadVisibleNodo(origen);
  if (origen.tipo === "estilo") {
    const metodo = origen.datos?.metodo ? ` · ${origen.datos.metodo}` : "";
    const variedadTexto = variedad ? ` (${variedad})` : "";
    return `${base}${metodo}${variedadTexto}`;
  }
  if (origen.tipo === "entrada") {
    const entradaId = obtenerEntradaIdDesdeNodo(origen);
    if (entradaId) return obtenerEtiquetaEntrada(entradaId);
    return variedad ? `${base} (${variedad})` : base;
  }
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    const info =
      origen.tipo === "deposito"
        ? buscarDepositoPorId(origen.datos?.id_ref)
        : (() => {
            const datos = origen.datos || {};
            const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
            const id = datos.contenedor_id || datos.id_ref;
            if (!id) return null;
            return tipoCont === "barrica" ? buscarBarricaPorId(id) : buscarDepositoPorId(id);
          })();
    const nombre = info?.codigo || origen.datos?.codigo || origen.titulo || base;
    const varTexto = variedad || "";
    const varLabel = varTexto ? ` (${varTexto})` : "";
    return `${nombre}${varLabel}`;
  }
  return variedad ? `${base} (${variedad})` : base;
}

function describirNodoDestino(dest) {
  if (!dest) return "Nodo";
  const contenedor = obtenerContenedorPorIdRef(dest.datos?.id_ref);
  if (contenedor) {
    const nombre =
      contenedor.codigo ||
      dest.datos?.codigo ||
      dest.titulo ||
      (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad = obtenerVariedadVisibleNodo(dest);
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  if (dest.tipo === "deposito") {
    const info = dest.datos?.id_ref ? buscarDepositoPorId(dest.datos.id_ref) : null;
    const nodosMap = getNodosPorId();
    const mapaDep = crearMapaDeposPorRef(nodosMap);
    const refKey = dest.datos?.id_ref != null ? String(dest.datos.id_ref) : null;
    const nombreMapa = refKey && mapaDep[refKey] ? mapaDep[refKey].codigo : null;
    const nombre =
      info?.codigo ||
      nombreMapa ||
      dest.datos?.codigo ||
      dest.titulo ||
      (dest.datos?.id_ref ? `Depósito #${dest.datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || dest.datos?.vino_tipo || dest.datos?.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  return etiquetarDestinoFlow(dest);
}

function obtenerContenedorPrevio(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return null;
  visitados.add(origen.id);
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    return origen;
  }
  const padres = obtenerPredecesores(origen.id);
  for (const pre of padres) {
    const encontrado = obtenerContenedorPrevio(pre, visitados);
    if (encontrado) return encontrado;
  }
  return null;
}

function nombreOrigenBlend(origen) {
  if (!origen) return "Origen";
  const datos = origen.datos || {};
  const contenedorPrevio = obtenerContenedorPrevio(origen);
  if (contenedorPrevio && contenedorPrevio !== origen) {
    return nombreOrigenBlend(contenedorPrevio);
  }
  if (origen.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      (datos.id_ref ? `Depósito ${datos.id_ref}` : "Depósito")
    );
  }
  if (origen.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback = datos.contenedor_id
      ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
      : "";
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza"
    );
  }
  if (origen.tipo === "entrada") {
    const entradaId = obtenerEntradaIdDesdeNodo(origen);
    return entradaId ? obtenerEtiquetaEntrada(entradaId) : origen.titulo || "Entrada";
  }
  return origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
}

function obtenerEtiquetaEntrada(id) {
  if (!id) return "";
  const entrada = cacheEntradas.find(e => String(e.id) === String(id));
  if (!entrada) return `Entrada #${id}`;
  const variedad = entrada.variedad ? ` (${entrada.variedad})` : "";
  return `Entrada #${id}${variedad}`;
}

function buscarEntradaPorId(id) {
  if (!id || !Array.isArray(cacheEntradas)) return null;
  return cacheEntradas.find(e => String(e.id) === String(id)) || null;
}

function buscarDepositoPorId(id) {
  if (!id || !Array.isArray(cacheDepositos)) return null;
  const dep = cacheDepositos.find(d => String(d.id) === String(id));
  if (dep) return dep;
  if (Array.isArray(cacheMastelones)) {
    const mas = cacheMastelones.find(m => String(m.id) === String(id));
    if (mas) return mas;
  }
  return null;
}

function buscarDepositoPorCodigo(codigo) {
  if (!codigo) return null;
  const dep =
    (cacheDepositos || []).find(d => filterByCodeOrAlias(d, codigo)) ||
    (cacheMastelones || []).find(d => filterByCodeOrAlias(d, codigo));
  return dep || null;
}

function resolverInfoDepositoDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "deposito") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.id_ref) {
    info = buscarDepositoPorId(datos.id_ref);
  }
  if (!info && datos.codigo) {
    info = buscarDepositoPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarDepositoPorCodigo(nodo.titulo);
  }
  return info;
}

function buscarBarricaPorId(id) {
  if (!id || !Array.isArray(cacheBarricas)) return null;
  return cacheBarricas.find(b => String(b.id) === String(id)) || null;
}

function buscarBarricaPorCodigo(codigo) {
  if (!codigo || !Array.isArray(cacheBarricas)) return null;
  return cacheBarricas.find(b => filterByCodeOrAlias(b, codigo)) || null;
}

function resolverInfoBarricaDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.contenedor_id) {
    info = buscarBarricaPorId(datos.contenedor_id);
  }
  if (!info && datos.codigo) {
    info = buscarBarricaPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarBarricaPorCodigo(nodo.titulo);
  }
  return info;
}

function obtenerContenedorPorIdRef(idRef) {
  if (!idRef) return null;
  const dep = buscarDepositoPorId(idRef);
  if (dep) {
    return { tipo: "deposito", codigo: dep.codigo, variedad: dep.vino_tipo };
  }
  const bar = buscarBarricaPorId(idRef);
  if (bar) {
    return { tipo: "barrica", codigo: bar.codigo, variedad: bar.vino_tipo };
  }
  return null;
}

function rellenarDatosDepositoDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "deposito") return;
  let info = null;
  if (nodo.datos?.id_ref) {
    info = buscarDepositoPorId(nodo.datos.id_ref);
  }
  if (!info) {
    info = buscarDepositoPorCodigo(nodo.datos?.codigo || nodo.titulo);
  }
  if (!info) return;
  if (nodo.datos && info.id != null && !nodo.datos.id_ref) {
    nodo.datos.id_ref = info.id;
  }
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    nodo.datos.capacidad ||
    info.capacidad_l ||
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.capacidad_l = nodo.datos.capacidad_l || nodo.datos.capacidad || info.capacidad_l || null;
}

function rellenarDatosCrianzaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const tipoCont = claveContenedor(nodo.datos?.contenedor_tipo) || "barrica";
  const id = nodo.datos?.contenedor_id || nodo.datos?.id_ref;
  if (!id) return;
  const info =
    tipoCont === "barrica"
      ? buscarBarricaPorId(id) || buscarBarricaPorCodigo(nodo.datos?.codigo || nodo.titulo)
      : buscarDepositoPorId(id) || buscarDepositoPorCodigo(nodo.datos?.codigo || nodo.titulo);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  const capInfo =
    info.capacidad_l ??
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : null) ??
    nodo.datos.capacidad;
  if (capInfo != null) {
    nodo.datos.capacidad = capInfo;
    nodo.datos.capacidad_l = capInfo;
  }
  // Texto descriptivo del contenedor elegido para mostrar en modal/nodo.
  const tipoLabel = nodo.datos.contenedor_tipo || (tipoCont === "barrica" ? "Barrica" : "Depósito");
  const descripcion = describirContenedor(info, tipoLabel);
  if (descripcion) {
    nodo.datos.tipo = descripcion;
  } else if (tipoLabel) {
    nodo.datos.tipo = tipoLabel;
  }
}

// Cargar nodos (preferimos el estado en memoria) y mapear por id
function getNodosPorId() {
  const enMemoria = Array.isArray(flujoNodos) ? flujoNodos : [];
  let nodos = enMemoria;
  if (!nodos.length) {
    const guardado = JSON.parse(localStorage.getItem("flowNodes") || "null");
    const normalizado = migrarSnapshotLegacy(guardado);
    nodos = normalizado.nodes;
  }
  return Object.fromEntries(nodos.map(n => [n.id, n]));
}

function crearMapaDeposPorRef(nodosPorId) {
  const mapa = {};
  Object.values(nodosPorId || {}).forEach(nodo => {
    if (nodo.tipo === "deposito" && nodo.datos?.id_ref != null) {
      const clave = String(nodo.datos.id_ref);
      rellenarDatosDepositoDesdeCache(nodo);
      if (!mapa[clave]) {
        mapa[clave] = {
          codigo: nodo.datos.codigo || nodo.titulo || `Depósito #${clave}`,
          nodoId: nodo.id,
        };
      }
    }
  });
  return mapa;
}

function getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef) {
  const nodo = nodosPorId[idNodoDestino];
  if (!nodo) return `Nodo ${idNodoDestino}`;

  const datos = nodo.datos || {};
  const mapa = mapaDepRef || crearMapaDeposPorRef(nodosPorId);

  switch (nodo.tipo) {
    case "deposito":
      // A1, A2, A3…
      if (datos.id_ref != null) {
        const depMap = mapa[String(datos.id_ref)];
        if (depMap?.codigo) return depMap.codigo;
        const info = buscarDepositoPorId(datos.id_ref);
        if (info?.codigo) return info.codigo;
      }
      return `${datos.codigo || nodo.titulo || "Depósito"}`;

    case "barrica":
      // Crianza / Barrica 500L Francés, etc.
      return nodo.titulo || datos.tipo || "Crianza";

    case "entrada":
      // Solo por si algún día enlazas a otra entrada
      const entradaId = obtenerEntradaIdDesdeNodo(nodo);
      const entrada = obtenerEntradaRealDesdeNodo(nodo);
      return `Entrada #${entradaId || "?"}${
        entrada?.variedad ? ` (${entrada.variedad})` : ""
      }`;

    default:
      return nodo.titulo || nodo.tipo || `Nodo ${idNodoDestino}`;
  }
}

function buildRepartoDestinos(nodoElaboracion) {
  if (!nodoElaboracion) return [];
  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const distribucion = nodoElaboracion.datos?.distribucion || {};
  return Object.entries(distribucion).map(([idNodoDestino, valores]) => {
    return {
      idNodoDestino,
      nombre: getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef),
      volumen: getVolumenFromDatos(valores) || 0,
    };
  });
}

function etiquetarDestinoFlow(dest) {
  if (!dest) return "Nodo";
  const datos = dest.datos || {};

  if (dest.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    const nombre =
      info?.codigo ||
      datos.codigo ||
      dest.titulo ||
      (datos.id_ref ? `Depósito #${datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback =
      datos.contenedor_id
        ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
        : "";
    const nombre =
      info?.codigo ||
      dest.titulo ||
      datos.codigo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza";
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "entrada") {
    const entradaId = obtenerEntradaIdDesdeNodo(dest);
    if (entradaId) return obtenerEtiquetaEntrada(entradaId);
  }

  // Si viene con id_ref de contenedor aunque el tipo no sea depósito/barrica, intentamos resolverlo
  const contenedor = obtenerContenedorPorIdRef(datos.id_ref);
  if (contenedor) {
    const nombre = contenedor.codigo || dest.titulo || (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad = obtenerVariedadVisibleNodo(dest);
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  return dest.titulo || dest.tipo || "Nodo";
}

function obtenerEtiquetaNodoLimite(nodo) {
  if (!nodo) return "Este nodo";
  if (nodo.tipo === "entrada") {
    const entradaId = obtenerEntradaIdDesdeNodo(nodo);
    return (entradaId ? obtenerEtiquetaEntrada(entradaId) : null) || "Esta entrada";
  }
  if (nodo.tipo === "deposito") {
    return nodo.datos?.codigo || nodo.titulo || "Depósito";
  }
  return nodo.titulo || "Este nodo";
}

function obtenerVolumenBaseNodoParaUI(nodo) {
  return calcularVolumenNodoPorFlujo(nodo);
}

function obtenerVolumenRestanteNodo(nodo) {
  if (!nodo) return null;
  const base = obtenerVolumenBaseNodoParaUI(nodo);
  if (!Number.isFinite(base)) return null;
  const role = obtenerRolNodo(nodo);
  if (role === "PROCESS" || nodo.tipo === "entrada") {
    return Number(base);
  }
  const targets = (nodo.targets || [])
    .map(id => normalizarIdNodo(id))
    .filter(Boolean);
  if (!targets.length) return Number(base);
  const memo = new Map();
  const stack = new Set();
  const nodoId = normalizarIdNodo(nodo);
  if (nodoId) memo.set(nodoId, base);
  let asignado = 0;
  targets.forEach(tid => {
    const dest = buscarNodoPorId(tid);
    if (!dest) return;
    const vol = calcularVolumenTransferido(nodo, dest, memo, stack);
    if (Number.isFinite(vol) && vol > 0) asignado += vol;
  });
  const restante = Math.max(0, Number(base) - asignado);
  return Number(restante.toFixed(2));
}

function obtenerAsignacionDestino(destino, origenId) {
  if (!destino?.datos?.asignaciones) return null;
  const key = origenId != null ? String(origenId) : "";
  const reg =
    destino.datos.asignaciones[key] ||
    destino.datos.asignaciones[normalizarIdNodo(origenId)];
  if (!reg) return null;
  const valor = getVolumenFromDatos(reg);
  return Number.isFinite(valor) && valor > 0 ? valor : null;
}

function calcularDistribucionManual(origen, targets, disponible) {
  if (!origen?.datos?.distribucion) return null;
  const distribucion = origen.datos.distribucion || {};
  const valores = {};
  let total = 0;
  targets.forEach(id => {
    const reg = distribucion[id];
    const val = getVolumenFromDatos(reg);
    if (Number.isFinite(val) && val > 0) {
      valores[id] = val;
      total += val;
    }
  });
  if (!(total > 0)) return null;
  if (Number.isFinite(disponible) && disponible > 0 && total > disponible + 0.0001) {
    const factor = disponible / total;
    const ajustados = {};
    Object.entries(valores).forEach(([id, v]) => {
      ajustados[id] = Number((v * factor).toFixed(2));
    });
    return ajustados;
  }
  return valores;
}

function calcularVolumenTransferidoBruto(origen, destino, memo, stack) {
  if (!origen || !destino) return 0;
  const destinoId = normalizarIdNodo(destino);
  if (!destinoId) return 0;
  const asignacion = obtenerAsignacionDestino(destino, origen.id);
  if (asignacion != null) return Number(asignacion.toFixed(2));

  const volOrigen = calcularVolumenNodoPorFlujo(origen, memo, stack);
  if (!Number.isFinite(volOrigen) || volOrigen <= 0) return 0;
  const targets = (origen.targets || [])
    .map(id => normalizarIdNodo(id))
    .filter(Boolean);
  if (!targets.length) return 0;

  const repartoManualEntrada = origen.tipo === "entrada" && origen.datos?.reparto_manual === true;
  const manual = repartoManualEntrada || origen.tipo === "estilo";
  if (manual) {
    const map = calcularDistribucionManual(origen, targets, volOrigen);
    if (map && map[destinoId] != null) return map[destinoId];
    if (repartoManualEntrada) return 0;
  }

  const partes = targets.length;
  return partes > 0 ? Number((volOrigen / partes).toFixed(2)) : 0;
}

function calcularVolumenTransferido(origen, destino, memo, stack) {
  if (!origen || !destino) return 0;
  const bruto = calcularVolumenTransferidoBruto(origen, destino, memo, stack);
  if (!(Number.isFinite(bruto) && bruto > 0)) return 0;

  // Tope duro: depósitos y barricas nunca superan su capacidad disponible.
  if (destino.tipo !== "deposito" && destino.tipo !== "barrica") {
    return bruto;
  }

  const capacidadLibreBase = obtenerCapacidadDisponibleContenedor(destino);
  if (capacidadLibreBase == null) return bruto;
  if (!(capacidadLibreBase > 0)) return 0;

  const destinoId = normalizarIdNodo(destino.id);
  const origenId = normalizarIdNodo(origen.id);
  const predecesores = (obtenerPredecesores(destinoId) || [])
    .map(pre => normalizarIdNodo(pre))
    .filter(Boolean);
  if (!predecesores.length) {
    return Math.min(bruto, Number(capacidadLibreBase.toFixed(2)));
  }

  let totalBrutoEntrante = 0;
  predecesores.forEach(preId => {
    const preNodo = buscarNodoPorId(preId);
    if (!preNodo) return;
    const brutoPre = calcularVolumenTransferidoBruto(preNodo, destino, memo, stack);
    if (Number.isFinite(brutoPre) && brutoPre > 0) {
      totalBrutoEntrante += brutoPre;
    }
  });

  if (!(totalBrutoEntrante > 0)) return 0;
  if (totalBrutoEntrante <= capacidadLibreBase + 0.0001) {
    return Number(bruto.toFixed(2));
  }

  const factor = capacidadLibreBase / totalBrutoEntrante;
  if (!(factor > 0)) return 0;
  if (!predecesores.includes(origenId)) return 0;
  return Number((bruto * factor).toFixed(2));
}

function calcularResumenTransferenciaCapacidad(origen, destino, memo = new Map(), stack = new Set()) {
  const solicitado = calcularVolumenTransferidoBruto(origen, destino, memo, stack);
  const aceptado = calcularVolumenTransferido(origen, destino, memo, stack);
  const solicitadoNum = Number.isFinite(solicitado) ? Number(solicitado) : 0;
  const aceptadoNum = Number.isFinite(aceptado) ? Number(aceptado) : 0;
  const retenido = Math.max(0, Number((solicitadoNum - aceptadoNum).toFixed(2)));
  return {
    solicitado: solicitadoNum,
    aceptado: aceptadoNum,
    retenido,
    clipped: retenido > 0.01,
  };
}

function obtenerVolumenRetenidoDestinoPorCapacidad(nodoDestino) {
  if (!nodoDestino || (nodoDestino.tipo !== "deposito" && nodoDestino.tipo !== "barrica")) return 0;
  const predecesores = obtenerPredecesores(nodoDestino.id) || [];
  if (!predecesores.length) return 0;
  let retenidoTotal = 0;
  predecesores.forEach(pre => {
    const resumen = calcularResumenTransferenciaCapacidad(pre, nodoDestino, new Map(), new Set());
    if (resumen.clipped) retenidoTotal += resumen.retenido;
  });
  return Number(retenidoTotal.toFixed(2));
}

function calcularVolumenNodoPorFlujo(nodo, memo = new Map(), stack = new Set(), aplicarMerma = true) {
  if (!nodo) return null;
  const idNorm = normalizarIdNodo(nodo);
  if (idNorm && memo.has(idNorm)) return memo.get(idNorm);
  if (idNorm && stack.has(idNorm)) return null;
  if (idNorm) stack.add(idNorm);

  if (nodo.tipo === "entrada") {
    const kilos = obtenerKilosEntradaDesdeNodo(nodo);
    const fallback = getVolumenFromDatos(nodo.datos);
    const valor =
      Number.isFinite(kilos) ? Number(kilos.toFixed(2)) :
      Number.isFinite(fallback) ? Number(fallback.toFixed(2)) : null;
    if (idNorm) {
      memo.set(idNorm, valor);
      stack.delete(idNorm);
    }
    return valor;
  }

  const predecesores = obtenerPredecesores(nodo.id);
  let total = 0;
  let tieneAportes = false;
  if (Array.isArray(predecesores) && predecesores.length) {
    predecesores.forEach(pre => {
      const aporte = calcularVolumenTransferido(pre, nodo, memo, stack);
      if (Number.isFinite(aporte) && aporte > 0) {
        total += aporte;
        tieneAportes = true;
      }
    });
  }
  let valorFinal = null;
  if (tieneAportes) {
    valorFinal = Number(total.toFixed(2));
  } else {
    const base = getVolumenFromDatos(nodo.datos);
    valorFinal = Number.isFinite(base) ? Number(base.toFixed(2)) : null;
  }
  if (
    aplicarMerma &&
    valorFinal != null &&
    nodo.tipo !== "entrada" &&
    !NODOS_SIN_VOLUMEN.has(nodo.tipo)
  ) {
    const mermaPct = normalizarNumero(nodo.datos?.merma);
    if (Number.isFinite(mermaPct) && mermaPct > 0) {
      const factor = Math.min(Math.max(mermaPct, 0), 95) / 100;
      valorFinal = Number((valorFinal * (1 - factor)).toFixed(2));
    }
  }
  if (idNorm) {
    memo.set(idNorm, valorFinal);
    stack.delete(idNorm);
  }
  return valorFinal;
}

function calcularVolumenNodoPorFlujoBase(nodo) {
  return calcularVolumenNodoPorFlujo(nodo, new Map(), new Set(), false);
}

function obtenerLitrosTransferenciaEntreNodos(origen, destino) {
  if (!origen || !destino) return 0;
  return calcularVolumenTransferido(origen, destino, new Map(), new Set());
}

function obtenerKilosTransferenciaEntreNodos(origen, destino) {
  if (!origen || !destino) return 0;
  return 0;
}

function obtenerVolumenTransferenciaEntreNodos(origen, destino) {
  const volumen = obtenerLitrosTransferenciaEntreNodos(origen, destino);
  return Number.isFinite(volumen) && volumen > 0 ? volumen : 0;
}

function obtenerVolumenVisualNodo(nodo) {
  if (!nodo) return null;
  if (esNodoProcesoSinVolumen(nodo)) return null;
  const restante = obtenerVolumenRestanteNodo(nodo);
  return restante != null ? restante : null;
}

const ESTADOS_VINO = Array.isArray(window.BITACORA_ESTADOS_VINO)
  ? window.BITACORA_ESTADOS_VINO
  : [
      { value: "tranquilo", label: "Tranquilo" },
      { value: "activo", label: "Activo" },
      { value: "violento", label: "Violento" },
      { value: "lento", label: "Lento" },
      { value: "inestable", label: "Inestable" },
      { value: "reductivo", label: "Reductivo" },
      { value: "abierto", label: "Abierto" },
      { value: "cerrado", label: "Cerrado" },
      { value: "tenso", label: "Tenso" },
      { value: "equilibrado", label: "Equilibrado" },
      { value: "personalizado", label: "Personalizado" },
    ];
const ESTADO_PERSONALIZADO = window.BITACORA_ESTADO_PERSONALIZADO || "personalizado";
const COPILOTO_ESTADOS_RAPIDOS = [
  { value: "densidad", label: "Densidad" },
  { value: "temperatura", label: "Temperatura" },
];

function crearTablaControlFermentacion(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.control)) {
    nodo.datos.control = [];
  }
  const contenedor = document.createElement("div");
  contenedor.className = "tabla-control-fermentacion";

  const toolbar = document.createElement("div");
  toolbar.style.display = "flex";
  toolbar.style.justifyContent = "flex-end";
  toolbar.style.marginBottom = "6px";
  const btnPdf = document.createElement("button");
  btnPdf.type = "button";
  btnPdf.className = "small-btn";
  btnPdf.textContent = "PDF";
  btnPdf.addEventListener("click", () => exportarTablaControlPDF(nodo));
  toolbar.appendChild(btnPdf);
  contenedor.appendChild(toolbar);

  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Fecha</th>
      <th>Densidad</th>
      <th>°C</th>
      <th>Estado</th>
      <th>Productos</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.control.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="6" style="text-align:center; color:#777;">Sin registros</td>`;
      tbody.appendChild(fila);
      return;
    }
    nodo.datos.control.forEach((registro, index) => {
      const tr = document.createElement("tr");
      const tdFecha = document.createElement("td");
      const inputFecha = document.createElement("input");
      inputFecha.type = "date";
      inputFecha.value = registro.fecha || "";
      inputFecha.dataset.index = index;
      inputFecha.dataset.campo = "fecha";
      tdFecha.appendChild(inputFecha);

      const tdDensidad = document.createElement("td");
      const inputDensidad = document.createElement("input");
      inputDensidad.type = "number";
      inputDensidad.step = "0.001";
      inputDensidad.value = registro.densidad || "";
      inputDensidad.dataset.index = index;
      inputDensidad.dataset.campo = "densidad";
      tdDensidad.appendChild(inputDensidad);

      const tdTemp = document.createElement("td");
      const inputTemp = document.createElement("input");
      inputTemp.type = "number";
      inputTemp.step = "0.1";
      inputTemp.value = registro.temperatura || "";
      inputTemp.dataset.index = index;
      inputTemp.dataset.campo = "temperatura";
      tdTemp.appendChild(inputTemp);

      const tdEstado = document.createElement("td");
      const estadoWrap = document.createElement("div");
      estadoWrap.style.display = "grid";
      estadoWrap.style.gap = "4px";
      const selectEstado = document.createElement("select");
      const optionEmpty = document.createElement("option");
      optionEmpty.value = "";
      optionEmpty.textContent = "Sin estado";
      selectEstado.appendChild(optionEmpty);
      ESTADOS_VINO.forEach(item => {
        const option = document.createElement("option");
        option.value = item.value;
        option.textContent = item.label;
        selectEstado.appendChild(option);
      });
      selectEstado.value = registro.estado_vino || "";
      selectEstado.dataset.index = index;
      selectEstado.dataset.campo = "estado_vino";

      const inputEstado = document.createElement("input");
      inputEstado.type = "text";
      inputEstado.placeholder = "Personalizado";
      inputEstado.maxLength = 40;
      inputEstado.value = registro.estado_vino_texto || "";
      inputEstado.dataset.index = index;
      inputEstado.dataset.campo = "estado_vino_texto";
      inputEstado.style.display = selectEstado.value === ESTADO_PERSONALIZADO ? "block" : "none";

      estadoWrap.appendChild(selectEstado);
      estadoWrap.appendChild(inputEstado);
      tdEstado.appendChild(estadoWrap);

      const tdProductos = document.createElement("td");
      const inputProductos = document.createElement("input");
      inputProductos.type = "text";
      inputProductos.value = registro.productos || "";
      inputProductos.dataset.index = index;
      inputProductos.dataset.campo = "productos";
      tdProductos.appendChild(inputProductos);

      const tdEliminar = document.createElement("td");
      const btnEliminar = document.createElement("button");
      btnEliminar.type = "button";
      btnEliminar.className = "small-btn";
      btnEliminar.dataset.index = index;
      btnEliminar.dataset.accion = "eliminar";
      btnEliminar.textContent = "✕";
      tdEliminar.appendChild(btnEliminar);

      tr.appendChild(tdFecha);
      tr.appendChild(tdDensidad);
      tr.appendChild(tdTemp);
      tr.appendChild(tdEstado);
      tr.appendChild(tdProductos);
      tr.appendChild(tdEliminar);
      tbody.appendChild(tr);
    });
  };
  renderFilas();
  tabla.appendChild(tbody);
  tabla.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    guardarEstadoNodos();
  });
  tabla.addEventListener("change", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    if (campo === "estado_vino") {
      const wrap = target.parentElement;
      const input = wrap?.querySelector("input[data-campo='estado_vino_texto']");
      if (input) {
        const mostrar = target.value === ESTADO_PERSONALIZADO;
        input.style.display = mostrar ? "block" : "none";
        if (!mostrar) {
          input.value = "";
          nodo.datos.control[index].estado_vino_texto = "";
        }
      }
    }
    guardarEstadoNodos();
  });
  tabla.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = btn.dataset.index;
    nodo.datos.control.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
  });
  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ Añadir control";
  btnAdd.addEventListener("click", () => {
    nodo.datos.control.push({
      fecha: nodo.datos.fecha_operacion || nodo.datos.fecha || "",
      densidad: "",
      temperatura: "",
      estado_vino: "",
      estado_vino_texto: "",
      productos: "",
    });
    guardarEstadoNodos();
    renderFilas();
  });
  contenedor.appendChild(tabla);
  contenedor.appendChild(btnAdd);
  return contenedor;
}

function crearTablaFormatosEmbotellado(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.formatos_botella)) {
    nodo.datos.formatos_botella = [];
  }
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-formatos-embotellado";
  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Formato</th>
      <th>Botellas</th>
      <th>L calc.</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  tabla.appendChild(tbody);
  const resumen = document.createElement("div");
  resumen.className = "tabla-formatos-resumen";
  const formatosDisponibles = Object.keys(VOLUMEN_BOTELLA_L);

  const calcularLitrosTexto = registro => {
    if (!registro) return "";
    const formato = registro.formato;
    const botellasRaw = normalizarNumero(registro.botellas);
    const botellas = Number.isFinite(botellasRaw) ? Math.max(0, Math.floor(botellasRaw)) : 0;
    const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
    if (volBotella > 0 && botellas > 0) {
      return (botellas * volBotella).toFixed(2);
    }
    return "";
  };

  const actualizarResumen = () => {
    const resumenDatos = calcularResumenFormatosBotella(nodo);
    const litrosDisponibles = obtenerLitrosDisponiblesPredecesoresLedger(nodo);
    const botellasTxt = resumenDatos.totalBotellas
      ? `${resumenDatos.totalBotellas.toLocaleString("es-ES")} botellas`
      : "0 botellas";
    const litrosTxt = resumenDatos.totalLitros
      ? ` · ${resumenDatos.totalLitros.toFixed(2)} L`
      : "";
    const dispTxt = litrosDisponibles
      ? ` · ${litrosDisponibles.toFixed(2)} L disponibles`
      : "";
    resumen.textContent = `Total: ${botellasTxt}${litrosTxt}${dispTxt}`;
  };

  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.formatos_botella.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="4" style="text-align:center; color:#777;">Sin formatos mixtos</td>`;
      tbody.appendChild(fila);
      actualizarResumen();
      return;
    }
    nodo.datos.formatos_botella.forEach((registro, index) => {
      const tr = document.createElement("tr");
      const tdFormato = document.createElement("td");
      const select = document.createElement("select");
      select.dataset.index = index;
      select.dataset.campo = "formato";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Selecciona formato";
      if (!registro.formato) placeholder.selected = true;
      select.appendChild(placeholder);
      formatosDisponibles.forEach(op => {
        const option = document.createElement("option");
        option.value = op;
        option.textContent = op;
        select.appendChild(option);
      });
      if (registro.formato) select.value = registro.formato;
      tdFormato.appendChild(select);
      const tdBotellas = document.createElement("td");
      const input = document.createElement("input");
      input.type = "number";
      input.min = "0";
      input.step = "1";
      input.dataset.index = index;
      input.dataset.campo = "botellas";
      input.value = registro.botellas != null ? registro.botellas : "";
      tdBotellas.appendChild(input);
      const tdLitros = document.createElement("td");
      tdLitros.dataset.index = index;
      tdLitros.dataset.campo = "litros";
      tdLitros.textContent = calcularLitrosTexto(registro);
      const tdAccion = document.createElement("td");
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "small-btn";
      btn.textContent = "✕";
      btn.dataset.index = index;
      btn.dataset.accion = "eliminar";
      tdAccion.appendChild(btn);
      tr.appendChild(tdFormato);
      tr.appendChild(tdBotellas);
      tr.appendChild(tdLitros);
      tr.appendChild(tdAccion);
      tbody.appendChild(tr);
    });
    actualizarResumen();
  };

  tbody.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    if (!nodo.datos.formatos_botella[index]) return;
    nodo.datos.formatos_botella[index][campo] = target.value;
    const litrosCell = tbody.querySelector(
      `td[data-index="${index}"][data-campo="litros"]`
    );
    if (litrosCell) {
      litrosCell.textContent = calcularLitrosTexto(nodo.datos.formatos_botella[index]);
    }
    guardarEstadoNodos();
    actualizarResumen();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  tbody.addEventListener("change", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    if (!nodo.datos.formatos_botella[index]) return;
    nodo.datos.formatos_botella[index][campo] = target.value;
    const litrosCell = tbody.querySelector(
      `td[data-index="${index}"][data-campo="litros"]`
    );
    if (litrosCell) {
      litrosCell.textContent = calcularLitrosTexto(nodo.datos.formatos_botella[index]);
    }
    guardarEstadoNodos();
    actualizarResumen();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  tbody.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = Number(btn.dataset.index);
    if (!Number.isFinite(index)) return;
    nodo.datos.formatos_botella.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ Añadir formato";
  btnAdd.addEventListener("click", () => {
    const formatoBase =
      (nodo.datos.botella && VOLUMEN_BOTELLA_L[nodo.datos.botella] != null
        ? nodo.datos.botella
        : formatosDisponibles[0]) || "";
    nodo.datos.formatos_botella.push({ formato: formatoBase, botellas: "" });
    guardarEstadoNodos();
    renderFilas();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  renderFilas();
  wrapper.appendChild(tabla);
  wrapper.appendChild(btnAdd);
  wrapper.appendChild(resumen);
  return wrapper;
}

function crearTablaAsignacionesDeposito(nodo, soloLectura = false) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  limpiarAsignacionesOrfanas(nodo);
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) {
    const mensaje =
      nodo.tipo === "coupage"
        ? "Conecta depósitos para seleccionar el volumen de cada uno."
        : "Conecta este depósito para repartir volumen.";
    wrapper.innerHTML = `<p style='font-size:13px; color:#666;'>${mensaje}</p>`;
    return wrapper;
  }
  nodo.datos = nodo.datos || {};
  nodo.datos.asignaciones = nodo.datos.asignaciones || {};
  const esCoupage = nodo.tipo === "coupage";
  if (esCoupage) {
    const infoDest = obtenerTotalesDestino(nodo);
    if (infoDest) {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#777";
      info.textContent = `Destino: capacidad ${formatearVolumenPlano(infoDest.capTotal)} · Libre ${formatearVolumenPlano(infoDest.libre)}`;
      wrapper.appendChild(info);
    } else {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#c06";
      info.textContent = "Conecta este blend a un destino (depósito o barrica) para ver la capacidad libre, o revisa que el destino tenga capacidad/volumen definidos.";
      wrapper.appendChild(info);
    }
  }
  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Origen</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  predecesores.forEach(origen => {
    const key = origen.id.toString();
    const volumenPorDefecto = Number(obtenerVolumenNumericoNodo(origen) || 0);
    const volumenNodoDisponibles = (() => {
	      if (!esCoupage) return volumenPorDefecto;
	      if (origen.tipo === "deposito") {
	        const idRef = origen.datos?.id_ref || origen.datos?.contenedor_id || origen.datos?.codigo || origen.id;
	        const vol = obtenerVolumenFinalNodoContenedor("deposito", idRef);
	        if (Number.isFinite(vol)) return vol;
	        const fallbackVol = obtenerVolumenNumericoNodo(origen) ?? volumenPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
	      }
	      if (origen.tipo === "barrica") {
	        const idRef = origen.datos?.contenedor_id || origen.datos?.id_ref || origen.datos?.codigo || origen.id;
	        const vol = obtenerVolumenFinalNodoContenedor("barrica", idRef);
	        if (Number.isFinite(vol)) return vol;
	        const fallbackVol = obtenerVolumenNumericoNodo(origen) ?? volumenPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      return volumenPorDefecto;
    })();
    const registro = asegurarAsignacionRegistro(
      nodo,
      origen.id,
      Number.isFinite(volumenPorDefecto) && volumenPorDefecto > 0 ? volumenPorDefecto : null
    );
    const tr = document.createElement("tr");
    const nombreBase = describirNodoOrigen(origen);
    const nombre = esCoupage
      ? nombreOrigenBlend(origen)
      : nombreBase;
    const disponibleTexto = esCoupage ? `Disponible: ${Number(volumenNodoDisponibles || 0).toFixed(2)}` : describirNodoOrigen(origen);
    const valorVolumen = getVolumenFromDatos(registro) || "";
    tr.innerHTML = `
      <td>${nombre}<br><small>${disponibleTexto}</small></td>
      <td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorVolumen}" data-origen="${key}" data-tipo="volumen"${esCoupage && Number.isFinite(volumenNodoDisponibles) ? ` data-max-volumen="${Number(volumenNodoDisponibles).toFixed(4)}"` : ""}></td>`;
    if (!soloLectura) {
	      const inputs = tr.querySelectorAll("input");
	      inputs.forEach(input => {
	        input.addEventListener("input", () => {
	          const valor = Number(input.value);
	          const tipo = input.dataset.tipo;
	          setVolumenRegistro(registro, Number.isFinite(valor) ? valor : null);
	          registro.__manual = true;
	          if (esCoupage && tipo === "volumen") {
	            const maxAttr = input.dataset.maxVolumen;
	            const max = maxAttr != null ? Number(maxAttr) : null;
	            if (Number.isFinite(max) && max > 0 && valor > max) {
              setVolumenRegistro(registro, max);
              input.value = max.toFixed(2);
              mostrarAviso("No puedes usar más volumen del disponible en el depósito.", "error");
            }
	          }
	          actualizarVariedadDesdeAportes(nodo);
	          guardarEstadoNodos();
	          renderFlowNodes();
	          mostrarInfoNodo(nodo.id);
	        });
	      });
	    }
    tbody.appendChild(tr);
  });
  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function limpiarDistribucionEstilo(nodo) {
  if (!nodo || !nodo.datos?.distribucion) return;
  const permitidos = new Set((nodo.targets || []).map(id => String(id)));
  Object.keys(nodo.datos.distribucion).forEach(key => {
    if (!permitidos.has(key)) {
      delete nodo.datos.distribucion[key];
    }
  });
}

function ajustarDistribucionEstilo(nodo, cargaBase) {
  if (!nodo || nodo.tipo !== "estilo") return;
  const distribucion = nodo.datos?.distribucion;
  if (!distribucion) return;
  const targets = (nodo.targets || []).map(id => String(id));
  if (!targets.length) return;
  let totalAsignado = 0;
  targets.forEach(id => {
    const reg = distribucion[id];
    if (!reg) return;
    const valor = getVolumenFromDatos(reg) || 0;
    if (valor > 0) totalAsignado += valor;
  });
  if (!(totalAsignado > 0)) return;
  const disponibleRaw = getVolumenFromDatos(cargaBase);
  const disponible = Number.isFinite(disponibleRaw) ? Number(disponibleRaw.toFixed(4)) : 0;
  if (totalAsignado <= disponible + 0.0001) return;
  const factor = disponible / totalAsignado;
  targets.forEach(id => {
    const reg = distribucion[id];
    if (!reg) return;
    const actual = getVolumenFromDatos(reg);
    if (!(actual > 0)) return;
    const nuevo = Number((actual * factor).toFixed(2));
    reg.volumen = nuevo;
    reg.kilos = null;
    reg.litros = null;
  });
  if (flowDebugActivo()) {
    console.debug("[flow][estilo] Distribucion ajustada", {
      nodo: nodo.id,
      disponible,
      totalAsignado,
      factor: Number(factor.toFixed(4)),
    });
  }
}

function crearTablaDistribucionEstilo(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const distribucion = nodo.datos?.distribucion || {};
  const entradasDistrib = Object.entries(distribucion);
  if (!entradasDistrib.length) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta este nodo a otro para repartir el volumen.</p>";
    return wrapper;
  }
  const mapaNodos = getNodosPorId();
  const dispVolumen = Number(calcularVolumenNodoPorFlujo(nodo) || 0);
  const totDestinos = nodo.tipo === "coupage" ? obtenerTotalesDestino(nodo) : null;
  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  const infoCap =
    totDestinos
      ? ` | Destino: ${Number.isFinite(totDestinos.capTotal) ? formatearVolumenPlano(totDestinos.capTotal) + " cap" : "capacidad n/d"} · Libre ${Number.isFinite(totDestinos.libre) ? formatearVolumenPlano(totDestinos.libre) : "—"}`
      : "";
  resumen.textContent = `Disponible: ${dispVolumen.toFixed(2)}${infoCap}`;
  wrapper.appendChild(resumen);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  const destinos = buildRepartoDestinos(nodo);

	  destinos.forEach(dest => {
	    const tr = document.createElement("tr");
	    tr.innerHTML = `
	      <td>${dest.nombre}</td>
	      <td><input type="number" step="0.01" min="0" value="${dest.volumen || ""}" data-destino="${dest.idNodoDestino}" data-tipo="volumen"></td>`;
	    tr.querySelectorAll("input").forEach(input => {
	      input.addEventListener("input", () => {
	        const snapshotDistrib = JSON.parse(JSON.stringify(nodo.datos?.distribucion || {}));
	        const valor = Number(input.value);
	        const tipo = input.dataset.tipo;
	        if (!nodo.datos.distribucion[dest.idNodoDestino]) {
	          nodo.datos.distribucion[dest.idNodoDestino] = { volumen: 0 };
	        }
	        nodo.datos.distribucion[dest.idNodoDestino][tipo] = Number.isFinite(valor) ? valor : "";
	        nodo.datos.distribucion[dest.idNodoDestino].kilos = null;
	        nodo.datos.distribucion[dest.idNodoDestino].litros = null;

	        guardarEstadoNodos();
	        renderFlowNodes();
	        mostrarInfoNodo(nodo.id);
	      });
	    });
	    tbody.appendChild(tr);
	  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function obtenerCargaDistribuida(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "estilo") return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  if (!registro) return null;
  const valor = getVolumenFromDatos(registro);
  // Si no hay valores positivos, tratamos la distribución como "no definida"
  // y dejamos que actúe el reparto automático (o el fallback a un único destino).
  if (!(valor > 0)) return null;
  const carga = { ...cargaBase };
  carga.volumen = valor;
  return carga;
}

function obtenerCargaDistribuidaEntrada(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "entrada" || origen.datos?.reparto_manual !== true) return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  const volumen = getVolumenFromDatos(registro);
  const carga = { ...cargaBase, __manual: true };
  carga.volumen = Math.max(0, volumen ?? 0);
  return carga;
}

function crearTablaDistribucionEntrada(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const targets = (nodo.targets || []).map(id => String(id));
  if (targets.length < 2) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta esta entrada a varios nodos para repartir el volumen.</p>";
    return wrapper;
  }

  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const dispVolumen = Number(calcularVolumenNodoPorFlujo(nodo) || 0);
  const manual = nodo.datos?.reparto_manual === true;

  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  resumen.textContent = manual
    ? `Disponible: ${dispVolumen.toFixed(2)} · Reparto manual`
    : `Disponible: ${dispVolumen.toFixed(2)} · Reparto automático (a partes iguales)`;
  wrapper.appendChild(resumen);

  const hint = document.createElement("p");
  hint.style.fontSize = "12px";
  hint.style.color = "#777";
  hint.style.marginTop = "-6px";
  hint.textContent = manual
    ? "Edita el volumen por destino. Los cambios se aplican al flujo."
    : "Edita cualquier valor para activar el reparto manual.";
  wrapper.appendChild(hint);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");

  targets.forEach(destinoId => {
    const destino = nodosPorId[destinoId];
    if (!destino) return;
    const nombre = getNombreNodoDestino(destinoId, nodosPorId, mapaDepRef);
    const volumenActual = obtenerVolumenTransferenciaEntreNodos(nodo, destino);
    const valorManual = getVolumenFromDatos(nodo.datos?.distribucion?.[destinoId]) ?? 0;

    const tr = document.createElement("tr");
    const tdNombre = document.createElement("td");
    tdNombre.textContent = nombre;
    const tdKilos = document.createElement("td");
    const input = document.createElement("input");
    input.type = "number";
    input.step = "0.01";
    input.min = "0";
    if (manual) input.value = String(valorManual);
    input.placeholder = Number(volumenActual).toFixed(2);
    input.dataset.destino = destinoId;
    tdKilos.appendChild(input);
    tr.appendChild(tdNombre);
    tr.appendChild(tdKilos);
    input.addEventListener("input", () => {
      nodo.datos = nodo.datos || {};
      const eraManual = nodo.datos.reparto_manual === true;
      const snapshotDistrib = JSON.parse(JSON.stringify(nodo.datos.distribucion || {}));

      if (!eraManual) {
        nodo.datos.reparto_manual = true;
        nodo.datos.distribucion = {};
        // Sembrar el reparto actual (auto) para no "vaciar" otras ramas al activar el manual.
        targets.forEach(tid => {
          const dest = nodosPorId[tid];
          if (!dest) return;
          nodo.datos.distribucion[tid] = {
            volumen: obtenerVolumenTransferenciaEntreNodos(nodo, dest),
          };
        });
      } else {
        nodo.datos.distribucion = nodo.datos.distribucion || {};
      }

      if (!nodo.datos.distribucion[destinoId]) {
        nodo.datos.distribucion[destinoId] = { volumen: 0 };
      }

      const valorIngresado = normalizarNumero(input.value);
      const volumen = Math.max(0, valorIngresado ?? 0);
      nodo.datos.distribucion[destinoId].volumen = volumen;
      nodo.datos.distribucion[destinoId].kilos = null;
      nodo.datos.distribucion[destinoId].litros = null;

      limpiarDistribucionEstilo(nodo);
      guardarEstadoNodos();
      renderFlowNodes();
      mostrarInfoNodo(nodo.id);
    });

    tbody.appendChild(tr);
  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}


function actualizarVariedadDesdeAportes(nodo) {
  if (!nodo) return;
  // No se recalcula composición aquí: la mezcla proviene del ledger (compositions).
  return;
}

function obtenerVariedadDesdeAsignaciones(nodo) {
  if (!nodo) return "";
  const comp = calcularComposicionVariedades(nodo);
  const mezcla = formatearComposicionVariedades(comp.mix, comp.total);
  return mezcla || "";
}

function capYVolDesdeInfo(info, fallbackCap, fallbackVol, extraCap = null) {
  if (!info && fallbackCap == null && fallbackVol == null && extraCap == null) return { cap: null, vol: null };
  const capRaw =
    (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
    fallbackCap ??
    extraCap;
  const volRaw =
    (info && (info.litros_actuales ?? info.volumen)) ??
    fallbackVol ??
    0;
  return { cap: Number(capRaw), vol: Number(volRaw) };
}

function capacidadDisponibleContenedorDesdeInfo(info, fallbackCap, fallbackVol) {
  const { cap, vol } = capYVolDesdeInfo(info, fallbackCap, fallbackVol);
  if (cap == null || Number.isNaN(cap)) return null;
  const capacidad = Number(cap);
  const volumen = Number(vol) || 0;
  if (!Number.isFinite(capacidad)) return null;
  return Math.max(0, capacidad - volumen);
}

function obtenerCapacidadDisponibleContenedor(nodoDestino) {
  if (!nodoDestino) return null;
  const datos = nodoDestino.datos || {};
  if (nodoDestino.tipo === "deposito") {
    const info = resolverInfoDepositoDesdeNodo(nodoDestino);
    const capRaw =
      (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
      datos.capacidad ??
      datos.capacidad_l;
    const capacidad = Number(capRaw);
    if (!Number.isFinite(capacidad) || capacidad <= 0) return null;
    // Para el mapa usamos ocupación del propio flujo (balance del nodo), no litros históricos de BD.
    const balance = obtenerBalanceNodo(nodoDestino.id);
    const volNodo = Number.isFinite(balance) ? balance : getVolumenFromDatos(datos) || 0;
    return Math.max(0, capacidad - Math.max(0, Number(volNodo) || 0));
  }
  if (nodoDestino.tipo === "barrica") {
    const info = resolverInfoBarricaDesdeNodo(nodoDestino);
    const capRaw =
      (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
      datos.capacidad ??
      datos.capacidad_l;
    const capacidad = Number(capRaw);
    if (!Number.isFinite(capacidad) || capacidad <= 0) return null;
    // Para el mapa usamos ocupación del propio flujo (balance del nodo), no litros históricos de BD.
    const balance = obtenerBalanceNodo(nodoDestino.id);
    const volNodo = Number.isFinite(balance) ? balance : getVolumenFromDatos(datos) || 0;
    return Math.max(0, capacidad - Math.max(0, Number(volNodo) || 0));
  }
  return null;
}

function obtenerTotalesDestino(nodo) {
  if (!nodo || !Array.isArray(nodo.targets) || !nodo.targets.length) return null;
  let capTotal = 0;
  let volTotal = 0;
  let tieneDestino = false;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const datos = dest.datos || {};
    tieneDestino = true;
	    if (dest.tipo === "deposito") {
	      if (datos.id_ref && (!datos.capacidad && !datos.capacidad_l)) {
	        intentarPoblarNodoDeposito(dest, true);
	      }
      const info = resolverInfoDepositoDesdeNodo(dest);
      const balance = obtenerBalanceNodo(dest.id);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        Number.isFinite(balance) ? balance : datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    } else if (dest.tipo === "barrica") {
      const info = resolverInfoBarricaDesdeNodo(dest);
      const balance = obtenerBalanceNodo(dest.id);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        Number.isFinite(balance) ? balance : datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    }
  });
  if (!tieneDestino) return null;
  const libreCalc = Number.isFinite(capTotal) ? Math.max(0, capTotal - volTotal) : null;
  return { capTotal, volTotal, libre: libreCalc };
}

function obtenerCapacidadDisponibleDesdeTargets(nodo) {
  if (!nodo || !Array.isArray(nodo.targets)) return null;
  let total = 0;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const cap = obtenerCapacidadDisponibleContenedor(dest);
    if (cap != null) total += cap;
  });
  return total > 0 ? total : null;
}

function sumarAsignacionesLitros(nodo) {
  if (!nodo?.datos?.asignaciones) return 0;
  return Object.values(nodo.datos.asignaciones).reduce((acc, reg) => {
    const val = getVolumenFromDatos(reg);
    return acc + (Number.isFinite(val) ? val : 0);
  }, 0);
}

function calcularTotalesAsignaciones(nodo) {
  if (!nodo?.datos?.asignaciones) return null;
  const permitidos = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  let totalVolumen = 0;
  Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
    if (!permitidos.has(origenId)) return;
    const volumen = getVolumenFromDatos(info);
    if (volumen != null && volumen > 0) totalVolumen += volumen;
  });
  if (totalVolumen <= 0) return null;
  return { totalVolumen, total: totalVolumen };
}

function obtenerEstadoDepositoDesdeNodo(idDeposito) {
  const estado = obtenerEstadoContenedorDesdeNodo("deposito", idDeposito);
  if (!estado) return null;
  return estado;
}


const ETAPAS_FLUJO = [
  { id: "entrada", titulo: "Entrada de uva", unidad: "kg" },
  { id: "despalillado", titulo: "Despalillado", unidad: "L" },
  { id: "deposito", titulo: "Depósitos", unidad: "L" },
  { id: "barrica", titulo: "Barricas", unidad: "L" },
  { id: "embotellado", titulo: "Embotellado", unidad: "L" },
  { id: "salida", titulo: "Salida de bodega", unidad: "L" },
];
const OPCIONES_TIPO_CONTENEDOR = [
  "Siempre lleno",
  "Cerrado",
  "Mastelone",
  "Ánfora",
  "Foudre",
  "Barrica",
  "Damajuana",
];
const OPCIONES_MATERIAL_CONTENEDOR = [
  "Inox",
  "Fibra de vidrio",
  "Cemento",
  "Barro",
  "Madera",
  "Cristal",
  "Plástico alimentario",
];

function poblarSelectOpciones(selectId, opciones, placeholder = "Selecciona") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    select.appendChild(placeholderOption);
  }
  opciones.forEach(op => {
    const option = document.createElement("option");
    option.value = op;
    option.textContent = op;
    select.appendChild(option);
  });
  if (valorActual && opciones.includes(valorActual)) {
    select.value = valorActual;
  }
}

const FLOW_NODE_TYPES = {
  entrada: {
    label: "Entrada de uva",
    icono: "🍇",
    campos: [
      { id: "id_ref", label: "ID existente", tipo: "number", placeholder: "ID en Entradas" },
      { id: "kilos", label: "Kilos", tipo: "info" },
      { id: "variedad", label: "Variedad", tipo: "info" },
      { id: "densidad", label: "Densidad", tipo: "info" },
      { id: "temperatura", label: "Temperatura", tipo: "info" },
    ],
  },
  fermentacion: {
    label: "Fermentación",
    icono: "⚗️",
    campos: [
      {
        id: "estilo",
        label: "Fermentación / Elaboración",
        tipo: "select",
        opciones: ["FA", "FML"],
        placeholder: "Selecciona tipo",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  estilo: {
    label: "Elaboración",
    icono: "⚗️",
    campos: [
      { id: "kilos", label: "Volumen asignado", tipo: "info" },
      {
        id: "metodo",
        label: "Método de elaboración",
        tipo: "select",
        opciones: ["Despalillado", "Pisado", "Prensado", "Filtrado", "Uva entera", "Mixto", "Sangrado", "Trasvase"],
      },
      { id: "descripcion", label: "Descripción de elaboración", tipo: "textarea", placeholder: "Detalles adicionales" },
    ],
  },
  deposito: {
    label: "Depósito",
    icono: "🛢️",
    campos: [
      { id: "id_ref", label: "Depósito / mastelone", tipo: "number", placeholder: "Selecciona depósito" },
      { id: "capacidad", label: "Capacidad y volumen", tipo: "info" },
      { id: "tipo", label: "Tipo", tipo: "info" },
      { id: "material", label: "Material", tipo: "info" },
      {
        id: "fase",
        label: "Estado",
        tipo: "select",
        opciones: ["FA", "FML", "CRIANZA"],
        placeholder: "Selecciona estado",
      },
      { id: "estado_vino", label: "Estado del vino", tipo: "estadoVino" },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  coupage: {
    label: "Coupage / Blend",
    icono: "🍷",
    campos: [
      { id: "nombre_blend", label: "Nombre del coupage/vino", tipo: "text", placeholder: "Coupage Tempranillo-Malvar" },
      { id: "litros_blend", label: "Volumen total del blend", tipo: "info" },
      { id: "descripcion", label: "Notas del blend", tipo: "textarea", placeholder: "Proporciones, estilo..." },
    ],
  },
  barrica: {
    label: "Crianza",
    icono: '<img src="/barricas.png" alt="Barrica" style="width:26px;height:26px;object-fit:contain;vertical-align:middle;">',
    campos: [
      { id: "nombre_vino", label: "Nombre vino", tipo: "text", placeholder: "Nombre del vino en crianza" },
      {
        id: "contenedor_id",
        label: "Contenedor asignado",
        tipo: "select",
        opciones: [],
        placeholder: "Selecciona contenedor",
      },
      { id: "tipo", label: "Tipo de contenedor", tipo: "info" },
      { id: "tiempo", label: "Fin previsto de la crianza", tipo: "date", placeholder: "" },
      { id: "tiempo_estimado", label: "Duración estimada", tipo: "info" },
      { id: "estado_vino", label: "Estado del vino", tipo: "estadoVino" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Batonnage mensual" },
    ],
  },
	  embotellado: {
	    label: "Embotellado",
	    icono: "🍾",
	    campos: [
	      { id: "nombre_vino", label: "Nombre del vino", tipo: "text", placeholder: "Ej. Autor · Tempranillo 2025" },
	      { id: "lote", label: "Nombre del lote", tipo: "text", placeholder: "Ej. Petrel Makaole L-2026", required: true },
	      {
	        id: "botella",
	        label: "Tipo de botella",
        tipo: "select",
        opciones: [
          "Mixto (varios formatos)",
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgoña 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
      { id: "filtrado", label: "Filtrado", tipo: "text", placeholder: "Tierra blanca" },
      {
        id: "cierre",
        label: "Tipo de cierre",
        tipo: "select",
        opciones: [
          "Corcho natural",
          "Corcho técnico",
          "Corcho aglomerado",
          "Tapón sintético",
          "Stelvin / Screw-cap",
          "Corona",
          "Vidrio Vinolok",
          "Tapa de rosca",
        ],
        placeholder: "Selecciona cierre",
      },
      { id: "botellas_resultantes", label: "Botellas resultantes", tipo: "info" },
    ],
  },
  almacen: {
    label: "Almacén",
    icono: "📦",
    campos: [
      {
        id: "caja_botellas",
        label: "Tipo de caja",
        tipo: "select",
        opciones: ["6 botellas", "3 botellas", "12 botellas"],
      },
      { id: "botellas_resultantes", label: "Botellas desde embotellado", tipo: "info" },
      { id: "cajas_resultantes", label: "Cajas resultantes", tipo: "info" },
      { id: "condicion", label: "Condición de guarda", tipo: "text", placeholder: "Horizontal, 15 ºC" },
      { id: "fecha", label: "Fecha de entrada", tipo: "date", placeholder: "" },
    ],
  },
  salida: {
    label: "Salida de bodega",
    icono: "🚛",
    campos: [
      { id: "cliente", label: "Cliente", tipo: "text", placeholder: "Cliente / Distribuidor" },
      { id: "cajas_cantidad", label: "Cantidad de cajas", tipo: "number", placeholder: "Ej. 24" },
      {
        id: "cajas_tipo",
        label: "Botellas por caja",
        tipo: "select",
        opciones: ["3 botellas", "6 botellas", "12 botellas"],
        placeholder: "Selecciona tamaño de caja",
      },
      { id: "botellas_totales", label: "Botellas totales", tipo: "info" },
    ],
  },
  prensado: {
    label: "Prensado",
    icono: "🌀",
    campos: [
      { id: "litros_resultantes", label: "Volumen resultante", tipo: "number", placeholder: "1275" },
      { id: "merma_abs", label: "Merma abs (volumen)", tipo: "number", placeholder: "425" },
      { id: "merma", label: "Merma (%)", tipo: "number", placeholder: "30" },
      { id: "presion", label: "Presión", tipo: "text", placeholder: "0.8 bar" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Observaciones" },
    ],
  },
};
Object.keys(FLOW_NODE_TYPES).forEach(key => {
  const tipo = FLOW_NODE_TYPES[key];
  tipo.campos = tipo.campos || [];
  const ids = new Set(tipo.campos.map(c => c.id));
  const esEntrada = key === "entrada";
  const asegurarCampo = (id, campo) => {
    if (!ids.has(id)) {
      tipo.campos.unshift({ id, ...campo });
      ids.add(id);
    }
  };
  if (esEntrada) {
    asegurarCampo("fecha", {
      label: "Fecha de entrada",
      tipo: "info",
      soloLectura: true,
    });
  } else {
    asegurarCampo("fecha_creacion", {
      label: "Fecha creación",
      tipo: "info",
      soloLectura: true,
    });
  }
  asegurarCampo("variedad", {
    label: "Variedad de uva",
    tipo: "text",
    placeholder: "Tempranillo",
    soloLectura: !esEntrada,
  });
  if (key !== "deposito" && key !== "entrada") {
    asegurarCampo("merma", {
      label: "Merma / pérdida (%)",
      tipo: "number",
      placeholder: "0",
    });
  }
  if (key !== "entrada") {
    asegurarCampo("fecha_operacion", {
      label: "Fecha operación",
      tipo: "date",
      placeholder: "",
    });
  }
});
		let datosEtapasFlujo = {};
		let flujoNodos = [];
		let nodoConectandoOrigen = null;
			let nodoSeleccionadoId = null;
			let nodoEnEdicion = null;
      let nodoEnEdicionPrevio = null;
      let nodoLimpiezaId = null;
      let flowExpandedIds = new Set();
			let dragEstado = null;
			let ultimoNodoManual = null;
			let flowZoom = 1;
      let flowMinimapDrag = null;
      let flowMinimapRaf = null;
      let avisoServidorFlujoMostrado = false;
      let flowAllowShrinkOnce = false;
			const FLOW_ZOOM_MIN = 0.3;
			const FLOW_ZOOM_MAX = 2;
			const FLOW_ZOOM_STEP = 0.1;
			const FLOW_WORLD_BASE = { width: 5000, height: 3000 };
	let filtrosMovimientos = {
  tipo: "",
  desde: "",
  hasta: "",
  contenedor: "",
  contenedor_tipo: "",
};
let filtroAnalisisDeposito = null;

function mostrarAviso(mensaje, tipo = "info") {
  const contenedor = document.getElementById("appAlerts");
  if (!contenedor) return;
  const toast = document.createElement("div");
  toast.className = `toast ${tipo}`;
  const icon = document.createElement("span");
  icon.className = "toast-icon";
  icon.textContent =
    tipo === "success" ? "🍷" : tipo === "error" ? "⚠️" : tipo === "info" ? "🍇" : "ℹ️";
  const text = document.createElement("span");
  text.className = "toast-text";
  text.textContent = mensaje;
  toast.appendChild(icon);
  toast.appendChild(text);
  contenedor.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateX(20px)";
  }, 3500);
  setTimeout(() => toast.remove(), 4200);
}

function mostrarSkeletonTabla(tbodyId, columnas, filas = 3) {
  const tbody = document.getElementById(tbodyId);
  if (!tbody) return;
  const celda = '<td><div class="skeleton-line"></div></td>';
  const fila = `<tr>${celda.repeat(columnas)}</tr>`;
  tbody.innerHTML = new Array(filas).fill(fila).join("");
}

function setFormFeedback(id, mensaje, tipo = "info") {
  const elemento = document.getElementById(id);
  if (!elemento) return;
  elemento.textContent = mensaje || "";
  elemento.className = `form-feedback ${tipo === "error" ? "error" : tipo === "success" ? "success" : ""}`;
}

// ---------- Copiloto ----------
function cargarConfigCopiloto() {
  let guardado = null;
  try {
    guardado = JSON.parse(localStorage.getItem(COPILOTO_STORAGE_KEY));
  } catch (e) {
    guardado = null;
  }
  const tempMaxGuardado = guardado && guardado.tempMax ? guardado.tempMax : {};
  copilotoConfig = {
    ...COPILOTO_DEFAULT_CONFIG,
    ...guardado,
    tempMax: {
      ...COPILOTO_DEFAULT_CONFIG.tempMax,
      ...tempMaxGuardado,
    },
  };
}

function guardarConfigCopiloto() {
  if (!copilotoConfig) return;
  try {
    localStorage.setItem(COPILOTO_STORAGE_KEY, JSON.stringify(copilotoConfig));
  } catch (e) {
    // noop
  }
}

function cargarEstadoCopiloto() {
  let guardado = null;
  try {
    guardado = JSON.parse(localStorage.getItem(COPILOTO_STATE_KEY));
  } catch (e) {
    guardado = null;
  }
  copilotoState = {
    snoozed: guardado && guardado.snoozed ? guardado.snoozed : {},
    done: guardado && guardado.done ? guardado.done : {},
    seen: guardado && guardado.seen ? guardado.seen : {},
  };
  limpiarEstadoCopiloto();
}

function guardarEstadoCopiloto() {
  if (!copilotoState) return;
  try {
    localStorage.setItem(COPILOTO_STATE_KEY, JSON.stringify(copilotoState));
  } catch (e) {
    // noop
  }
}

function limpiarEstadoCopiloto() {
  if (!copilotoState) return;
  const ahora = Date.now();
  const limpiar = (obj) => {
    if (!obj) return;
    Object.keys(obj).forEach(key => {
      const exp = Number(obj[key] || 0);
      if (!exp || exp < ahora) delete obj[key];
    });
  };
  limpiar(copilotoState.snoozed);
  limpiar(copilotoState.done);
  if (copilotoState.seen) {
    Object.keys(copilotoState.seen).forEach(key => {
      const ts = Number(copilotoState.seen[key] || 0);
      if (!ts || ahora - ts > 48 * 60 * 60 * 1000) delete copilotoState.seen[key];
    });
  }
}

function leerNumeroInput(id, fallback) {
  const input = document.getElementById(id);
  if (!input) return fallback;
  const raw = (input.value || "").toString().replace(",", ".");
  const num = Number(raw);
  return Number.isFinite(num) ? num : fallback;
}

function sincronizarCopilotoUI() {
  if (!copilotoConfig) cargarConfigCopiloto();
  const cfg = copilotoConfig || COPILOTO_DEFAULT_CONFIG;
  const setVal = (id, val) => {
    const input = document.getElementById(id);
    if (input) input.value = val;
  };
  setVal("copilotoParadaHoras", cfg.paradaHoras);
  setVal("copilotoParadaDelta", cfg.paradaDelta);
  setVal("copilotoTempTinto", cfg.tempMax.tinto);
  setVal("copilotoTempBlanco", cfg.tempMax.blanco);
  setVal("copilotoTempRosado", cfg.tempMax.rosado);
  setVal("copilotoOxidacionHoras", cfg.oxidacionHoras);
  setVal("copilotoOxidacionLlenado", cfg.oxidacionMinLlenado);
  setVal("copilotoAnaliticaHoras", cfg.analiticaHoras);
  setVal("copilotoRefreshMin", cfg.refreshMin);
  const toggle = document.getElementById("copilotoToggleExpert");
  if (toggle) {
    toggle.textContent = `Modo experto: ${cfg.modoExperto ? "ON" : "OFF"}`;
  }
  const notif = document.getElementById("copilotoToggleNotif");
  if (notif) {
    notif.textContent = `Notificaciones: ${cfg.notificaciones ? "ON" : "OFF"}`;
  }
}

function actualizarConfigCopilotoDesdeUI() {
  if (!copilotoConfig) cargarConfigCopiloto();
  copilotoConfig.paradaHoras = leerNumeroInput("copilotoParadaHoras", COPILOTO_DEFAULT_CONFIG.paradaHoras);
  copilotoConfig.paradaDelta = leerNumeroInput("copilotoParadaDelta", COPILOTO_DEFAULT_CONFIG.paradaDelta);
  copilotoConfig.tempMax = {
    ...copilotoConfig.tempMax,
    tinto: leerNumeroInput("copilotoTempTinto", COPILOTO_DEFAULT_CONFIG.tempMax.tinto),
    blanco: leerNumeroInput("copilotoTempBlanco", COPILOTO_DEFAULT_CONFIG.tempMax.blanco),
    rosado: leerNumeroInput("copilotoTempRosado", COPILOTO_DEFAULT_CONFIG.tempMax.rosado),
    default: COPILOTO_DEFAULT_CONFIG.tempMax.default,
  };
  copilotoConfig.oxidacionHoras = leerNumeroInput("copilotoOxidacionHoras", COPILOTO_DEFAULT_CONFIG.oxidacionHoras);
  const llenado = leerNumeroInput("copilotoOxidacionLlenado", COPILOTO_DEFAULT_CONFIG.oxidacionMinLlenado);
  copilotoConfig.oxidacionMinLlenado = Math.min(100, Math.max(10, llenado));
  copilotoConfig.analiticaHoras = leerNumeroInput("copilotoAnaliticaHoras", COPILOTO_DEFAULT_CONFIG.analiticaHoras);
  copilotoConfig.refreshMin = leerNumeroInput("copilotoRefreshMin", COPILOTO_DEFAULT_CONFIG.refreshMin);
  guardarConfigCopiloto();
}

function poblarSelectCopilotoNotaEstados() {
  const select = document.getElementById("copilotoNotaEstado");
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  const optionEmpty = document.createElement("option");
  optionEmpty.value = "";
  optionEmpty.textContent = "Selecciona acción";
  select.appendChild(optionEmpty);
  COPILOTO_ESTADOS_RAPIDOS.forEach(item => {
    const option = document.createElement("option");
    option.value = item.value;
    option.textContent = item.label;
    select.appendChild(option);
  });
  if (valorActual) select.value = valorActual;
  actualizarChipsEstadoCopilotoNota();
}

function actualizarChipsEstadoCopilotoNota() {
  const select = document.getElementById("copilotoNotaEstado");
  if (!select) return;
  const valor = (select.value || "").toString().trim();
  document.querySelectorAll(".copiloto-note-state-chip").forEach(chip => {
    const estado = (chip.dataset.estado || "").toString().trim();
    chip.classList.toggle("is-active", Boolean(valor) && estado === valor);
  });
}

function obtenerOpcionesContenedoresCopiloto({ soloConLiquido = false } = {}) {
  const tieneLiquido = (tipo, item) => {
    if (!soloConLiquido) return true;
    if (!item) return false;
    const num = v => {
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    };
    const directos = [
      item.litros_actuales,
      item.volumen,
      item.volumen_l,
      item.contenido_l,
      item.litros,
    ];
    if (directos.some(v => num(v) > 0)) return true;
    if (typeof resolverEstadoVisualContenedor === "function") {
      try {
        const estado = resolverEstadoVisualContenedor(tipo, item);
        if (Number(estado?.volumenFinal) > 0) return true;
      } catch (_err) {
        // noop
      }
    }
    return false;
  };

  const opciones = [];
  const agregar = (tipo, items) => {
    (items || []).forEach(item => {
      if (!item || item.id == null) return;
      if (!tieneLiquido(tipo, item)) return;
      opciones.push({
        tipo,
        id: item.id,
        nombre: obtenerNombreContenedorCopiloto(tipo, item.id),
      });
    });
  };
  agregar("deposito", cacheDepositos);
  agregar("mastelone", cacheMastelones);
  agregar("barrica", cacheBarricas);
  const vistos = new Set();
  const lista = opciones.filter(opt => {
    const key = `${opt.tipo}:${opt.id}`;
    if (vistos.has(key)) return false;
    vistos.add(key);
    return true;
  });
  lista.sort((a, b) => a.nombre.localeCompare(b.nombre, "es", { sensitivity: "base" }));
  return lista;
}

function poblarSelectCopilotoContenedores(selectId, placeholderTexto, { soloConLiquido = false } = {}) {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  const lista = obtenerOpcionesContenedoresCopiloto({ soloConLiquido });
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = placeholderTexto;
  select.appendChild(placeholder);
  lista.forEach(opt => {
    const option = document.createElement("option");
    option.value = `${opt.tipo}:${opt.id}`;
    option.textContent = opt.nombre;
    select.appendChild(option);
  });
  if (valorActual) select.value = valorActual;
}

function poblarSelectCopilotoNotaContenedores() {
  poblarSelectCopilotoContenedores(
    "copilotoNotaContenedor",
    "(Selecciona contenedor con líquido)",
    { soloConLiquido: true }
  );
}

function poblarSelectCopilotoTimelineContenedores() {
  poblarSelectCopilotoContenedores("copilotoTimelineContenedor", "Todos");
}

function setCopilotoNotaStatus(mensaje, tipo = "info") {
  const status = document.getElementById("copilotoNotaStatus");
  if (!status) return;
  status.textContent = mensaje || "";
  status.classList.remove("success", "error");
  if (tipo === "success") status.classList.add("success");
  if (tipo === "error") status.classList.add("error");
}

function normalizarOrigenCopiloto(valor) {
  const origen = (valor || "").toString().toLowerCase();
  if (origen === "express" || origen === "control" || origen === "manual") return origen;
  return "todos";
}

function obtenerAccionEventoCopiloto(evento) {
  const accionTexto = (evento?.meta?.accion_texto || "").toString().trim();
  const raw = (accionTexto || evento?.meta?.accion || evento?.tipo || "").toString().trim();
  const key = raw.toLowerCase();
  return {
    key,
    label: accionTexto || formatearAccionEvento(raw),
  };
}

function formatearHoraCorta(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
  } catch (_err) {
    return "—";
  }
}

function resolverEtiquetaDiaTimeline(ms) {
  if (!ms) return "Sin fecha";
  const hoy = new Date();
  const claveHoy = obtenerClaveDiaLocal(hoy.getTime());
  const ayer = new Date();
  ayer.setDate(hoy.getDate() - 1);
  const claveAyer = obtenerClaveDiaLocal(ayer.getTime());
  const clave = obtenerClaveDiaLocal(ms);
  if (clave && clave === claveHoy) return "Hoy";
  if (clave && clave === claveAyer) return "Ayer";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      weekday: "short",
      day: "2-digit",
      month: "short",
    });
  } catch (_err) {
    return "—";
  }
}

function obtenerFiltrosTimeline() {
  const selectCont = document.getElementById("copilotoTimelineContenedor");
  const selectAccion = document.getElementById("copilotoTimelineAccion");
  const inputBuscar = document.getElementById("copilotoTimelineBuscar");
  return {
    contenedor: selectCont ? selectCont.value : "",
    accion: selectAccion ? selectAccion.value : "",
    buscar: inputBuscar ? inputBuscar.value.trim().toLowerCase() : "",
    origen: normalizarOrigenCopiloto(copilotoTimelineFiltros.origen),
  };
}

function resetearVisibilidadTimeline() {
  copilotoTimelineVisible = COPILOTO_TIMELINE_INIT;
}

function actualizarOpcionesAccionTimeline(eventos) {
  const select = document.getElementById("copilotoTimelineAccion");
  if (!select) return;
  const valorActual = select.value;
  const mapa = new Map();
  (eventos || []).forEach(evento => {
    const { key, label } = obtenerAccionEventoCopiloto(evento);
    if (!key) return;
    if (!mapa.has(key)) mapa.set(key, label);
  });
  const opciones = Array.from(mapa.entries()).sort((a, b) =>
    a[1].localeCompare(b[1], "es", { sensitivity: "base" })
  );
  select.innerHTML = "";
  const base = document.createElement("option");
  base.value = "";
  base.textContent = "Todas";
  select.appendChild(base);
  opciones.forEach(([key, label]) => {
    const option = document.createElement("option");
    option.value = key;
    option.textContent = label;
    select.appendChild(option);
  });
  if (valorActual === "") {
    select.value = "";
  } else {
    const existe = Array.from(select.options).some(opt => opt.value === valorActual);
    if (existe) select.value = valorActual;
  }
}

function actualizarEventosCopilotoLocales(evento) {
  if (!evento) return;
  const actuales = Array.isArray(copilotoEventosCache) ? [...copilotoEventosCache] : [];
  const id = evento.id;
  const filtrados = id != null ? actuales.filter(ev => ev?.id !== id) : actuales;
  filtrados.unshift(evento);
  copilotoEventosCache = filtrados.slice(0, COPILOTO_EVENTOS_LIMIT);
  copilotoEventosTs = Date.now();
  actualizarOpcionesAccionTimeline(copilotoEventosCache);
  renderCopilotoActividad(copilotoEventosCache);
  renderCopilotoTimeline(copilotoEventosCache);
  renderCopilotoHeatmap(copilotoEventosCache);
}

async function guardarNotaCopiloto() {
  const selectCont = document.getElementById("copilotoNotaContenedor");
  const textarea = document.getElementById("copilotoNotaTexto");
  const inputDensidad = document.getElementById("copilotoNotaDensidad");
  const inputTemperatura = document.getElementById("copilotoNotaTemperatura");
  const btn = document.getElementById("copilotoNotaGuardar");
  if (!selectCont || !textarea) return;
  const parseCampoNumero = valor => {
    const raw = (valor || "").toString().trim();
    if (!raw) return { value: null, ok: true };
    const normalizado = raw.replace(",", ".");
    const num = Number(normalizado);
    return { value: Number.isFinite(num) ? num : null, ok: Number.isFinite(num) };
  };
  const texto = textarea.value.trim();
  const densidadDato = parseCampoNumero(inputDensidad?.value);
  const temperaturaDato = parseCampoNumero(inputTemperatura?.value);
  if (!densidadDato.ok) {
    setCopilotoNotaStatus("Densidad inválida.", "error");
    return;
  }
  if (!temperaturaDato.ok) {
    setCopilotoNotaStatus("Temperatura inválida.", "error");
    return;
  }
  const densidadValor = densidadDato.value;
  const temperaturaValor = temperaturaDato.value;
  if (!texto && densidadValor == null && temperaturaValor == null) {
    setCopilotoNotaStatus("Escribe una nota o registra densidad/temperatura.", "error");
    return;
  }
  if (!selectCont.value) {
    setCopilotoNotaStatus("Selecciona un contenedor para guardar la nota.", "info");
    return;
  }
  const [tipo, idRaw] = selectCont.value.split(":");
  const id = Number(idRaw);
  if (!tipo || !Number.isFinite(id)) {
    setCopilotoNotaStatus("Contenedor inválido.", "error");
    return;
  }
  const meta = { fuente: "copiloto", accion: "nota" };
  if (densidadValor != null) {
    meta.densidad = Number(densidadValor);
  }
  if (temperaturaValor != null) {
    meta.temperatura_c = Number(temperaturaValor);
  }
  let detalle = texto;
  if (!detalle) {
    const partes = [];
    if (densidadValor != null) partes.push(`Densidad ${densidadValor}`);
    if (temperaturaValor != null) partes.push(`Temperatura ${temperaturaValor}°C`);
    detalle = partes.join(" · ") || "Registro rápido";
  }
  const payload = {
    contenedor_tipo: tipo,
    contenedor_id: id,
    tipo: "nota",
    resumen: "Nota rápida",
    detalle,
    origen: "manual",
    meta,
  };
  const textoBtn = btn ? btn.textContent : "";
  if (btn) {
    btn.disabled = true;
    btn.textContent = "Guardando...";
  }
  setCopilotoNotaStatus("Guardando nota...", "info");
  try {
    const res = await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      setCopilotoNotaStatus(data?.error || "No se pudo guardar la nota.", "error");
      return;
    }
    setCopilotoNotaStatus("Anotado en Bitácora.", "success");
    textarea.value = "";
    if (inputDensidad) inputDensidad.value = "";
    if (inputTemperatura) inputTemperatura.value = "";
    const evento = data?.evento || {
      ...payload,
      id: data?.id,
      fecha_hora: new Date().toISOString(),
    };
    actualizarEventosCopilotoLocales(evento);
  } catch (_err) {
    setCopilotoNotaStatus("No se pudo guardar la nota.", "error");
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.textContent = textoBtn || "Guardar nota";
    }
  }
}

function inicializarCopilotoUI() {
  cargarConfigCopiloto();
  cargarEstadoCopiloto();
  sincronizarCopilotoUI();
  const btnGuardar = document.getElementById("copilotoGuardar");
  if (btnGuardar) {
    btnGuardar.addEventListener("click", () => {
      actualizarConfigCopilotoDesdeUI();
      sincronizarCopilotoUI();
      programarAutoCopiloto();
      mostrarAviso("Reglas del copiloto guardadas.", "success");
      actualizarCopiloto(true);
    });
  }
  const formConfig = document.getElementById("copilotoConfig");
  if (formConfig) {
    formConfig.addEventListener("submit", ev => ev.preventDefault());
  }
  const btnRefresh = document.getElementById("copilotoRefresh");
  if (btnRefresh) {
    btnRefresh.addEventListener("click", () => actualizarCopiloto(true));
  }
  const btnExpert = document.getElementById("copilotoToggleExpert");
  if (btnExpert) {
    btnExpert.addEventListener("click", () => {
      copilotoConfig.modoExperto = !copilotoConfig.modoExperto;
      guardarConfigCopiloto();
      sincronizarCopilotoUI();
      actualizarCopiloto(true);
    });
  }
  const btnNotif = document.getElementById("copilotoToggleNotif");
  if (btnNotif) {
    btnNotif.addEventListener("click", async () => {
      if (copilotoConfig.notificaciones) {
        copilotoConfig.notificaciones = false;
        guardarConfigCopiloto();
        sincronizarCopilotoUI();
        mostrarAviso("Notificaciones silenciadas.", "info");
        return;
      }
      if (!("Notification" in window)) {
        mostrarAviso("Tu navegador no soporta notificaciones.", "error");
        return;
      }
      if (Notification.permission === "denied") {
        mostrarAviso("Las notificaciones están bloqueadas en el navegador.", "error");
        return;
      }
      if (Notification.permission === "default") {
        const permiso = await Notification.requestPermission();
        if (permiso !== "granted") {
          mostrarAviso("Necesito permiso para avisarte.", "error");
          return;
        }
      }
      copilotoConfig.notificaciones = true;
      guardarConfigCopiloto();
      sincronizarCopilotoUI();
      mostrarAviso("Notificaciones activadas.", "success");
    });
  }
  poblarSelectCopilotoNotaEstados();
  poblarSelectCopilotoNotaContenedores();
  poblarSelectCopilotoTimelineContenedores();
  const btnNota = document.getElementById("copilotoNotaGuardar");
  if (btnNota) {
    btnNota.addEventListener("click", guardarNotaCopiloto);
  }
  const chipsNota = document.querySelectorAll(".copiloto-note-chip");
  if (chipsNota.length) {
    const textarea = document.getElementById("copilotoNotaTexto");
    chipsNota.forEach(chip => {
      chip.addEventListener("click", () => {
        if (!textarea) return;
        const raw = (chip.dataset.tag || chip.textContent || "").toString().trim();
        if (!raw) return;
        const etiqueta = raw.replace(/\s+/g, "");
        const token = `#${etiqueta}`;
        const actual = textarea.value || "";
        const separador = actual && !/\s$/.test(actual) ? " " : "";
        textarea.value = `${actual}${separador}${token} `;
        textarea.focus();
      });
    });
  }
  const chipsEstadoNota = document.querySelectorAll(".copiloto-note-state-chip");
  if (chipsEstadoNota.length) {
    const selectEstadoNota = document.getElementById("copilotoNotaEstado");
    const inputDensidad = document.getElementById("copilotoNotaDensidad");
    const inputTemperatura = document.getElementById("copilotoNotaTemperatura");
    chipsEstadoNota.forEach(chip => {
      chip.addEventListener("click", () => {
        if (!selectEstadoNota) return;
        const estado = (chip.dataset.estado || "").toString().trim();
        if (!estado) return;
        const existe = Array.from(selectEstadoNota.options).some(opt => opt.value === estado);
        if (!existe) return;
        selectEstadoNota.value = estado;
        actualizarChipsEstadoCopilotoNota();
        if (estado === "densidad" && inputDensidad) inputDensidad.focus();
        if (estado === "temperatura" && inputTemperatura) inputTemperatura.focus();
      });
    });
    if (selectEstadoNota) {
      selectEstadoNota.addEventListener("change", actualizarChipsEstadoCopilotoNota);
      actualizarChipsEstadoCopilotoNota();
    }
  }
  const btnHeatmap = document.getElementById("copilotoHeatmapClear");
  if (btnHeatmap) {
    btnHeatmap.addEventListener("click", () => {
      setCopilotoFiltroDia(null, copilotoEventosCache);
    });
  }
  const selectFiltroCont = document.getElementById("copilotoTimelineContenedor");
  if (selectFiltroCont) {
    selectFiltroCont.addEventListener("change", () => {
      resetearVisibilidadTimeline();
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  const selectFiltroAccion = document.getElementById("copilotoTimelineAccion");
  if (selectFiltroAccion) {
    selectFiltroAccion.addEventListener("change", () => {
      resetearVisibilidadTimeline();
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  const inputBuscar = document.getElementById("copilotoTimelineBuscar");
  if (inputBuscar) {
    inputBuscar.addEventListener("input", () => {
      if (copilotoTimelineBusquedaTimer) clearTimeout(copilotoTimelineBusquedaTimer);
      copilotoTimelineBusquedaTimer = setTimeout(() => {
        resetearVisibilidadTimeline();
        renderCopilotoTimeline(copilotoEventosCache);
      }, 200);
    });
  }
  const chipsOrigen = document.querySelectorAll("#copilotoTimelineOrigen .copiloto-chip");
  if (chipsOrigen.length) {
    const activo = document.querySelector("#copilotoTimelineOrigen .copiloto-chip.is-active");
    if (activo) {
      copilotoTimelineFiltros.origen = normalizarOrigenCopiloto(activo.dataset.origen || "todos");
    }
    chipsOrigen.forEach(chip => {
      chip.addEventListener("click", () => {
        chipsOrigen.forEach(btn => btn.classList.remove("is-active"));
        chip.classList.add("is-active");
        copilotoTimelineFiltros.origen = normalizarOrigenCopiloto(chip.dataset.origen || "todos");
        resetearVisibilidadTimeline();
        renderCopilotoTimeline(copilotoEventosCache);
      });
    });
  }
  const btnMas = document.getElementById("copilotoTimelineMas");
  if (btnMas) {
    btnMas.addEventListener("click", () => {
      copilotoTimelineVisible += COPILOTO_TIMELINE_STEP;
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  programarAutoCopiloto();
}

function programarAutoCopiloto() {
  if (copilotoAutoTimer) clearInterval(copilotoAutoTimer);
  if (!copilotoConfig) cargarConfigCopiloto();
  const minutos = Math.max(1, Number(copilotoConfig.refreshMin) || COPILOTO_DEFAULT_CONFIG.refreshMin);
  copilotoAutoTimer = setInterval(() => actualizarCopiloto(), minutos * 60 * 1000);
}

function programarActualizacionCopiloto(forzar = false) {
  if (copilotoUpdateTimer) clearTimeout(copilotoUpdateTimer);
  copilotoUpdateTimer = setTimeout(() => actualizarCopiloto(forzar), 350);
}

function parseFechaMs(valor) {
  if (!valor) return null;
  const ms = new Date(valor).getTime();
  return Number.isNaN(ms) ? null : ms;
}

function horasEntre(msInicio, msFin = Date.now()) {
  if (!msInicio || !msFin) return null;
  return Math.max(0, (msFin - msInicio) / 36e5);
}

function formatearTiempoRelativo(ms) {
  if (!ms) return "—";
  const diff = Date.now() - ms;
  if (!Number.isFinite(diff) || diff < 0) return "—";
  const minutos = Math.round(diff / 60000);
  if (minutos < 60) return `hace ${minutos} min`;
  const horas = Math.round(minutos / 60);
  if (horas < 24) return `hace ${horas} h`;
  const dias = Math.round(horas / 24);
  return `hace ${dias} d`;
}

function formatearAccionEvento(valor) {
  const texto = (valor || "").toString().trim().toLowerCase();
  if (!texto) return "Evento";
  return texto
    .replace(/_/g, " ")
    .replace(/\b\w/g, letra => letra.toUpperCase());
}

function extraerEstadoMetaCopiloto(meta) {
  if (!meta) return null;
  const raw = meta.estado || meta.estado_vino || meta.estadoVino || null;
  if (!raw) return null;
  if (typeof raw === "string") {
    const limpio = raw.trim();
    return limpio ? { valor: limpio.toLowerCase(), texto: "" } : null;
  }
  if (typeof raw === "object") {
    const valor = (raw.valor || raw.id || raw.codigo || "").toString().trim().toLowerCase();
    const texto = (raw.texto || raw.nombre || raw.custom || raw.etiqueta || "").toString().trim();
    return valor || texto ? { valor, texto } : null;
  }
  return null;
}

function resolverEtiquetaEstado(estado) {
  if (!estado) return "";
  const valor = (estado.valor || "").toString().trim().toLowerCase();
  const texto = (estado.texto || "").toString().trim();
  if (valor === ESTADO_PERSONALIZADO) return texto || "Personalizado";
  const encontrado = ESTADOS_VINO.find(item => item.value === valor)
    || COPILOTO_ESTADOS_RAPIDOS.find(item => item.value === valor);
  if (encontrado) return encontrado.label;
  return texto || estado.valor || "";
}

async function obtenerEventosBitacoraRecientes(forzar = false) {
  const ahora = Date.now();
  if (!forzar && copilotoEventosTs && ahora - copilotoEventosTs < COPILOTO_EVENTOS_TTL_MS) {
    return Array.isArray(copilotoEventosCache) ? copilotoEventosCache : [];
  }
  try {
    const res = await fetch(`/api/eventos?scope=contenedor&limit=${COPILOTO_EVENTOS_LIMIT}`);
    if (!res.ok) return [];
    const data = await res.json().catch(() => ({}));
    const eventos = Array.isArray(data.eventos) ? data.eventos : [];
    copilotoEventosCache = eventos;
    copilotoEventosTs = ahora;
    actualizarOpcionesAccionTimeline(eventos);
    return eventos;
  } catch (_err) {
    return [];
  }
}

function mapearEventosPorContenedor(eventos) {
  const mapa = new Map();
  (eventos || []).forEach(evento => {
    const tipo = (evento.contenedor_tipo || "").toString().toLowerCase();
    const id = Number(evento.contenedor_id);
    if (!tipo || !Number.isFinite(id)) return;
    const key = `${tipo}:${id}`;
    if (!mapa.has(key)) {
      mapa.set(key, evento);
    }
  });
  return mapa;
}

function obtenerFaseContenedor(cont) {
  if (!cont) return "";
  if (cont.tipo === "barrica") return "Crianza";
  const nodo = obtenerNodoFinalContenedor("deposito", cont.id);
  const fase = (nodo?.datos?.fase || "").toString().trim().toUpperCase();
  if (fase === "FA") return "Fermentación";
  if (fase === "FML") return "Maloláctica";
  if (fase === "CRIANZA") return "Crianza";
  return "Activo";
}

function obtenerEtiquetaContenedor(contenedor) {
  if (!contenedor) return "";
  const tipoLabel =
    contenedor.tipo === "mastelone"
      ? "Mastelone"
      : contenedor.tipo === "barrica"
      ? "Barrica"
      : "Depósito";
  const codigo = (contenedor.codigo || "").toString().trim();
  const alias = (contenedor.alias || "").toString().trim();
  const base = `${tipoLabel} ${codigo || "#" + contenedor.id}`;
  return alias ? `${base} — ${alias}` : base;
}

function obtenerNombreContenedorCopiloto(tipo, id) {
  if (!tipo || id == null) return "Contenedor";
  const idNum = Number(id);
  if (tipo === "deposito") return obtenerNombreDeposito(idNum);
  if (tipo === "mastelone") return obtenerNombreMastelone(idNum);
  if (tipo === "barrica") return obtenerNombreBarrica(idNum);
  return `${tipo} ${id}`;
}

function obtenerContenedoresCopiloto() {
  const contenedores = [];
  const agregar = (tipo, item) => {
    if (!item) return;
    const estadoNodo =
      tipo === "barrica"
        ? obtenerEstadoBarricaDesdeNodo(item.id)
        : obtenerEstadoDepositoDesdeNodo(item.id);
    const capacidad =
      item.capacidad_l != null
        ? Number(item.capacidad_l)
        : item.capacidad_hl != null
        ? Number(item.capacidad_hl * 100)
        : null;
    const volumenNodo = estadoNodo?.volumen;
    const volumen = Number.isFinite(volumenNodo)
      ? Number(volumenNodo)
      : Number(item.litros_actuales ?? 0);
    const variedad = estadoNodo?.variedad || item.vino_tipo || "";
    const estado = item.estado || "";
    const activo = (Number(volumen) > 0) || (estado && estado !== "vacio");
    if (!activo) return;
    contenedores.push({
      tipo,
      id: item.id,
      codigo: item.codigo || "",
      alias: item.alias || "",
      capacidad: Number.isFinite(capacidad) ? capacidad : null,
      volumen: Number.isFinite(volumen) ? volumen : 0,
      variedad,
      vino_tipo: item.vino_tipo || "",
      estado,
    });
  };
  (cacheDepositos || []).forEach(item => agregar("deposito", item));
  (cacheMastelones || []).forEach(item => agregar("mastelone", item));
  (cacheBarricas || []).forEach(item => agregar("barrica", item));
  return contenedores;
}

function obtenerMovimientosContenedor(tipo, id) {
  if (!Array.isArray(cacheMovimientos)) return [];
  return cacheMovimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .sort((a, b) => {
      const aMs = parseFechaMs(a.fecha || a.fecha_hora) || 0;
      const bMs = parseFechaMs(b.fecha || b.fecha_hora) || 0;
      return bMs - aMs;
    });
}

async function obtenerAnaliticosCopiloto(tipo, id, forzar = false) {
  const key = `${tipo}:${id}`;
  const ahora = Date.now();
  const ultimo = copilotoAnaliticosTs.get(key);
  if (!forzar && ultimo && ahora - ultimo < COPILOTO_ANALITICOS_TTL_MS) {
    return copilotoAnaliticosCache.get(key) || [];
  }
  try {
    const res = await fetch(`/api/registros/${tipo}/${id}`);
    if (!res.ok) return [];
    const datos = await res.json();
    datos.sort((a, b) => {
      const aMs = parseFechaMs(a.fecha_hora || a.fecha) || 0;
      const bMs = parseFechaMs(b.fecha_hora || b.fecha) || 0;
      return bMs - aMs;
    });
    copilotoAnaliticosCache.set(key, datos);
    copilotoAnaliticosTs.set(key, ahora);
    return datos;
  } catch (err) {
    console.warn("No se pudieron cargar registros analíticos:", err);
    return [];
  }
}

function inferirEstiloContenedor(contenedor) {
  const base = (contenedor.vino_tipo || contenedor.variedad || "").toString().trim();
  if (!base) return "default";
  const limpio = base
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (limpio.includes("rosado") || limpio.includes("clarete")) return "rosado";
  if (limpio.includes("tinto")) return "tinto";
  if (limpio.includes("blanco")) return "blanco";
  const norm = normalizarTextoUva(limpio);
  if (esVariedadBlanca(norm)) return "blanco";
  return "tinto";
}

function contieneProteccion(nota) {
  if (!nota) return false;
  const limpio = nota
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  const claves = ["so2", "sulf", "sulfuroso", "co2", "n2", "nitrogeno", "inert"];
  return claves.some(clave => limpio.includes(clave));
}

function reglaFermentacionEstancada(contenedor, analiticos, config) {
  const conDensidad = (analiticos || []).filter(r => r.densidad != null).slice(0, 2);
  if (conDensidad.length < 2) return null;
  const [ultima, anterior] = conDensidad;
  const densUlt = normalizarNumero(ultima.densidad);
  const densAnt = normalizarNumero(anterior.densidad);
  if (densUlt == null || densAnt == null) return null;
  const msUlt = parseFechaMs(ultima.fecha_hora || ultima.fecha);
  const msAnt = parseFechaMs(anterior.fecha_hora || anterior.fecha);
  if (!msUlt || !msAnt) return null;
  const horas = Math.abs(msUlt - msAnt) / 36e5;
  const bajada = densAnt - densUlt;
  if (horas < config.paradaHoras) return null;
  if (bajada > config.paradaDelta) return null;
  const temp = normalizarNumero(ultima.temperatura_c);
  const tempTxt = temp != null ? `${temp.toFixed(1)} °C` : "—";
  const horasTxt = Math.round(horas);
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `fermentacion:${contenedor.tipo}:${contenedor.id}`,
    level: "alta",
    titulo: "Riesgo de parada de fermentación",
    mensaje: `La densidad no ha bajado en ${horasTxt} h y la temperatura está en ${tempTxt}. Revisa nutrición/temperatura y mueve lías si aplica.`,
    acciones: ["Revisar nutrientes", "Ajustar temperatura", "Mover lías"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `Ojo: ${etiqueta} lleva ${horasTxt} h sin bajar densidad (temp ${tempTxt}).`,
  };
}

function reglaOxidacion(contenedor, movimientos, config) {
  if (!contenedor.capacidad || !Number.isFinite(contenedor.capacidad)) return null;
  if (!movimientos || !movimientos.length) return null;
  const llenado = contenedor.capacidad > 0 ? contenedor.volumen / contenedor.capacidad : 0;
  const llenadoPct = Math.round(llenado * 100);
  if (llenadoPct >= config.oxidacionMinLlenado) return null;
  const ultimo = movimientos[0];
  const msUlt = parseFechaMs(ultimo.fecha || ultimo.fecha_hora);
  const horas = horasEntre(msUlt);
  if (horas == null || horas < config.oxidacionHoras) return null;
  const proteccion = movimientos.some(mov => {
    const msMov = parseFechaMs(mov.fecha || mov.fecha_hora);
    const horasMov = horasEntre(msMov);
    if (horasMov == null || horasMov > config.proteccionHoras) return false;
    return contieneProteccion(mov.nota);
  });
  if (proteccion) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `oxidacion:${contenedor.tipo}:${contenedor.id}`,
    level: "media",
    titulo: "Riesgo de oxidación",
    mensaje: `Movimiento largo sin protección registrada (${Math.round(horas)} h). Si puedes, satura con CO2 y minimiza exposición.`,
    acciones: ["Proteger con CO2", "Minimizar exposición", "Revisar SO2"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} lleva ${Math.round(horas)} h sin movimiento y está al ${llenadoPct}%.`,
  };
}

function reglaTemperaturaAlta(contenedor, analiticos, config) {
  const registro = (analiticos || []).find(r => r.temperatura_c != null);
  if (!registro) return null;
  const temp = normalizarNumero(registro.temperatura_c);
  if (temp == null) return null;
  const estilo = inferirEstiloContenedor(contenedor);
  const maxTemp =
    Number(config.tempMax?.[estilo]) ||
    Number(config.tempMax?.default) ||
    COPILOTO_DEFAULT_CONFIG.tempMax.default;
  if (!(temp > maxTemp)) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  const estiloTexto = estilo === "default" ? "este estilo" : estilo;
  return {
    id: `temperatura:${contenedor.tipo}:${contenedor.id}`,
    level: "media",
    titulo: "Control de temperatura",
    mensaje: `Temperatura alta (${temp.toFixed(1)} °C) para ${estiloTexto}. Puede subir VA o extraer de más.`,
    acciones: ["Bajar temperatura", "Revisar extracción", "Controlar VA"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} va caliente (${temp.toFixed(1)} °C) para ${estiloTexto}.`,
  };
}

function reglaAnaliticaPendiente(contenedor, analiticos, config) {
  const registro = (analiticos || [])[0];
  if (!registro) {
    const etiqueta = obtenerEtiquetaContenedor(contenedor);
    return {
      id: `analitica:${contenedor.tipo}:${contenedor.id}`,
      level: "baja",
      basica: true,
      titulo: "Faltan datos críticos",
      mensaje: "No hay registros analíticos recientes. Sin datos no hay copiloto.",
      acciones: ["Medir densidad", "Medir temperatura", "Añadir nota sensorial"],
      contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
      feed: `${etiqueta} no tiene registros analíticos aún.`,
    };
  }
  const ms = parseFechaMs(registro.fecha_hora || registro.fecha);
  const horas = horasEntre(ms);
  if (horas == null || horas < config.analiticaHoras) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `analitica:${contenedor.tipo}:${contenedor.id}`,
    level: "baja",
    basica: true,
    titulo: "Analítica pendiente",
    mensaje: `Hace ${Math.round(horas)} h que no registras datos. Necesito densidad y temperatura.`,
    acciones: ["Medir densidad", "Medir temperatura", "Actualizar nota"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} lleva ${Math.round(horas)} h sin analítica.`,
  };
}

function ordenarAlertasCopiloto(alertas) {
  const prioridad = { alta: 3, media: 2, baja: 1 };
  return [...alertas].sort((a, b) => {
    const score = (prioridad[b.level] || 0) - (prioridad[a.level] || 0);
    if (score !== 0) return score;
    return (a.titulo || "").localeCompare(b.titulo || "");
  });
}

function filtrarAlertasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  limpiarEstadoCopiloto();
  const ahora = Date.now();
  return alertas.filter(alerta => {
    const snooze = copilotoState.snoozed?.[alerta.id];
    const done = copilotoState.done?.[alerta.id];
    if (snooze && snooze > ahora) return false;
    if (done && done > ahora) return false;
    return true;
  });
}

function generarTareasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  const tareas = [];
  const vistos = new Set();
  alertas.forEach(alerta => {
    (alerta.acciones || []).forEach((accion, idx) => {
      const id = `${alerta.id}:accion:${idx}`;
      if (vistos.has(id)) return;
      if (copilotoState.done?.[id]) return;
      vistos.add(id);
      tareas.push({
        id,
        texto: accion,
        contenedor: alerta.contenedor,
        basica: alerta.basica || false,
      });
    });
  });
  return tareas;
}

function crearElementoCopilotoEmpty(texto) {
  const empty = document.createElement("div");
  empty.className = "copiloto-empty";
  empty.textContent = texto;
  return empty;
}

function obtenerEstadoNodoCopiloto(contenedor) {
  if (!contenedor) return null;
  if (contenedor.tipo === "barrica") {
    const nodo = obtenerNodoFinalContenedor("barrica", contenedor.id);
    const valor = (nodo?.datos?.estado_vino || "").toString().trim();
    const texto = (nodo?.datos?.estado_vino_texto || "").toString().trim();
    return valor ? { valor, texto } : null;
  }
  if (contenedor.tipo === "deposito" || contenedor.tipo === "mastelone") {
    const nodo = obtenerNodoFinalContenedor("deposito", contenedor.id);
    const control = Array.isArray(nodo?.datos?.control) ? nodo.datos.control : [];
    const ultimo = control.length ? control[control.length - 1] : null;
    const valor = (ultimo?.estado_vino || "").toString().trim();
    const texto = (ultimo?.estado_vino_texto || "").toString().trim();
    return valor ? { valor, texto } : null;
  }
  return null;
}

function construirLineaVariablesCopiloto(meta) {
  if (!meta) return "";
  const partes = [];
  if (meta.densidad !== undefined && meta.densidad !== null && meta.densidad !== "") {
    const densidad = Number(meta.densidad);
    if (Number.isFinite(densidad)) partes.push(`Densidad ${densidad}`);
  }
  let temperatura = null;
  if (meta.temperatura_c !== undefined && meta.temperatura_c !== null && meta.temperatura_c !== "") {
    temperatura = Number(meta.temperatura_c);
  } else if (meta.temperatura !== undefined && meta.temperatura !== null && meta.temperatura !== "") {
    temperatura = Number(meta.temperatura);
  }
  if (Number.isFinite(temperatura)) partes.push(`Temperatura ${temperatura}°C`);
  if (meta.so2 !== undefined && meta.so2 !== null && meta.so2 !== "") {
    const so2 = Number(meta.so2);
    if (Number.isFinite(so2)) partes.push(`SO2 ${so2}`);
  }
  if (meta.nivel_llenado !== undefined && meta.nivel_llenado !== null && meta.nivel_llenado !== "") {
    const nivel = Number(meta.nivel_llenado);
    if (Number.isFinite(nivel)) partes.push(`Nivel ${nivel}%`);
  }
  if (meta.litros !== undefined && meta.litros !== null && meta.litros !== "") {
    const litros = Number(meta.litros);
    if (Number.isFinite(litros)) partes.push(`Litros ${litros}`);
  }
  if (meta.volumen !== undefined && meta.volumen !== null && meta.volumen !== "") {
    const volumen = Number(meta.volumen);
    if (Number.isFinite(volumen)) partes.push(`Volumen ${volumen}`);
  }
  const producto = (meta.productos || meta.producto || "").toString().trim();
  if (producto) partes.push(`Producto ${producto}`);
  let dosisTexto = "";
  if (meta.dosis && typeof meta.dosis === "object") {
    const cantidad = meta.dosis.cantidad != null ? String(meta.dosis.cantidad).trim() : "";
    const unidad = meta.dosis.unidad != null ? String(meta.dosis.unidad).trim() : "";
    dosisTexto = [cantidad, unidad].filter(Boolean).join(" ");
  } else if (meta.dosis != null && meta.dosis !== "") {
    dosisTexto = String(meta.dosis).trim();
  }
  if (dosisTexto) partes.push(`Dosis ${dosisTexto}`);
  if (meta.bazuqueo) partes.push("Bazuqueo");
  if (meta.remontado) partes.push("Remontado");
  if (meta.trasiego) partes.push("Trasiego");
  return partes.join(" · ");
}

function obtenerClaveDiaLocal(ms) {
  if (!ms) return "";
  const fecha = new Date(ms);
  if (Number.isNaN(fecha.getTime())) return "";
  const y = fecha.getFullYear();
  const m = String(fecha.getMonth() + 1).padStart(2, "0");
  const d = String(fecha.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function formatearDiaCorto(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      day: "2-digit",
      month: "short",
    });
  } catch (_err) {
    return "—";
  }
}

function formatearDiaLargo(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      weekday: "long",
      day: "2-digit",
      month: "long",
    });
  } catch (_err) {
    return "—";
  }
}

function formatearFechaHoraCopiloto(ms) {
  if (!ms) return "—";
  try {
    const fecha = new Date(ms);
    const dia = fecha.toLocaleDateString("es-ES", {
      weekday: "short",
      day: "2-digit",
      month: "short",
    });
    const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
    return `${dia} · ${hora}`;
  } catch (_err) {
    return "—";
  }
}

function parseClaveDiaLocal(clave) {
  if (!clave) return null;
  const partes = clave.split("-").map(n => Number(n));
  if (partes.length !== 3) return null;
  const [anio, mes, dia] = partes;
  if (!anio || !mes || !dia) return null;
  return new Date(anio, mes - 1, dia).getTime();
}

function detectarInconsistenciaCopiloto(contenedor) {
  if (!contenedor) return false;
  const volumen = Number(contenedor.volumen) || 0;
  const variedad = (contenedor.variedad || contenedor.vino_tipo || "").toString().trim();
  const estado = (contenedor.estado || "").toString().trim().toLowerCase();
  const tieneVolumen = volumen > 0;
  const tieneVariedad = Boolean(variedad);
  if (tieneVariedad && !tieneVolumen) return true;
  if (tieneVolumen && !tieneVariedad) return true;
  if (estado === "vacio" && tieneVolumen) return true;
  return false;
}

function calcularSemaforoCopiloto(contenedor, evento, analiticos) {
  if (detectarInconsistenciaCopiloto(contenedor)) {
    return { nivel: "actua", emoji: "🔴", texto: "Actúa" };
  }
  const msEvento = parseFechaMs(evento?.fecha_hora || evento?.fecha);
  const horasEvento = horasEntre(msEvento);
  if (horasEvento == null || horasEvento > COPILOTO_SEMAFORO_HORAS) {
    return { nivel: "preparate", emoji: "🟠", texto: "Prepárate" };
  }
  const activo = esFermentacionActiva(contenedor, analiticos) || esCrianzaActiva(contenedor);
  if (activo) {
    return { nivel: "observa", emoji: "🔵", texto: "Observa" };
  }
  return { nivel: "mantener", emoji: "🟢", texto: "Mantén" };
}

function renderCopilotoVivo(contenedores, analiticosMap, eventosMap) {
  const contenedor = document.getElementById("copilotoVivo");
  if (!contenedor) return [];
  contenedor.innerHTML = "";
  const lista = Array.isArray(contenedores) ? contenedores : [];
  if (!lista.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin contenedores activos todavía."));
    return [];
  }

  const items = lista.map(cont => {
    const key = `${cont.tipo}:${cont.id}`;
    const evento = eventosMap?.get(key) || null;
    const estadoEvento = extraerEstadoMetaCopiloto(evento?.meta);
    const estadoNodo = obtenerEstadoNodoCopiloto(cont);
    const estadoFinal = estadoEvento || estadoNodo;
    const analiticos = analiticosMap?.get(key) || [];
    const densidadReg = analiticos.find(r => r.densidad != null);
    const tempReg = analiticos.find(r => r.temperatura_c != null || r.temperatura != null);
    const densidadValor = densidadReg ? Number(densidadReg.densidad) : Number(evento?.meta?.densidad);
    const temperaturaValor = tempReg
      ? Number(tempReg.temperatura_c ?? tempReg.temperatura)
      : Number(evento?.meta?.temperatura_c ?? evento?.meta?.temperatura);

    const msEvento = parseFechaMs(evento?.fecha_hora || evento?.fecha);
    const msAnalitico = parseFechaMs(analiticos?.[0]?.fecha_hora || analiticos?.[0]?.fecha);
    const mov = obtenerMovimientosContenedor(cont.tipo, cont.id)[0];
    const msMov = parseFechaMs(mov?.fecha || mov?.fecha_hora);
    const ultimoMs = [msEvento, msAnalitico, msMov].filter(Boolean).sort((a, b) => b - a)[0] || null;
    const semaforo = calcularSemaforoCopiloto(cont, evento, analiticos);

    return {
      cont,
      evento,
      estadoFinal,
      densidadValor: Number.isFinite(densidadValor) ? densidadValor : null,
      temperaturaValor: Number.isFinite(temperaturaValor) ? temperaturaValor : null,
      ultimoMs,
      fase: obtenerFaseContenedor(cont),
      semaforo,
    };
  });

  items.sort((a, b) => {
    const aMs = a.ultimoMs || 0;
    const bMs = b.ultimoMs || 0;
    return aMs - bMs;
  });

  items.slice(0, 12).forEach(item => {
    const card = document.createElement("div");
    card.className = "copiloto-live-item";

    const top = document.createElement("div");
    top.className = "copiloto-live-top";
    const titulo = document.createElement("div");
    titulo.className = "copiloto-live-title";
    titulo.textContent = obtenerEtiquetaContenedor(item.cont);

    const badges = document.createElement("div");
    badges.className = "copiloto-live-badges";
    const badgeFase = document.createElement("span");
    badgeFase.className = "copiloto-badge";
    badgeFase.textContent = item.fase;
    badges.appendChild(badgeFase);

    if (item.semaforo) {
      const badgeSemaforo = document.createElement("span");
      badgeSemaforo.className = "copiloto-semaforo";
      badgeSemaforo.dataset.level = item.semaforo.nivel;
      badgeSemaforo.textContent = `${item.semaforo.emoji} ${item.semaforo.texto}`;
      badges.appendChild(badgeSemaforo);
    }

    const estadoTxt = resolverEtiquetaEstado(item.estadoFinal);
    if (estadoTxt) {
      const badgeEstado = document.createElement("span");
      badgeEstado.className = "copiloto-badge";
      badgeEstado.dataset.estado = (item.estadoFinal?.valor || "").toString().toLowerCase();
      badgeEstado.textContent = estadoTxt;
      badges.appendChild(badgeEstado);
    }

    top.appendChild(titulo);
    top.appendChild(badges);

    const meta = document.createElement("div");
    meta.className = "copiloto-live-meta";
    const densTxt = item.densidadValor != null && typeof formatearDensidad === "function"
      ? (formatearDensidad(item.densidadValor) || item.densidadValor)
      : (item.densidadValor != null ? item.densidadValor : "—");
    const tempTxt = item.temperaturaValor != null
      ? `${item.temperaturaValor.toFixed(1)}°C`
      : "—";
    meta.innerHTML = `
      <span>Última densidad: <strong>${densTxt}</strong></span>
      <span>Última temp: <strong>${tempTxt}</strong></span>
      <span>Última acción: <strong>${formatearTiempoRelativo(item.ultimoMs)}</strong></span>
    `;

    const acciones = document.createElement("div");
    acciones.className = "copiloto-live-actions";

    const btnExpress = document.createElement("button");
    btnExpress.type = "button";
    btnExpress.className = "small-btn copiloto-action-express";
    btnExpress.textContent = "Express";
    btnExpress.addEventListener("click", () => {
      const fab = document.getElementById("express-fab");
      if (fab) fab.click();
    });

    const btnBitacora = document.createElement("button");
    btnBitacora.type = "button";
    btnBitacora.className = "small-btn";
    btnBitacora.textContent = "Bitácora";
    btnBitacora.addEventListener("click", () => {
      if (typeof window.abrirModalBitacora === "function") {
        window.abrirModalBitacora({
          contenedorTipo: item.cont.tipo,
          contenedorId: item.cont.id,
          nombre: obtenerEtiquetaContenedor(item.cont),
        });
      }
    });

    const btnEditar = document.createElement("button");
    btnEditar.type = "button";
    btnEditar.className = "small-btn";
    btnEditar.textContent = "Editar";
    btnEditar.addEventListener("click", () => {
      if (item.cont.tipo === "barrica") {
        if (typeof editarBarricaDatos === "function") editarBarricaDatos(item.cont.id);
      } else if (typeof editarDepositoDatos === "function") {
        editarDepositoDatos(item.cont.id);
      }
    });

    acciones.appendChild(btnExpress);
    acciones.appendChild(btnBitacora);
    acciones.appendChild(btnEditar);

    card.appendChild(top);
    card.appendChild(meta);
    card.appendChild(acciones);
    contenedor.appendChild(card);
  });

  return items;
}

function renderCopilotoActividad(eventos) {
  const contenedor = document.getElementById("copilotoActividad");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const lista = Array.isArray(eventos) ? eventos.slice(0, 15) : [];
  if (!lista.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin actividad reciente."));
    return;
  }
  lista.forEach(evento => {
    const item = document.createElement("div");
    item.className = "copiloto-activity-item";
    const contTipo = (evento.contenedor_tipo || "").toString().toLowerCase();
    const contId = Number(evento.contenedor_id);
    const nombre = contTipo && Number.isFinite(contId)
      ? obtenerNombreContenedorCopiloto(contTipo, contId)
      : "Contenedor";
    const accionTexto = (evento?.meta?.accion_texto || "").toString().trim();
    const accion = accionTexto || formatearAccionEvento(evento?.meta?.accion || evento?.tipo);
    const estadoMeta = extraerEstadoMetaCopiloto(evento?.meta);
    const estadoTxt = resolverEtiquetaEstado(estadoMeta);
    const origenRaw = (evento.origen || "manual").toString().toLowerCase();
    const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
    const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);

    const meta = document.createElement("div");
    meta.className = "copiloto-activity-meta";
    meta.innerHTML = `
      <span>${formatearTiempoRelativo(fechaMs)}</span>
      <span>${nombre}</span>
    `;

    const badgeOrigen = document.createElement("span");
    badgeOrigen.className = "copiloto-badge";
    badgeOrigen.dataset.origen = origen;
    badgeOrigen.textContent = origen === "express" ? "Express" : origen === "control" ? "Control" : "Manual";
    meta.appendChild(badgeOrigen);

    if (estadoTxt) {
      const badgeEstado = document.createElement("span");
      badgeEstado.className = "copiloto-badge";
      badgeEstado.dataset.estado = (estadoMeta?.valor || "").toString().toLowerCase();
      badgeEstado.textContent = estadoTxt;
      meta.appendChild(badgeEstado);
    }

    const titulo = document.createElement("div");
    titulo.className = "copiloto-activity-title";
    titulo.textContent = `${accion} · ${evento.resumen || "Evento"}`;

    item.appendChild(meta);
    item.appendChild(titulo);

    if (evento.detalle) {
      const desc = document.createElement("div");
      desc.style.fontSize = "12px";
      desc.style.opacity = "0.78";
      desc.textContent = evento.detalle;
      item.appendChild(desc);
    }
    const variables = construirLineaVariablesCopiloto(evento?.meta);
    if (variables) {
      const vars = document.createElement("div");
      vars.style.fontSize = "12px";
      vars.style.opacity = "0.7";
      vars.textContent = variables;
      item.appendChild(vars);
    }

    item.addEventListener("click", () => {
      if (typeof window.abrirModalBitacora === "function" && contTipo && Number.isFinite(contId)) {
        window.abrirModalBitacora({
          contenedorTipo: contTipo,
          contenedorId: contId,
          nombre,
        });
      }
    });

    contenedor.appendChild(item);
  });
}

function obtenerEventosOrdenadosCopiloto(eventos) {
  const lista = Array.isArray(eventos) ? [...eventos] : [];
  return lista.sort((a, b) => {
    const aMs = parseFechaMs(a?.fecha_hora || a?.fecha) || 0;
    const bMs = parseFechaMs(b?.fecha_hora || b?.fecha) || 0;
    return bMs - aMs;
  });
}

function setCopilotoFiltroDia(clave, eventos) {
  copilotoFiltroDia = clave || null;
  resetearVisibilidadTimeline();
  const lista = Array.isArray(eventos) ? eventos : (Array.isArray(copilotoEventosCache) ? copilotoEventosCache : []);
  renderCopilotoHeatmap(lista);
  renderCopilotoTimeline(lista);
}

function renderCopilotoHeatmap(eventos) {
  const contenedor = document.getElementById("copilotoHeatmap");
  if (!contenedor) return;
  contenedor.innerHTML = "";

  const label = document.getElementById("copilotoHeatmapLabel");
  const btnClear = document.getElementById("copilotoHeatmapClear");
  const lista = Array.isArray(eventos) ? eventos : [];
  const conteos = {};
  lista.forEach(evento => {
    const ms = parseFechaMs(evento?.fecha_hora || evento?.fecha);
    const clave = obtenerClaveDiaLocal(ms);
    if (!clave) return;
    conteos[clave] = (conteos[clave] || 0) + 1;
  });

  const hoy = new Date();
  const dias = [];
  for (let i = COPILOTO_HEATMAP_DIAS - 1; i >= 0; i -= 1) {
    const fecha = new Date(hoy);
    fecha.setDate(hoy.getDate() - i);
    const ms = fecha.getTime();
    const clave = obtenerClaveDiaLocal(ms);
    dias.push({ clave, ms, count: conteos[clave] || 0 });
  }
  const max = dias.reduce((acc, dia) => Math.max(acc, dia.count), 0);

  dias.forEach(dia => {
    const cell = document.createElement("button");
    cell.type = "button";
    cell.className = "copiloto-heatmap-cell";
    if (dia.count > 0) {
      let nivel = max <= 1 ? 1 : Math.ceil((dia.count / max) * 4);
      nivel = Math.min(4, Math.max(1, nivel));
      cell.classList.add(`heat-${nivel}`);
    }
    if (copilotoFiltroDia && dia.clave === copilotoFiltroDia) {
      cell.classList.add("is-selected");
    }
    cell.title = `${formatearDiaLargo(dia.ms)} · ${dia.count} eventos`;
    cell.addEventListener("click", () => setCopilotoFiltroDia(dia.clave, eventos));
    contenedor.appendChild(cell);
  });

  if (label) {
    if (copilotoFiltroDia) {
      const msFiltro = parseClaveDiaLocal(copilotoFiltroDia);
      label.textContent = msFiltro ? `Filtrando: ${formatearDiaCorto(msFiltro)}` : "Filtrando";
    } else {
      label.textContent = `Últimos ${COPILOTO_HEATMAP_DIAS} días`;
    }
  }
  if (btnClear) {
    btnClear.disabled = !copilotoFiltroDia;
  }
}

function renderCopilotoTimeline(eventos) {
  const contenedor = document.getElementById("copilotoTimeline");
  if (!contenedor) return;
  contenedor.innerHTML = "";

  const info = document.getElementById("copilotoTimelineInfo");
  const footer = document.getElementById("copilotoTimelineFooter");
  const countEl = document.getElementById("copilotoTimelineCount");
  const btnMas = document.getElementById("copilotoTimelineMas");
  const ordenados = obtenerEventosOrdenadosCopiloto(eventos);
  const filtros = obtenerFiltrosTimeline();
  let filtrados = ordenados;

  if (filtros.contenedor) {
    const [tipo, idRaw] = filtros.contenedor.split(":");
    const id = Number(idRaw);
    filtrados = filtrados.filter(ev => {
      const evTipo = (ev.contenedor_tipo || "").toString().toLowerCase();
      const evId = Number(ev.contenedor_id);
      return evTipo === tipo && Number.isFinite(evId) && evId === id;
    });
  }

  if (filtros.origen !== "todos") {
    filtrados = filtrados.filter(ev => {
      const origenRaw = (ev.origen || "manual").toString().toLowerCase();
      const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
      return origen === filtros.origen;
    });
  }

  if (filtros.accion) {
    filtrados = filtrados.filter(ev => obtenerAccionEventoCopiloto(ev).key === filtros.accion);
  }

  if (filtros.buscar) {
    filtrados = filtrados.filter(ev => {
      const contTipo = (ev.contenedor_tipo || "").toString().toLowerCase();
      const contId = Number(ev.contenedor_id);
      const nombre = contTipo && Number.isFinite(contId)
        ? obtenerNombreContenedorCopiloto(contTipo, contId)
        : "Contenedor";
      const { label } = obtenerAccionEventoCopiloto(ev);
      const resumen = (ev.resumen || "").toString().trim();
      const detalle = (ev.detalle || "").toString().trim();
      const variables = construirLineaVariablesCopiloto(ev?.meta);
      const texto = [label, resumen, detalle, variables, nombre, contTipo]
        .filter(Boolean)
        .join(" ")
        .toLowerCase();
      return texto.includes(filtros.buscar);
    });
  }

  if (copilotoFiltroDia) {
    filtrados = filtrados.filter(ev =>
      obtenerClaveDiaLocal(parseFechaMs(ev?.fecha_hora || ev?.fecha)) === copilotoFiltroDia
    );
  }

  const maximo = Math.min(COPILOTO_TIMELINE_LIMIT, filtrados.length);
  const visible = Math.min(copilotoTimelineVisible, maximo);
  const lista = filtrados.slice(0, visible);

  if (!lista.length) {
    const mensaje = copilotoFiltroDia ? "Sin eventos en este día." : "Sin eventos todavía.";
    contenedor.appendChild(crearElementoCopilotoEmpty(mensaje));
    return;
  }

  const grupos = [];
  let actual = null;
  lista.forEach(evento => {
    const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);
    const clave = obtenerClaveDiaLocal(fechaMs) || "sin-fecha";
    if (!actual || actual.clave !== clave) {
      actual = { clave, ms: fechaMs, eventos: [] };
      grupos.push(actual);
    }
    actual.eventos.push(evento);
  });

  const LIMITE_ACTOS_DIA = 3;
  const mostrarTodo = copilotoTimelineExpandAll;

  grupos.forEach((grupo, grupoIndex) => {
    const bloque = document.createElement("div");
    bloque.className = "copiloto-timeline-day";
    if (!mostrarTodo && grupoIndex > 0) {
      bloque.style.display = "none";
      bloque.dataset.hiddenGroup = "1";
    }
    const tituloDia = document.createElement("div");
    tituloDia.className = "copiloto-timeline-day-title";
    tituloDia.textContent = resolverEtiquetaDiaTimeline(grupo.ms);
    bloque.appendChild(tituloDia);

    grupo.eventos.forEach((evento, index) => {
      const contTipo = (evento.contenedor_tipo || "").toString().toLowerCase();
      const contId = Number(evento.contenedor_id);
      const nombre = contTipo && Number.isFinite(contId)
        ? obtenerNombreContenedorCopiloto(contTipo, contId)
        : "Contenedor";
      const tipoLabel =
        contTipo === "barrica"
          ? "Barrica"
          : contTipo === "mastelone"
          ? "Mastelone"
          : contTipo
          ? "Depósito"
          : "Contenedor";
      const { label: accionLabel } = obtenerAccionEventoCopiloto(evento);
      const accion = accionLabel || "Evento";
      const resumen = (evento.resumen || "").toString().trim();
      const detalle = (evento.detalle || "").toString().trim();
      const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);
      const estadoMeta = extraerEstadoMetaCopiloto(evento?.meta);
      const estadoTxt = resolverEtiquetaEstado(estadoMeta);
      const origenRaw = (evento.origen || "manual").toString().toLowerCase();
      const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
      const variables = construirLineaVariablesCopiloto(evento?.meta);

      const card = document.createElement("div");
      card.className = "copiloto-timeline-card";

      const top = document.createElement("div");
      top.className = "copiloto-card-top";

      const hora = document.createElement("div");
      hora.className = "copiloto-card-time";
      hora.textContent = formatearHoraCorta(fechaMs);

      const main = document.createElement("div");
      main.className = "copiloto-card-main";

      const meta = document.createElement("div");
      meta.className = "copiloto-card-meta";
      const nombreEl = document.createElement("span");
      nombreEl.textContent = nombre;
      meta.appendChild(nombreEl);

      const badgeTipo = document.createElement("span");
      badgeTipo.className = "copiloto-badge";
      badgeTipo.textContent = tipoLabel;
      meta.appendChild(badgeTipo);

      const badgeOrigen = document.createElement("span");
      badgeOrigen.className = "copiloto-badge";
      badgeOrigen.dataset.origen = origen;
      badgeOrigen.textContent = origen === "express" ? "Express" : origen === "control" ? "Control" : "Manual";
      meta.appendChild(badgeOrigen);

      if (estadoTxt) {
        const badgeEstado = document.createElement("span");
        badgeEstado.className = "copiloto-badge";
        badgeEstado.dataset.estado = (estadoMeta?.valor || "").toString().toLowerCase();
        badgeEstado.textContent = estadoTxt;
        meta.appendChild(badgeEstado);
      }

      const titulo = document.createElement("div");
      titulo.className = "copiloto-card-title";
      titulo.textContent = accion;

      main.appendChild(meta);
      main.appendChild(titulo);

      const subline = variables || (resumen && resumen !== accion ? resumen : "");
      if (subline) {
        const sub = document.createElement("div");
        sub.className = "copiloto-card-sub";
        sub.textContent = subline;
        main.appendChild(sub);
      }

      let notaTexto = detalle;
      if (!notaTexto && resumen && resumen !== accion && subline !== resumen) {
        notaTexto = resumen;
      }

      let notaEl = null;
      let btnExpandir = null;
      if (notaTexto) {
        notaEl = document.createElement("div");
        notaEl.className = "copiloto-card-note";
        notaEl.textContent = notaTexto;
        main.appendChild(notaEl);
        if (notaTexto.length > 140) {
          btnExpandir = document.createElement("button");
          btnExpandir.type = "button";
          btnExpandir.className = "small-btn";
          btnExpandir.textContent = "Ver más";
          btnExpandir.addEventListener("click", ev => {
            ev.stopPropagation();
            notaEl.classList.toggle("is-expanded");
            btnExpandir.textContent = notaEl.classList.contains("is-expanded") ? "Ver menos" : "Ver más";
          });
        }
      }

      top.appendChild(hora);
      top.appendChild(main);
      card.appendChild(top);

      const acciones = document.createElement("div");
      acciones.className = "copiloto-card-actions";
      const enlace = document.createElement("button");
      enlace.type = "button";
      enlace.className = "small-btn";
      enlace.textContent = "Ver en bitácora";
      const abrirBitacora = () => {
        if (typeof window.abrirModalBitacora === "function" && contTipo && Number.isFinite(contId)) {
          window.abrirModalBitacora({
            contenedorTipo: contTipo,
            contenedorId: contId,
            nombre,
          });
        }
      };
      enlace.addEventListener("click", ev => {
        ev.stopPropagation();
        abrirBitacora();
      });

      if (btnExpandir) acciones.appendChild(btnExpandir);
      acciones.appendChild(enlace);
      card.appendChild(acciones);

      card.addEventListener("click", abrirBitacora);
      if (!mostrarTodo && grupoIndex === 0 && index >= LIMITE_ACTOS_DIA) {
        card.dataset.hidden = "1";
        card.style.display = "none";
      }
      bloque.appendChild(card);
    });

    if (grupoIndex === 0 && (grupo.eventos.length > LIMITE_ACTOS_DIA || grupos.length > 1)) {
      const btnToggle = document.createElement("button");
      btnToggle.type = "button";
      btnToggle.className = "copiloto-day-toggle";
      btnToggle.textContent = mostrarTodo ? "Ver menos" : "Leer más";
      btnToggle.addEventListener("click", ev => {
        ev.stopPropagation();
        copilotoTimelineExpandAll = !copilotoTimelineExpandAll;
        renderCopilotoTimeline(eventos);
      });
      bloque.appendChild(btnToggle);
    }

    contenedor.appendChild(bloque);
  });

  const visibleCount = mostrarTodo
    ? lista.length
    : Math.min(LIMITE_ACTOS_DIA, grupos[0]?.eventos?.length || 0);

  if (info) {
    if (copilotoFiltroDia) {
      const msFiltro = parseClaveDiaLocal(copilotoFiltroDia);
      const label = msFiltro ? resolverEtiquetaDiaTimeline(msFiltro) : "este día";
      info.textContent = `Eventos de ${label} · ${filtrados.length}`;
    } else {
      info.textContent = `Mostrando ${visibleCount} de ${filtrados.length}`;
    }
  }

  if (footer && countEl) {
    const hayMas = filtrados.length > lista.length;
    footer.style.display = hayMas ? "flex" : "none";
    countEl.textContent = `Mostrando ${visibleCount} de ${filtrados.length}`;
    if (btnMas) btnMas.disabled = !hayMas;
  }
}

function renderCopilotoAlertas(alertas) {
  const contenedor = document.getElementById("copilotoAlertas");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  if (!alertas.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin alertas activas."));
    return;
  }
  alertas.forEach(alerta => {
    const card = document.createElement("div");
    card.className = "copiloto-alert";
    card.dataset.level = alerta.level || "baja";

    const title = document.createElement("div");
    title.className = "copiloto-alert-title";
    const titulo = document.createElement("span");
    titulo.textContent = alerta.titulo || "Alerta";
    const meta = document.createElement("span");
    meta.className = "copiloto-alert-meta";
    meta.textContent = alerta.contenedor?.etiqueta || "";
    title.appendChild(titulo);
    title.appendChild(meta);

    const mensaje = document.createElement("div");
    mensaje.className = "copiloto-alert-meta";
    mensaje.textContent = alerta.mensaje || "";

    card.appendChild(title);
    card.appendChild(mensaje);

    if (alerta.acciones && alerta.acciones.length) {
      const acciones = document.createElement("div");
      acciones.className = "copiloto-alert-actions";
      alerta.acciones.forEach(accion => {
        const chip = document.createElement("span");
        chip.className = "copiloto-chip";
        chip.textContent = accion;
        acciones.appendChild(chip);
      });
      card.appendChild(acciones);
    }

    const botones = document.createElement("div");
    botones.className = "copiloto-alert-actions";

    if (alerta.contenedor) {
      const verBtn = document.createElement("button");
      verBtn.className = "small-btn";
      verBtn.type = "button";
      verBtn.textContent = "Ver contenedor";
      verBtn.addEventListener("click", () => irAlContenedor(alerta.contenedor));
      botones.appendChild(verBtn);
    }

    const ignoreBtn = document.createElement("button");
    ignoreBtn.className = "small-btn";
    ignoreBtn.type = "button";
    ignoreBtn.textContent = `Ignorar ${COPILOTO_SNOOZE_HOURS}h`;
    ignoreBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.snoozed[alerta.id] = Date.now() + COPILOTO_SNOOZE_HOURS * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    botones.appendChild(ignoreBtn);

    const doneBtn = document.createElement("button");
    doneBtn.className = "small-btn";
    doneBtn.type = "button";
    doneBtn.textContent = "Hecho";
    doneBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.done[alerta.id] = Date.now() + COPILOTO_DONE_DAYS * 24 * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    botones.appendChild(doneBtn);

    card.appendChild(botones);
    contenedor.appendChild(card);
  });
}

function renderCopilotoTareas(tareas) {
  const contenedor = document.getElementById("copilotoTareas");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const filtradas = (tareas || []).filter(t => !(copilotoConfig?.modoExperto && t.basica));
  if (!filtradas.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin tareas pendientes."));
    return;
  }
  filtradas.forEach(tarea => {
    const row = document.createElement("div");
    row.className = "copiloto-task";
    const info = document.createElement("div");
    const titulo = document.createElement("div");
    titulo.textContent = tarea.texto;
    info.appendChild(titulo);
    if (tarea.contenedor?.etiqueta) {
      const small = document.createElement("small");
      small.textContent = tarea.contenedor.etiqueta;
      info.appendChild(small);
    }
    const doneBtn = document.createElement("button");
    doneBtn.className = "small-btn";
    doneBtn.type = "button";
    doneBtn.textContent = "Hecho";
    doneBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.done[tarea.id] = Date.now() + COPILOTO_DONE_DAYS * 24 * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    row.appendChild(info);
    row.appendChild(doneBtn);
    contenedor.appendChild(row);
  });
}

function renderCopilotoFeed(alertas) {
  const contenedor = document.getElementById("copilotoFeed");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const items = (alertas || [])
    .filter(a => !(copilotoConfig?.modoExperto && a.basica))
    .slice(0, 4);
  if (!items.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin novedades críticas."));
    return;
  }
  items.forEach(alerta => {
    const item = document.createElement("div");
    item.className = "copiloto-feed-item";
    item.textContent = alerta.feed || alerta.mensaje || "Actualización del copiloto.";
    contenedor.appendChild(item);
  });
}

function esFermentacionActiva(contenedor, analiticos = []) {
  if (!contenedor || contenedor.tipo === "barrica") return false;
  const fase = obtenerFaseContenedor(contenedor);
  if (fase === "Fermentación" || fase === "Maloláctica") return true;
  const registro = analiticos.find(r => r.densidad != null);
  const ms = parseFechaMs(registro?.fecha_hora || registro?.fecha);
  const horas = horasEntre(ms);
  return horas != null && horas <= 120;
}

function esCrianzaActiva(contenedor) {
  if (!contenedor) return false;
  if (contenedor.tipo === "barrica") return true;
  return obtenerFaseContenedor(contenedor) === "Crianza";
}

function renderCopiloto(alertas, tareas, data = {}) {
  renderCopilotoAlertas(alertas);
  renderCopilotoTareas(tareas);
  const itemsVivos = renderCopilotoVivo(data.contenedores || [], data.analiticosMap || new Map(), data.eventosMap || new Map());
  const eventos = Array.isArray(data.eventos)
    ? data.eventos
    : (Array.isArray(copilotoEventosCache) ? copilotoEventosCache : []);
  actualizarOpcionesAccionTimeline(eventos);
  renderCopilotoActividad(eventos);
  renderCopilotoTimeline(eventos);
  renderCopilotoHeatmap(eventos);
  poblarSelectCopilotoNotaContenedores();
  poblarSelectCopilotoTimelineContenedores();
  const estado = document.getElementById("copilotoEstado");
  const actualizado = document.getElementById("copilotoActualizado");
  const pendientes = document.getElementById("copilotoPendientes");
  const fechaEl = document.getElementById("copilotoFecha");
  const campaniaEl = document.getElementById("copilotoCampania");
  const fermentacionesEl = document.getElementById("copilotoFermentaciones");
  const crianzaEl = document.getElementById("copilotoCrianza");
  const niveles = alertas.map(a => a.level);
  const nivelMax = niveles.includes("alta")
    ? "En guardia"
    : niveles.includes("media")
    ? "En vigilancia"
    : niveles.includes("baja")
    ? "En calma"
    : "Sin riesgos";
  if (estado) estado.textContent = `Estado: ${nivelMax}`;
  if (pendientes) pendientes.textContent = `${alertas.length} alertas activas`;
  if (actualizado) {
    const ahora = new Date();
    actualizado.textContent = `Última lectura: ${ahora.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })}`;
  }
  if (fechaEl) {
    fechaEl.textContent = new Date().toLocaleDateString("es-ES", {
      weekday: "long",
      day: "2-digit",
      month: "short",
    });
  }
  if (campaniaEl) {
    const anio = Number(obtenerAnadaVitivinicolaDesdeFecha(new Date().toISOString()));
    campaniaEl.textContent = `Añada ${anio}`;
  }
  const contenedores = Array.isArray(data.contenedores) ? data.contenedores : [];
  const analiticosMap = data.analiticosMap || new Map();
  const fermentaciones = contenedores.filter(cont => esFermentacionActiva(cont, analiticosMap.get(`${cont.tipo}:${cont.id}`) || []));
  const crianzas = contenedores.filter(cont => esCrianzaActiva(cont));
  if (fermentacionesEl) fermentacionesEl.textContent = `Fermentaciones activas: ${fermentaciones.length}`;
  if (crianzaEl) crianzaEl.textContent = `Contenedores en crianza: ${crianzas.length}`;
  return { itemsVivos };
}

function notificarAvisosVivosCopiloto(itemsVivos) {
  if (!Array.isArray(itemsVivos) || !itemsVivos.length) return;
  if (!copilotoState) cargarEstadoCopiloto();
  if (!copilotoConfig?.notificaciones) return;
  if (!("Notification" in window) || Notification.permission !== "granted") return;

  const avisos = itemsVivos.filter(item => {
    const nivel = (item?.semaforo?.nivel || "").toString().toLowerCase();
    return nivel === "preparate" || nivel === "actua";
  });
  if (!avisos.length) return;

  const ahora = Date.now();
  const ventanaMs = 2 * 60 * 60 * 1000;
  const nuevos = avisos.filter(item => {
    const nivel = (item?.semaforo?.nivel || "").toString().toLowerCase();
    const key = `vivo:${item.cont?.tipo}:${item.cont?.id}:${nivel}`;
    const visto = Number(copilotoState?.seen?.[key] || 0);
    return !visto || (ahora - visto > ventanaMs);
  });
  if (!nuevos.length) return;

  const resumen = nuevos.slice(0, 3).map(item => obtenerEtiquetaContenedor(item.cont)).join(", ");
  const body = nuevos.length === 1
    ? `${resumen} pide atención en "Lo que está vivo".`
    : `${nuevos.length} contenedores con aviso: ${resumen}${nuevos.length > 3 ? "..." : ""}`;
  try {
    new Notification("Copiloto: aviso en vivo", {
      body,
      tag: "copiloto-vivo",
    });
  } catch (_err) {
    return;
  }

  nuevos.forEach(item => {
    const nivel = (item?.semaforo?.nivel || "").toString().toLowerCase();
    const key = `vivo:${item.cont?.tipo}:${item.cont?.id}:${nivel}`;
    copilotoState.seen[key] = ahora;
  });
  guardarEstadoCopiloto();
}

function notificarAlertasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  const ahora = Date.now();
  alertas.forEach(alerta => {
    if (alerta.level !== "alta") return;
    if (copilotoState.seen?.[alerta.id]) return;
    mostrarAviso(alerta.mensaje, "error");
    if (
      copilotoConfig?.notificaciones &&
      "Notification" in window &&
      Notification.permission === "granted"
    ) {
      try {
        new Notification(`Copiloto: ${alerta.titulo}`, {
          body: alerta.mensaje,
          tag: alerta.id,
        });
      } catch (e) {
        // noop
      }
    }
    copilotoState.seen[alerta.id] = ahora;
  });
  guardarEstadoCopiloto();
}

async function actualizarCopiloto(forzar = false) {
  const contenedorAlertas = document.getElementById("copilotoAlertas");
  if (!contenedorAlertas) return;
  if (copilotoEnProgreso) return;
  copilotoEnProgreso = true;
  if (!copilotoConfig) cargarConfigCopiloto();
  if (!copilotoState) cargarEstadoCopiloto();
  const contenedores = obtenerContenedoresCopiloto();
  try {
    const analiticosMap = new Map();
    if (contenedores.length) {
      await Promise.all(
        contenedores.map(async cont => {
          const registros = await obtenerAnaliticosCopiloto(cont.tipo, cont.id, forzar);
          analiticosMap.set(`${cont.tipo}:${cont.id}`, registros);
        })
      );
    }
    const alertas = [];
    contenedores.forEach(cont => {
      const analiticos = analiticosMap.get(`${cont.tipo}:${cont.id}`) || [];
      const movimientos = obtenerMovimientosContenedor(cont.tipo, cont.id);
      [
        reglaFermentacionEstancada(cont, analiticos, copilotoConfig),
        reglaOxidacion(cont, movimientos, copilotoConfig),
        reglaTemperaturaAlta(cont, analiticos, copilotoConfig),
        reglaAnaliticaPendiente(cont, analiticos, copilotoConfig),
      ]
        .filter(Boolean)
        .forEach(alerta => alertas.push(alerta));
    });
    const ordenadas = ordenarAlertasCopiloto(alertas);
    const filtradas = filtrarAlertasCopiloto(ordenadas);
    const tareas = generarTareasCopiloto(filtradas);
    const eventos = await obtenerEventosBitacoraRecientes(forzar);
    const eventosMap = mapearEventosPorContenedor(eventos);
    const renderInfo = renderCopiloto(filtradas, tareas, {
      contenedores,
      analiticosMap,
      eventos,
      eventosMap,
    });
    notificarAvisosVivosCopiloto(renderInfo?.itemsVivos || []);
    notificarAlertasCopiloto(filtradas);
  } finally {
    copilotoEnProgreso = false;
  }
}

function obtenerAnadaVitivinicolaDesdeFecha(fechaStr) {
  if (!fechaStr) return "";
  const parseDesdeTexto = texto => {
    const m = String(texto || "").trim().match(/^(\d{4})-(\d{2})/);
    if (!m) return null;
    const year = Number(m[1]);
    const month = Number(m[2]);
    if (!Number.isFinite(year) || !Number.isFinite(month) || month < 1 || month > 12) return null;
    return { year, month };
  };

  const parsed = parseDesdeTexto(fechaStr);
  let year = null;
  let month = null;
  if (parsed) {
    year = parsed.year;
    month = parsed.month;
  } else {
    const d = new Date(fechaStr);
    if (!Number.isNaN(d.getTime())) {
      year = d.getFullYear();
      month = d.getMonth() + 1;
    }
  }
  if (!Number.isFinite(year) || !Number.isFinite(month)) return "";
  return String(month >= 8 ? year : year - 1);
}

function obtenerAnadaDesdeFecha(fechaStr) {
  return obtenerAnadaVitivinicolaDesdeFecha(fechaStr);
}

function obtenerValorAnada(valor) {
  if (!valor) return "Sin añada";
  return valor.toString();
}

function coincideConFiltros(anadaVal, vinoVal, filtros) {
  const anadaComparar = obtenerValorAnada(anadaVal);
  const vinoComparar = (vinoVal || "").trim() || "Sin clasificar";
  const okAnada = filtros.anada === "todos" || filtros.anada === anadaComparar;
  const okVino = filtros.vino === "todos" || vinoComparar === filtros.vino;
  return okAnada && okVino;
}

function obtenerInfoContenedor(tipo, id) {
  if (tipo === "deposito") {
    return mapaDepositosPorId && mapaDepositosPorId.get(id);
  }
  if (tipo === "mastelone") {
    return mapaMastelonesPorId && mapaMastelonesPorId.get(id);
  }
  if (tipo === "barrica") {
    return mapaBarricasPorId && mapaBarricasPorId.get(id);
  }
  return null;
}

function obtenerCapacidadFormateada(info) {
  if (!info) return "";
  const capacidad =
    info.capacidad_l != null
      ? Number(info.capacidad_l)
      : info.capacidad_hl != null
      ? Number(info.capacidad_hl) * 100
      : null;
  if (!Number.isFinite(capacidad) || capacidad <= 0) return "";
  return capacidad % 1 === 0 ? capacidad.toFixed(0) : capacidad.toFixed(2);
}

function describirContenedor(info, tipoLabel) {
  const partes = [];
  if (tipoLabel) partes.push(tipoLabel);
  if (info) {
    const cap = obtenerCapacidadFormateada(info);
    if (cap) partes.push(cap);
    const material =
      info.material ||
      info.tipo_roble ||
      info.tipo ||
      info.marca ||
      info.clase ||
      "";
    if (material) partes.push(material);
  }
  return partes.join(" ").trim();
}

function parsearFechaValor(valor) {
  if (!valor) return null;
  let base = valor.trim();
  if (!base) return null;
  if (base.includes("/")) {
    const partes = base.split("/");
    if (partes.length === 3) {
      // dd/mm/yyyy -> yyyy-mm-dd
      base = `${partes[2]}-${partes[1].padStart(2, "0")}-${partes[0].padStart(2, "0")}`;
    }
  }
  const fecha = new Date(base);
  return isNaN(fecha.getTime()) ? null : fecha;
}

function calcularMesesEntre(fechaInicio, fechaFin) {
  const inicio = parsearFechaValor(fechaInicio);
  const fin = parsearFechaValor(fechaFin);
  if (!inicio || !fin) return null;
  let meses = (fin.getFullYear() - inicio.getFullYear()) * 12 + (fin.getMonth() - inicio.getMonth());
  if (fin.getDate() < inicio.getDate()) {
    meses -= 1;
  }
  if (meses < 0) meses = 0;
  return meses;
}

function actualizarDuracionPrevista(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const inicio = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const fin = nodo.datos?.tiempo;
  if (!inicio || !fin) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  const meses = calcularMesesEntre(inicio, fin);
  if (meses == null) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  nodo.datos.tiempo_estimado = meses === 1 ? "1 mes" : `${meses} meses`;
}

function refrescarDuracionModal(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  actualizarDuracionPrevista(nodo);
  const display = document.getElementById("flowField-tiempo_estimado-display");
  if (display) {
    display.textContent = nodo.datos?.tiempo_estimado || "—";
  }
  const hidden = document.getElementById("flowField-tiempo_estimado");
  if (hidden) {
    hidden.value = nodo.datos?.tiempo_estimado || "";
  }
}

function obtenerVinosEntrada(entrada) {
  const vinos = new Set();
  if (Array.isArray(entrada.destinos)) {
    entrada.destinos.forEach(dest => {
      const info = obtenerInfoContenedor(dest.contenedor_tipo, dest.contenedor_id);
      if (info && info.vino_tipo) {
        vinos.add(info.vino_tipo);
      }
    });
  }
  if (!vinos.size && entrada.variedad) {
    vinos.add(entrada.variedad);
  }
  return vinos;
}

function calcularDatosMapaFlujo() {
  const resultado = {
    entrada: { valor: 0, detalle: "" },
    despalillado: { valor: 0, detalle: "" },
    deposito: { valor: 0, detalle: "" },
    barrica: { valor: 0, detalle: "" },
    embotellado: { valor: 0, detalle: "" },
    salida: { valor: 0, detalle: "" },
  };

  const entradas = cacheEntradas || [];
  resultado.entrada.valor = entradas.reduce((acc, e) => {
    const volumen = getVolumenFromDatos(e);
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.entrada.detalle = `${entradas.length} entradas registradas`;

  let volumenDesp = 0;
  entradas.forEach(entrada => {
    if (Array.isArray(entrada.destinos) && entrada.destinos.length) {
      entrada.destinos.forEach(dest => {
        const volumen = getVolumenFromDatos(dest);
        if (Number.isFinite(volumen)) volumenDesp += volumen;
      });
    } else {
      const volumen = getVolumenFromDatos(entrada);
      if (Number.isFinite(volumen)) volumenDesp += volumen;
    }
  });
  resultado.despalillado.valor = volumenDesp;
  resultado.despalillado.detalle = "Estimación tras despalillado / prensado";

  const depositos = (cacheDepositos || []).concat(cacheMastelones || []);
  resultado.deposito.valor = depositos.reduce((acc, d) => {
    const volumen = getVolumenFromDatos({
      volumen: d.volumen,
      litros: d.litros_actuales,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.deposito.detalle = `${depositos.length} depósitos / mastelones`;

  const barricas = cacheBarricas || [];
  resultado.barrica.valor = barricas.reduce((acc, b) => {
    const volumen = getVolumenFromDatos({
      volumen: b.volumen,
      litros: b.litros_actuales,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.barrica.detalle = `${barricas.length} barricas activas`;

  const embotellados = cacheEmbotellados || [];
  resultado.embotellado.valor = embotellados.reduce((acc, e) => {
    const volumen = getVolumenFromDatos({
      volumen: e.volumen,
      litros: e.litros,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.embotellado.detalle = `${embotellados.length} lotes embotellados`;

  const salidas = (cacheMovimientos || []).filter(m => {
    const tipo = (m.tipo || "").toLowerCase();
    return tipo === "venta" || tipo === "salida" || tipo === "expedicion" || m.destino_tipo === "venta";
  });
  resultado.salida.valor = salidas.reduce((acc, m) => {
    const volumen = getVolumenFromDatos({
      volumen: m.volumen,
      litros: m.litros,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.salida.detalle = `${salidas.length} movimientos de salida`;

  return resultado;
}

function actualizarMapaFlujo() {
  datosEtapasFlujo = calcularDatosMapaFlujo();
}

function limitarZoomFlow(valor) {
  const num = Number(valor);
  if (!Number.isFinite(num)) return 1;
  return Math.min(Math.max(num, FLOW_ZOOM_MIN), FLOW_ZOOM_MAX);
}

function actualizarEtiquetaZoomFlow() {
  const label = document.getElementById("flowZoomLabel");
  if (!label) return;
  label.textContent = `${Math.round(flowZoom * 100)}%`;
}

function aplicarLayoutFlow({ mantenerCentro = false } = {}) {
  const editor = document.getElementById("flowEditor");
  const stage = document.getElementById("flowStage");
  const world = document.getElementById("flowWorld");
  if (!editor || !stage || !world) return;

  const prevZoom = flowZoom || 1;
  let centroWorld = null;
  if (mantenerCentro) {
    const cx = editor.scrollLeft + editor.clientWidth / 2;
    const cy = editor.scrollTop + editor.clientHeight / 2;
    centroWorld = { x: cx / prevZoom, y: cy / prevZoom };
  }

  flowZoom = limitarZoomFlow(flowZoom);
  world.style.width = `${FLOW_WORLD_BASE.width}px`;
  world.style.height = `${FLOW_WORLD_BASE.height}px`;
  world.style.transform = `scale(${flowZoom})`;
  stage.style.width = `${FLOW_WORLD_BASE.width * flowZoom}px`;
  stage.style.height = `${FLOW_WORLD_BASE.height * flowZoom}px`;

  if (centroWorld) {
    editor.scrollLeft = Math.max(0, centroWorld.x * flowZoom - editor.clientWidth / 2);
    editor.scrollTop = Math.max(0, centroWorld.y * flowZoom - editor.clientHeight / 2);
  }

  actualizarEtiquetaZoomFlow();
  programarActualizacionMinimapFlow();
}

function aplicarZoomMapaFlujo(nuevoZoom, { mantenerCentro = true } = {}) {
  flowZoom = limitarZoomFlow(nuevoZoom);
  aplicarLayoutFlow({ mantenerCentro });
  try {
    localStorage.setItem("flowZoom", String(flowZoom));
  } catch (err) {
    // noop
  }
  renderFlowConnections();
}

function zoomMapaFlujo(direccion) {
  const delta = Number(direccion) || 0;
  if (!delta) return;
  aplicarZoomMapaFlujo(flowZoom + delta * FLOW_ZOOM_STEP);
}

function resetZoomMapaFlujo() {
  aplicarZoomMapaFlujo(1);
}

function programarActualizacionMinimapFlow() {
  if (flowMinimapRaf) return;
  flowMinimapRaf = requestAnimationFrame(() => {
    flowMinimapRaf = null;
    actualizarMinimapFlow();
  });
}

function inicializarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const viewport = document.getElementById("flowMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("flowEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    flowMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapFlow(ev);
    world.addEventListener("pointermove", moverDesdeMinimapFlow);
    world.addEventListener("pointerup", finalizarMinimapFlow);
    world.addEventListener("pointercancel", finalizarMinimapFlow);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, editor } = flowMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / (rect.width || 1)) * (FLOW_WORLD_BASE.width || 1);
  const worldY = (relY / (rect.height || 1)) * (FLOW_WORLD_BASE.height || 1);
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, worldX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function finalizarMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, pointerId } = flowMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapFlow);
  world.removeEventListener("pointerup", finalizarMinimapFlow);
  world.removeEventListener("pointercancel", finalizarMinimapFlow);
  flowMinimapDrag = null;
}

function centrarNodoFlowEnVista(nodo) {
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!editor || !canvas) return;
  const el = Array.from(canvas.querySelectorAll(".flow-node")).find(n => n.dataset.id === nodo.id);
  const w = el ? el.offsetWidth : 160;
  const h = el ? el.offsetHeight : 110;
  const centerX = (Number(nodo.x) || 0) + w / 2;
  const centerY = (Number(nodo.y) || 0) + h / 2;
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, centerX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function actualizarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const dotsHost = document.getElementById("flowMinimapDots");
  const viewport = document.getElementById("flowMinimapViewport");
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const baseW = FLOW_WORLD_BASE.width || 1;
  const baseH = FLOW_WORLD_BASE.height || 1;
  const aspect = baseH / baseW;
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = flowZoom || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / baseW) * mmW}px`;
  viewport.style.top = `${(viewY / baseH) * mmH}px`;
  viewport.style.width = `${(viewW / baseW) * mmW}px`;
  viewport.style.height = `${(viewH / baseH) * mmH}px`;

  const nodeEls = Array.from(canvas.querySelectorAll(".flow-node"));
  dotsHost.innerHTML = "";
  nodeEls.forEach(nodeEl => {
    const id = nodeEl.dataset.id || "";
    const tipo = nodeEl.dataset.tipo || "";
    const x = parseFloat(nodeEl.style.left || "") || 0;
    const y = parseFloat(nodeEl.style.top || "") || 0;
    const cx = x + nodeEl.offsetWidth / 2;
    const cy = y + nodeEl.offsetHeight / 2;
    const px = (cx / baseW) * mmW;
    const py = (cy / baseH) * mmH;
    const dot = document.createElement("div");
    dot.className = `flow-minimap-dot ${tipo || ""}`;
    if (id && nodoSeleccionadoId && String(nodoSeleccionadoId) === String(id)) {
      dot.classList.add("seleccionado");
    }
    dot.style.left = `${px}px`;
    dot.style.top = `${py}px`;
    const nodo = id ? obtenerNodoPorId(id) : null;
    dot.title = nodo?.titulo ? nodo.titulo : tipo ? tipo : "Nodo";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!id) return;
      const nodoClick = obtenerNodoPorId(id);
      if (!nodoClick) return;
      nodoSeleccionadoId = nodoClick.id;
      renderFlowNodes();
      mostrarInfoNodo(nodoClick.id);
      requestAnimationFrame(() => centrarNodoFlowEnVista(nodoClick));
    });
    dotsHost.appendChild(dot);
  });
}

function exportarNodosComoImagen() {
  const editor = document.querySelector(".flow-editor");
  if (!editor) return;

  const descargarCanvas = canvas => {
    const data = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = data;
    link.download = "mapa-nodos.png";
    document.body.appendChild(link);
    link.click();
    link.remove();
  };

  const hacerCaptura = () => {
    if (window.html2canvas) {
      window.html2canvas(editor, {
        backgroundColor: "#0b0515",
        scale: 2,
        useCORS: true,
        logging: false,
      }).then(descargarCanvas);
      return true;
    }
    return false;
  };

  if (hacerCaptura()) return;

  // Cargar html2canvas al vuelo si no está disponible
  const script = document.createElement("script");
  script.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
  script.onload = () => hacerCaptura();
  script.onerror = () => mostrarAviso("No se pudo exportar la imagen. Intenta con otra captura.", "error");
  document.body.appendChild(script);
}

	async function inicializarFlowEditor() {
	  await cargarNodosGuardados();
	  try {
	    const savedZoom = Number(localStorage.getItem("flowZoom"));
	    if (Number.isFinite(savedZoom)) {
	      flowZoom = savedZoom;
	    }
	  } catch (err) {
	    // noop
	  }
	  flowZoom = limitarZoomFlow(flowZoom);
	  aplicarLayoutFlow();
	  renderFlowNodes();
	  const editor = document.getElementById("flowEditor");
	  if (editor) {
	    editor.addEventListener("scroll", programarActualizacionMinimapFlow, { passive: true });
	  }
	  const canvas = document.getElementById("flowCanvas");
		  if (canvas) {
		    canvas.addEventListener("click", e => {
		      if (!e.target.closest(".flow-node")) {
		        ocultarFlowTooltip();
		        nodoSeleccionadoId = null;
	        try {
	          mostrarInfoNodo(null);
	        } catch (err) {
	          // noop
	        }
	        canvas
	          .querySelectorAll(".flow-node.is-selected")
	          .forEach(el => el.classList.remove("is-selected"));
	      }
		      cancelarConexionEnCurso();
		    });
		  }
		  window.addEventListener("resize", renderFlowConnections);
		  window.addEventListener("resize", programarActualizacionMinimapFlow);
      if (!flowTimelineSyncInit) {
        window.addEventListener("bitacora:nueva", () => {
          programarActualizacionFlowTimeline();
        });
        flowTimelineSyncInit = true;
      }
		  try {
		    mostrarInfoNodo(null);
		  } catch (err) {
		    // noop
		  }
		  programarActualizacionMinimapFlow();
		}

function generarIdNodo() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `nodo-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
}

function crearNodoManual(tipo) {
  try {
    console.log("Crear nodo manual", tipo, "flujoNodos len:", Array.isArray(flujoNodos) ? flujoNodos.length : flujoNodos);
    const config = FLOW_NODE_TYPES[tipo];
    if (!config) {
      console.error("Tipo de nodo desconocido", tipo);
      mostrarAviso("No se reconoce este tipo de nodo.", "error");
      return;
    }
    const nodo = {
      id: generarIdNodo(),
      tipo,
      titulo: config.label,
      x: 60 + flujoNodos.length * 40,
      y: 60 + flujoNodos.length * 20,
      datos: {},
      targets: [],
    };
    asegurarFechaCreacionNodo(nodo);
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    flujoNodos.push(nodo);
    registrarAccionNodoMapa("Nodo creado", nodo, { noteType: "accion" });
    ultimoNodoManual = nodo.id;
    guardarEstadoNodos();
    console.log("Nodo creado", nodo.id, "total nodos", flujoNodos.length);
    renderFlowNodes();
    abrirFlowModal(nodo.id);
  } catch (err) {
    console.error("Error creando nodo", err);
    const msg = err && err.message ? err.message : "Error desconocido";
    mostrarAviso(`No se pudo crear el nodo: ${msg}`, "error");
  }
}

function cerrarMenusNodo() {
  document.querySelectorAll(".flow-node-menu.visible").forEach(menu => {
    menu.classList.remove("visible");
    const host = menu.closest(".flow-node");
    if (host) host.classList.remove("menu-open");
  });
}

function obtenerResumenCompactoNodo(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  const tipo = nodo.tipo || "";
  const variedadRaw = obtenerVariedadVisibleNodo(nodo);
  const variedadLinea = variedadRaw ? variedadRaw.split(/\r?\n/)[0] : "";
  const variedad = limpiarTextoVariedad(variedadLinea) || variedadLinea;

  if (tipo === "entrada") {
    const variedadEntrada = variedad || datos.variedad || datos.variedadBase || "";
    return variedadEntrada || "Sin variedad";
  }
  if (tipo === "estilo") {
    return datos.metodo || datos.estilo || "Sin método";
  }
  if (tipo === "fermentacion") {
    return datos.estilo || datos.metodo || datos.fase || "Sin fase";
  }
  if (tipo === "deposito") {
    const estado = obtenerEstadoVisual(nodo);
    return estado?.label || (datos.fase ? String(datos.fase).toUpperCase() : "Sin estado");
  }
  if (tipo === "barrica") {
    const tipoContRaw = claveContenedor(datos.contenedor_tipo || datos.tipo || "");
    const tipoCont = tipoContRaw || "barrica";
    const id = datos.contenedor_id || datos.id_ref;
    const info = id ? obtenerInfoContenedor(tipoCont, id) : null;
    const labelCont = tipoCont === "barrica" ? "Barrica" : "Depósito";
    const nombre = (info?.codigo || datos.codigo || "").toString().trim();
    if (nombre) return `${nombre} · ${labelCont}`;
    if (id) return `${labelCont} ${id}`;
    return labelCont;
  }
  if (tipo === "coupage") {
    return datos.nombre_blend || datos.nombre_vino || "Blend";
  }
  if (tipo === "embotellado") {
    return obtenerTextoVolumenNodo(nodo) || "Embotellado";
  }
  if (tipo === "almacen") {
    return datos.nombre || datos.descripcion || "Almacén";
  }
  if (tipo === "salida") {
    return datos.motivo || datos.nota || "Salida";
  }
  return resumenNodo(nodo);
}

const COMPACT_MODO_KEYWORDS = [
  { re: /despalill/i, label: "Despalillado" },
  { re: /prens/i, label: "Prensado" },
  { re: /filtrad/i, label: "Filtrado" },
  { re: /uva\s*entera/i, label: "Uva entera" },
  { re: /encubad/i, label: "Encubado" },
  { re: /macer/i, label: "Maceración" },
  { re: /sangr/i, label: "Sangrado" },
  { re: /pisad/i, label: "Pisado" },
  { re: /mixt/i, label: "Mixto" },
  { re: /trasieg/i, label: "Trasiego" },
  { re: /trasvas/i, label: "Trasvase" },
  { re: /\bfml\b|malolac/i, label: "FML" },
  { re: /\bfa\b|alcoh/i, label: "FA" },
  { re: /crianza/i, label: "Crianza" },
];

function normalizarTextoCompacto(texto) {
  return (texto || "")
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();
}

function normalizarClaveVariedad(nombre) {
  return normalizarTextoCompacto(nombre).replace(/\s+/g, "-");
}

function obtenerKindDesdeTipo(tipo) {
  const tipoNorm = String(tipo || "").toLowerCase();
  if (tipoNorm === "entrada") return "entrada";
  if (tipoNorm === "estilo" || tipoNorm === "fermentacion" || tipoNorm === "coupage") return "proceso";
  if (tipoNorm === "deposito") return "deposito";
  if (tipoNorm === "barrica") return "barrica";
  if (tipoNorm === "embotellado") return "embotellado";
  if (tipoNorm === "almacen") return "almacen";
  if (tipoNorm === "salida") return "salida";
  return "";
}

function obtenerVariedadDominante(nodo) {
  const comp = calcularComposicionVariedades(nodo);
  let top = "";
  let max = 0;
  comp.mix.forEach((val, name) => {
    if (val > max) {
      max = val;
      top = name;
    }
  });
  return top ? normalizarClaveVariedad(top) : "";
}

function detectarModoProceso(texto) {
  const base = normalizarTextoCompacto(texto);
  if (!base) return "";
  for (const item of COMPACT_MODO_KEYWORDS) {
    if (item.re.test(base)) return item.label;
  }
  return "";
}

function extraerNumeroElaboracion(titulo) {
  const match = (titulo || "").toString().match(/\b(\d+)\b/);
  return match ? match[1] : "";
}

function obtenerNombreCortoContenedor(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  const tipoCont = claveContenedor(datos.contenedor_tipo || datos.tipo || "") || nodo.tipo || "";
  const id = datos.contenedor_id || datos.id_ref;
  const info = id ? obtenerInfoContenedor(tipoCont, id) : null;
  return (
    (info?.codigo ||
      datos.codigo ||
      datos.name ||
      datos.nombre ||
      datos.alias ||
      "")
  )
    .toString()
    .trim();
}

function normalizarEstadoOperativo(texto) {
  const base = normalizarTextoCompacto(texto);
  if (!base) return "";
  if (/\bfml\b/.test(base) || base.includes("malol")) return "FML";
  if (/\bfa\b/.test(base) || base.includes("fermentacion") || base.includes("alcohol")) return "FA";
  if (base.includes("crianza")) return "CRIANZA";
  return "";
}

function extraerEstadoOperativoDeTexto(texto) {
  const base = normalizarTextoCompacto(texto);
  if (!base) return "";
  const tieneFml = /\bfml\b/.test(base) || base.includes("malol");
  const tieneFa = /\bfa\b/.test(base) || base.includes("fermentacion") || base.includes("alcohol");
  const tieneCrianza = base.includes("crianza");
  const total = [tieneFml, tieneFa, tieneCrianza].filter(Boolean).length;
  if (total !== 1) return "";
  if (tieneFml) return "FML";
  if (tieneFa) return "FA";
  if (tieneCrianza) return "CRIANZA";
  return "";
}

function resolveOperationalState(nodo, ctx = {}) {
  const datos = nodo?.datos || {};
  const directo = normalizarEstadoOperativo(datos.estado_operativo);
  if (directo) {
    return {
      key: directo,
      months: directo === "CRIANZA" ? obtenerMesesCrianza(nodo, ctx) : null,
    };
  }
  const legacy = [
    datos.estadoProceso,
    datos.estado_proceso,
    datos.phase,
    datos.fase,
    datos.estado,
    datos.estado_vino,
  ];
  for (const valor of legacy) {
    const normalizado = normalizarEstadoOperativo(valor);
    if (normalizado) {
      return {
        key: normalizado,
        months: normalizado === "CRIANZA" ? obtenerMesesCrianza(nodo, ctx) : null,
      };
    }
  }
  const desdeTitulo = extraerEstadoOperativoDeTexto(nodo?.titulo || "");
  if (desdeTitulo) {
    return {
      key: desdeTitulo,
      months: desdeTitulo === "CRIANZA" ? obtenerMesesCrianza(nodo, ctx) : null,
    };
  }
  return { key: null };
}

function obtenerModoProcesoCompacto(nodo) {
  const datos = nodo?.datos || {};
  const candidatos = [
    datos.modo,
    datos.subtipo,
    datos.etapa,
    datos.metodo,
    datos.estilo,
    datos.fase,
  ];
  for (const valor of candidatos) {
    const modo = detectarModoProceso(valor);
    if (modo) return modo;
  }
  const desdeTitulo = detectarModoProceso(nodo?.titulo || "");
  return desdeTitulo || "Proceso";
}

function obtenerMesesCrianza(nodo, ctx) {
  const datos = nodo?.datos || {};
  const directo = Number.isFinite(Number(datos.crianza_meses))
    ? Number(datos.crianza_meses)
    : Number.isFinite(Number(datos.meses))
    ? Number(datos.meses)
    : null;
  if (directo != null) return Math.max(0, Math.round(directo));
  const fechaInicio =
    datos.fecha_inicio_crianza ||
    datos.inicio_crianza ||
    datos.fecha_crianza ||
    "";
  if (!fechaInicio) return null;
  const inicio = new Date(fechaInicio);
  if (Number.isNaN(inicio.getTime())) return null;
  const ahora = ctx?.now instanceof Date ? ctx.now : new Date();
  let meses =
    (ahora.getFullYear() - inicio.getFullYear()) * 12 +
    (ahora.getMonth() - inicio.getMonth());
  if (ahora.getDate() < inicio.getDate()) meses -= 1;
  return Math.max(0, meses);
}

function buildCompactTitleParts(nodo, ctx = {}) {
  if (!nodo) return { title: "" };
  const tipo = nodo.tipo || "";
  const role = obtenerRolNodo(nodo);
  const config = FLOW_NODE_TYPES[tipo] || {};

  if (role === "SOURCE" || tipo === "entrada") {
    const idNorm = normalizarIdNodo(nodo);
    const idx =
      ctx?.sourceIndexMap instanceof Map ? Number(ctx.sourceIndexMap.get(idNorm) || 0) : 0;
    return { title: idx > 0 ? `Entrada de uva ${idx}` : "Entrada de uva" };
  }

  if (tipo === "embotellado" || tipo === "almacen" || tipo === "salida" || tipo === "coupage") {
    return { title: (config.label || nodo.titulo || "Nodo").toString().trim() };
  }

  if (tipo === "estilo" || tipo === "fermentacion" || role === "PROCESS") {
    const numero = extraerNumeroElaboracion(nodo?.titulo || config.label || "");
    const base = numero ? `Elaboración ${numero}` : "Elaboración";
    const modo = obtenerModoProcesoCompacto(nodo);
    return { title: `${base} · ${modo}` };
  }

  if (role === "CONTAINER") {
    const nombre = obtenerNombreCortoContenedor(nodo) || config.label || "Contenedor";
    const op = resolveOperationalState(nodo, ctx);
    if (op.key) {
      if (op.key === "CRIANZA") {
        const meses = op.months != null ? op.months : null;
        const estadoTxt =
          meses != null && meses > 0 ? `CRIANZA + ${meses} meses` : "CRIANZA";
        return { title: nombre, stateText: estadoTxt, stateKey: "CRIANZA" };
      }
      return { title: nombre, stateText: op.key, stateKey: op.key };
    }
    const balance =
      (ctx?.balances instanceof Map && ctx.balances.get(String(nodo?.id)) != null
        ? ctx.balances.get(String(nodo?.id))
        : obtenerBalanceNodo(nodo?.id));
    const enUso = Number.isFinite(balance) && balance > 0;
    const estadoTxt = enUso ? "EN USO" : "VACÍO";
    return { title: nombre, stateText: estadoTxt, stateKey: enUso ? "USO" : "VACIO" };
  }

  return { title: (nodo.titulo || config.label || "Nodo").toString().trim() };
}

function buildCompactTitle(nodo, ctx = {}) {
  const parts = buildCompactTitleParts(nodo, ctx);
  if (!parts || !parts.title) return "";
  if (parts.stateText) return `${parts.title} — ${parts.stateText}`;
  return parts.title;
}

let hoverNodeId = null;
let hoverRelatedNodes = new Set();
let hoverRelatedEdges = new Set();

function construirIndicesEntradaFlow(nodos = []) {
  const map = new Map();
  let n = 0;
  (Array.isArray(nodos) ? nodos : []).forEach(nodo => {
    if (!nodo || String(nodo.tipo || "").toLowerCase() !== "entrada") return;
    n += 1;
    map.set(normalizarIdNodo(nodo), n);
  });
  return map;
}

function construirMapaPredecesoresFlow(edges = []) {
  const mapa = new Map();
  edges.forEach(e => {
    const from = normalizarIdNodo(e.from);
    const to = normalizarIdNodo(e.to);
    if (!from || !to) return;
    if (!mapa.has(to)) mapa.set(to, new Set());
    mapa.get(to).add(from);
  });
  return mapa;
}

function construirMapaSucesoresFlow(edges = []) {
  const mapa = new Map();
  edges.forEach(e => {
    const from = normalizarIdNodo(e.from);
    const to = normalizarIdNodo(e.to);
    if (!from || !to) return;
    if (!mapa.has(from)) mapa.set(from, new Set());
    mapa.get(from).add(to);
  });
  return mapa;
}

function edgeIdFromTo(fromId, toId) {
  return `${fromId}=>${toId}`;
}

function calcularRelacionadosHover(hoverId, edges = []) {
  const relatedNodes = new Set();
  const relatedEdges = new Set();
  if (!hoverId) return { relatedNodes, relatedEdges };
  const hoverNorm = normalizarIdNodo(hoverId);
  if (!hoverNorm) return { relatedNodes, relatedEdges };
  const nodoHover = buscarNodoPorId(hoverNorm);
  const esEntrada = (nodoHover?.tipo || "") === "entrada";
  const mapa = esEntrada
    ? construirMapaSucesoresFlow(edges)
    : construirMapaPredecesoresFlow(edges);
  const cola = [hoverNorm];
  relatedNodes.add(hoverNorm);

  while (cola.length) {
    const actual = cola.shift();
    const vecinos = mapa.get(actual);
    if (!vecinos) continue;
    vecinos.forEach(vecino => {
      const vecinoNorm = normalizarIdNodo(vecino);
      if (!vecinoNorm || relatedNodes.has(vecinoNorm)) return;
      relatedNodes.add(vecinoNorm);
      cola.push(vecinoNorm);
      relatedEdges.add(
        esEntrada ? edgeIdFromTo(actual, vecinoNorm) : edgeIdFromTo(vecinoNorm, actual)
      );
    });
  }
  return { relatedNodes, relatedEdges };
}

function aplicarHoverCadenaDOM() {
  const canvas = document.getElementById("flowCanvas");
  if (!canvas) return;
  const hayHover = !!hoverNodeId;
  canvas.querySelectorAll(".flow-node").forEach(el => {
    const id = normalizarIdNodo(el.dataset.id);
    if (!hayHover) {
      el.classList.remove("is-related", "is-dim");
      return;
    }
    if (hoverRelatedNodes.has(id)) {
      el.classList.add("is-related");
      el.classList.remove("is-dim");
    } else {
      el.classList.remove("is-related");
      el.classList.add("is-dim");
    }
    if (el.classList.contains("is-selected") || el.classList.contains("is-connect-source")) {
      el.classList.remove("is-dim");
    }
  });

  document.querySelectorAll(".flow-edge").forEach(edge => {
    if (!hayHover) {
      edge.classList.remove("is-related", "is-dim");
      return;
    }
    const edgeId = edge.dataset.edgeId || "";
    if (edgeId && hoverRelatedEdges.has(edgeId)) {
      edge.classList.add("is-related");
      edge.classList.remove("is-dim");
    } else {
      edge.classList.remove("is-related");
      edge.classList.add("is-dim");
    }
    if (edge.classList.contains("is-highlight")) {
      edge.classList.remove("is-dim");
    }
  });
}

function actualizarHoverCadena(nodoId = null) {
  hoverNodeId = nodoId ? normalizarIdNodo(nodoId) : null;
  if (!hoverNodeId) {
    hoverRelatedNodes = new Set();
    hoverRelatedEdges = new Set();
    aplicarHoverCadenaDOM();
    return;
  }
  const calc = calcularRelacionadosHover(hoverNodeId, flowEdges || []);
  hoverRelatedNodes = calc.relatedNodes;
  hoverRelatedEdges = calc.relatedEdges;
  aplicarHoverCadenaDOM();
}

function actualizarBotonExpandirTodosFlow() {
  const boton = document.getElementById("flowToggleExpandBtn");
  if (!boton) return;
  const total = Array.isArray(flujoNodos) ? flujoNodos.length : 0;
  if (!total) {
    boton.textContent = "Expandir todo";
    boton.disabled = true;
    return;
  }
  boton.disabled = false;
  const todosExpandido = flujoNodos.every(n => flowExpandedIds.has(normalizarIdNodo(n)));
  boton.textContent = todosExpandido ? "Compactar todo" : "Expandir todo";
}

function toggleExpandirTodosFlow() {
  if (!Array.isArray(flujoNodos) || !flujoNodos.length) {
    actualizarBotonExpandirTodosFlow();
    return;
  }
  const todosExpandido = flujoNodos.every(n => flowExpandedIds.has(normalizarIdNodo(n)));
  if (todosExpandido) {
    flowExpandedIds = new Set();
  } else {
    flowExpandedIds = new Set(flujoNodos.map(n => normalizarIdNodo(n)).filter(Boolean));
  }
  renderFlowNodes();
}

// Override renderFlowNodes with a clean version (prev block had duplicated closures)

		function renderFlowNodes() {
		  const canvas = document.getElementById("flowCanvas");
		  if (!canvas) return;
		  normalizarFlujoNodos();
      const DRAG_THRESHOLD = 5;
      flowEdges = construirEdgesDesdeTargets(flujoNodos);
      flujoNodos.forEach(asignarRolNodo);
      flowBalancesDirty = true;
      recalcularBalancesFlow();
		  aplicarLayoutFlow();
		  canvas.innerHTML = "";
		  canvas.dataset.mode = nodoConectandoOrigen ? "connecting" : "default";
      const compactCtx = {
        now: new Date(),
        balances: flowBalances,
        sourceIndexMap: construirIndicesEntradaFlow(flujoNodos),
      };
		  if (flowDebugActivo()) {
		    console.debug("[flow][render]", { nodos: flujoNodos.length });
		  }
	
	  flujoNodos.forEach(nodo => {
	    try {
	      if (nodo.tipo === "entrada") {
	        rellenarDatosEntradaDesdeCache(nodo);
      } else if (nodo.tipo === "deposito") {
        rellenarDatosDepositoDesdeCache(nodo);
        actualizarTituloNodo(nodo);
      } else if (nodo.tipo === "barrica") {
        rellenarDatosCrianzaDesdeCache(nodo);
        actualizarTituloNodo(nodo);
      }
		      const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo" };
		      const div = document.createElement("div");
		      div.className = "flow-node";
		      div.dataset.tipo = nodo.tipo;
          div.dataset.role = obtenerRolNodo(nodo);
          const kind = obtenerKindDesdeTipo(nodo.tipo);
          if (kind) div.dataset.kind = kind;
        const nodoIdNorm = normalizarIdNodo(nodo);
        const estaExpandido = flowExpandedIds.has(nodoIdNorm);
        div.dataset.state = estaExpandido ? "open" : "compact";
	      const tooltipFlow =
	        nodo.tipo === "barrica"
	          ? obtenerTooltipCrianza(nodo)
	          : nodo.tipo === "embotellado"
	          ? obtenerTooltipEmbotellado(nodo)
	          : "";
	      if (tooltipFlow) {
	        div.title = tooltipFlow;
	        div.addEventListener("pointerenter", e => {
	          if (e.pointerType !== "mouse") return;
	          ocultarFlowTooltip();
	          mostrarFlowTooltip(tooltipFlow, e.clientX, e.clientY);
	        });
	        div.addEventListener("pointermove", e => {
	          if (e.pointerType !== "mouse") return;
	          posicionarFlowTooltip(e.clientX, e.clientY);
	        });
	        div.addEventListener("pointerleave", () => ocultarFlowTooltip());
	        div.addEventListener("pointerdown", () => ocultarFlowTooltip());
	      }
	      div.addEventListener("pointerenter", e => {
	        if (e.pointerType && e.pointerType !== "mouse") return;
	        actualizarHoverCadena(nodoIdNorm);
	      });
	      div.addEventListener("pointerleave", e => {
	        if (e.pointerType && e.pointerType !== "mouse") return;
	        if (hoverNodeId === nodoIdNorm) {
	          actualizarHoverCadena(null);
	        }
	      });
	      const conectandoNorm = nodoConectandoOrigen ? normalizarIdNodo(nodoConectandoOrigen) : "";
	      const seleccionadoNorm = nodoSeleccionadoId ? normalizarIdNodo(nodoSeleccionadoId) : "";
	      if (conectandoNorm && conectandoNorm === nodoIdNorm) {
	        div.classList.add("is-connect-source");
	      }
	      if (seleccionadoNorm && seleccionadoNorm === nodoIdNorm) {
	        div.classList.add("is-selected");
	      }
        if (flowWarningNodes && flowWarningNodes.has(nodoIdNorm)) {
          div.classList.add("node--warn");
        }
	
	      const fill = document.createElement("div");
	      fill.className = "fill-level";
	      const volumenVisual = obtenerVolumenVisualNodo(nodo);
	      const barricaVacia =
	        nodo.tipo === "barrica" && volumenVisual != null && volumenVisual <= 0;
	      const colorVino = barricaVacia ? "" : obtenerColorVino(nodo);
	      if (colorVino) {
	        div.dataset.vino = colorVino;
	        fill.classList.add(
	          colorVino === "white" ? "white" : colorVino === "rosado" ? "rosado" : "red"
	        );
	      } else {
	        div.dataset.vino = "";
	      }
      const ocupacion = calcularOcupacionNodo(nodo, volumenVisual);
      if (ocupacion != null) {
        fill.style.height = `${(ocupacion * 100).toFixed(1)}%`;
      } else if (barricaVacia) {
        fill.style.height = "0%";
      }
      div.appendChild(fill);

	      const progresoBarrica = calcularProgresoBarrica(nodo);
	      if (progresoBarrica != null) {
	        const ring = document.createElement("div");
	        const pct = Math.max(0, Math.min(1, progresoBarrica));
	        const ang = pct * 360;
	        ring.className = "flow-progress-ring";
	        ring.style.background = `conic-gradient(from -90deg, var(--flow-accent, rgba(255,255,255,0.75)) 0deg ${ang}deg, rgba(255,255,255,0.08) ${ang}deg 360deg)`;
	        div.appendChild(ring);
	      }

	      div.style.left = `${nodo.x}px`;
	      div.style.top = `${nodo.y}px`;
	      div.dataset.id = nodoIdNorm;
	
	      const headerWrap = document.createElement("div");
	      headerWrap.className = "flow-node-header";
	      const icon = document.createElement("span");
	      icon.className = "flow-node-icon";
	      if (config.icono && config.icono.trim().startsWith("<")) {
	      icon.innerHTML = config.icono;
    } else {
      let iconChar = config.icono || "●";
      if (config.icono === "🍇") iconChar = "🍇";
      icon.textContent = iconChar;
    }
    headerWrap.appendChild(icon);
    if (config.icono === "🍇") {
      const badge = document.createElement("span");
      const tono = colorVino === "white" ? "white" : "red";
      badge.className = `grape-badge ${tono}`;
      badge.title = tono === "white" ? "Uva blanca" : "Uva tinta";
      headerWrap.appendChild(badge);
    }
    const header = document.createElement("h4");
    const estadoInline = obtenerEstadoVisual(nodo);
    const tituloAbierto =
      nodo.tipo === "entrada"
        ? buildCompactTitleParts(nodo, compactCtx)?.title || nodo.titulo || config.label
        : nodo.titulo || config.label;
    header.textContent = tituloAbierto;
    if (estadoInline) {
      const estadoSpan = document.createElement("span");
      estadoSpan.className = "flow-state-inline";
      const separador = header.textContent ? " - " : "";
      estadoSpan.textContent = `${separador}${estadoInline.label}`;
      if (estadoInline.color) {
        estadoSpan.style.color = estadoInline.color;
      }
      header.appendChild(estadoSpan);
    }
    headerWrap.appendChild(header);

    const compactLine = document.createElement("div");
    compactLine.className = "flow-node__titleCompact flow-node-compact";
    const compactParts = buildCompactTitleParts(nodo, compactCtx) || { title: "—" };
    const compactTitle = compactParts.title || "—";
    compactLine.textContent = "";
    compactLine.appendChild(document.createTextNode(compactTitle));
    if (compactParts.stateText) {
      const sep = document.createElement("span");
      sep.className = "flow-node__sep";
      sep.textContent = "—";
      compactLine.appendChild(sep);
      const stateSpan = document.createElement("span");
      stateSpan.className = "flow-node__state";
      if (compactParts.stateKey) {
        stateSpan.dataset.state = compactParts.stateKey;
      }
      stateSpan.textContent = compactParts.stateText;
      compactLine.appendChild(stateSpan);
    }
    const compactFull = buildCompactTitle(nodo, compactCtx) || compactTitle;
    compactLine.title = compactFull;
    if (compactParts.stateKey === "VACIO") {
      div.dataset.empty = "true";
    } else {
      delete div.dataset.empty;
    }
    div.appendChild(compactLine);

    const extra = document.createElement("div");
    extra.className = "flow-node__extra";
    extra.appendChild(headerWrap);

    const body = document.createElement("div");
    body.className = "flow-node-body";
    const densidadNodo = nodo.tipo === "entrada" ? obtenerDensidadEntradaDesdeNodo(nodo) : null;
    const temperaturaNodo = nodo.tipo === "entrada" ? obtenerTemperaturaEntradaDesdeNodo(nodo) : null;
    const phNodo = nodo.tipo === "entrada" ? obtenerPhEntradaDesdeNodo(nodo) : null;
    const acidezNodo = nodo.tipo === "entrada" ? obtenerAcidezTotalEntradaDesdeNodo(nodo) : null;
    const variedadVisible = obtenerVariedadVisibleNodo(nodo);
    const nombreVinoVisible = obtenerNombreVinoVisibleNodo(nodo);

    if (nodo.tipo === "entrada") {
      if (variedadVisible) {
        const subtitleVar = document.createElement("div");
        subtitleVar.className = "flow-node-subtitle flow-subtitle-variedad flow-entry-variedad";
        subtitleVar.textContent = variedadVisible;
        subtitleVar.title = variedadVisible;
        body.appendChild(subtitleVar);
      }
      {
        const metrics = document.createElement("div");
        metrics.className = "flow-node-metrics flow-entry-metrics";
        if (densidadNodo != null) {
          const chip = document.createElement("span");
          chip.className = "flow-chip";
          chip.textContent = `${formatearDensidad(densidadNodo)} dens`;
          metrics.appendChild(chip);
        }
        if (temperaturaNodo != null) {
          const chip = document.createElement("span");
          chip.className = "flow-chip";
          chip.textContent = `${temperaturaNodo.toFixed(1)}°C`;
          metrics.appendChild(chip);
        }
        body.appendChild(metrics);

        if (phNodo != null || acidezNodo != null) {
          const linea = document.createElement("div");
          linea.className = "flow-node-subtitle flow-entry-analitica";
          const phTxt = phNodo != null
            ? Number(phNodo).toFixed(1).replace(".", ",")
            : "—";
          const acidezTxt = acidezNodo != null
            ? Number(acidezNodo).toFixed(2)
            : "—";
          linea.textContent = `${phTxt} pH Acidez ${acidezTxt} g/L`;
          body.appendChild(linea);
        }
      }
    } else if (variedadVisible) {
      const subtitleVar = document.createElement("div");
      subtitleVar.className = "flow-node-subtitle flow-subtitle-variedad";
      subtitleVar.textContent = variedadVisible;
      subtitleVar.title = variedadVisible;
      body.appendChild(subtitleVar);
    }

    if (
      (nodo.tipo === "embotellado" || nodo.tipo === "almacen" || nodo.tipo === "salida") &&
      nombreVinoVisible
    ) {
      const vinoEl = document.createElement("div");
      vinoEl.className = "flow-node-subtitle flow-entry-variedad";
      vinoEl.textContent = nombreVinoVisible;
      vinoEl.title = nombreVinoVisible;
      body.appendChild(vinoEl);
    }

    if (nodo.tipo === "salida") {
      const salidaInfo = obtenerResumenSalidaNodo(nodo);
      const cajasEl = document.createElement("div");
      cajasEl.className = "flow-node-subtitle";
      if (salidaInfo.cajas > 0) {
        cajasEl.textContent =
          `Cajas: ${salidaInfo.cajas.toLocaleString("es-ES")} · ${salidaInfo.tipoCaja}` +
          ` (${salidaInfo.totalBotellas.toLocaleString("es-ES")} botellas)`;
      } else {
        cajasEl.textContent = "Cajas: —";
      }
      body.appendChild(cajasEl);
    }

    const textoVolumen = obtenerTextoVolumenNodo(nodo);
    if (textoVolumen) {
      const volEl = document.createElement("div");
      volEl.className = `flow-node-subtitle${nodo.tipo === "entrada" ? " flow-entry-kilos" : ""}`;
      volEl.textContent = textoVolumen;
      body.appendChild(volEl);
      if (nodo.tipo === "entrada") {
        const fechaEntrada = obtenerFechaEntradaDesdeNodo(nodo);
        if (fechaEntrada) {
          const fechaEl = document.createElement("div");
          fechaEl.className = "flow-node-subtitle flow-entry-fecha";
          fechaEl.textContent = fechaEntrada;
          body.appendChild(fechaEl);
        }
      }
      if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
        const historico = obtenerHistoricoNodo(nodo);
        const histEl = document.createElement("div");
        histEl.className = "flow-node-subtitle";
        const histTxt =
          historico != null ? `${Number(historico.toFixed(0))} L` : "—";
        histEl.textContent = `Histórico ${histTxt}`;
        body.appendChild(histEl);
      }
    } else {
      const unidadBadge = document.createElement("div");
      unidadBadge.className = "flow-unit";
      unidadBadge.textContent = obtenerUnidadVisual(nodo);
      body.appendChild(unidadBadge);
    }
    if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
      const diagVol = obtenerDiagnosticoVolumenContenedor(nodo);
      if (diagVol) {
        const fuenteEl = document.createElement("div");
        fuenteEl.className = "flow-node-subtitle flow-source-badge";
        fuenteEl.textContent = `Fuente ${diagVol.fuente}`;
        body.appendChild(fuenteEl);
        if (diagVol.discrepancia) {
          const diffEl = document.createElement("div");
          diffEl.className = "flow-node-subtitle flow-discrepancia";
          const mapaTxt =
            diagVol.volumenMapa != null ? `${Number(diagVol.volumenMapa.toFixed(0))}L` : "—";
          const fichaTxt =
            diagVol.volumenFicha != null ? `${Number(diagVol.volumenFicha.toFixed(0))}L` : "—";
          diffEl.textContent = `Mapa ${mapaTxt} · Ficha ${fichaTxt}`;
          body.appendChild(diffEl);
        }
      }
      const retenidoCap = obtenerVolumenRetenidoDestinoPorCapacidad(nodo);
      if (retenidoCap > 0.01) {
        const retEl = document.createElement("div");
        retEl.className = "flow-node-subtitle flow-capacidad-alerta";
        retEl.textContent = `Retenido por capacidad ${formatearVolumenPlano(retenidoCap)}`;
        body.appendChild(retEl);
      }
    }
    extra.appendChild(body);

    if (nodo.tipo === "estilo" && nodo.datos?.metodo) {
      const metodoSubtitle = document.createElement("div");
      metodoSubtitle.className = "flow-node-subtitle flow-node-metodo";
      metodoSubtitle.textContent = nodo.datos.metodo;
      extra.appendChild(metodoSubtitle);
    }

    const controls = document.createElement("div");
    controls.className = "flow-node-controls";
    const btnConectar = document.createElement("button");
    btnConectar.className = `green ${conectandoNorm === nodoIdNorm ? "conectando" : ""}`;
    btnConectar.title = "Conectar";
    if (conectandoNorm === nodoIdNorm) btnConectar.classList.add("conectando");
    btnConectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnConectar.addEventListener("click", e => {
      e.stopPropagation();
      prepararConexion(nodo.id);
    });
    const btnDesconectar = document.createElement("button");
    btnDesconectar.className = "red";
    btnDesconectar.title = "Desconectar";
    btnDesconectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnDesconectar.addEventListener("click", e => {
      e.stopPropagation();
      if (!nodo._clickDesconectar) {
        desconectarNodo(nodo.id);
        nodo._clickDesconectar = Date.now();
        mostrarAviso("Pulsa de nuevo rápidamente para eliminar el nodo.", "info");
        setTimeout(() => {
          if (nodo._clickDesconectar && Date.now() - nodo._clickDesconectar > 800) delete nodo._clickDesconectar;
        }, 900);
      } else if (Date.now() - nodo._clickDesconectar < 800) {
        delete nodo._clickDesconectar;
        eliminarNodoPorId(nodo.id);
      } else {
        nodo._clickDesconectar = Date.now();
      }
    });
    controls.appendChild(btnConectar);
    controls.appendChild(btnDesconectar);

    let menu = null;
    extra.appendChild(controls);

    const tempNodo = obtenerTemperaturaNodo(nodo);
    const estado = (nodo.datos?.estado || "").toLowerCase();
    const enFermentacion = estado.includes("ferment");
    if (enFermentacion && tempNodo != null && tempNodo >= 28) {
      div.classList.add("temp-alert");
    }

    div.appendChild(extra);

	    div.addEventListener("pointerdown", e => iniciarArrastreNodo(e, nodo.id));
      let suppressClickUntil = 0;
      let pointerDragTrack = null;
      const onPointerMoveGuard = ev => {
        if (!pointerDragTrack || ev.pointerId !== pointerDragTrack.pointerId) return;
        const dx = ev.clientX - pointerDragTrack.startX;
        const dy = ev.clientY - pointerDragTrack.startY;
        if (!pointerDragTrack.moved && Math.hypot(dx, dy) >= DRAG_THRESHOLD) {
          pointerDragTrack.moved = true;
        }
      };
      const onPointerUpGuard = ev => {
        if (!pointerDragTrack || ev.pointerId !== pointerDragTrack.pointerId) return;
        if (pointerDragTrack.moved) {
          suppressClickUntil = performance.now() + 200;
        }
        div.removeEventListener("pointermove", onPointerMoveGuard);
        div.removeEventListener("pointerup", onPointerUpGuard);
        div.removeEventListener("pointercancel", onPointerUpGuard);
        pointerDragTrack = null;
      };
	    div.addEventListener("pointerdown", e => {
	      pointerDragTrack = {
	        startX: e.clientX,
	        startY: e.clientY,
	        pointerId: e.pointerId,
	        moved: false,
	      };
	      div.addEventListener("pointermove", onPointerMoveGuard);
	      div.addEventListener("pointerup", onPointerUpGuard);
	      div.addEventListener("pointercancel", onPointerUpGuard);
	    });
	    div.addEventListener("click", () => {
	      if (suppressClickUntil && performance.now() < suppressClickUntil) return;
	      if (dragEstado && dragEstado.activo) return;
	      if (conectandoNorm && conectandoNorm !== nodoIdNorm) {
	        conectarNodos(conectandoNorm, nodoIdNorm);
	        nodoConectandoOrigen = null;
	        renderFlowNodes();
	        return;
	      }
	      // Solo selecciona el nodo; expandir/compactar queda reservado al botón global.
	      nodoSeleccionadoId = nodoIdNorm;
	      const canvasEl = document.getElementById("flowCanvas");
	      if (canvasEl) {
	        canvasEl
	          .querySelectorAll(".flow-node.is-selected")
	          .forEach(el => el.classList.remove("is-selected"));
	        div.classList.add("is-selected");
	      }
	      mostrarInfoNodo(nodoIdNorm);
	    });
    div.addEventListener("dblclick", e => {
      e.stopPropagation();
      if (suppressClickUntil && performance.now() < suppressClickUntil) {
        e.preventDefault();
        return;
      }
      if (menu) {
        const abierto = menu.classList.contains("visible");
        cerrarMenusNodo();
        if (!abierto) {
          menu.classList.add("visible");
          div.classList.add("menu-open");
        }
        return;
      }
      abrirFlowModal(nodo.id);
    });

    canvas.appendChild(div);
    } catch (err) {
      console.warn("Error renderizando nodo del flujo:", nodo?.id || nodo, err);
    }
  });

  renderFlowConnections();
  programarActualizacionMinimapFlow();
  aplicarHoverCadenaDOM();
  actualizarBotonExpandirTodosFlow();
}

function resumenNodo(nodo) {
  const datos = nodo.datos || {};
  if (datos.resumen) return datos.resumen;
  const keys = Object.keys(datos).filter(k => datos[k]);
  if (!keys.length) return "Doble clic para detallar";
  return keys
    .slice(0, 2)
    .map(k => `${k}: ${datos[k]}`)
    .join(" · ");
}

	function renderFlowConnections() {
	  const svg = document.getElementById("flowConnections");
	  const canvas = document.getElementById("flowCanvas");
	  const layer = document.getElementById("flowConnectionsLayer");
	  if (!svg || !canvas) return;
	  normalizarFlujoNodos();
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  const targetLayer = layer || svg;
  if (layer) {
    layer.innerHTML = "";
  } else {
    svg.innerHTML = "";
  }
  const nodosDom = new Map();
  canvas.querySelectorAll(".flow-node").forEach(nodeEl => {
    nodosDom.set(nodeEl.dataset.id, nodeEl);
  });

	  flujoNodos.forEach(nodo => {
	    try {
	      const origenId = normalizarIdNodo(nodo);
	      const origenEl = nodosDom.get(origenId);
	      if (!origenEl) return;
      const x1 = nodo.x + origenEl.offsetWidth / 2;
      const y1 = nodo.y + origenEl.offsetHeight / 2;
      (nodo.targets || []).forEach(targetId => {
        const destinoId = normalizarIdNodo(targetId);
        const destinoEl = nodosDom.get(destinoId);
        if (!destinoEl) return;
        const destinoNodo = buscarNodoPorId(destinoId);
        if (!destinoNodo) return;
	        const x2 = destinoNodo.x + destinoEl.offsetWidth / 2;
	        const y2 = destinoNodo.y + destinoEl.offsetHeight / 2;
	        const ns = "http://www.w3.org/2000/svg";
	        const edgeGroup = document.createElementNS(ns, "g");
	        edgeGroup.classList.add("flow-edge");
	        const delta = Math.max(Math.abs(x2 - x1) / 2, 60);
	        const d = `M${x1} ${y1} C ${x1 + delta} ${y1}, ${x2 - delta} ${y2}, ${x2} ${y2}`;
	        const tipoLinea = String(nodo.tipo || "").toLowerCase();
	        const seleccionadoNorm = nodoSeleccionadoId ? normalizarIdNodo(nodoSeleccionadoId) : "";
	        const seleccion =
	          seleccionadoNorm &&
	          (seleccionadoNorm === origenId || seleccionadoNorm === destinoId);
	        const edgeId = edgeIdFromTo(origenId, destinoId);
	        if (seleccion) {
	          edgeGroup.classList.add("is-highlight");
	        }
	        edgeGroup.dataset.edgeId = edgeId;
	        edgeGroup.dataset.source = origenId;
	        edgeGroup.dataset.target = destinoId;
	        if (hoverNodeId) {
	          if (hoverRelatedEdges.has(edgeId)) {
	            edgeGroup.classList.add("is-related");
	          } else {
	            edgeGroup.classList.add("is-dim");
	          }
	        }
	        const colorVariedad = obtenerColorVino(nodo) || obtenerColorVino(destinoNodo);
	        if (colorVariedad) {
	          edgeGroup.dataset.vino = colorVariedad;
	        }
	        const variedadDominante = obtenerVariedadDominante(nodo);
	        if (variedadDominante) {
	          edgeGroup.dataset.variety = variedadDominante;
	        } else {
	          const kind = obtenerKindDesdeTipo(nodo.tipo);
	          if (kind) edgeGroup.dataset.kind = kind;
	        }
	        const resumenCapacidad = calcularResumenTransferenciaCapacidad(
	          nodo,
	          destinoNodo,
	          new Map(),
	          new Set()
	        );
	        if (resumenCapacidad.clipped) {
	          edgeGroup.classList.add("is-cap-clipped");
	          edgeGroup.dataset.capRequested = String(resumenCapacidad.solicitado);
	          edgeGroup.dataset.capAccepted = String(resumenCapacidad.aceptado);
	          edgeGroup.dataset.capRetained = String(resumenCapacidad.retenido);
	        }

	        const hit = document.createElementNS(ns, "path");
	        hit.setAttribute("d", d);
	        hit.setAttribute("class", "flow-connector-hit");
	        edgeGroup.appendChild(hit);

	        const outline = document.createElementNS(ns, "path");
	        outline.setAttribute("d", d);
	        outline.setAttribute("class", "flow-connector-outline");
	        edgeGroup.appendChild(outline);

	        const curva = document.createElementNS(ns, "path");
	        curva.setAttribute("d", d);
	        curva.setAttribute(
	          "class",
	          `flow-connector-line${tipoLinea ? " type-" + tipoLinea : ""}`
	        );
	        edgeGroup.appendChild(curva);

	        let labelGroup = null;
	        let labelText = null;
	        let labelBg = null;
	        try {
	          const comp = calcularComposicionVariedades(nodo);
	          const textoComp = formatearComposicionVariedades(comp.mix, comp.total);
            const textoCapacidad = resumenCapacidad.clipped
              ? `Entran ${formatearVolumenPlano(resumenCapacidad.aceptado)} de ${formatearVolumenPlano(
                  resumenCapacidad.solicitado
                )} · Retenidos ${formatearVolumenPlano(resumenCapacidad.retenido)}`
              : "";
            const textoEtiqueta = textoComp && textoCapacidad
              ? `${textoComp} · ${textoCapacidad}`
              : textoCapacidad || textoComp;
	          if (textoEtiqueta) {
	            const midX = (x1 + x2) / 2;
	            const midY = (y1 + y2) / 2 - 6;
	            labelGroup = document.createElementNS(ns, "g");
	            labelGroup.setAttribute("class", "flow-connector-label");
	            labelBg = document.createElementNS(ns, "rect");
	            labelBg.setAttribute("rx", "999");
	            labelBg.setAttribute("ry", "999");
	            labelText = document.createElementNS(ns, "text");
	            labelText.setAttribute("x", midX);
	            labelText.setAttribute("y", midY);
	            labelText.setAttribute("text-anchor", "middle");
	            labelText.textContent = textoEtiqueta;
	            labelGroup.appendChild(labelBg);
	            labelGroup.appendChild(labelText);
	            edgeGroup.appendChild(labelGroup);
	          }
	        } catch (err) {
	          console.warn("No se pudo calcular la composición del conector:", err);
	        }

	        (layer || svg).appendChild(edgeGroup);

	        if (labelGroup && labelText && labelBg) {
	          try {
	            const bbox = labelText.getBBox();
	            const padX = 6;
	            const padY = 3;
	            labelBg.setAttribute("x", bbox.x - padX);
	            labelBg.setAttribute("y", bbox.y - padY);
	            labelBg.setAttribute("width", bbox.width + padX * 2);
	            labelBg.setAttribute("height", bbox.height + padY * 2);
	          } catch (e) {
	            // noop
	          }
	        }
      });
    } catch (err) {
      console.error("Error renderizando conexiones", err);
    }
  });
}

function iniciarArrastreNodo(ev, nodoId) {
  const nodo = flujoNodos.find(n => n.id === nodoId);
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  const editorRect = editor.getBoundingClientRect();
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  dragEstado = {
    id: nodoId,
    offsetX: posX - nodo.x,
    offsetY: posY - nodo.y,
    startX: ev.clientX,
    startY: ev.clientY,
    activo: false,
    elemento: ev.currentTarget,
    editor,
    pointerId: ev.pointerId,
  };
  ev.currentTarget.classList.add("dragging");
  try {
    ev.currentTarget.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  ev.currentTarget.addEventListener("pointermove", moverNodoArrastre);
  ev.currentTarget.addEventListener("pointerup", finalizarArrastreNodo);
  ev.currentTarget.addEventListener("pointercancel", finalizarArrastreNodo);
}

function moverNodoArrastre(ev) {
  if (!dragEstado) return;
  const nodo = flujoNodos.find(n => n.id === dragEstado.id);
  if (!nodo) return;
  const canvas = document.getElementById("flowCanvas");
  const editor = dragEstado.editor || document.getElementById("flowEditor");
  const editorRect = editor.getBoundingClientRect();
  const dx = ev.clientX - dragEstado.startX;
  const dy = ev.clientY - dragEstado.startY;
  if (!dragEstado.activo) {
    if (Math.abs(dx) + Math.abs(dy) < 4) {
      return;
    }
    dragEstado.activo = true;
  }
  const nodoWidth = dragEstado.elemento ? dragEstado.elemento.offsetWidth : 120;
  const nodoHeight = dragEstado.elemento ? dragEstado.elemento.offsetHeight : 70;
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  const maxX = Math.max(0, canvas.offsetWidth - nodoWidth - 10);
  const maxY = Math.max(0, canvas.offsetHeight - nodoHeight - 10);
  nodo.x = Math.min(Math.max(posX - dragEstado.offsetX, 10), maxX);
  nodo.y = Math.min(Math.max(posY - dragEstado.offsetY, 10), maxY);
  if (dragEstado.elemento) {
    dragEstado.elemento.style.left = `${nodo.x}px`;
    dragEstado.elemento.style.top = `${nodo.y}px`;
  }
  renderFlowConnections();
  programarActualizacionMinimapFlow();
}

function finalizarArrastreNodo(ev) {
  if (ev.currentTarget) {
    try {
      if (dragEstado && dragEstado.pointerId != null) {
        ev.currentTarget.releasePointerCapture(dragEstado.pointerId);
      }
    } catch (e) {
      // noop
    }
    ev.currentTarget.classList.remove("dragging");
    ev.currentTarget.removeEventListener("pointermove", moverNodoArrastre);
    ev.currentTarget.removeEventListener("pointerup", finalizarArrastreNodo);
    ev.currentTarget.removeEventListener("pointercancel", finalizarArrastreNodo);
  }
  if (dragEstado && dragEstado.activo) {
    guardarEstadoNodos();
  }
  dragEstado = null;
}

function prepararConexion(id) {
  const idNorm = normalizarIdNodo(id);
  if (!idNorm) return;
  const conectandoNorm = nodoConectandoOrigen ? normalizarIdNodo(nodoConectandoOrigen) : "";
  if (conectandoNorm && conectandoNorm === idNorm) {
    nodoConectandoOrigen = null;
  } else if (!conectandoNorm) {
    nodoConectandoOrigen = idNorm;
  } else {
    conectarNodos(conectandoNorm, idNorm);
    nodoConectandoOrigen = null;
  }
  renderFlowNodes();
}

function cancelarConexionEnCurso() {
  if (nodoConectandoOrigen) {
    nodoConectandoOrigen = null;
    renderFlowNodes();
    mostrarAviso("Conexión cancelada.", "info");
  }
}

function conectarNodos(origenId, destinoId, silencioso = false) {
  const origenNorm = normalizarIdNodo(origenId);
  const destinoNorm = normalizarIdNodo(destinoId);
  if (!origenNorm || !destinoNorm) return;
  normalizarFlujoNodos();
  const origen = buscarNodoPorId(origenNorm);
  const destino = buscarNodoPorId(destinoNorm);
  if (!origen) return;
  if (esAncestro(destinoNorm, origenNorm)) {
    mostrarAviso("No puedes crear ciclos en el flujo.", "error");
    return;
  }
  origen.targets = origen.targets || [];
  if (!origen.targets.includes(destinoNorm)) {
    origen.targets.push(destinoNorm);
    if (origen.tipo === "estilo") {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoNorm.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { volumen: 0 };
      }
    }
    if (origen.tipo === "entrada" && origen.datos?.reparto_manual === true) {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoNorm.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { volumen: 0 };
      }
    }
    if (destino) {
      sembrarDatosIniciales(origen, destino);
    }
    guardarEstadoNodos();
    renderFlowNodes();
    registrarConexionMapaNodos(origen, destino || buscarNodoPorId(destinoNorm));
    if (!silencioso) {
      mostrarAviso("Nodos conectados.", "success");
    }
  }
}

function actualizarBotellasResultantes(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return;
  const selectBotella = document.getElementById("flowField-botella");
  const display = document.getElementById("flowField-botellas_resultantes-display");
  const hidden = document.getElementById("flowField-botellas_resultantes");
  if (!selectBotella || !display || !hidden) return;
  const litrosDisponibles = obtenerLitrosDisponiblesPredecesoresLedger(nodo);
  const resumen = calcularResumenFormatosBotella(nodo);
  if (resumen.totalBotellas > 0) {
    const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
    const formatosTxt = resumen.formatosActivos > 1 ? ` · ${resumen.formatosActivos} formatos` : "";
    const volumenTxt = resumen.totalLitros > 0
      ? ` (${formatearVolumenPlano(resumen.totalLitros)} volumen calculado)`
      : "";
    display.textContent = `${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${formatosTxt}${volumenTxt}`;
    hidden.value = resumen.totalBotellas;
    nodo.datos = nodo.datos || {};
    nodo.datos.botellas = resumen.totalBotellas;
    return;
  }
  const volBotella = VOLUMEN_BOTELLA_L[selectBotella.value] || 0;
  const botellas = volBotella > 0 ? Math.floor(litrosDisponibles / volBotella) : 0;
  display.textContent = botellas
    ? `${botellas} uds (${formatearVolumenPlano(litrosDisponibles)} volumen disponible)`
    : "—";
  hidden.value = botellas;
  nodo.datos = nodo.datos || {};
  nodo.datos.botellas = botellas;
}

async function asegurarJsPDF() {
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  const cargar = src =>
    new Promise(resolve => {
      const script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.onload = resolve;
      script.onerror = resolve;
      document.head.appendChild(script);
    });
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js");
  return window.jspdf && window.jspdf.jsPDF ? window.jspdf.jsPDF : null;
}

async function exportarTablaControlPDF(nodo) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se cargó). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const anada =
      nodo.datos?.anada ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha) ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha_operacion) ||
      "";
    const titulo = `Control analítico de ${nodo.titulo || "Depósito"}${anada ? " · añada " + anada : ""}`;
    doc.setFontSize(14);
    doc.text(titulo, 14, 18);
    doc.setFontSize(11);

    const depInfo = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const variedad = depInfo?.vino_tipo || nodo.datos?.variedad || nodo.datos?.vino || "";
    const tipoDep = depInfo?.tipo || nodo.datos?.tipo || "Depósito";
    const capacidadRaw =
      depInfo?.capacidad_l ??
      (depInfo?.capacidad_hl != null ? depInfo.capacidad_hl * 100 : nodo.datos?.capacidad);
    const capacidad = Number.isFinite(capacidadRaw) ? `${Number(capacidadRaw).toFixed(2)} L` : "—";
    const volumenRaw =
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos ??
      depInfo?.litros_actuales;
    const volumen = Number.isFinite(Number(volumenRaw))
      ? `${Number(volumenRaw).toFixed(2)} L`
      : "—";

    const infoLines = [
      `Variedad de uva: ${variedad || "—"}`,
      `Tipo de depósito: ${tipoDep || "—"}`,
      `Capacidad depósito: ${capacidad}`,
      `Volumen uva/vino: ${volumen}`,
    ];
    doc.setFontSize(10);
    infoLines.forEach((linea, idx) => {
      doc.text(linea, 14, 24 + idx * 6);
    });

    const startYTable = 24 + infoLines.length * 6 + 6;

    const formatearFechaCorta = fechaStr => {
      if (!fechaStr) return "";
      const d = new Date(fechaStr);
      if (isNaN(d.getTime())) return fechaStr;
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    };

    const filas = (nodo.datos?.control || []).map(reg => [
      formatearFechaCorta(reg.fecha),
      reg.densidad || "",
      reg.temperatura || "",
      reg.productos || "",
    ]);
    const body = filas.length ? filas : [["", "", "", ""]];
    const headers = [["Fecha", "Densidad", "°C", "Productos"]];
    const autoTable = (window.jspdf && window.jspdf.autoTable) || (doc && doc.autoTable);
    if (autoTable) {
      (window.jspdf && window.jspdf.autoTable ? window.jspdf.autoTable : doc.autoTable).call(doc, {
        head: headers,
        body,
        startY: startYTable,
        styles: { fontSize: 11, cellPadding: 4 },
        headStyles: { fillColor: [60, 0, 90], textColor: 255 },
        alternateRowStyles: { fillColor: [245, 240, 248] },
      });
    } else {
      let y = startYTable;
      doc.text(headers[0].join(" | "), 14, y);
      y += 8;
      body.forEach(row => {
        doc.text(row.join(" | "), 14, y);
        y += 8;
      });
    }
    const nombreArchivo = `control-${(nodo.titulo || "deposito").toString().replace(/\s+/g, "-")}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de control:", err);
    alert("No se pudo generar el PDF.");
  }
}

function normalizarNumero(valor) {
  if (valor === undefined || valor === null || valor === "") return null;
  if (typeof valor === "number") return Number.isFinite(valor) ? valor : null;
  let limpio = typeof valor === "string" ? valor.trim() : String(valor);
  if (!limpio) return null;
  limpio = limpio.replace(/\s+/g, "");
  const tieneComa = limpio.includes(",");
  const tienePunto = limpio.includes(".");
  if (tieneComa && tienePunto) {
    limpio = limpio.replace(/\./g, "").replace(",", ".");
  } else if (tieneComa) {
    limpio = limpio.replace(",", ".");
  } else if (tienePunto) {
    const partes = limpio.split(".");
    if (partes.length > 2) {
      const dec = partes.pop();
      limpio = partes.join("") + "." + dec;
    }
  }
  const numero = Number(limpio);
  return Number.isFinite(numero) ? numero : null;
}

function normalizarNumeroFlexible(valor) {
  const directo = normalizarNumero(valor);
  if (Number.isFinite(directo)) return directo;
  if (typeof valor !== "string") return null;
  const raw = valor.trim();
  if (!raw) return null;
  const match = raw.match(/-?\d+(?:[.,]\d+)?/);
  if (!match) return null;
  return normalizarNumero(match[0]);
}

function normalizarKilosLitrosDesdeDatos(datos) {
  const volumen = getVolumenFromDatos(datos);
  return {
    volumen: volumen != null ? Number(volumen.toFixed(2)) : null,
  };
}

function recalcularVolumenNodo(nodo, motivo = "") {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const role = obtenerRolNodo(nodo);
  if (role !== "CONTAINER") {
    limpiarVolumenNodoProceso(nodo);
    return null;
  }
  const normalizado = normalizarKilosLitrosDesdeDatos(nodo.datos);
  const volumen = normalizado.volumen;
  nodo.datos.volumen = volumen != null ? Number(volumen.toFixed(2)) : null;
  if (flowDebugActivo()) {
    console.debug("[flow][volumen]", {
      motivo,
      volumen,
      nodo: nodo.id,
      tipo: nodo.tipo,
    });
  }
  return nodo.datos.volumen;
}

function formatearDensidad(valor) {
  const num = normalizarNumero(valor);
  if (num == null) return "";
  const entero = Math.round(num);
  return entero.toString().padStart(4, "0");
}

function obtenerVariedadNodo(nodo, visitados = new Set()) {
  const comp = calcularComposicionVariedades(nodo, visitados);
  if (comp.mix.size) {
    const composicion = guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    return composicion.map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`).join("/");
  }
  return nodo?.datos?.variedad || nodo?.datos?.variedadBase || "";
}

function obtenerMermaDefault(nodo) {
  // Por defecto no aplicamos merma; solo se usa la que indique el usuario.
  return MERMA_DEFAULT_GENERAL;
}

function asegurarMermaPorDefecto(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  if (esNodoPrensado(nodo)) return;
  const mermaActual = normalizarNumero(nodo.datos.merma);
  if (mermaActual == null) {
    nodo.datos.merma = 0;
  }
}

function obtenerFactorMermaNodo(nodo) {
  const mermaDatos = nodo?.datos ? normalizarNumero(nodo.datos.merma) : null;
  const base = mermaDatos != null ? mermaDatos : obtenerMermaDefault(nodo);
  const factor = Number.isFinite(base) ? base / 100 : 0;
  return Math.min(Math.max(factor, 0), 0.95);
}

function aplicarMerma(base, factor) {
  const resultado = base * (1 - factor);
  return Number.isFinite(resultado) ? Number(resultado.toFixed(2)) : 0;
}

function flowDebugActivo() {
  if (typeof window === "undefined") return false;
  try {
    return window.__FLOW_DEBUG === true || localStorage.getItem("flowDebug") === "1";
  } catch (_err) {
    return window.__FLOW_DEBUG === true;
  }
}

function obtenerMermaLitrosNodo(nodo) {
  const valor = normalizarNumero(
    nodo?.datos?.merma_abs ?? nodo?.datos?.merma_litros ?? nodo?.datos?.merma_l
  );
  return valor != null && valor >= 0 ? valor : null;
}

function obtenerLitrosResultantesNodo(nodo) {
  const valor = normalizarNumero(
    nodo?.datos?.litros_resultantes ?? nodo?.datos?.litros_result
  );
  return valor != null && valor >= 0 ? valor : null;
}

function obtenerParametrosPrensadoNodo(nodo) {
  return {
    litrosResultantes: obtenerLitrosResultantesNodo(nodo),
    mermaAbs: obtenerMermaLitrosNodo(nodo),
    mermaPct: normalizarNumero(nodo?.datos?.merma),
  };
}

function calcularSalidaPrensado({ kilos, litros, litrosResultantes, mermaAbs, mermaPct }) {
  const kilosEntrada = normalizarNumero(kilos);
  const litrosEntrada = normalizarNumero(litros);
  const volumenEntradaRaw = getVolumenFromDatos({ kilos, litros });
  const volumenEntrada = volumenEntradaRaw != null ? Number(volumenEntradaRaw.toFixed(2)) : 0;
  if (!(volumenEntrada > 0)) {
    return { ok: false, error: "Sin volumen de entrada.", volumenEntrada, volumenFinal: 0 };
  }

  const litrosRes = normalizarNumero(litrosResultantes);
  const mermaAbsVal = normalizarNumero(mermaAbs);
  const mermaPctVal = normalizarNumero(mermaPct);
  const tieneMermaConfig =
    litrosRes != null ||
    (mermaAbsVal != null && mermaAbsVal > 0) ||
    (mermaPctVal != null && mermaPctVal > 0);
  let volumenFinal = null;
  let mermaAbsFinal = null;
  let mermaPctFinal = null;

  if (!tieneMermaConfig) {
    return {
      ok: true,
      kilosEntrada,
      litrosEntrada,
      volumenEntrada,
      volumenFinal: volumenEntrada,
      mermaAbs: 0,
      mermaPct: 0,
    };
  }

  if (litrosRes != null) {
    volumenFinal = Number(litrosRes.toFixed(2));
    mermaAbsFinal = Number((volumenEntrada - volumenFinal).toFixed(2));
    mermaPctFinal = Number(((mermaAbsFinal / volumenEntrada) * 100).toFixed(2));
  } else if (mermaAbsVal != null && mermaAbsVal > 0) {
    mermaAbsFinal = Number(mermaAbsVal.toFixed(2));
    volumenFinal = Number((volumenEntrada - mermaAbsFinal).toFixed(2));
    mermaPctFinal = Number(((mermaAbsFinal / volumenEntrada) * 100).toFixed(2));
  } else if (mermaPctVal != null && mermaPctVal > 0) {
    mermaPctFinal = Number(mermaPctVal.toFixed(2));
    mermaAbsFinal = Number(((volumenEntrada * mermaPctFinal) / 100).toFixed(2));
    volumenFinal = Number((volumenEntrada - mermaAbsFinal).toFixed(2));
  } else {
    return {
      ok: true,
      kilosEntrada,
      litrosEntrada,
      volumenEntrada,
      volumenFinal: volumenEntrada,
      mermaAbs: 0,
      mermaPct: 0,
    };
  }

  if (volumenFinal > volumenEntrada) {
    return {
      ok: false,
      error: "El volumen resultante no puede superar el de entrada.",
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    };
  }
  if (volumenFinal < 0) {
    return {
      ok: false,
      error: "La merma supera el volumen de entrada.",
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    };
  }

  if (flowDebugActivo()) {
    console.debug("[flow][prensado]", {
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    });
  }

  return {
    ok: true,
    kilosEntrada,
    litrosEntrada,
    volumenEntrada,
    volumenFinal,
    mermaAbs: mermaAbsFinal,
    mermaPct: mermaPctFinal,
  };
}

function obtenerValorUnidadNodo(nodo, _unidad) {
  if (!nodo) return 0;
  const volumen = getVolumenFromNodo(nodo);
  return Number.isFinite(volumen) ? volumen : 0;
}

function obtenerVolumenActualNodo(nodo) {
  if (!nodo) return null;
  const vol = calcularVolumenNodoPorFlujo(nodo);
  return Number.isFinite(vol) ? vol : null;
}

function setKilosLitrosNodo(nodo, kilos, litros, motivo = "") {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const role = obtenerRolNodo(nodo);
  if (role !== "CONTAINER") {
    limpiarVolumenNodoProceso(nodo);
    return null;
  }
  const volumen = getVolumenFromDatos({ volumen: null, kilos, litros });
  nodo.datos.volumen = volumen != null ? Number(volumen.toFixed(2)) : null;
  const kilosNum = normalizarNumero(kilos);
  const litrosNum = normalizarNumero(litros);
  if (kilosNum != null && kilosNum > 0) {
    nodo.datos.kilos = Number(kilosNum.toFixed(2));
    nodo.datos.litros = null;
    nodo.datos.litros_directos = null;
  } else if (litrosNum != null && litrosNum > 0) {
    nodo.datos.litros = Number(litrosNum.toFixed(2));
    nodo.datos.litros_directos = nodo.datos.litros;
    nodo.datos.kilos = null;
  } else {
    if (kilosNum != null) nodo.datos.kilos = Number(kilosNum.toFixed(2));
    if (litrosNum != null) {
      nodo.datos.litros = Number(litrosNum.toFixed(2));
      nodo.datos.litros_directos = nodo.datos.litros;
    }
  }
  return recalcularVolumenNodo(nodo, motivo);
}

function applyVolumeOperation(nodo, { litrosDelta = 0, kilosDelta = 0, motivo = "" } = {}) {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const role = obtenerRolNodo(nodo);
  if (role !== "CONTAINER") {
    limpiarVolumenNodoProceso(nodo);
    return null;
  }
  const actual = getVolumenFromNodo(nodo) || 0;
  const delta = getVolumenFromDatos({ volumen: null, kilos: kilosDelta, litros: litrosDelta }) || 0;
  nodo.datos.volumen = Math.max(0, Number((actual + delta).toFixed(2)));
  return recalcularVolumenNodo(nodo, motivo);
}

function aplicarVolumenAbsoluto(nodo, valor, unidad, motivo = "") {
  const objetivo = normalizarNumero(valor);
  if (objetivo == null) return null;
  const actual = obtenerValorUnidadNodo(nodo, unidad);
  const delta = Number((objetivo - actual).toFixed(2));
  return applyVolumeOperation(nodo, { litrosDelta: delta, motivo });
}

function esConexionTrasiego(origen, destino) {
  return (
    TIPOS_NODO_CONTENEDOR.has(origen.tipo) &&
    TIPOS_NODO_CONTENEDOR.has(destino.tipo) &&
    origen.id !== destino.id
  );
}

function aplicarCargaANodo(nodo, carga) {
  nodo.datos = nodo.datos || {};
  const acumular = false; // evitar acumulados duplicados // en nodos de proceso sumamos aportes múltiples
  const prevVol = getVolumenFromNodo(nodo) || 0;
  if (carga.variedad) {
    nodo.datos.variedad = carga.variedad;
  }
  if (carga.parcela) {
    nodo.datos.parcela = carga.parcela;
  }
  if (carga.anada) {
    nodo.datos.anada = carga.anada;
  }
  const volumenCarga = getVolumenFromDatos(carga);
  if (volumenCarga != null) {
    const nuevos = Number(volumenCarga.toFixed(2));
    nodo.datos.volumen = acumular ? Number((prevVol + nuevos).toFixed(2)) : nuevos;
    recalcularVolumenNodo(nodo, "aplicarCargaANodo");
  }
  if (carga.fecha) {
    nodo.datos.fecha = carga.fecha;
    if (!nodo.datos.fecha_operacion) {
      nodo.datos.fecha_operacion = carga.fecha;
    }
  }
  const densidadCarga = normalizarNumero(carga.densidad);
  if (densidadCarga != null) {
    nodo.datos.densidad = Number(densidadCarga.toFixed(4));
  }
  const tempCarga = normalizarNumero(carga.temperatura);
  if (tempCarga != null) {
    nodo.datos.temperatura = Number(tempCarga.toFixed(2));
  }
}
function aplicarCargaProcesoSinDuplicar(destino, origenId, carga) {
  if (!destino) return;
  destino.datos = destino.datos || {};
  destino.datos.aportes = destino.datos.aportes || {};
  const aporteVolumen = getVolumenFromDatos(carga);
  const aporte = {
    volumen: aporteVolumen != null ? Number(aporteVolumen.toFixed(2)) : null,
    variedad: carga.variedad,
    anada: carga.anada,
    parcela: carga.parcela,
    fecha: carga.fecha,
    densidad: normalizarNumero(carga.densidad),
    temperatura: normalizarNumero(carga.temperatura),
  };
  destino.datos.aportes[normalizarIdNodo(origenId)] = aporte;
  limpiarAportesOrfanos(destino);
  let sumVol = 0;
  const mixVariedades = new Map();
  let densidadSuma = 0;
  let densidadPeso = 0;
  let densidadPrimera = null;
  let tempSuma = 0;
  let tempPeso = 0;
  let tempPrimera = null;

  const pesoParaAporte = a => {
    const volumen = getVolumenFromDatos(a);
    return Number.isFinite(volumen) ? volumen : 0;
  };

  Object.values(destino.datos.aportes).forEach(a => {
    const volumen = getVolumenFromDatos(a);
    const volumenSeguro = Number.isFinite(volumen) ? volumen : 0;
    if (volumenSeguro > 0) sumVol += volumenSeguro;
    const peso = pesoParaAporte(a);
    if (a.variedad && peso > 0) {
      agregarVariedadAPeso(mixVariedades, a.variedad, peso);
    }
    const dens = normalizarNumero(a.densidad);
    if (dens != null) {
      const pesoD = peso || 1;
      densidadSuma += dens * pesoD;
      densidadPeso += pesoD;
      if (densidadPrimera == null) densidadPrimera = dens;
    }
    const temp = normalizarNumero(a.temperatura);
    if (temp != null) {
      const pesoT = peso || 1;
      tempSuma += temp * pesoT;
      tempPeso += pesoT;
      if (tempPrimera == null) tempPrimera = temp;
    }
  });
  const totalMix = Array.from(mixVariedades.values()).reduce((acc, v) => acc + v, 0);
  if (mixVariedades.size) {
    guardarComposicionEnNodo(destino, mixVariedades, totalMix);
  } else if (aporte.variedad) {
    destino.datos.composicionVariedades = [];
    destino.datos.variedad = aporte.variedad;
  }
  if (aporte.anada) destino.datos.anada = aporte.anada;
  if (aporte.parcela) destino.datos.parcela = aporte.parcela;
  if (aporte.fecha) destino.datos.fecha = aporte.fecha;
  const densidadMedia =
    densidadPeso > 0 ? densidadSuma / densidadPeso : densidadPrimera;
  const temperaturaMedia = tempPeso > 0 ? tempSuma / tempPeso : tempPrimera;
  destino.datos.densidad =
    densidadMedia != null ? Number(densidadMedia.toFixed(4)) : "";
  destino.datos.temperatura =
    temperaturaMedia != null ? Number(temperaturaMedia.toFixed(2)) : "";

  // Para contenedores dejamos que el volumen lo gestionen asignaciones; solo propagamos mezcla.
  if (TIPOS_NODO_CONTENEDOR.has(destino.tipo)) {
    // Aseguramos que el mix se refleje aunque las asignaciones estén vacías
    if (mixVariedades.size) {
      guardarComposicionEnNodo(destino, mixVariedades, totalMix);
    }
    // En barricas no tenemos tabla de asignaciones, así que guardamos volumen para el relleno visual.
    if (destino.tipo === "barrica") {
      setKilosLitrosNodo(
        destino,
        null,
        Number(sumVol.toFixed(2)),
        "aportes_barrica"
      );
    }
    return;
  }

  // En nodos de proceso sí consolidamos los volúmenes para mostrar totales.
  setKilosLitrosNodo(
    destino,
    null,
    Number(sumVol.toFixed(2)),
    "aportes_proceso"
  );
}

function desconectarNodo(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  if (!nodo) return;
  const conexionesPrevias = construirConexionesNodoMapa(nodo);
  const afectados = new Set();
  nodo.targets = [];
  flujoNodos.forEach(other => {
    if (other.targets) {
      const longitudInicial = other.targets.length;
      other.targets = other.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== other.targets.length) {
        afectados.add(other.id);
        if (other.datos?.distribucion) {
          limpiarDistribucionEstilo(other);
        }
      }
    }
  });
  if (nodo.datos?.distribucion) {
    limpiarDistribucionEstilo(nodo);
  }
  if (nodoConectandoOrigen === id) {
    nodoConectandoOrigen = null;
  }
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  limpiarVariedadDepositosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  registrarDesconexionMapaNodos(nodo, conexionesPrevias);
  mostrarAviso("Conexiones eliminadas para este nodo.", "info");
}

function limpiarVariedadDepositosSinEntradas() {
  flujoNodos
    .filter(n => n.tipo === "deposito")
    .forEach(dep => {
      const padres = obtenerPredecesores(dep.id);
      const sinEntradas = !padres || padres.length === 0;
      const tieneSalidas = Array.isArray(dep.targets) && dep.targets.length > 0;
      if (sinEntradas && !tieneSalidas) {
        dep.datos = dep.datos || {};
        dep.datos.variedad = "";
        dep.datos.variedadBase = "";
        dep.datos.vino_tipo = "";
        dep.datos.vino = "";
        dep.datos.tipoColor = "";
        dep.datos.composicionVariedades = [];
        dep.datos.aportes = {};
      }
    });
}

function limpiarEstadoEnologicoNodo(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  limpiarCargaNodo(nodo);
  const datos = nodo.datos;
  const camposTexto = [
    "variedad",
    "variedadBase",
    "tipoColor",
    "vino_tipo",
    "vino",
    "vino_anio",
    "anada",
    "nombre_vino",
    "nombre_blend",
    "descripcion",
    "notas",
  ];
  const camposFecha = ["tiempo", "tiempo_estimado", "fecha", "fecha_operacion", "fecha_uso"];
  camposTexto.forEach(campo => {
    if (campo in datos) datos[campo] = "";
  });
  camposFecha.forEach(campo => {
    if (campo in datos) datos[campo] = "";
  });
  if ("litros_blend" in datos) datos.litros_blend = 0;
  if ("control" in datos) datos.control = [];
  if ("estado_vino" in datos) datos.estado_vino = "";
  if ("estado_vino_texto" in datos) datos.estado_vino_texto = "";
  if ("fase" in datos) datos.fase = "";
  datos.estado = "vacio";
}

function obtenerNombreContenedorNodo(nodo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return nodo?.titulo || "Nodo";
  if (contenedor.tipo === "barrica") return obtenerNombreBarrica(contenedor.id);
  if (contenedor.tipo === "mastelone") return obtenerNombreMastelone(contenedor.id);
  return obtenerNombreDeposito(contenedor.id);
}

function formatearKilosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} kg`;
}

function formatearVolumenPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })}`;
}

function normalizarTextoMapa(valor) {
  if (valor == null) return "";
  const texto = valor.toString().trim();
  return texto;
}

function obtenerEtiquetaNodoMapa(nodo) {
  if (!nodo) return "Nodo";
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (contenedor) return obtenerNombreContenedorNodo(nodo);
  if (nodo.tipo === "entrada") {
    const entradaId = obtenerEntradaIdDesdeNodo(nodo);
    return entradaId ? obtenerEtiquetaEntrada(entradaId) : (nodo.titulo || "Entrada");
  }
  return nodo.titulo || FLOW_NODE_TYPES[nodo.tipo]?.label || "Nodo";
}

function obtenerOperacionNodoMapa(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  if (nodo.tipo === "estilo" && datos.metodo) return datos.metodo;
  if (nodo.tipo === "fermentacion" && datos.estilo) return datos.estilo;
  if (nodo.tipo === "deposito" && datos.fase) return datos.fase;
  if (nodo.tipo === "barrica") {
    const estado = normalizarTextoMapa(datos.estado_vino_texto || datos.estado_vino);
    return estado ? estado : "Crianza";
  }
  return "";
}

function obtenerFechaEventoNodo(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  return normalizarTextoMapa(datos.fecha_operacion || datos.fecha);
}

function agregarLineaMapa(lineas, etiqueta, valor) {
  const texto = normalizarTextoMapa(valor);
  if (!texto) return;
  lineas.push(`${etiqueta}: ${texto}`);
}

function construirDetalleNodoMapa(nodo) {
  const lineas = [];
  if (!nodo) return lineas;
  const datos = nodo.datos || {};
  const tipoLabel = FLOW_NODE_TYPES[nodo.tipo]?.label || nodo.tipo || "Nodo";
  const nombre = obtenerEtiquetaNodoMapa(nodo);
  agregarLineaMapa(lineas, "Tipo", tipoLabel);
  if (nombre && nombre !== tipoLabel) {
    agregarLineaMapa(lineas, "Nodo", nombre);
  }
  const fecha = obtenerFechaEventoNodo(nodo);
  agregarLineaMapa(lineas, "Fecha", fecha);
  const operacion = obtenerOperacionNodoMapa(nodo);
  agregarLineaMapa(lineas, "Operación", operacion);
  const variedad = obtenerVariedadVisibleNodo(nodo);
  agregarLineaMapa(lineas, "Variedad", variedad);
  const volumen = obtenerTextoVolumenNodo(nodo);
  if (volumen) lineas.push(volumen);

  if (nodo.tipo === "entrada") {
    const densidad = obtenerDensidadEntradaDesdeNodo(nodo);
    if (densidad != null) agregarLineaMapa(lineas, "Densidad", densidad);
    const temp = obtenerTemperaturaEntradaDesdeNodo(nodo);
    if (temp != null) agregarLineaMapa(lineas, "Temperatura", `${temp} ºC`);
    const ph = obtenerPhEntradaDesdeNodo(nodo);
    if (ph != null) agregarLineaMapa(lineas, "pH", Number(ph).toFixed(2));
    const acidez = obtenerAcidezTotalEntradaDesdeNodo(nodo);
    if (acidez != null) agregarLineaMapa(lineas, "Acidez total", `${Number(acidez).toFixed(2)} g/L`);
    const entrada = obtenerEntradaRealDesdeNodo(nodo);
    agregarLineaMapa(lineas, "Parcela", entrada?.parcela || "");
  } else if (nodo.tipo === "fermentacion") {
    agregarLineaMapa(lineas, "Fermentación", datos.estilo);
    const registros = Array.isArray(datos.control) ? datos.control : [];
    const ultimo = registros.length ? registros[registros.length - 1] : null;
    if (ultimo) {
      const densidad = normalizarNumero(ultimo.densidad);
      if (densidad != null) agregarLineaMapa(lineas, "Densidad", densidad);
      const temp = normalizarNumero(ultimo.temperatura);
      if (temp != null) agregarLineaMapa(lineas, "Temperatura", `${temp} ºC`);
    }
  } else if (nodo.tipo === "estilo") {
    agregarLineaMapa(lineas, "Método", datos.metodo);
    agregarLineaMapa(lineas, "Descripción", datos.descripcion);
  } else if (nodo.tipo === "deposito") {
    agregarLineaMapa(lineas, "Fase", datos.fase);
    agregarLineaMapa(lineas, "Estado", datos.estado);
  } else if (nodo.tipo === "barrica") {
    agregarLineaMapa(lineas, "Vino", datos.nombre_vino);
    agregarLineaMapa(lineas, "Fin crianza", datos.tiempo);
    agregarLineaMapa(lineas, "Notas", datos.notas);
  } else if (nodo.tipo === "prensado") {
    const merma = normalizarNumero(datos.merma);
    if (merma != null) agregarLineaMapa(lineas, "Merma", `${merma}%`);
    agregarLineaMapa(lineas, "Presión", datos.presion);
    agregarLineaMapa(lineas, "Notas", datos.notas);
  } else if (nodo.tipo === "embotellado") {
    agregarLineaMapa(lineas, "Botella", datos.botella);
    agregarLineaMapa(lineas, "Cierre", datos.cierre);
    agregarLineaMapa(lineas, "Filtrado", datos.filtrado);
    const botellas = normalizarNumero(datos.botellas || datos.botellas_resultantes);
    if (botellas != null) agregarLineaMapa(lineas, "Botellas", botellas);
  } else if (nodo.tipo === "coupage") {
    agregarLineaMapa(lineas, "Nombre", datos.nombre_blend);
    const volumenBlend = normalizarNumero(datos.litros_blend);
    if (volumenBlend != null) agregarLineaMapa(lineas, "Volumen", formatearVolumenPlano(volumenBlend));
    agregarLineaMapa(lineas, "Notas", datos.descripcion);
  } else if (nodo.tipo === "almacen") {
    agregarLineaMapa(lineas, "Condición", datos.condicion);
    agregarLineaMapa(lineas, "Tipo de caja", datos.caja_botellas);
    const botellas = obtenerBotellasDisponiblesPredecesoresAlmacen(nodo);
    const tamCaja = obtenerTamanoCaja(datos.caja_botellas || "6 botellas");
    const cajas = Math.floor(botellas / tamCaja);
    agregarLineaMapa(lineas, "Botellas", botellas);
    agregarLineaMapa(lineas, "Cajas", `${cajas} (${tamCaja} botellas/caja)`);
    agregarLineaMapa(lineas, "Fecha", datos.fecha);
  } else if (nodo.tipo === "salida") {
    agregarLineaMapa(lineas, "Cliente", datos.cliente || datos.destino);
    agregarLineaMapa(lineas, "Cantidad de cajas", datos.cajas_cantidad || datos.transporte);
    agregarLineaMapa(lineas, "Botellas por caja", datos.cajas_tipo || datos.formato_botella);
    const cajasRaw = normalizarNumero(datos.cajas_cantidad || 0);
    const cajas = Number.isFinite(cajasRaw) && cajasRaw > 0 ? Math.floor(cajasRaw) : 0;
    const tamCaja = obtenerTamanoCaja(datos.cajas_tipo || "6 botellas");
    const totalBotellas = Number.isFinite(normalizarNumero(datos.botellas_totales))
      ? Math.floor(Number(datos.botellas_totales))
      : cajas * tamCaja;
    agregarLineaMapa(lineas, "Botellas totales", totalBotellas);
  }
  return lineas;
}

function registrarBitacoraMapaNodosGeneral(texto, noteType = "accion") {
  const limpio = normalizarTextoMapa(texto);
  if (!limpio) return;
  fetch("/api/bitacora", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: limpio,
      scope: "general",
      origin: "mapa_nodos",
      note_type: noteType,
    }),
  })
    .then(() => programarActualizacionFlowTimeline())
    .catch(() => {});
}

function registrarEventoContenedorMapaNodos(contenedor, resumen, detalle, meta, fechaEvento, tipoEvento = "nota") {
  if (!contenedor) return;
  const resumenFinal = resumen || "Mapa de nodos";
  const detalleFinal = detalle
    ? [resumenFinal, detalle].filter(Boolean).join("\n")
    : resumenFinal;
  const payload = {
    contenedor_tipo: contenedor.tipo,
    contenedor_id: contenedor.id,
    tipo: tipoEvento,
    resumen: resumenFinal,
    detalle: detalleFinal,
    origen: "control",
    meta: meta || { accion: "mapa_nodos" },
  };
  if (fechaEvento) payload.fecha_hora = fechaEvento;
  fetch("/api/eventos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  }).then(() => {
    programarActualizacionFlowTimeline();
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  }).catch(() => {});
}

function registrarMapaNodosEvento({ resumen, detalle, contenedores, meta, fechaEvento, noteType, tipoEvento } = {}) {
  const lista = Array.isArray(contenedores) ? contenedores.filter(Boolean) : [];
  const vistos = new Map();
  lista.forEach(cont => {
    const key = `${cont.tipo}:${cont.id}`;
    if (!vistos.has(key)) vistos.set(key, cont);
  });
  const unicos = [...vistos.values()];
  if (unicos.length) {
    unicos.forEach(cont => {
      registrarEventoContenedorMapaNodos(cont, resumen, detalle, meta, fechaEvento, tipoEvento);
    });
    return;
  }
  const texto = [resumen, detalle].filter(Boolean).join("\n").trim();
  if (texto) {
    registrarBitacoraMapaNodosGeneral(texto, noteType || "accion");
  }
}

function describirNodoMapaNodos(nodo) {
  const base = obtenerEtiquetaNodoMapa(nodo);
  const operacion = obtenerOperacionNodoMapa(nodo);
  if (operacion && !base.includes(operacion)) return `${base} (${operacion})`;
  return base;
}

function construirCantidadConexionMapa(origen, destino) {
  const volumen = obtenerVolumenTransferenciaEntreNodos(origen, destino);
  if (volumen > 0) return formatearVolumenPlano(volumen);
  return "";
}

function construirDetalleConexionMapa(origen, destino, cantidad) {
  const lineas = [];
  const origenTxt = describirNodoMapaNodos(origen);
  const destinoTxt = describirNodoMapaNodos(destino);
  agregarLineaMapa(lineas, "Origen", origenTxt);
  agregarLineaMapa(lineas, "Destino", destinoTxt);
  agregarLineaMapa(lineas, "Volumen", cantidad);
  const variedad = obtenerVariedadVisibleNodo(origen) || obtenerVariedadVisibleNodo(destino);
  agregarLineaMapa(lineas, "Variedad", variedad);
  const opOrigen = obtenerOperacionNodoMapa(origen);
  const opDestino = obtenerOperacionNodoMapa(destino);
  agregarLineaMapa(lineas, "Operación origen", opOrigen);
  agregarLineaMapa(lineas, "Operación destino", opDestino);
  return lineas;
}

function registrarConexionMapaNodos(origen, destino) {
  if (!origen || !destino) return;
  const cantidad = construirCantidadConexionMapa(origen, destino);
  const cantidadTexto = cantidad ? `Volumen ${cantidad}` : "";
  const origenTxt = describirNodoMapaNodos(origen);
  const destinoTxt = describirNodoMapaNodos(destino);
  const resumenBase = `${origenTxt} → ${destinoTxt}`;
  const resumen = `${resumenBase}${cantidadTexto ? ` · ${cantidadTexto}` : ""} · mapa de nodos`;
  const detalleLineas = construirDetalleConexionMapa(origen, destino, cantidad);
  const detalle = detalleLineas.join("\n");
  const contenedores = [
    resolverContenedorDesdeNodoControl(origen),
    resolverContenedorDesdeNodoControl(destino),
  ];
  const meta = {
    accion: "mapa_nodos",
    evento: "conexion",
    tipo_movimiento: "conexion",
    origen: origenTxt,
    destino: destinoTxt,
    cantidad: cantidadTexto || null,
    observacion: "mapa de nodos",
    origen_nodo: origen.id,
    destino_nodo: destino.id,
    origen_tipo: origen.tipo,
    destino_tipo: destino.tipo,
  };
  const fechaEvento = obtenerFechaEventoNodo(destino) || obtenerFechaEventoNodo(origen);
  registrarMapaNodosEvento({
    resumen,
    detalle,
    contenedores,
    meta,
    fechaEvento,
    noteType: "accion",
    tipoEvento: "movimiento",
  });
}

function registrarPrensadoMapaNodos(origen, destino, salida) {
  if (!origen || !salida?.ok) return;
  const contenedor = resolverContenedorDesdeNodoControl(origen);

  const nombre = obtenerNombreContenedorNodo(origen);
  const resumen = `PRENSADO ${nombre}: entrada ${salida.volumenEntrada}, salida ${salida.volumenFinal}, merma ${salida.mermaAbs} (${salida.mermaPct}%)`;
  const meta = {
    accion: "mapa_nodos",
    tipo_evento: "prensado",
    volumen_entrada: salida.volumenEntrada,
    volumen_salida: salida.volumenFinal,
    litros: salida.volumenFinal,
    merma_abs: salida.mermaAbs,
    merma_pct: salida.mermaPct,
    origen_id: contenedor?.id ?? null,
    destino: destino?.titulo || "",
  };
  const fechaEvento = obtenerFechaEventoNodo(origen) || obtenerFechaEventoNodo(destino);
  registrarMapaNodosEvento({
    resumen,
    detalle: resumen,
    contenedores: contenedor ? [contenedor] : [],
    meta,
    fechaEvento,
    noteType: "accion",
    tipoEvento: "prensado",
  });
}

function registrarAccionNodoMapa(accion, nodo, { noteType = "accion", extraLineas = [] } = {}) {
  if (!nodo) return;
  const nombre = describirNodoMapaNodos(nodo);
  const resumen = `${accion}: ${nombre} · mapa de nodos`;
  const detalleLineas = construirDetalleNodoMapa(nodo);
  const lineas = [resumen, ...detalleLineas, ...extraLineas].filter(Boolean);
  const detalle = [...detalleLineas, ...extraLineas].join("\n");
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  const meta = {
    accion: "mapa_nodos",
    evento: accion.toLowerCase().replace(/\s+/g, "_"),
    nodo_id: nodo.id,
    nodo_tipo: nodo.tipo,
  };
  const fechaEvento = obtenerFechaEventoNodo(nodo);
  registrarMapaNodosEvento({
    resumen,
    detalle,
    contenedores: contenedor ? [contenedor] : [],
    meta,
    fechaEvento,
    noteType,
  });
}

function construirConexionesNodoMapa(nodo) {
  const conexiones = [];
  if (!nodo) return conexiones;
  const nodoId = normalizarIdNodo(nodo);
  (nodo.targets || []).forEach(targetId => {
    const destino = buscarNodoPorId(targetId);
    if (destino) conexiones.push({ origen: nodo, destino });
  });
  flujoNodos.forEach(other => {
    if (!other.targets) return;
    if (other.targets.includes(nodoId)) {
      conexiones.push({ origen: other, destino: nodo });
    }
  });
  return conexiones;
}

function registrarDesconexionMapaNodos(nodo, conexiones) {
  const lista = Array.isArray(conexiones) ? conexiones : [];
  if (!lista.length) return;
  const resumen = `Conexiones eliminadas · mapa de nodos`;
  const lineas = [];
  lista.forEach(con => {
    const cantidad = construirCantidadConexionMapa(con.origen, con.destino);
    const origenTxt = describirNodoMapaNodos(con.origen);
    const destinoTxt = describirNodoMapaNodos(con.destino);
    lineas.push(`${origenTxt} → ${destinoTxt}${cantidad ? ` · ${cantidad}` : ""}`);
  });
  const detalle = lineas.join("\n");
  const contenedores = [];
  lista.forEach(con => {
    contenedores.push(resolverContenedorDesdeNodoControl(con.origen));
    contenedores.push(resolverContenedorDesdeNodoControl(con.destino));
  });
  const meta = {
    accion: "mapa_nodos",
    evento: "desconexion",
    nodo_id: nodo?.id || null,
    nodo_tipo: nodo?.tipo || null,
  };
  registrarMapaNodosEvento({ resumen, detalle, contenedores, meta, noteType: "accion" });
}

function abrirBitacoraDesdeNodo(nodo) {
  if (!nodo) return;
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor para abrir la bitácora.", "error");
    return;
  }
  if (typeof window.abrirModalBitacora !== "function") {
    mostrarAviso("No se pudo abrir la bitácora.", "error");
    return;
  }
  const nombre = obtenerNombreContenedorNodo(nodo);
  window.abrirModalBitacora({
    contenedorTipo: contenedor.tipo,
    contenedorId: contenedor.id,
    nombre,
  });
}

function abrirLimpiezaNodo(nodoId) {
  const nodo = flujoNodos.find(n => n.id === nodoId);
  if (!nodo) return;
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor antes de limpiar el nodo.", "error");
    return;
  }
  nodoLimpiezaId = nodo.id;
  const modal = document.getElementById("flowCleanModal");
  const titulo = document.getElementById("flowCleanTitulo");
  const detalle = document.getElementById("flowCleanDetalle");
  const check = document.getElementById("flowCleanCheck");
  const btnConfirmar = document.getElementById("flowCleanConfirm");
  const nombre = obtenerNombreContenedorNodo(nodo);
  if (titulo) titulo.textContent = `Limpieza de nodo · ${nombre}`;
  if (detalle) {
    detalle.textContent =
      "Vas a resetear la información del vino de este contenedor para iniciar una nueva línea. " +
      "Se borra: variedades, volumen, estado del vino, flags de vino activo/datos actuales. " +
      "Se mantiene: el nodo, el depósito/barrica y la Bitácora completa (NO se borra).";
  }
  if (check) {
    check.checked = false;
    check.onchange = () => {
      if (btnConfirmar) btnConfirmar.disabled = !check.checked;
    };
  }
  if (btnConfirmar) btnConfirmar.disabled = true;
  if (modal) modal.classList.add("visible");
}

function cerrarLimpiezaNodo() {
  const modal = document.getElementById("flowCleanModal");
  if (modal) modal.classList.remove("visible");
  nodoLimpiezaId = null;
}

function abrirLimpiezaNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  abrirLimpiezaNodo(nodoEnEdicion.id);
}

async function registrarBitacoraLimpieza(nodo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return;
  const meta = {
    accion: "limpieza",
    accion_texto: "Limpieza de nodo",
  };
  try {
    await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contenedor_tipo: contenedor.tipo,
        contenedor_id: contenedor.id,
        tipo: "accion",
        resumen: "Limpieza",
        detalle: "Reset de contenedor para iniciar nueva línea de vino (desde modal del nodo).",
        origen: "control",
        meta,
      }),
    });
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  } catch (_err) {
    // Silencioso para no romper el flujo.
  }
}

async function confirmarLimpiezaNodo() {
  if (!nodoLimpiezaId) return;
  const check = document.getElementById("flowCleanCheck");
  if (check && !check.checked) {
    mostrarAviso("Confirma la limpieza antes de continuar.", "info");
    return;
  }
  const nodo = flujoNodos.find(n => n.id === nodoLimpiezaId);
  if (!nodo) {
    cerrarLimpiezaNodo();
    return;
  }
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor antes de limpiar el nodo.", "error");
    cerrarLimpiezaNodo();
    return;
  }
  limpiarEstadoEnologicoNodo(nodo);
  cerrarLimpiezaNodo();
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarInfoNodo(nodo.id);
  if (nodoEnEdicion && nodoEnEdicion.id === nodo.id) {
    abrirFlowModal(nodo.id);
  }
  await registrarBitacoraLimpieza(nodo);
  try {
    await Promise.all([cargarDepositos(), cargarBarricas()]);
  } catch (err) {
    console.warn("No se pudieron refrescar los contenedores tras la limpieza:", err);
  }
  mostrarAviso("Nodo limpiado y listo para nueva línea.", "success");
}

function eliminarNodoPorId(id) {
  const nodo = flujoNodos.find(n => n.id === id) || null;
  flowAllowShrinkOnce = true;
  const conexionesPrevias = nodo ? construirConexionesNodoMapa(nodo) : [];
  const afectados = new Set();
  flujoNodos = flujoNodos.filter(n => n.id !== id);
  flujoNodos.forEach(n => {
    if (n.targets) {
      const longitudInicial = n.targets.length;
      n.targets = n.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== n.targets.length) {
        afectados.add(n.id);
        if (n.datos?.distribucion) {
          limpiarDistribucionEstilo(n);
        }
      }
    }
  });
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  nodoEnEdicion = null;
  mostrarInfoNodo(null);
  cerrarFlowModal();
  if (nodo) {
    registrarAccionNodoMapa("Nodo eliminado", nodo, { noteType: "accion", extraLineas: conexionesPrevias.map(con => {
      const cantidad = construirCantidadConexionMapa(con.origen, con.destino);
      const origenTxt = describirNodoMapaNodos(con.origen);
      const destinoTxt = describirNodoMapaNodos(con.destino);
      return `Conexión: ${origenTxt} → ${destinoTxt}${cantidad ? ` · ${cantidad}` : ""}`;
    }) });
  }
  mostrarAviso("Nodo eliminado.", "error");
}

async function actualizarDepositoContenido(idRef, variedad, volumen, anada) {
  if (!idRef) return;
  const dep = buscarDepositoPorId(idRef);
  if (!dep) return;
  const materialActual = dep.material || dep.contenido || "";
  // Intentar usar la mezcla real del nodo de flujo si existe
  let variedadNodo = "";
  const nodoDepo = flujoNodos.find(
    n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idRef)
  );
  if (nodoDepo) {
    try {
      const comp = calcularComposicionVariedades(nodoDepo);
      if (comp.mix.size) {
        guardarComposicionEnNodo(nodoDepo, comp.mix, comp.total);
        variedadNodo = formatearComposicionVariedades(comp.mix, comp.total);
      } else {
        variedadNodo = nodoDepo.datos?.variedad || nodoDepo.datos?.variedadBase || "";
      }
    } catch (e) {
      console.warn("No se pudo calcular mezcla del depósito para guardar:", e);
    }
  }
  const volumenNum = normalizarNumero(volumen);
  const hayVino = volumenNum == null ? true : volumenNum > 0;
  const variedadFinal = hayVino ? (variedadNodo || variedad || dep.vino_tipo) : "";
  try {
    const res = await fetch(`/api/depositos/${idRef}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo: dep.codigo,
        tipo: dep.tipo,
        capacidad_l:
          dep.capacidad_l != null ? dep.capacidad_l : dep.capacidad_hl != null ? dep.capacidad_hl * 100 : null,
        material: materialActual,
        contenido: materialActual,
        elaboracion: dep.elaboracion,
        vino_tipo: variedadFinal,
        vino_anio: anada || dep.vino_anio,
        fecha_uso: dep.fecha_uso,
        clase: dep.clase || "deposito",
        estado: dep.estado || "vacio",
      }),
    });
    if (res.ok) {
      await cargarDepositos();
    }
  } catch (err) {
    console.error("No se pudo actualizar el depósito:", err);
  }
}

	function mostrarInfoNodo(id) {
	  const panel = document.getElementById("flowNodeInfo");
	  if (!panel) return;
	  const escapeHtml = value =>
	    String(value ?? "")
	      .replace(/&/g, "&amp;")
	      .replace(/</g, "&lt;")
	      .replace(/>/g, "&gt;")
	      .replace(/\"/g, "&quot;")
	      .replace(/'/g, "&#39;");

	  const minimapHtml = `
	    <div class="flow-minimap-world" id="flowMinimapWorld" aria-label="Minimapa del mapa de nodos" role="img">
	      <div class="flow-minimap-grid"></div>
	      <div class="flow-minimap-dots" id="flowMinimapDots"></div>
	      <div class="flow-minimap-viewport" id="flowMinimapViewport"></div>
	    </div>
	    <div class="flow-minimap-hint">Minimapa: clic o arrastra para moverte · Zoom: botones ±</div>
	  `;

	  const renderEmpty = () => {
	    panel.innerHTML = `
	      <div class="flow-inspector-header">
	        <div class="flow-inspector-icon">🔎</div>
	        <div>
	          <div class="flow-inspector-title">Inspector</div>
	          <div class="flow-inspector-sub">Selecciona un nodo en el mapa para ver detalles.</div>
	        </div>
	      </div>
	      ${minimapHtml}
	      <div class="flow-inspector-tags">
	        <span class="flow-tag">Doble clic: editar</span>
	        <span class="flow-tag">Conectar: origen → destino</span>
	        <span class="flow-tag">Arrastrar: mover</span>
	        <span class="flow-tag">Click fuera: limpiar</span>
	      </div>
	      <dl class="flow-inspector-fields">
	        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Exportar imagen” para compartir el flujo.</dd></div>
	      </dl>
	    `;
	    inicializarMinimapFlow();
	    programarActualizacionMinimapFlow();
	  };

	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) {
	    renderEmpty();
	    return;
	  }

	  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
	  const iconHtml =
	    config.icono && config.icono.trim().startsWith("<")
	      ? config.icono
	      : escapeHtml(config.icono || "●");
	  const tituloNodo = escapeHtml(nodo.titulo || config.label);
	  const tipoLabel = escapeHtml(config.label || nodo.tipo || "Nodo");

	  const entradas = obtenerPredecesores(nodo.id).length;
	  const salidas = (nodo.targets || []).length;
	  const unidad = obtenerUnidadVisual(nodo);
	  const textoVolumen = obtenerTextoVolumenNodo(nodo);
    const diagVol = obtenerDiagnosticoVolumenContenedor(nodo);

	  const tags = [
	    `Tipo: ${tipoLabel}`,
	    `Entradas: ${entradas}`,
	    `Salidas: ${salidas}`,
	    `Unidad: ${unidad}`,
	  ];
    if (diagVol) {
      tags.push(`Fuente volumen: ${diagVol.fuente}`);
      if (diagVol.discrepancia && diagVol.delta != null) {
        tags.push(`Δ mapa/ficha: ${Math.abs(diagVol.delta).toFixed(1)} L`);
      }
    }
    if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
      const retenidoCapTag = obtenerVolumenRetenidoDestinoPorCapacidad(nodo);
      if (retenidoCapTag > 0.01) {
        tags.push(`Retenido por capacidad: ${retenidoCapTag.toFixed(1)} L`);
      }
    }

	  const campos = (config.campos || []).filter(campo => campo && campo.tipo !== "tablaControl");
	  const filas = campos
	    .map(campo => ({
	      label: campo.label,
	      value: obtenerValorCampoVisual(nodo, campo),
	    }))
	    .filter(item => item.label && item.value);
    if (diagVol) {
      if (diagVol.volumenMapa != null) {
        filas.push({ label: "Volumen mapa", value: `${Number(diagVol.volumenMapa.toFixed(2))} L` });
      }
      if (diagVol.volumenFicha != null) {
        filas.push({ label: "Volumen ficha", value: `${Number(diagVol.volumenFicha.toFixed(2))} L` });
      }
    }
    if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
      const retenidoCap = obtenerVolumenRetenidoDestinoPorCapacidad(nodo);
      if (retenidoCap > 0.01) {
        filas.push({ label: "Retenido por capacidad", value: `${Number(retenidoCap.toFixed(2))} L` });
      }
    }

	  const detalles =
	    filas.length > 0
	      ? `<dl class="flow-inspector-fields">${filas
	          .map(
	            item =>
	              `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
	          )
	          .join("")}</dl>`
	      : `<div class="flow-inspector-sub">Sin datos adicionales.</div>`;

	  panel.innerHTML = `
	    <div class="flow-inspector-header">
	      <div class="flow-inspector-icon">${iconHtml}</div>
	      <div>
	        <div class="flow-inspector-title">${tituloNodo}</div>
	        <div class="flow-inspector-sub">${escapeHtml(textoVolumen || "")}</div>
	      </div>
	    </div>
	    ${minimapHtml}
	    <div class="flow-inspector-tags">${tags
	      .map(t => {
          const warn = t.startsWith("Δ mapa/ficha") || t.startsWith("Retenido por capacidad:");
          return `<span class="flow-tag${warn ? " warn" : ""}">${escapeHtml(t)}</span>`;
        })
	      .join("")}</div>
	    ${detalles}
	  `;
	  inicializarMinimapFlow();
	  programarActualizacionMinimapFlow();
	}

function abrirFlowModal(id) {
	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) return;
  if (nodo.tipo === "entrada") {
    intentarPoblarNodoEntrada(nodo, true);
    sincronizarFechaEntradaNodo(nodo);
  }
  nodoEnEdicion = nodo;
  asegurarFechaCreacionNodo(nodoEnEdicion);
  nodoEnEdicionPrevio = JSON.parse(JSON.stringify(nodo));
  const modal = document.getElementById("flowModal");
  const titulo = document.getElementById("flowModalTitulo");
  const form = document.getElementById("flowModalForm");
  if (!modal || !titulo || !form) return;
  const btnLimpieza = document.getElementById("flowCleanBtn");
  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
  let nombreExtra = "";
  if (nodo.tipo === "deposito") {
    const infoDep = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const nom = nodo.datos?.codigo || infoDep?.codigo;
    if (nom) nombreExtra = ` ${nom}`;
  } else if (nodo.tipo === "barrica") {
    const infoBar = nodo.datos?.contenedor_id ? buscarBarricaPorId(nodo.datos.contenedor_id) : null;
    const nom = nodo.datos?.tipo || infoBar?.codigo || (nodo.datos?.contenedor_id ? `#${nodo.datos.contenedor_id}` : "");
    if (nom) nombreExtra = ` ${nom}`;
  }
  const tituloTexto = `Editar ${config.label}${nombreExtra}`;
  if (config.icono && config.icono.trim().startsWith("<")) {
    titulo.innerHTML = `${config.icono} ${tituloTexto}`;
  } else if (config.icono) {
    titulo.textContent = `${config.icono} ${tituloTexto}`;
  } else {
    titulo.textContent = tituloTexto;
  }
  form.innerHTML = "";
  if (btnLimpieza) {
    const esContenedorAccion = nodo.tipo === "deposito" || nodo.tipo === "barrica";
    btnLimpieza.style.display = esContenedorAccion ? "inline-flex" : "none";
  }
	  const camposOrdenados = ordenarCamposParaModal(config.campos);
	  camposOrdenados.forEach(campo => {
    if (nodo.tipo !== "entrada" && campo.id === "fecha") return;
	    const label = document.createElement("label");
	    label.textContent = campo.label;
	    if (campo.required) {
	      const marca = document.createElement("span");
	      marca.className = "field-required";
	      marca.textContent = " *";
	      label.appendChild(marca);
	    }
	    form.appendChild(label);
    if (campo.tipo === "tablaControl") {
      const tabla = crearTablaControlFermentacion(nodo);
      form.appendChild(tabla);
      return;
    }
    if (campo.tipo === "estadoVino") {
      const wrapper = document.createElement("div");
      wrapper.style.display = "grid";
      wrapper.style.gap = "6px";

      const select = document.createElement("select");
      select.id = `flowField-${campo.id}`;
      const optionEmpty = document.createElement("option");
      optionEmpty.value = "";
      optionEmpty.textContent = "Sin estado";
      select.appendChild(optionEmpty);
      ESTADOS_VINO.forEach(item => {
        const option = document.createElement("option");
        option.value = item.value;
        option.textContent = item.label;
        select.appendChild(option);
      });
      select.value = nodo.datos ? nodo.datos[campo.id] || "" : "";

      const input = document.createElement("input");
      input.type = "text";
      input.id = `flowField-${campo.id}-texto`;
      input.placeholder = "Estado personalizado";
      input.maxLength = 40;
      input.value = nodo.datos ? nodo.datos[`${campo.id}_texto`] || "" : "";
      input.style.display = select.value === ESTADO_PERSONALIZADO ? "block" : "none";

      select.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = select.value;
        const mostrar = select.value === ESTADO_PERSONALIZADO;
        input.style.display = mostrar ? "block" : "none";
        if (!mostrar) {
          input.value = "";
          nodo.datos[`${campo.id}_texto`] = "";
        }
      });
      input.addEventListener("input", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[`${campo.id}_texto`] = input.value;
      });

      wrapper.appendChild(select);
      wrapper.appendChild(input);
      form.appendChild(wrapper);
      return;
    }
    if (campo.tipo === "info") {
      const info = document.createElement("div");
      info.className = "campo-info";
      info.id = `flowField-${campo.id}-display`;
      const texto = obtenerValorCampoVisual(nodo, campo);
      info.textContent = texto || "—";
      form.appendChild(info);
      const hidden = document.createElement("input");
      hidden.type = "hidden";
      hidden.id = `flowField-${campo.id}`;
      hidden.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
      form.appendChild(hidden);
      return;
    }
    const esCampoProtegido =
      (nodo.tipo === "entrada" && campo.id !== "id_ref" && campo.id !== "merma") ||
      (["variedad", "fecha"].includes(campo.id) && nodo.tipo !== "entrada");
  const esCampoUnidadBloqueada =
      ["kilos", "litros", "litros_directos", "volumen"].includes(campo.id) &&
      nodo.tipo !== "entrada";
    let input;
    if (campo.tipo === "textarea") {
      input = document.createElement("textarea");
    } else if (campo.tipo === "select") {
      input = document.createElement("select");
      if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
        const tipoSeleccionado = nodo.datos?.contenedor_tipo || "";
        poblarSelectContenedorCrianza(input, tipoSeleccionado, nodo.datos?.contenedor_id || "");
      } else {
        if (campo.placeholder) {
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = campo.placeholder;
          placeholderOption.disabled = true;
          placeholderOption.selected = true;
          input.appendChild(placeholderOption);
        }
        (campo.opciones || []).forEach(op => {
          const option = document.createElement("option");
          option.value = op;
          option.textContent = op;
          input.appendChild(option);
        });
      }
    } else if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input = document.createElement("select");
      const idActualRaw =
        nodo.datos?.id_ref ??
        nodo.datos?.entradaId ??
        nodo.datos?.entryId ??
        "";
      const idActual = idActualRaw != null ? String(idActualRaw).trim() : "";
      const ids = nodo.tipo === "entrada"
        ? (cacheEntradas || []).map(e => {
            const dens = formatearDensidad(e.densidad);
            const temp = normalizarNumero(e.temperatura);
            const kilosVal = normalizarNumero(e.kilos);
            const mixEntrada = formatearResumenVariedades(e.composicionVariedades || e.composicion_variedades);
            const variedadesTexto = mixEntrada || e.variedad || "";
            const partes = [];
            if (variedadesTexto) partes.push(variedadesTexto);
            if (kilosVal != null) partes.push(`${kilosVal.toFixed(0)} kg`);
            if (dens) partes.push(`${dens} dens`);
            if (temp != null) partes.push(`${temp.toFixed(1)}°C`);
            const sufijo = partes.length ? ` (${partes.join(" · ")})` : "";
            return { id: e.id, label: `Entrada #${e.id}${sufijo}` };
          })
        : ([...(cacheDepositos || []), ...(cacheMastelones || [])].map(d => {
            const mixDep = formatearResumenVariedades(d.composicionVariedades || d.composicion_variedades);
            const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
            const volumenActual = Number.isFinite(estadoNodo?.volumen)
              ? Number(estadoNodo.volumen)
              : Number(d.litros_actuales || 0);
            const tieneVino = Number.isFinite(volumenActual) && volumenActual > 0;
            let variedades = tieneVino ? (mixDep || d.vino_tipo || "") : "";
            // Si el depósito está en el mapa de nodos, usar su mezcla real aunque aún no esté persistida en la BD.
            try {
              const nodoDepo = flujoNodos.find(
                n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(d.id)
              );
              if (nodoDepo && tieneVino) {
                const comp = calcularComposicionVariedades(nodoDepo);
                const texto = formatearComposicionVariedades(comp.mix, comp.total);
                if (texto) variedades = texto;
              }
            } catch (e) {
              // noop
            }
            const labelVar = variedades ? ` · ${variedades}` : "";
            const tipoCont = (d.clase || "").toString().toLowerCase() === "mastelone" ? "mastelone" : "deposito";
            const etiqueta = formatContainerLabel(d, { tipo: tipoCont }) || `Depósito #${d.id}`;
            return {
              id: d.id,
              label: etiqueta + labelVar,
            };
          }));
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent =
        nodo.tipo === "entrada" ? "Quitar vínculo de entrada" : "Selecciona depósito/mastelone";
      input.appendChild(empty);
      ids.forEach(item => {
        const option = document.createElement("option");
        option.value = item.id;
        option.textContent = item.label;
        input.appendChild(option);
      });
      // Si no hay cache (o falta ese id), mantenemos visible el vínculo actual para no perderlo al reabrir.
      if (
        idActual &&
        !ids.some(item => String(item.id) === idActual)
      ) {
        const fallback = document.createElement("option");
        fallback.value = idActual;
        fallback.textContent =
          nodo.tipo === "entrada"
            ? `Entrada #${idActual} (vinculada)`
            : `Contenedor #${idActual} (vinculado)`;
        input.appendChild(fallback);
      }
    } else {
      input = document.createElement("input");
      input.type = campo.tipo || "text";
    }
    input.id = `flowField-${campo.id}`;
    if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      const clave = claveContenedor(nodo.datos?.contenedor_tipo);
      input.value =
        clave && nodo.datos?.contenedor_id
          ? `${clave}:${nodo.datos.contenedor_id}`
          : "";
    } else if (campo.id === "variedad" && nodo.tipo !== "entrada") {
      const variedadVisible = obtenerVariedadVisibleNodo(nodo);
      input.value = variedadVisible || (nodo.datos ? nodo.datos[campo.id] || "" : "");
    } else {
      input.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
    }
	    if (campo.placeholder) input.placeholder = campo.placeholder;
	    if (campo.required) {
	      input.required = true;
	      input.setAttribute("aria-required", "true");
	    }
	    if (esCampoProtegido || campo.soloLectura || esCampoUnidadBloqueada) {
      if (input.tagName === "SELECT") {
        input.disabled = true;
      } else {
        input.readOnly = true;
      }
      input.classList.add("field-readonly");
      input.title = esCampoProtegido
        ? "Dato sincronizado desde Entrada de uva"
        : "El volumen se calcula automáticamente en el flujo";
    }
    if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        const nuevoId = String(input.value || "").trim();
        nodo.datos.id_ref = nuevoId;
        if (nodo.tipo === "entrada") {
          nodo.datos.entradaId = nuevoId;
          nodo.datos.entryId = nuevoId;
        }
        if (nodo.tipo === "entrada") {
          intentarPoblarNodoEntrada(nodo);
        } else {
          intentarPoblarNodoDeposito(nodo);
        }
        config.campos.forEach(c => {
          const campoInput = document.getElementById(`flowField-${c.id}`);
          if (campoInput && nodo.datos[c.id] != null) {
            campoInput.value = nodo.datos[c.id];
          }
          const displayEl = document.getElementById(`flowField-${c.id}-display`);
          if (displayEl) {
            const texto = obtenerValorCampoVisual(nodo, c) || "—";
            displayEl.textContent = texto;
          }
        });
        guardarEstadoNodos();
        renderFlowNodes();
        mostrarInfoNodo(nodo.id);
      });
    } else if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        const valor = input.value;
        if (!valor) {
          nodo.datos.contenedor_id = "";
          nodo.datos.contenedor_tipo = "";
          nodo.datos.tipo = "";
          guardarEstadoNodos();
          renderFlowNodes();
          return;
        }
        const [tipoSeleccionado, idSeleccionado] = valor.split(":");
        const idNumerico = idSeleccionado ? Number(idSeleccionado) : "";
        nodo.datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
        nodo.datos.contenedor_id = idNumerico;
        const infoCont = obtenerInfoContenedor(
          nodo.datos.contenedor_tipo === "Barrica" ? "barrica" : "deposito",
          idNumerico
        );
        const descripcion = describirContenedor(infoCont, nodo.datos.contenedor_tipo);
        nodo.datos.tipo = descripcion || nodo.datos.contenedor_tipo || "";
        // Rellenamos capacidad/volumen de la crianza al seleccionar contenedor para que el llenado funcione como en depósitos.
        if (infoCont) {
          const capInfo =
            infoCont.capacidad_l ??
            (infoCont.capacidad_hl != null ? infoCont.capacidad_hl * 100 : null);
          if (capInfo != null) {
            nodo.datos.capacidad = capInfo;
            nodo.datos.capacidad_l = capInfo;
          }
          if (infoCont.litros_actuales != null || infoCont.volumen != null) {
            const vol = infoCont.litros_actuales ?? infoCont.volumen;
            aplicarVolumenAbsoluto(nodo, vol, "litros", "seleccionar_contenedor");
          }
          const estadoCont = tipoSeleccionado === "barrica"
            ? obtenerEstadoBarricaDesdeNodo(idNumerico)
            : obtenerEstadoDepositoDesdeNodo(idNumerico);
          const variedadContenedor =
            formatearVariedadLinea(estadoCont?.variedad || "") ||
            obtenerVariedadPersistidaContenedor(infoCont) ||
            formatearVariedadLinea(infoCont.vino_tipo || "");
          nodo.datos.vino_tipo = variedadContenedor || nodo.datos.vino_tipo || "";
          nodo.datos.variedadBase = variedadContenedor || nodo.datos.variedadBase || "";
          if (!Array.isArray(nodo.datos.composicionVariedades) || !nodo.datos.composicionVariedades.length) {
            nodo.datos.variedad = variedadContenedor || nodo.datos.variedad || nodo.datos.variedadBase;
          }
        }
        const tipoInput = document.getElementById("flowField-tipo");
        if (tipoInput) {
          tipoInput.value = nodo.datos.tipo;
        }
        const variedadInput = document.getElementById("flowField-variedad");
        if (variedadInput) {
          const variedadVisible = obtenerVariedadVisibleNodo(nodo);
          variedadInput.value = variedadVisible || nodo.datos.variedad || nodo.datos.variedadBase || "";
        }
        guardarEstadoNodos();
        renderFlowNodes();
      });
    } else if (campo.id === "caja_botellas" && nodo.tipo === "almacen") {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos.caja_botellas = input.value || "6 botellas";
        actualizarResumenCajasAlmacen(nodo);
        guardarEstadoNodos();
        renderFlowNodes();
        mostrarInfoNodo(nodo.id);
      });
    } else if (nodo.tipo === "salida" && (campo.id === "cajas_cantidad" || campo.id === "cajas_tipo")) {
      const evt = campo.id === "cajas_cantidad" ? "input" : "change";
      input.addEventListener(evt, () => {
        nodo.datos = nodo.datos || {};
        if (campo.id === "cajas_cantidad") {
          nodo.datos.cajas_cantidad = input.value || "";
        } else {
          nodo.datos.cajas_tipo = input.value || "6 botellas";
        }
        actualizarBotellasTotalesSalida(nodo);
      });
    }
    if (
      nodo.tipo === "barrica" &&
      (campo.id === "tiempo" || campo.id === "fecha_operacion")
    ) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = input.value;
        refrescarDuracionModal(nodo);
      });
    }
    if (nodo.tipo === "embotellado" && campo.id === "botella") {
      input.addEventListener("change", () => actualizarBotellasResultantes(nodo));
    }
	    form.appendChild(input);
	    if (campo.required) {
	      const error = document.createElement("div");
	      error.className = "field-inline-error";
	      error.id = `flowField-${campo.id}-error`;
	      error.textContent = `Completa ${campo.label.toLowerCase()}.`;
	      form.appendChild(error);
	    }
	  });
  if (nodo.tipo === "barrica") {
    refrescarDuracionModal(nodo);
  }
  if (nodo.tipo === "embotellado") {
    actualizarBotellasResultantes(nodo);
    const labelFormatos = document.createElement("label");
    labelFormatos.textContent = "Formatos mixtos (opcional)";
    form.appendChild(labelFormatos);
    form.appendChild(crearTablaFormatosEmbotellado(nodo));
  }
  if (nodo.tipo === "almacen") {
    const selectCaja = document.getElementById("flowField-caja_botellas");
    if (selectCaja && !selectCaja.value) {
      selectCaja.value = nodo.datos?.caja_botellas || "6 botellas";
    }
    actualizarResumenCajasAlmacen(nodo);
  }
  if (nodo.tipo === "salida") {
    const selectTipoCaja = document.getElementById("flowField-cajas_tipo");
    if (selectTipoCaja && !selectTipoCaja.value) {
      selectTipoCaja.value = nodo.datos?.cajas_tipo || "6 botellas";
    }
    actualizarBotellasTotalesSalida(nodo);
  }
  if (nodo.tipo === "coupage") {
    const labelAsign = document.createElement("label");
    labelAsign.textContent =
      "Selecciona el volumen de cada depósito para el blend";
    form.appendChild(labelAsign);
    form.appendChild(crearTablaAsignacionesDeposito(nodo));
  }
  if (nodo.tipo === "estilo") {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de volumen hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEstilo(nodo));
  }
  if (nodo.tipo === "entrada" && (nodo.targets || []).length > 1) {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de kilos hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEntrada(nodo));
  }
  modal.classList.add("visible");
}

function cerrarFlowModal() {
  const modal = document.getElementById("flowModal");
  if (modal) modal.classList.remove("visible");
  nodoEnEdicion = null;
  nodoEnEdicionPrevio = null;
}

function resolverContenedorDesdeNodoControl(nodo) {
  if (!nodo) return null;
  if (nodo.tipo === "deposito") {
    const idRef = nodo.datos?.id_ref || nodo.datos?.contenedor_id;
    const idNum = Number(idRef);
    if (!Number.isFinite(idNum) || idNum <= 0) return null;
    const info = typeof buscarDepositoPorId === "function" ? buscarDepositoPorId(idNum) : null;
    const tipo = info?.clase === "mastelone" ? "mastelone" : "deposito";
    return { tipo, id: idNum };
  }
  if (nodo.tipo === "barrica") {
    const idNum = Number(nodo.datos?.contenedor_id);
    if (!Number.isFinite(idNum) || idNum <= 0) return null;
    const tipoRaw = (nodo.datos?.contenedor_tipo || "").toString().toLowerCase();
    const tipo = tipoRaw.includes("barrica") ? "barrica" : "deposito";
    return { tipo, id: idNum };
  }
  return null;
}

async function registrarBitacoraControl(nodo, previo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return;

  let resumen = "";
  let detalle = "";
  let tipo = "accion";
  let accion = "control";
  const meta = {};
  let fechaEvento = "";

  if (nodo.tipo === "deposito") {
    const controlPrevio = JSON.stringify(previo?.datos?.control || []);
    const controlActual = JSON.stringify(nodo.datos?.control || []);
    if (controlPrevio === controlActual) return;
    const registros = Array.isArray(nodo.datos?.control) ? nodo.datos.control : [];
    const ultimo = registros.length ? registros[registros.length - 1] : null;
    if (!ultimo) return;
    const densidad = ultimo.densidad ? Number(ultimo.densidad) : null;
    const temperatura = ultimo.temperatura ? Number(ultimo.temperatura) : null;
    const productos = (ultimo.productos || "").toString().trim();
    const estadoValor = (ultimo.estado_vino || "").toString().trim();
    const estadoTexto = (ultimo.estado_vino_texto || "").toString().trim();
    if (ultimo.fecha) {
      fechaEvento = ultimo.fecha;
    }
    const partes = [];
    if (Number.isFinite(densidad)) partes.push(`Densidad ${densidad}`);
    if (Number.isFinite(temperatura)) partes.push(`Temperatura ${temperatura}°C`);
    if (productos) partes.push(`Productos: ${productos}`);
    resumen = partes.join(" · ") || "Control de depósito";
    detalle = ultimo.fecha ? `Fecha: ${ultimo.fecha}` : "";
    tipo = Number.isFinite(densidad) || Number.isFinite(temperatura) ? "analitica" : "accion";
    if (Number.isFinite(densidad) && Number.isFinite(temperatura)) {
      accion = "densidad_temperatura";
    } else if (Number.isFinite(densidad)) {
      accion = "densidad";
    } else if (Number.isFinite(temperatura)) {
      accion = "temperatura";
    } else if (productos) {
      accion = "tratamiento";
    }
    meta.densidad = Number.isFinite(densidad) ? densidad : null;
    meta.temperatura = Number.isFinite(temperatura) ? temperatura : null;
    meta.productos = productos || null;
    meta.fecha = ultimo.fecha || null;
    if (estadoValor) {
      meta.estado = estadoValor === ESTADO_PERSONALIZADO
        ? { valor: ESTADO_PERSONALIZADO, texto: estadoTexto || "Personalizado" }
        : { valor: estadoValor };
    }
  } else if (nodo.tipo === "barrica") {
    const notaPrev = (previo?.datos?.notas || "").toString().trim();
    const notaActual = (nodo.datos?.notas || "").toString().trim();
    const estadoPrev = (previo?.datos?.estado_vino || "").toString().trim();
    const estadoPrevTexto = (previo?.datos?.estado_vino_texto || "").toString().trim();
    const estadoActual = (nodo.datos?.estado_vino || "").toString().trim();
    const estadoTexto = (nodo.datos?.estado_vino_texto || "").toString().trim();
    const estadoCambio = estadoPrev !== estadoActual || estadoPrevTexto !== estadoTexto;
    if (notaPrev === notaActual && !estadoCambio) return;
    const nota = (nodo.datos?.notas || "").toString().trim();
    if (!nota && !estadoActual) return;
    if (nota) {
      resumen = "Nota de crianza";
      detalle = nota;
      tipo = "nota";
      accion = "nota";
      meta.nota = nota;
    } else {
      resumen = "Estado del vino";
      detalle = "";
      tipo = "accion";
      accion = "estado_vino";
    }
    if (estadoActual) {
      meta.estado = estadoActual === ESTADO_PERSONALIZADO
        ? { valor: ESTADO_PERSONALIZADO, texto: estadoTexto || "Personalizado" }
        : { valor: estadoActual };
    }
  } else {
    return;
  }

  meta.accion = accion;
  try {
    const payload = {
      contenedor_tipo: contenedor.tipo,
      contenedor_id: contenedor.id,
      tipo,
      resumen,
      detalle,
      origen: "control",
      meta,
    };
    if (fechaEvento) {
      payload.fecha_hora = fechaEvento;
    }
    await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  } catch (_err) {
    // Silencioso para no romper el flujo del modal.
  }
}

function guardarNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  if (nodoEnEdicion.tipo === "entrada") {
    sincronizarFechaEntradaNodo(nodoEnEdicion);
  }
  const nodoId = nodoEnEdicion.id;
  const snapshot = JSON.parse(JSON.stringify(flujoNodos));
  const config = FLOW_NODE_TYPES[nodoEnEdicion.tipo];
  const datos = {};
  let primerCampoConError = null;
  const limpiarErrorCampo = campoId => {
    const err = document.getElementById(`flowField-${campoId}-error`);
    if (err) err.classList.remove("visible");
  };
  const mostrarErrorCampo = (campo, mensaje) => {
    const err = document.getElementById(`flowField-${campo.id}-error`);
    if (err) {
      err.textContent = mensaje;
      err.classList.add("visible");
    }
    if (!primerCampoConError) {
      primerCampoConError = campo.id;
    }
  };
  if (config) {
    (config.campos || []).forEach(campo => {
      if (!campo?.id) return;
      limpiarErrorCampo(campo.id);
    });
  }
  const metodoPrevio = nodoEnEdicion.datos?.metodo || "";
  const eraConversorAntes =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoPrevio) ||
    esMetodoSangrado(metodoPrevio);
	  if (config) {
	    config.campos.forEach(campo => {
	      if (campo.tipo === "tablaControl" || campo.tipo === "info") return;
	      const input = document.getElementById(`flowField-${campo.id}`);
      if (input) {
        if (campo.tipo === "estadoVino") {
          datos[campo.id] = input.value;
          const inputTexto = document.getElementById(`flowField-${campo.id}-texto`);
          if (inputTexto) {
            datos[`${campo.id}_texto`] = inputTexto.value;
          }
        } else if (campo.id === "contenedor_id" && nodoEnEdicion.tipo === "barrica") {
          const valor = input.value;
          if (!valor) {
            datos.contenedor_id = "";
            datos.contenedor_tipo = "";
          } else {
            const [tipoSeleccionado, idSeleccionado] = valor.split(":");
            datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
            datos.contenedor_id = idSeleccionado ? Number(idSeleccionado) : "";
          }
        } else {
          datos[campo.id] = input.value;
        }
      } else if (nodoEnEdicion.datos && nodoEnEdicion.datos[campo.id] != null) {
        datos[campo.id] = nodoEnEdicion.datos[campo.id];
      }
    });
  }
  let hayErrores = false;
  if (config) {
    (config.campos || []).forEach(campo => {
      if (!campo?.required) return;
      if (campo.tipo === "tablaControl" || campo.tipo === "info") return;
      const valor = datos[campo.id] != null ? datos[campo.id] : nodoEnEdicion?.datos?.[campo.id];
      if (String(valor ?? "").trim()) return;
      hayErrores = true;
      mostrarErrorCampo(campo, `Completa ${campo.label.toLowerCase()}.`);
    });
  }
  if (hayErrores) {
    if (primerCampoConError) {
      const input = document.getElementById(`flowField-${primerCampoConError}`);
      if (input && typeof input.focus === "function") input.focus();
    }
    mostrarAviso("Faltan campos obligatorios en el nodo.", "error");
    return;
  }
	  const metodoCandidato = datos.metodo != null ? datos.metodo : metodoPrevio;
	  const esConversorCandidato =
	    nodoEnEdicion.tipo === "prensado" ||
	    esMetodoPrensado(metodoCandidato) ||
	    esMetodoSangrado(metodoCandidato);
  nodoEnEdicion.datos = { ...(nodoEnEdicion.datos || {}), ...datos };
  asegurarMermaPorDefecto(nodoEnEdicion);
  actualizarDuracionPrevista(nodoEnEdicion);
  if (mapearRolPorTipo(nodoEnEdicion.tipo) === "SOURCE") {
    recalcularVolumenNodo(nodoEnEdicion, "guardar_modal");
  }
  actualizarTituloNodo(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "entrada") {
    intentarPoblarNodoEntrada(nodoEnEdicion);
  } else if (nodoEnEdicion.tipo === "deposito") {
    intentarPoblarNodoDeposito(nodoEnEdicion);
    actualizarVariedadDesdeAportes(nodoEnEdicion);
  }
  guardarEstadoNodos();
  renderFlowNodes();
  if (nodoEnEdicion.tipo === "embotellado") {
    cargarEmbotellados();
  }
  mostrarInfoNodo(nodoId);
  sincronizarNodoConSistema(nodoEnEdicion);
  const nodoPrevio = nodoEnEdicionPrevio || snapshot.find(n => n.id === nodoId) || null;
  registrarBitacoraControl(nodoEnEdicion, nodoPrevio);
  const datosPrevios = JSON.stringify(nodoPrevio?.datos || {});
  const datosActuales = JSON.stringify(nodoEnEdicion?.datos || {});
  const tituloPrevio = nodoPrevio?.titulo || "";
  const tituloActual = nodoEnEdicion?.titulo || "";
  if (datosPrevios !== datosActuales || tituloPrevio !== tituloActual) {
    registrarAccionNodoMapa("Nodo actualizado", nodoEnEdicion, { noteType: "accion" });
  }
  cerrarFlowModal();
}

function intentarPoblarNodoEntrada(nodo, silencioso = false) {
  const id = Number(nodo.datos.id_ref || nodo.datos.entradaId || nodo.datos.entryId);
  if (!id || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => Number(e.id) === id);
  if (!entrada) {
    if (!silencioso) {
      mostrarAviso("No se encontró la entrada con ese ID.", "error");
    }
    return;
  }
  nodo.datos.id_ref = id;
  nodo.datos.entradaId = id;
  nodo.datos.entryId = id;
  const fechaEntrada =
    entrada.fecha ||
    entrada.fecha_entrada ||
    entrada.fecha_recepcion ||
    entrada.fecha_registro ||
    "";
  const fechaIso = normalizarFechaSoloDia(fechaEntrada);
  if (fechaIso) {
    nodo.datos.fecha_entrada_bodega = fechaIso;
    nodo.datos.fecha = fechaIso;
  }
  actualizarTituloNodo(nodo);
  if (!silencioso) {
    mostrarAviso("Entrada vinculada al nodo.", "success");
  }
}

function intentarPoblarNodoDeposito(nodo, silencioso = false, evitarRedistribuir = false) {
  const idRef = nodo?.datos?.id_ref;
  if (idRef == null || idRef === "") return;
  const deposito = buscarDepositoPorId(idRef) || buscarDepositoPorCodigo(idRef);
  if (!deposito) {
    if (!silencioso) {
      mostrarAviso("No se encontró el depósito/mastelone con ese ID o código.", "error");
    }
    return;
  }
  const esRaiz = nodo?.id ? obtenerPredecesores(nodo.id).length === 0 : false;
  // Normalizar: si venía un código (p.ej. 'M1'), guardamos el id real para el resto del flujo.
  if (nodo.datos && deposito.id != null && String(nodo.datos.id_ref) !== String(deposito.id)) {
    nodo.datos.id_ref = deposito.id;
  }
  const camposResguardar = ["volumen", "tipo", "material", "fase", "kilos", "variedad"];
  const valoresPrevios = {};
  camposResguardar.forEach(campo => {
    if (!nodo.datos) return;
    const valor = nodo.datos[campo];
    if (valor == null || valor === "") return;
    // Si viene a 0 (default), dejamos que el depósito real rellene el volumen/kilos.
    if (["volumen", "kilos"].includes(campo)) {
      const num = normalizarNumero(valor);
      if (num != null && num !== 0) {
        valoresPrevios[campo] = valor;
      }
      return;
    }
    valoresPrevios[campo] = valor;
  });
  const controlPrevio = Array.isArray(nodo.datos.control)
    ? nodo.datos.control.map(item => ({ ...item }))
    : null;
  const asignacionesPrevias = nodo.datos.asignaciones
    ? JSON.parse(JSON.stringify(nodo.datos.asignaciones))
    : null;
  nodo.datos.codigo = deposito.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    deposito.capacidad_l ||
    (deposito.capacidad_hl ? deposito.capacidad_hl * 100 : nodo.datos.capacidad);
  // Solo rellenamos volumen desde el sistema cuando el nodo es un "punto de partida" (sin entradas).
  // En nodos intermedios, el volumen se reconstruye por asignaciones/aportes del flujo.
  if (esRaiz) {
    const volBase = deposito.litros_actuales ?? nodo.datos.volumen;
    if (volBase != null) {
      aplicarVolumenAbsoluto(nodo, volBase, "litros", "cache_deposito");
    }
  }
  nodo.datos.vino = deposito.vino_tipo || nodo.datos.vino;
  // No sobreescribir variedad: se hereda desde la entrada/asignaciones
  nodo.datos.estado = deposito.estado || nodo.datos.estado;
  nodo.datos.fecha = deposito.fecha_uso ? deposito.fecha_uso.slice(0, 10) : nodo.datos.fecha;
  nodo.datos.material = deposito.material || deposito.contenido || nodo.datos.material;
  nodo.datos.tipo = deposito.tipo || nodo.datos.tipo;
  Object.entries(valoresPrevios).forEach(([campo, valor]) => {
    nodo.datos[campo] = valor;
  });
  if (controlPrevio) {
    nodo.datos.control = controlPrevio;
  }
  if (asignacionesPrevias) {
    nodo.datos.asignaciones = asignacionesPrevias;
  }
  recalcularVolumenNodo(nodo, "cache_deposito");
  actualizarTituloNodo(nodo);
  if (!silencioso) {
    mostrarAviso("Datos del nodo cargados desde el depósito.", "success");
  }
}

function eliminarNodoActivo() {
  if (!nodoEnEdicion) return;
  eliminarNodoPorId(nodoEnEdicion.id);
}

function guardarEstadoNodos() {
  try {
    const flow = sanitizarFlowParaGuardar();
    localStorage.setItem("flowNodes", JSON.stringify(flow));
    if (flowDebugActivo()) {
      console.debug("[flow][persist]", { destino: "localStorage", nodos: flow.nodes.length });
    }
  } catch (err) {
    console.warn("No se pudo guardar nodos en localStorage:", err);
  }
  if (temporizadorGuardadoFlujo) {
    clearTimeout(temporizadorGuardadoFlujo);
  }
  temporizadorGuardadoFlujo = setTimeout(() => {
    temporizadorGuardadoFlujo = null;
    guardarFlujoEnServidor();
  }, RETARDO_GUARDADO_FLUJO);
}

async function cargarNodosGuardados() {
  try {
    const res = await fetch("/api/flujo");
    if (res.ok) {
      const data = await res.json();
      const raw = data.flow ?? data.nodos ?? data;
      const normalizado = migrarSnapshotLegacy(raw);
        if (Array.isArray(normalizado.nodes)) {
        flujoNodos = normalizado.nodes;
        flowExpandedIds = new Set();
        flowMovements = normalizado.movements;
        flowEdges = normalizado.edges || [];
        flowCompositions = normalizado.compositions || [];
        flowSchemaVersion = normalizado.schemaVersion;
        hidratarNodosContenedor(flujoNodos);
        flowCompositionsDirty = true;
        const migrado = flowCoreMigrated;
        flowCoreMigrated = false;
        flowBalancesDirty = true;
        normalizarFlujoNodos();
        recalcularBalancesFlow();
        if (flowDebugActivo()) {
          console.log(
            "[flow][load]",
            {
              schemaVersion: flowSchemaVersion,
              nodes: flujoNodos.length,
              edges: flowEdges.length,
              movements: flowMovements.length,
              warnings: flowWarnings.length,
            }
          );
        }
        if (migrado) {
          guardarEstadoNodos();
        }
        return;
      }
    }
  } catch (err) {
    console.warn("No se pudo cargar flujo del servidor:", err);
    if (!avisoServidorFlujoMostrado) {
      avisoServidorFlujoMostrado = true;
      mostrarAviso("Servidor no disponible. Se usa la copia local del mapa.", "info");
    }
  }
  try {
    const guardados = JSON.parse(localStorage.getItem("flowNodes"));
    const normalizado = migrarSnapshotLegacy(guardados);
    if (Array.isArray(normalizado.nodes)) {
        flujoNodos = normalizado.nodes;
        flowExpandedIds = new Set();
        flowMovements = normalizado.movements;
        flowEdges = normalizado.edges || [];
        flowCompositions = normalizado.compositions || [];
        flowSchemaVersion = normalizado.schemaVersion;
        hidratarNodosContenedor(flujoNodos);
      flowCompositionsDirty = true;
      const migrado = flowCoreMigrated;
      flowCoreMigrated = false;
      flowBalancesDirty = true;
      normalizarFlujoNodos();
      recalcularBalancesFlow();
      if (flowDebugActivo()) {
        console.log(
          "[flow][load]",
          {
            schemaVersion: flowSchemaVersion,
            nodes: flujoNodos.length,
            edges: flowEdges.length,
            movements: flowMovements.length,
            warnings: flowWarnings.length,
            }
          );
      }
      if (migrado) {
        guardarEstadoNodos();
      }
    }
  } catch (err) {
    flujoNodos = [];
  }
}

document.addEventListener("DOMContentLoaded", () => {
  cargarFlowWarningsDebug();
  const toggle = document.getElementById("flowWarningsDebugToggle");
  if (toggle) {
    toggle.addEventListener("change", () => {
      setFlowWarningsDebug(toggle.checked);
    });
  }
});

async function guardarFlujoEnServidor() {
  try {
    const flow = sanitizarFlowParaGuardar();
    const res = await fetch("/api/flujo", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ...flow, force: flowAllowShrinkOnce }),
    });
    if (res.status === 409) {
      let msg = "Guardado bloqueado: el mapa se ha reducido. Confirma la eliminación.";
      try {
        const data = await res.json();
        if (data?.previo != null && data?.nuevo != null) {
          msg = `Guardado bloqueado: mapa reducido (${data.nuevo}/${data.previo}).`;
        }
      } catch (e) {
        // noop
      }
      mostrarAviso(msg, "error");
      return;
    }
    if (flowDebugActivo()) {
      console.debug("[flow][persist]", {
        destino: "servidor",
        ok: res.ok,
        status: res.status,
        nodos: flow.nodes.length,
      });
    }
    if (res.ok) {
      flowAllowShrinkOnce = false;
    }
  } catch (err) {
    console.warn("No se pudo sincronizar el flujo con el servidor:", err);
  }
}

function limpiarNodosFlujo() {
  const campaniaActiva = obtenerCampaniaActivaCliente();
  const etiqueta = campaniaActiva ? `AÑADA ${campaniaActiva}` : "AÑADA ACTIVA";
  const confirmacion = prompt(`Escribe ${etiqueta} para vaciar solo ese mapa.`) || "";
  if (confirmacion.trim().toUpperCase() !== etiqueta.toUpperCase()) {
    mostrarAviso("Confirmación incorrecta. No se vació el mapa.", "info");
    return;
  }
  flowAllowShrinkOnce = true;
  flujoNodos = [];
  guardarEstadoNodos();
  renderFlowNodes();
  guardarFlujoEnServidor();
  registrarBitacoraMapaNodosGeneral("Mapa de nodos vaciado · mapa de nodos", "accion");
}

// Resetea el mapa localmente sin pedir confirmación extra (botón rápido)
function resetMapaFlujoLocal() {
  const campaniaActiva = obtenerCampaniaActivaCliente();
  const etiqueta = campaniaActiva ? `AÑADA ${campaniaActiva}` : "AÑADA ACTIVA";
  const confirmacion = prompt(`Escribe ${etiqueta} para vaciar solo ese mapa.`) || "";
  if (confirmacion.trim().toUpperCase() !== etiqueta.toUpperCase()) {
    mostrarAviso("Confirmación incorrecta. No se vació el mapa.", "info");
    return;
  }
  flowAllowShrinkOnce = true;
  flujoNodos = [];
  guardarEstadoNodos();
  guardarFlujoEnServidor();
  renderFlowNodes();
  mostrarAviso("Mapa vaciado.", "success");
  registrarBitacoraMapaNodosGeneral("Mapa de nodos vaciado · mapa de nodos", "accion");
}

// Carga un mapa mínimo con entrada → depósito para probar desde cero
function seedMapaSimple() {
  const entradaId = generarIdNodo();
  const depositoId = generarIdNodo();
  const entrada = {
    id: entradaId,
    tipo: "entrada",
    titulo: "Entrada de uva",
    x: 120,
    y: 140,
    datos: {
      variedad: "Tempranillo",
      kilos: 1000,
      fecha: new Date().toISOString().slice(0, 10),
    },
    targets: [depositoId],
  };
  asegurarMermaPorDefecto(entrada);
  const deposito = {
    id: depositoId,
    tipo: "deposito",
    titulo: "Depósito A1",
    x: 380,
    y: 160,
    datos: {
      codigo: "A1",
      capacidad: 1500,
      volumen: 0,
      variedad: "",
    },
    targets: [],
  };
  asegurarMermaPorDefecto(deposito);
  flujoNodos = [entrada, deposito];
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Mapa simple cargado.", "success");
}

async function sincronizarNodoConSistema(nodo) {
  if (!nodo || nodo.datos?.sincronizado) return;
  try {
    switch (nodo.tipo) {
      case "entrada":
        await sincronizarEntradaDesdeNodo(nodo);
        break;
      case "embotellado":
        await sincronizarEmbotelladoDesdeNodo(nodo);
        break;
      default:
        // Para depósitos y barricas solo se crea desde el formulario manual.
        break;
    }
  } catch (err) {
    console.error("No se pudo sincronizar nodo:", err);
    mostrarAviso("No se pudo sincronizar el nodo con la base de datos.", "error");
  }
}

async function sincronizarEntradaDesdeNodo(nodo) {
  if (nodo.datos.id_ref) {
    mostrarAviso("La entrada ya existe en la base de datos.", "info");
    nodo.datos.sincronizado = true;
    return;
  }
  const kilos = Number(nodo.datos.kilos || 0);
  if (!kilos) {
    mostrarAviso("Indica kilos para sincronizar la entrada.", "error");
    return;
  }
  const fechaEntradaNodo =
    nodo.datos.fecha_entrada_bodega ||
    nodo.datos.fecha_entrada ||
    nodo.datos.fecha ||
    "";
  if (!fechaEntradaNodo) {
    mostrarAviso("Falta la fecha de entrada de uva en bodega.", "error");
    return;
  }
  const body = {
    fecha: fechaEntradaNodo,
    variedad: nodo.datos.variedad || "Variedad nodo",
    viticultor: "",
    tipo_suelo: "",
    parcela: nodo.datos.parcela || "",
    anos_vid: null,
    kilos,
    destinos: [],
  };
  const res = await fetch("/api/entradas_uva", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la entrada desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Entrada creada desde el nodo.", "success");
    await cargarEntradas();
  }
}

async function sincronizarDepositoDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || nodo.datos.volumen || 0);
  if (!capacidad) {
    mostrarAviso("Indica capacidad para el depósito.", "error");
    return;
  }
  const material = nodo.datos.material || nodo.datos.contenido || "";
  const body = {
    codigo,
    clase: "deposito",
    tipo: nodo.datos.tipo || "",
    capacidad_l: capacidad,
    material,
    contenido: material,
    vino_tipo: nodo.datos.variedad || nodo.datos.vino || "",
    vino_anio: nodo.datos.anada || "",
    elaboracion: nodo.datos.elaboracion || "",
    fecha_uso: nodo.datos.fecha || null,
    estado: nodo.datos.estado || "vacio",
  };
  const res = await fetch("/api/depositos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el depósito desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Depósito creado desde el nodo.", "success");
    await cargarDepositos();
  }
}

async function sincronizarBarricaDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || 225);
  const body = {
    codigo,
    capacidad_l: capacidad,
    tipo_roble: nodo.datos.tipo || "",
    tostado: nodo.datos.tostado || "",
    marca: nodo.datos.marca || "",
    anio: nodo.datos.anio || "",
    vino_anio: nodo.datos.anada || "",
    vino_tipo: nodo.datos.vino || "",
  };
  const res = await fetch("/api/barricas", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la barrica desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Barrica creada desde el nodo.", "success");
    await cargarBarricas();
  }
}

async function sincronizarEmbotelladoDesdeNodo(nodo) {
  const resumen = calcularResumenFormatosBotella(nodo);
  const litros = Number(
    nodo.datos.litros ||
    resumen.totalLitros ||
    obtenerLitrosDisponiblesPredecesoresLedger(nodo) ||
    0
  );
  if (!litros) {
    mostrarAviso("Indica volumen para el embotellado.", "error");
    return;
  }
  const lote = String(nodo?.datos?.lote || "").trim();
  if (!lote) {
    mostrarAviso("Indica el nombre del lote en opciones del nodo embotellado.", "error");
    return;
  }
  const formatos = Array.isArray(nodo.datos?.formatos_botella)
    ? nodo.datos.formatos_botella
    : null;
  const body = {
    fecha: nodo.datos.fecha_operacion || nodo.datos.fecha || new Date().toISOString(),
    contenedor_tipo: nodo.datos.origen_tipo || "deposito",
    contenedor_id: Number(nodo.datos.origen_id || 1),
    litros,
    botellas: Number(nodo.datos.botellas || 0) || resumen.totalBotellas || null,
    lote,
    nota: nodo.datos.notas || "",
    formatos: formatos && formatos.length ? formatos : null,
  };
  const res = await fetch("/api/embotellados", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el embotellado desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Embotellado creado desde el nodo.", "success");
    await cargarEmbotellados();
  }
}

function toggleNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (!menu || !toggle) return;
  const abierto = menu.classList.toggle("visible");
  toggle.classList.toggle("open", abierto);
  if (abierto) {
    prepararNavMenuAbierto();
  } else {
    limpiarNavBusqueda();
  }
}

function cerrarNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (menu) menu.classList.remove("visible");
  if (toggle) toggle.classList.remove("open");
  limpiarNavBusqueda();
}

function prepararNavMenuAbierto() {
  const input = document.getElementById("navSearch");
  if (!input) return;
  try {
    input.focus({ preventScroll: true });
    input.select();
  } catch (e) {
    // noop
  }
}

function normalizarTextoBusqueda(texto) {
  return (texto || "")
    .toString()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim();
}

function filtrarNavMenu(valor) {
  const menu = document.getElementById("navMenu");
  if (!menu) return;
  const empty = document.getElementById("navSearchEmpty");
  const q = normalizarTextoBusqueda(valor);
  const enlaces = Array.from(menu.querySelectorAll("a"));
  let visibles = 0;
  enlaces.forEach(a => {
    if (!q) {
      a.classList.remove("nav-item-hidden");
      return;
    }
    const txt = normalizarTextoBusqueda(
      [
        a.textContent,
        a.dataset.section || "",
        a.dataset.keywords || "",
        a.getAttribute("title") || "",
      ].join(" ")
    );
    const visible = txt.includes(q);
    a.classList.toggle("nav-item-hidden", !visible);
    if (visible) visibles += 1;
  });
  if (empty) {
    empty.style.display = q && visibles === 0 ? "block" : "none";
  }
}

function limpiarNavBusqueda() {
  const input = document.getElementById("navSearch");
  if (input) input.value = "";
  filtrarNavMenu("");
}

function onNavSearchKeydown(ev) {
  const menu = document.getElementById("navMenu");
  if (!menu) return;
  const key = ev.key || "";
  if (key === "Escape") {
    ev.preventDefault();
    cerrarNavMenu();
    return;
  }
  if (key === "Enter") {
    ev.preventDefault();
    const first = menu.querySelector("a:not(.nav-item-hidden)");
    if (first) {
      first.click();
    }
    return;
  }
  if (key === "ArrowDown") {
    ev.preventDefault();
    const first = menu.querySelector("a:not(.nav-item-hidden)");
    if (first) first.focus();
    return;
  }
}

function obtenerInicialesUsuario(usuario) {
  if (!usuario) return "--";
  const partes = usuario
    .split(/[^A-Za-z0-9]+/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) {
    return usuario.slice(0, 2).toUpperCase();
  }
  if (partes.length === 1) {
    return (partes[0][0] || partes[0]).toUpperCase().slice(0, 2);
  }
  return (
    (partes[0][0] || "") +
    (partes[1][0] || "")
  ).toUpperCase();
}

function obtenerIdentificadoresContenedor(tipo, idRef) {
  const ids = new Set();
  if (idRef != null && idRef !== "") ids.add(String(idRef));
  if (tipo === "deposito") {
    const dep = buscarDepositoPorId(idRef) || buscarDepositoPorCodigo(idRef);
    if (dep?.id != null) ids.add(String(dep.id));
    if (dep?.codigo) ids.add(String(dep.codigo));
  } else if (tipo === "barrica") {
    const bar = buscarBarricaPorId(idRef) || buscarBarricaPorCodigo(idRef);
    if (bar?.id != null) ids.add(String(bar.id));
    if (bar?.codigo) ids.add(String(bar.codigo));
  }
  return Array.from(ids).filter(Boolean);
}

function normalizarClaveContenedor(valor) {
  return normalizarTextoCompacto(valor).replace(/[^a-z0-9]/g, "");
}

function extraerTokensContenedor(valor) {
  const raw = (valor || "").toString().trim();
  if (!raw) return [];
  const tokens = new Set();
  const addToken = t => {
    const key = normalizarClaveContenedor(t);
    if (key) tokens.add(key);
  };
  addToken(raw);
  const base = normalizarTextoCompacto(raw);
  base.split(/[^a-z0-9]+/).forEach(addToken);
  const codigos = base.match(/\b[a-z]{0,4}\d{1,6}[a-z]{0,2}\b/g) || [];
  codigos.forEach(addToken);
  return Array.from(tokens);
}

function obtenerNodoFinalContenedor(tipo, idRef) {
  if (idRef == null || !Array.isArray(flujoNodos)) return null;
  const ids = obtenerIdentificadoresContenedor(tipo, idRef);
  if (!ids.length) return null;
  const idsSet = new Set(
    ids.flatMap(extraerTokensContenedor).filter(Boolean)
  );
  const coincide = n => {
    if (!n || n.tipo !== tipo) return false;
    const datos = n.datos || {};
    const nombreCorto = obtenerNombreCortoContenedor(n);
    const candidatos = [
      datos.id_ref,
      datos.contenedor_id,
      datos.codigo,
      datos.name,
      datos.nombre,
      datos.alias,
      n.titulo,
      nombreCorto,
      n.id,
    ].filter(v => v != null && v !== "");
    return candidatos.some(v =>
      extraerTokensContenedor(v).some(token => idsSet.has(token))
    );
  };
  const candidatos = flujoNodos.filter(coincide);
  if (!candidatos.length) return null;
  const esFinal = nodo => {
    const targets = nodo.targets || [];
    return !targets.some(tid => {
      const target = obtenerNodoPorId(tid);
      return target && TIPOS_CONTENEDOR_FLUJO.has(target.tipo);
    });
  };
  const finales = candidatos.filter(esFinal);
  const elegidos = finales.length ? finales : candidatos;
  return elegidos[elegidos.length - 1] || null;
}

function obtenerEstadoContenedorDesdeNodo(tipo, idRef) {
  if (!idRef || !Array.isArray(flujoNodos)) return null;
  const nodo = obtenerNodoFinalContenedor(tipo, idRef);
  if (!nodo) return null;
  let variedadTexto = "";
  try {
    variedadTexto = obtenerVariedadVisibleNodo(nodo) || "";
  } catch (e) {
    // noop
  }
  const volumen = obtenerVolumenNumericoNodo(nodo);
  const volumenNum = Number.isFinite(volumen) ? Number(volumen) : null;
  if (!Number.isFinite(volumenNum) || volumenNum <= 0) {
    variedadTexto = "";
  }
  return {
    volumen: volumenNum,
    variedad: variedadTexto,
    enMapa: true,
  };
}

function obtenerVolumenFinalNodoContenedor(tipo, idRef) {
  const ultimo = obtenerNodoFinalContenedor(tipo, idRef);
  if (!ultimo) return null;
  const volumen = obtenerVolumenNumericoNodo(ultimo);
  return Number.isFinite(volumen) ? volumen : null;
}

function obtenerEstadoBarricaDesdeNodo(idBarrica) {
  return obtenerEstadoContenedorDesdeNodo("barrica", idBarrica);
}

function formatearFechaTopbar(date = new Date()) {
  const fmt = new Intl.DateTimeFormat("es-ES", {
    weekday: "long",
    day: "2-digit",
    month: "short",
  });
  return fmt.format(date).replace(/\./g, "").toUpperCase();
}

function formatearHoraTopbar(date = new Date()) {
  return date.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
}

function obtenerCampaniaActivaCliente() {
  const sel = document.getElementById("topbarAnada");
  const selVal = (sel?.value || "").toString().trim();
  const storedVal = (localStorage.getItem("bodega_campania_activa") || "").toString().trim();
  const candidate = selVal || storedVal;
  const year = Number(candidate);
  if (!Number.isFinite(year) || year < 1900 || year > 2999) return "2025";
  return String(year);
}

const _nativeFetchBodega = window.fetch.bind(window);
window.fetch = function fetchConCampania(input, init = undefined) {
  const reqUrl = typeof input === "string" ? input : (input?.url || "");
  if (!reqUrl || !reqUrl.startsWith("/api/")) {
    return _nativeFetchBodega(input, init);
  }
  if (reqUrl.startsWith("/api/campanias") || reqUrl.startsWith("/api/me")) {
    return _nativeFetchBodega(input, init);
  }
  const reqHeaders = typeof Request !== "undefined" && input instanceof Request
    ? input.headers
    : undefined;
  const headers = new Headers(reqHeaders || {});
  if (init?.headers) {
    new Headers(init.headers).forEach((value, key) => headers.set(key, value));
  }
  const campaniaActiva = obtenerCampaniaActivaCliente();
  if (campaniaActiva && !headers.has("x-campania-id")) {
    headers.set("x-campania-id", campaniaActiva);
  }
  return _nativeFetchBodega(input, { ...(init || {}), headers });
};

function setTopbarAnadaMsg(texto, estado = "") {
  const msg = document.getElementById("topbarAnadaMsg");
  if (!msg) return;
  msg.textContent = texto || "";
  msg.classList.toggle("error", estado === "error");
}

function ajustarAnchoSelectAnada(sel) {
  if (!sel) return;
  const option = sel.options[sel.selectedIndex];
  if (!option) return;
  const texto = option.textContent || "";
  const style = window.getComputedStyle(sel);
  const canvas = ajustarAnchoSelectAnada._canvas || (ajustarAnchoSelectAnada._canvas = document.createElement("canvas"));
  const ctx = canvas.getContext("2d");
  const font = `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${style.fontSize} / ${style.lineHeight} ${style.fontFamily}`;
  ctx.font = font;
  const widthTexto = ctx.measureText(texto).width;
  const letterSpacing = style.letterSpacing === "normal" ? 0 : parseFloat(style.letterSpacing) || 0;
  const extraSpacing = letterSpacing > 0 ? letterSpacing * Math.max(texto.length - 1, 0) : 0;
  const padLeft = parseFloat(style.paddingLeft) || 0;
  const padRight = parseFloat(style.paddingRight) || 0;
  sel.style.width = `${Math.ceil(widthTexto + extraSpacing + padLeft + padRight)}px`;
}

async function cargarTopbarFechaYAnada() {
  const elFecha = document.getElementById("topbarFecha");
  if (elFecha) elFecha.textContent = formatearFechaTopbar();
  const elHora = document.getElementById("topbarHora");
  if (elHora) elHora.textContent = formatearHoraTopbar();

  const sel = document.getElementById("topbarAnada");
  if (!sel) return;

  try {
    const r = await fetch("/api/campanias", { credentials: "same-origin" });
    if (!r.ok) return;
    const data = await r.json();
    if (!data?.campanias) return;

    const campaniasMap = new Map(
      data.campanias.map(c => [Number(c.anio), c]).filter(([anio]) => Number.isFinite(anio))
    );

    sel.innerHTML = "";
    for (let anio = 2020; anio <= 2040; anio += 1) {
      const existente = campaniasMap.get(anio);
      const opt = document.createElement("option");
      opt.value = String(anio);
      opt.textContent = existente ? `AÑADA ${anio}` : `AÑADA ${anio} · CREAR`;
      opt.dataset.anio = String(anio);
      sel.appendChild(opt);
    }

    const activaCampania =
      data.activa_id != null
        ? data.campanias.find(c => Number(c.id) === Number(data.activa_id))
        : null;
    const yearActual = Number(obtenerAnadaVitivinicolaDesdeFecha(new Date().toISOString()));
    let prevValue = String(activaCampania?.anio || yearActual);
    if (sel.querySelector(`option[value="${prevValue}"]`)) {
      sel.value = prevValue;
    }
    localStorage.setItem("bodega_campania_activa", sel.value);
    ajustarAnchoSelectAnada(sel);

    sel.onchange = async () => {
      const valor = sel.value;
      const anio = Number(valor);
      if (!Number.isFinite(anio)) return;
      sel.disabled = true;
      setTopbarAnadaMsg("Actualizando añada...");
      ajustarAnchoSelectAnada(sel);
      try {
        const payload = { anio };
        const res = await fetch("/api/campanias/activa", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          sel.value = prevValue;
          localStorage.setItem("bodega_campania_activa", prevValue);
          setTopbarAnadaMsg("No se pudo cambiar la añada.", "error");
          sel.disabled = false;
          ajustarAnchoSelectAnada(sel);
          return;
        }
        prevValue = valor;
        localStorage.setItem("bodega_campania_activa", prevValue);
        location.reload();
      } catch (err) {
        sel.value = prevValue;
        localStorage.setItem("bodega_campania_activa", prevValue);
        setTopbarAnadaMsg("No se pudo cambiar la añada.", "error");
        sel.disabled = false;
        ajustarAnchoSelectAnada(sel);
      }
    };
  } catch (err) {
    console.error("Error cargando añadas del topbar:", err);
  }
}

async function cargarUsuarioActivo() {
  const badge = document.getElementById("userBadge");
  const marca = document.getElementById("marcaTexto");
  const submarca = document.getElementById("submarcaTexto");
  if (!badge) return;
  badge.textContent = "—";
  try {
    const res = await fetch("/api/me", { credentials: "same-origin" });
    if (!res.ok) {
      badge.textContent = "??";
      return;
    }
    const data = await res.json();
    badge.textContent = obtenerInicialesUsuario(data.usuario);
    badge.setAttribute("title", data.usuario);
    if (marca && data.bodega_nombre) {
      const nombre = data.bodega_nombre || "";
      const limpio = nombre.trim();
      const normalizado = limpio.normalize("NFKC").replace(/[\u200B-\u200F\uFEFF]/g, "");
      const sinDuplicado = normalizado.replace(/\bbodega\b(?:[\s_-]+\bbodega\b)+/gi, "Bodega");
      marca.textContent = sinDuplicado.replace(/\s{2,}/g, " ").trim();
    }
    if (submarca) {
      submarca.textContent = "";
    }
  } catch (err) {
    console.error("Error cargando usuario:", err);
    badge.textContent = "!!";
  }
}

function irAFormulario(seccion, campo) {
  mostrarSeccion(seccion);
  setTimeout(() => {
    const elemento = document.getElementById(campo);
    if (elemento) {
      elemento.scrollIntoView({ behavior: "smooth", block: "center" });
      elemento.focus();
    }
  }, 320);
}

document.addEventListener("click", event => {
  const navMenu = document.getElementById("navMenu");
  const navToggle = document.getElementById("navToggle");
  if (
    navMenu &&
    navToggle &&
    !navMenu.contains(event.target) &&
    !navToggle.contains(event.target)
  ) {
    cerrarNavMenu();
  }
  if (
    !event.target.closest(".flow-node-menu") &&
    !event.target.closest(".flow-node-controls")
  ) {
    cerrarMenusNodo();
  }
});

document.addEventListener("keydown", ev => {
  const menu = document.getElementById("navMenu");
  const target = ev.target;
  const esEditable =
    target &&
    (target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.tagName === "SELECT" ||
      target.isContentEditable);

  if (!esEditable && (ev.metaKey || ev.ctrlKey) && (ev.key || "").toLowerCase() === "k") {
    ev.preventDefault();
    toggleNavMenu();
    return;
  }

  if ((ev.key || "") === "Escape" && menu && menu.classList.contains("visible")) {
    cerrarNavMenu();
  }
});

document.addEventListener("DOMContentLoaded", () => {
  mostrarSeccion("bodega");
  poblarSelectOpciones("depTipo", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterial", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectOpciones("depTipoEdit", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterialEdit", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectEstados("depEstadoEdit");
  const navToggleBtn = document.getElementById("navToggle");
  if (navToggleBtn) {
    navToggleBtn.addEventListener("click", event => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }
  const navSearch = document.getElementById("navSearch");
  if (navSearch) {
    navSearch.addEventListener("input", () => filtrarNavMenu(navSearch.value));
    navSearch.addEventListener("keydown", onNavSearchKeydown);
  }
  const navLogout = document.getElementById("navLogout");
  if (navLogout) {
    navLogout.addEventListener("click", async event => {
      event.preventDefault();
      cerrarNavMenu();
      try {
        const res = await fetch("/logout", { method: "POST", credentials: "same-origin" });
        if (!res.ok) {
          mostrarAviso("No se pudo cerrar la sesión.", "error");
          return;
        }
      } catch (err) {
        console.error("Error cerrando sesión:", err);
        mostrarAviso("No se pudo cerrar la sesión.", "error");
        return;
      }
      window.location.assign("/login");
    });
  }
  inicializarFlowEditor();
  renderFormatosEmbotelladoFormulario();
  cargarUsuarioActivo();
  cargarTopbarFechaYAnada();
});
let planoDrag = null;
let planoSeleccion = null;
let planoSeleccionItemActual = null;
let planoZoom = 1;
let planoWorldBase = { width: 2800, height: 1600 };
let planoUIInicializada = false;
let planoPanBloqueado = false;
let planoPanSpace = false;
let planoPanDrag = null;
let planoMinimapDrag = null;
let planoMinimapRaf = null;
const PLANO_ZOOM_MIN = 0.2;
const PLANO_ZOOM_MAX = 2.5;
const PLANO_ZOOM_STEP = 0.1;
const PLANO_DRAG_THRESHOLD_PX = 4;
const PLANO_CARD_WIDTH = 148;
const PLANO_CARD_HEIGHT_BASE = 176;
const PLANO_CARD_HEIGHT_MAX = 420;
let mapaDepositosPorId = new Map();
let mapaBarricasPorId = new Map();
let mapaMastelonesPorId = new Map();
let entradaEditandoId = null;
const MERMA_DEFAULT_PRENSADO = 30;
const MERMA_DEFAULT_SANGRADO = 40;
const MERMA_DEFAULT_GENERAL = 0;
const FACTOR_MERMA_PRENSA = MERMA_DEFAULT_PRENSADO / 100;
const FACTOR_MERMA_TRASIEGO = 0.02;
const ESTADOS_DEPOSITO_UI = [
  { id: "fa", label: "FA", descripcion: "Fermentación alcohólica", color: "#d85c5c" },
  { id: "fml", label: "FML", descripcion: "Fermentación maloláctica", color: "#c47d21" },
  { id: "reposo", label: "Reposo", descripcion: "Reposo / Crianza", color: "#8c6ff7" },
  { id: "limpio", label: "Limpio", descripcion: "Limpio y listo", color: "#40a578" },
  { id: "vacio", label: "Vacío", descripcion: "Vacío", color: "#9ba1b0" },
  { id: "mantenimiento", label: "Mant.", descripcion: "Mantenimiento / Limpieza", color: "#f0a500" },
  { id: "analitica", label: "Analítica", descripcion: "Analítica pendiente", color: "#ff7aa8" },
];
const TIPOS_NODO_CONTENEDOR = new Set(["deposito", "barrica", "almacen", "coupage"]);
const VOLUMEN_BOTELLA_L = {
  "Split 0,187 L": 0.187,
  "Demi 0,375 L": 0.375,
  "Borgoña 0,75 L": 0.75,
  "Bordelesa 0,75 L": 0.75,
  "Magnum 1,5 L": 1.5,
  "Doble Magnum 3 L": 3,
  "Jeroboam 3 L": 3,
  "Rehoboam 4,5 L": 4.5,
  "Methuselah 6 L": 6,
  "Salmanazar 9 L": 9,
  "Balthazar 12 L": 12,
  "Nebuchadnezzar 15 L": 15,
};

function obtenerInfoEstadoDeposito(id) {
  if (!id) return ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
  return ESTADOS_DEPOSITO_UI.find(e => e.id === id) || ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
}

function poblarSelectEstados(selectId, placeholder = "Selecciona estado") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder;
    opt.disabled = true;
    opt.selected = true;
    select.appendChild(opt);
  }
  ESTADOS_DEPOSITO_UI.forEach(estado => {
    const option = document.createElement("option");
    option.value = estado.id;
    option.textContent = `${estado.label} · ${estado.descripcion}`;
    select.appendChild(option);
  });
  if (valorActual) {
    const existente = Array.from(select.options).find(op => op.value === valorActual);
    if (existente) {
      select.value = valorActual;
    }
  }
}

function claveContenedor(tipo) {
  if (!tipo) return "";
  const normal = tipo.toString().toLowerCase();
  if (normal.includes("barrica")) return "barrica";
  return "deposito";
}

function poblarSelectContenedorCrianza(select, tipoPreferido = "", valorId = "") {
  if (!select) return;
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Selecciona depósito o barrica";
  placeholder.disabled = true;
  if (!valorId) {
    placeholder.selected = true;
  }
  select.appendChild(placeholder);
  const agregarOpciones = (lista, tipoLabel) => {
    if (!Array.isArray(lista)) return;
    const tipoKey = tipoLabel === "Barrica" ? "barrica" : "deposito";
    lista.forEach(item => {
      const option = document.createElement("option");
      option.value = `${tipoKey}:${item.id}`;
      option.dataset.tipo = tipoKey;
      option.dataset.id = item.id;
      const etiquetaBase = formatContainerLabel(item, { tipo: tipoKey });
      const fallback = tipoLabel === "Barrica" ? `Barrica #${item.id}` : `Depósito #${item.id}`;
      const estadoVisual = resolverEstadoVisualContenedor(tipoKey, item);
      const variedad = formatearVariedadLinea(estadoVisual?.variedadVisible || "");
      const volumen = Number.isFinite(estadoVisual?.volumenFinal) ? formatearLitrosPlano(estadoVisual.volumenFinal) : "";
      const sufijo = [];
      if (variedad && variedad !== "Vacío" && variedad !== "Sin vino" && variedad !== "—") {
        sufijo.push(variedad);
      }
      if (volumen && volumen !== "0 L") {
        sufijo.push(volumen);
      }
      option.textContent = `${etiquetaBase || fallback}${sufijo.length ? ` · ${sufijo.join(" · ")}` : ""}`;
      select.appendChild(option);
    });
  };
  agregarOpciones(cacheDepositos, "Depósito");
  agregarOpciones(cacheBarricas, "Barrica");
  let valorSeleccionado = "";
  if (valorId) {
    const tipoKey = claveContenedor(tipoPreferido) || "deposito";
    valorSeleccionado = `${tipoKey}:${valorId}`;
  }
  if (valorSeleccionado) {
    select.value = valorSeleccionado;
  } else {
    select.selectedIndex = 0;
  }
}

async function manejarRespuesta(res, mensajeError) {
  if (res.ok) return true;
  let info = null;
  try {
    info = await res.json();
  } catch (e) {}
  mostrarAviso((info && info.error) || mensajeError, "error");
  return false;
}

function actualizarBarra(idBar, idLabel, valor, unidad, max) {
  const bar = document.getElementById(idBar);
  const label = document.getElementById(idLabel);
  if (label) {
    const rounded = Math.round(valor).toLocaleString();
    label.textContent = `${rounded} ${unidad}`;
  }
  if (bar) {
    const porcentaje = max > 0 ? Math.max(8, (valor / max) * 100) : 0;
    bar.style.width = `${Math.min(100, porcentaje)}%`;
  }
}

function calcularLitrosResumenDesdeCaches() {
  const sumarLitros = (lista, tipoNodo) =>
    (lista || []).reduce((acc, item) => {
      const capacidad = Number(item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)) || 0;
      const estadoVisual = tipoNodo
        ? resolverEstadoVisualContenedor(tipoNodo, item)
        : { volumenFinal: Number(item.litros_actuales ?? 0) || 0 };
      const volumen = Number.isFinite(estadoVisual?.volumenFinal)
        ? Number(estadoVisual.volumenFinal)
        : (Number(item.litros_actuales ?? 0) || 0);
      return { capacidad: acc.capacidad + capacidad, volumen: acc.volumen + (Number.isFinite(volumen) ? volumen : 0) };
    }, { capacidad: 0, volumen: 0 });

  const dep = sumarLitros(cacheDepositos, "deposito");
  const mast = sumarLitros(cacheMastelones, "deposito");
  const bar = sumarLitros(cacheBarricas, "barrica");
  const kilos = (cacheEntradas || []).reduce((acc, e) => acc + (Number(e.kilos) || 0), 0);

  return {
    kilos_entrados: kilos,
    litros_depositos: dep.volumen,
    litros_mastelones: mast.volumen,
    litros_barricas: bar.volumen,
  };
}

function refrescarGraficosResumenDesdeCaches() {
  const chartKilos = document.getElementById("chartKilosValue");
  const chartLitros = document.getElementById("chartLitrosValue");
  if (!chartKilos || !chartLitros) return;
  const calculado = calcularLitrosResumenDesdeCaches();
  actualizarGraficosResumen(calculado);
}

function actualizarGraficosResumen(data) {
  const calculado = calcularLitrosResumenDesdeCaches();
  const elegir = (valorApi, valorLocal) => {
    const apiNum = Number(valorApi);
    if (Number.isFinite(apiNum) && apiNum > 0) return apiNum;
    const localNum = Number(valorLocal);
    return Number.isFinite(localNum) ? localNum : 0;
  };
  const kilos = elegir(data?.kilos_entrados, calculado.kilos_entrados);
  const litrosDepositos = elegir(data?.litros_depositos, calculado.litros_depositos);
  const litrosMastelones = elegir(data?.litros_mastelones, calculado.litros_mastelones);
  const litrosBarricas = elegir(data?.litros_barricas, calculado.litros_barricas);
  const litrosTotales = litrosDepositos + litrosMastelones + litrosBarricas;
  const maxValor = Math.max(kilos, litrosTotales, 1);

  actualizarBarra("chartKilosBar", "chartKilosValue", kilos, "kg", maxValor);
  actualizarBarra("chartLitrosBar", "chartLitrosValue", litrosTotales, "L", maxValor);

  const detalle = document.getElementById("chartLitrosDetalle");
  if (detalle) {
    const depTxt = `${Math.round(litrosDepositos).toLocaleString()} L`;
    const mastTxt = `${Math.round(litrosMastelones).toLocaleString()} L`;
    const barrTxt = `${Math.round(litrosBarricas).toLocaleString()} L`;
    detalle.innerHTML = `
      🛢 Depósitos: ${depTxt} ·
      🪣 Mastelones: ${mastTxt} ·
      <span style="display:inline-flex; align-items:center; gap:4px;">
        <img src="/barricas.png" alt="Barricas" style="width:16px; height:16px; object-fit:contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); mix-blend-mode:multiply; background:transparent;">
        Barricas: ${barrTxt}
      </span>
    `;
  }
}

function formatearNumeroCorto(valor) {
  const num = Number(valor) || 0;
  if (Math.abs(num) >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (Math.abs(num) >= 1000) return `${(num / 1000).toFixed(1)}k`;
  return num.toLocaleString("es-ES", { maximumFractionDigits: 0 });
}

function actualizarIndicadores() {
  const depPrincipal = document.getElementById("indicadorDepositosPrincipal");
  if (!depPrincipal) return;

  const calcularTotales = (lista, tipoNodo) =>
    (lista || []).reduce(
      (acc, item) => {
        const capacidad = Number(
          item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)
        ) || 0;
        const estadoVisual = tipoNodo
          ? resolverEstadoVisualContenedor(tipoNodo, item)
          : { volumenFinal: Number(item.litros_actuales || 0) || 0 };
        const volumen = Number.isFinite(estadoVisual?.volumenFinal)
          ? Number(estadoVisual.volumenFinal)
          : (Number(item.litros_actuales || 0) || 0);
        return {
          capacidad: acc.capacidad + capacidad,
          volumen: acc.volumen + volumen,
        };
      },
      { capacidad: 0, volumen: 0 }
    );

  const dep = calcularTotales(cacheDepositos, "deposito");
  const depCount = document.getElementById("indicadorDepositosCount");
  if (depCount) {
    depCount.textContent = `${(cacheDepositos || []).length}`;
  }
  const depPorcentaje = dep.capacidad > 0 ? Math.round((dep.volumen / dep.capacidad) * 100) : 0;
  depPrincipal.textContent = `${depPorcentaje}% ocupado`;
  const depDetalle = document.getElementById("indicadorDepositosDetalle");
  if (depDetalle) {
    depDetalle.textContent = `${formatearLitrosPlano(dep.volumen)} de ${formatearLitrosPlano(
      dep.capacidad
    )}`;
  }
  const depExtra = document.getElementById("indicadorDepositosExtra");
  if (depExtra) {
    const libre = Math.max(dep.capacidad - dep.volumen, 0);
    depExtra.textContent = libre
      ? `${formatearLitrosPlano(libre)} libres`
      : "Sin capacidad libre";
  }

  const mast = calcularTotales(cacheMastelones, "deposito");
  const mastPrincipal = document.getElementById("indicadorMastelonesPrincipal");
  const mastCount = document.getElementById("indicadorMastelonesCount");
  if (mastCount) {
    mastCount.textContent = `${(cacheMastelones || []).length}`;
  }
  if (mastPrincipal) {
    const mastPorcentaje =
      mast.capacidad > 0 ? Math.round((mast.volumen / mast.capacidad) * 100) : 0;
    mastPrincipal.textContent = `${mastPorcentaje}% ocupado`;
    const mastDetalle = document.getElementById("indicadorMastelonesDetalle");
    if (mastDetalle) {
      mastDetalle.textContent = `${formatearLitrosPlano(mast.volumen)} de ${formatearLitrosPlano(
        mast.capacidad
      )}`;
    }
    const mastExtra = document.getElementById("indicadorMastelonesExtra");
    if (mastExtra) {
      const libre = Math.max(mast.capacidad - mast.volumen, 0);
      mastExtra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Sin capacidad libre";
    }
  }

  const bar = calcularTotales(cacheBarricas, "barrica");
  const barPrincipal = document.getElementById("indicadorBarricasPrincipal");
  const barCount = document.getElementById("indicadorBarricasCount");
  if (barCount) {
    barCount.textContent = `${(cacheBarricas || []).length}`;
  }
  if (barPrincipal) {
    const barPorcentaje = bar.capacidad > 0 ? Math.round((bar.volumen / bar.capacidad) * 100) : 0;
    barPrincipal.textContent = `${barPorcentaje}% ocupado`;
    const detalle = document.getElementById("indicadorBarricasDetalle");
    if (detalle) {
      detalle.textContent = `${formatearLitrosPlano(bar.volumen)} de ${formatearLitrosPlano(
        bar.capacidad
      )}`;
    }
    const extra = document.getElementById("indicadorBarricasExtra");
    if (extra) {
      const libre = Math.max(bar.capacidad - bar.volumen, 0);
      extra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Barricas al máximo";
    }
  }

  const totalBotellasStock = (cacheAlmacenVino || []).reduce((acc, lote) => {
    const n = normalizarNumeroFlexible(lote?.botellas_actuales);
    return acc + (Number.isFinite(n) && n > 0 ? Math.floor(n) : 0);
  }, 0);

  const totalBotellasEmb = (cacheEmbotellados || []).reduce((acc, e) => {
    const botDirectas =
      normalizarNumeroFlexible(e?.botellas_actuales) ??
      normalizarNumeroFlexible(e?.botellas) ??
      normalizarNumeroFlexible(e?.cantidad_botellas);
    if (Number.isFinite(botDirectas) && botDirectas > 0) {
      return acc + Math.floor(botDirectas);
    }
    const formatos = parsearFormatosEmbotellado(e?.formatos);
    const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
    if (resumen.totalBotellas > 0) return acc + resumen.totalBotellas;
    return acc;
  }, 0);
  const lotesMapa = construirLotesVirtualesDesdeFlujo();
  const totalBotellasStockMapa = lotesMapa.reduce((acc, lote) => {
    const n = normalizarNumeroFlexible(lote?.botellas_actuales);
    return acc + (Number.isFinite(n) && n > 0 ? Math.floor(n) : 0);
  }, 0);
  const totalBotellasEmbMapa = lotesMapa.reduce((acc, lote) => {
    const n = normalizarNumeroFlexible(lote?.botellas_entrada);
    return acc + (Number.isFinite(n) && n > 0 ? Math.floor(n) : 0);
  }, 0);
  const totalBotellas = totalBotellasStock > 0
    ? totalBotellasStock
    : totalBotellasStockMapa > 0
    ? totalBotellasStockMapa
    : totalBotellasEmb > 0
    ? totalBotellasEmb
    : totalBotellasEmbMapa;
  const embPrincipal = document.getElementById("indicadorEmbotelladosPrincipal");
  const embCount = document.getElementById("indicadorEmbotelladosCount");
  if (embCount) {
    embCount.textContent = `${formatearNumeroCorto(totalBotellas)} Bot`;
  }
  if (embPrincipal) {
    embPrincipal.textContent = `${formatearNumeroCorto(totalBotellas)} botellas`;
    const detalle = document.getElementById("indicadorEmbotelladosDetalle");
    if (detalle) {
      detalle.textContent = totalBotellas
        ? `${totalBotellas.toLocaleString("es-ES")} botellas embotelladas`
        : "Aún no hay embotellados recientes";
    }
  }
}
function actualizarAprovechamientoAnual() {
  const tbody = document.getElementById("tablaAprovechamiento");
  if (!tbody) return;

  const kilosPorAnada = {};
  (cacheEntradas || []).forEach(e => {
    const anada = (e.anada || obtenerAnadaDesdeFecha(e.fecha || "") || "Sin añada").toString();
    const kilos = Number(e.kilos || 0);
    kilosPorAnada[anada] = (kilosPorAnada[anada] || 0) + kilos;
  });

  const litrosPorAnada = {};
  const acumularLitros = (coleccion, campoAnada) => {
    coleccion.forEach(item => {
      const litros = Number(item.litros_actuales || 0);
      if (!litros) return;
      const anadaValor =
        item[campoAnada] ||
        item.anada_creacion ||
        obtenerAnadaDesdeFecha(item.fecha_uso || "");
      const anada = (anadaValor || "Sin añada").toString();
      litrosPorAnada[anada] = (litrosPorAnada[anada] || 0) + litros;
    });
  };
  acumularLitros(cacheDepositos || [], "vino_anio");
  acumularLitros(cacheMastelones || [], "vino_anio");
  acumularLitros(cacheBarricas || [], "vino_anio");

  const todas = Array.from(new Set([...Object.keys(kilosPorAnada), ...Object.keys(litrosPorAnada)]));
  todas.sort((a, b) => {
    const numA = Number(a);
    const numB = Number(b);
    if (Number.isNaN(numA) || Number.isNaN(numB)) return a.localeCompare(b);
    return numB - numA;
  });

  tbody.innerHTML = "";
  if (!todas.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="4">No hay datos disponibles todavía.</td>';
    tbody.appendChild(tr);
    return;
  }

  todas.forEach(anada => {
    const kilos = kilosPorAnada[anada] || 0;
    const litros = litrosPorAnada[anada] || 0;
    const aprovechamiento = kilos > 0 ? ((litros / kilos) * 100) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${anada}</td>
      <td>${kilos.toLocaleString("es-ES", { maximumFractionDigits: 0 })} kg</td>
      <td>${litros.toLocaleString("es-ES", { maximumFractionDigits: 1 })} L</td>
      <td>${aprovechamiento.toFixed(1)} %</td>
    `;
    tbody.appendChild(tr);
  });
}


function limitarZoomPlanoBodega(valor) {
  const z = Number(valor);
  if (!Number.isFinite(z)) return 1;
  return Math.max(PLANO_ZOOM_MIN, Math.min(PLANO_ZOOM_MAX, z));
}

function actualizarZoomPlanoBodegaUI() {
  const label = document.getElementById("planoZoomLabel");
  if (label) {
    label.textContent = `${Math.round((planoZoom || 1) * 100)}%`;
  }
  const range = document.getElementById("planoZoomRange");
  if (range) {
    range.value = String(Math.round((planoZoom || 1) * 100));
  }
}

function aplicarZoomPlanoBodega(nuevoZoom, opciones = {}) {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const prevZoom = planoZoom || 1;
  const centroWorld = opciones.centroWorld || {
    x: (editor.scrollLeft + editor.clientWidth / 2) / prevZoom,
    y: (editor.scrollTop + editor.clientHeight / 2) / prevZoom,
  };

  planoZoom = limitarZoomPlanoBodega(nuevoZoom);
  try {
    localStorage.setItem("planoZoom", String(planoZoom));
  } catch (e) {
    // noop
  }

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;
  canvas.style.transform = `scale(${planoZoom})`;
  stage.style.width = `${planoWorldBase.width * planoZoom}px`;
  stage.style.height = `${planoWorldBase.height * planoZoom}px`;

  editor.scrollLeft = Math.max(0, centroWorld.x * planoZoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centroWorld.y * planoZoom - editor.clientHeight / 2);

  actualizarZoomPlanoBodegaUI();
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function zoomPlanoBodega(direccion) {
  const signo = direccion < 0 ? -1 : 1;
  aplicarZoomPlanoBodega((planoZoom || 1) + signo * PLANO_ZOOM_STEP);
}

function resetZoomPlanoBodega() {
  aplicarZoomPlanoBodega(1);
}

function setZoomPlanoBodega(valorPorcentaje) {
  const pct = Number(valorPorcentaje);
  if (!Number.isFinite(pct)) return;
  aplicarZoomPlanoBodega(pct / 100);
}

function esSeccionPlanoActiva() {
  const sec = document.getElementById("plano");
  return Boolean(sec && sec.classList.contains("visible"));
}

function actualizarModoManoPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const activo = Boolean(planoPanBloqueado || planoPanSpace);
  editor.classList.toggle("pan-activo", activo);
}

function toggleModoManoPlanoBodega() {
  planoPanBloqueado = !planoPanBloqueado;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarPanPlanoBodega(ev, editor) {
  if (!editor) return;
  if (planoPanDrag) return;
  ev.preventDefault();
  planoPanDrag = {
    editor,
    pointerId: ev.pointerId,
    startX: ev.clientX,
    startY: ev.clientY,
    startScrollLeft: editor.scrollLeft,
    startScrollTop: editor.scrollTop,
  };
  editor.classList.add("panning");
  try {
    editor.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  editor.addEventListener("pointermove", moverPanPlanoBodega);
  editor.addEventListener("pointerup", finalizarPanPlanoBodega);
  editor.addEventListener("pointercancel", finalizarPanPlanoBodega);
}

function moverPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, startX, startY, startScrollLeft, startScrollTop } = planoPanDrag;
  const dx = ev.clientX - startX;
  const dy = ev.clientY - startY;
  editor.scrollLeft = startScrollLeft - dx;
  editor.scrollTop = startScrollTop - dy;
  programarActualizacionMinimapPlanoBodega();
}

function finalizarPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, pointerId } = planoPanDrag;
  try {
    editor.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  editor.classList.remove("panning");
  editor.removeEventListener("pointermove", moverPanPlanoBodega);
  editor.removeEventListener("pointerup", finalizarPanPlanoBodega);
  editor.removeEventListener("pointercancel", finalizarPanPlanoBodega);
  planoPanDrag = null;
}

function manejarPointerDownPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const target = ev.target;
  if (target && target.closest && target.closest(".plano-item")) return;

  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanBloqueado || planoPanSpace || boton === 1);
  if (esPan) {
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  limpiarSeleccionPlanoBodega();
}

function manejarWheelPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (!(ev.ctrlKey || ev.metaKey)) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  ev.preventDefault();
  const signo = ev.deltaY < 0 ? 1 : -1;
  const nuevoZoom = (planoZoom || 1) + signo * PLANO_ZOOM_STEP;
  const rect = editor.getBoundingClientRect();
  const pointerX = ev.clientX - rect.left;
  const pointerY = ev.clientY - rect.top;
  const centroWorld = {
    x: (editor.scrollLeft + pointerX) / (planoZoom || 1),
    y: (editor.scrollTop + pointerY) / (planoZoom || 1),
  };
  aplicarZoomPlanoBodega(nuevoZoom, { centroWorld });
}

function onPlanoKeyDown(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (ev.code !== "Space") return;
  const target = ev.target;
  if (
    target &&
    (target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.tagName === "SELECT" ||
      target.isContentEditable)
  ) {
    return;
  }
  if (planoPanSpace) return;
  planoPanSpace = true;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function onPlanoKeyUp(ev) {
  if (ev.code !== "Space") return;
  if (!planoPanSpace) return;
  planoPanSpace = false;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function programarActualizacionMinimapPlanoBodega() {
  if (planoMinimapRaf) return;
  planoMinimapRaf = requestAnimationFrame(() => {
    planoMinimapRaf = null;
    actualizarMinimapPlanoBodega();
  });
}

function seleccionarPlanoBodegaPorClave(tipo, id, opciones = {}) {
  if (!tipo || id == null) return;
  planoSeleccion = { tipo, id };
  renderPlano();
  if (opciones.centrar) {
    requestAnimationFrame(() => centrarSeleccionPlanoBodega());
  }
}

function inicializarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const viewport = document.getElementById("planoMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    planoMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapPlanoBodega(ev);
    world.addEventListener("pointermove", moverDesdeMinimapPlanoBodega);
    world.addEventListener("pointerup", finalizarMinimapPlanoBodega);
    world.addEventListener("pointercancel", finalizarMinimapPlanoBodega);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, editor } = planoMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / rect.width) * (planoWorldBase.width || 1);
  const worldY = (relY / rect.height) * (planoWorldBase.height || 1);
  editor.scrollLeft = Math.max(0, worldX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * (planoZoom || 1) - editor.clientHeight / 2);
  programarActualizacionMinimapPlanoBodega();
}

function finalizarMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, pointerId } = planoMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapPlanoBodega);
  world.removeEventListener("pointerup", finalizarMinimapPlanoBodega);
  world.removeEventListener("pointercancel", finalizarMinimapPlanoBodega);
  planoMinimapDrag = null;
}

function actualizarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const dotsHost = document.getElementById("planoMinimapDots");
  const viewport = document.getElementById("planoMinimapViewport");
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const aspect = (planoWorldBase.height || 1) / (planoWorldBase.width || 1);
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = planoZoom || 1;
  const worldW = planoWorldBase.width || 1;
  const worldH = planoWorldBase.height || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / worldW) * mmW}px`;
  viewport.style.top = `${(viewY / worldH) * mmH}px`;
  viewport.style.width = `${(viewW / worldW) * mmW}px`;
  viewport.style.height = `${(viewH / worldH) * mmH}px`;

  const cardWidth = PLANO_CARD_WIDTH;
  const itemEls = Array.from(canvas.querySelectorAll(".plano-item"));
  dotsHost.innerHTML = "";
  itemEls.forEach(el => {
    const tipo = el.dataset.tipo || "";
    const id = el.dataset.id || "";
    const codigo = el.dataset.codigo || "";
    const xPct = parseFloat(el.dataset.posx || "") || 0;
    const yPct = parseFloat(el.dataset.posy || "") || 0;
    const elH = el.offsetHeight || PLANO_CARD_HEIGHT_BASE;
    const worldX = (xPct / 100) * worldW + cardWidth / 2;
    const worldY = (yPct / 100) * worldH + elH / 2;
    const x = (worldX / worldW) * mmW;
    const y = (worldY / worldH) * mmH;
    const dot = document.createElement("div");
    dot.className = `plano-minimap-dot ${tipo}`;
    if (el.classList.contains("seleccionado")) dot.classList.add("seleccionado");
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.title = tipo ? `${tipo} ${codigo || `#${id}`}` : "Contenedor";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      seleccionarPlanoBodegaPorClave(tipo, id, { centrar: true });
    });
    dotsHost.appendChild(dot);
  });
}

function limpiarSeleccionPlanoBodega() {
  planoSeleccion = null;
  planoSeleccionItemActual = null;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  renderInspectorPlanoBodega(null);
}

function seleccionarPlanoBodega(item, elemento) {
  if (!item || !item.tipo || item.id == null) return;
  planoSeleccion = { tipo: item.tipo, id: item.id };
  planoSeleccionItemActual = item;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  if (elemento) elemento.classList.add("seleccionado");
  renderInspectorPlanoBodega(item);
}

function abrirSeleccionPlanoBodega() {
  if (!planoSeleccionItemActual) return;
  irAlContenedor(planoSeleccionItemActual);
}

function centrarSeleccionPlanoBodega() {
  if (!planoSeleccion) return;
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const selector = `.plano-item[data-tipo="${planoSeleccion.tipo}"][data-id="${planoSeleccion.id}"]`;
  const el = canvas.querySelector(selector);
  if (!el) return;

  const xPct = parseFloat(el.dataset.posx || "") || 0;
  const yPct = parseFloat(el.dataset.posy || "") || 0;
  const centerX = (xPct / 100) * planoWorldBase.width + el.offsetWidth / 2;
  const centerY = (yPct / 100) * planoWorldBase.height + el.offsetHeight / 2;
  editor.scrollLeft = Math.max(0, centerX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * (planoZoom || 1) - editor.clientHeight / 2);
}

function ajustarVistaPlanoBodega() {
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const items = Array.from(canvas.querySelectorAll(".plano-item"));
  if (!items.length) {
    resetZoomPlanoBodega();
    editor.scrollLeft = 0;
    editor.scrollTop = 0;
    return;
  }

  const baseW = planoWorldBase.width || canvas.clientWidth || 1200;
  const baseH = planoWorldBase.height || canvas.clientHeight || 620;
  const cardWidth = PLANO_CARD_WIDTH;
  const cardWPercent = (cardWidth / baseW) * 100;

  let minX = 100;
  let minY = 100;
  let maxX = 0;
  let maxY = 0;
  items.forEach(el => {
    const x = parseFloat(el.dataset.posx || "") || 0;
    const y = parseFloat(el.dataset.posy || "") || 0;
    const cardHPercent = ((el.offsetHeight || PLANO_CARD_HEIGHT_BASE) / baseH) * 100;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + cardWPercent);
    maxY = Math.max(maxY, y + cardHPercent);
  });

  const bboxW = ((maxX - minX) / 100) * baseW;
  const bboxH = ((maxY - minY) / 100) * baseH;
  if (!(bboxW > 0 && bboxH > 0)) return;

  const padding = 0.92;
  const zoom = padding * Math.min(editor.clientWidth / bboxW, editor.clientHeight / bboxH);
  const centerX = (((minX + maxX) / 2) / 100) * baseW;
  const centerY = (((minY + maxY) / 2) / 100) * baseH;
  aplicarZoomPlanoBodega(zoom, { centroWorld: { x: centerX, y: centerY } });
}

function inicializarPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const baseW = parseFloat(canvas.style.width) || canvas.clientWidth || canvas.offsetWidth || 2800;
  const baseH = parseFloat(canvas.style.height) || canvas.clientHeight || canvas.offsetHeight || 1600;
  planoWorldBase = {
    width: Math.max(600, Math.round(baseW)),
    height: Math.max(520, Math.round(baseH)),
  };

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;

  if (!planoUIInicializada) {
    editor.addEventListener("pointerdown", manejarPointerDownPlanoEditor);
    editor.addEventListener("wheel", manejarWheelPlanoEditor, { passive: false });
    editor.addEventListener("scroll", programarActualizacionMinimapPlanoBodega, { passive: true });
    window.addEventListener("keydown", onPlanoKeyDown);
    window.addEventListener("keyup", onPlanoKeyUp);
    window.addEventListener("resize", programarActualizacionMinimapPlanoBodega);
    planoUIInicializada = true;
  }

  let initZoom = 1;
  try {
    const saved = Number(localStorage.getItem("planoZoom"));
    if (Number.isFinite(saved) && saved > 0) {
      initZoom = saved;
    } else {
      const fit = Math.min(
        1,
        (editor.clientWidth || planoWorldBase.width) / planoWorldBase.width,
        (editor.clientHeight || planoWorldBase.height) / planoWorldBase.height
      );
      initZoom = fit;
    }
  } catch (e) {
    // noop
  }
  aplicarZoomPlanoBodega(initZoom);
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function renderInspectorPlanoBodega(item) {
  const panel = document.getElementById("planoInfo");
  if (!panel) return;
  const escapeHtml = value =>
    String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");

  const zoomPct = Math.round((planoZoom || 1) * 100);
  const zoomMin = Math.round(PLANO_ZOOM_MIN * 100);
  const zoomMax = Math.round(PLANO_ZOOM_MAX * 100);
  const modoManoActivo = Boolean(planoPanBloqueado);
  const modoManoBtnClass = modoManoActivo ? "btnPrimario" : "btnSecundario";
  const modoManoBtnLabel = modoManoActivo ? "🖐 Mano: ON" : "🖐 Mano";

  const zoomHtml = `
    <div class="plano-zoom-controls">
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(-1)" title="Alejar" aria-label="Alejar">−</button>
      <button class="btnSecundario plano-zoom-label" id="planoZoomLabel" type="button" onclick="resetZoomPlanoBodega()" title="Reset zoom" aria-label="Reset zoom">${zoomPct}%</button>
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(1)" title="Acercar" aria-label="Acercar">+</button>
    </div>
    <input class="plano-zoom-range" id="planoZoomRange" type="range" min="${zoomMin}" max="${zoomMax}" step="5" value="${zoomPct}" oninput="setZoomPlanoBodega(this.value)" aria-label="Zoom del plano" />
  `;

  const minimapHtml = `
    <div class="plano-minimap-world" id="planoMinimapWorld" aria-label="Minimapa del plano" role="img">
      <div class="plano-minimap-grid"></div>
      <div class="plano-minimap-dots" id="planoMinimapDots"></div>
      <div class="plano-minimap-viewport" id="planoMinimapViewport"></div>
    </div>
    <div class="plano-minimap-hint">Minimapa: clic o arrastra para moverte · Space o “Mano” para arrastrar el lienzo</div>
  `;

  const baseHeader = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🛢</div>
      <div>
        <div class="flow-inspector-title">Inspector del plano</div>
        <div class="flow-inspector-sub">Selecciona un depósito, mastelone o barrica para ver el desglose.</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
  `;

  if (!item) {
    panel.innerHTML = `
      ${baseHeader}
      <div class="flow-inspector-tags">
        <span class="flow-tag">Click: seleccionar</span>
        <span class="flow-tag">Arrastrar: mover</span>
        <span class="flow-tag">Doble clic: abrir ficha</span>
        <span class="flow-tag">Space/Mano: pan</span>
        <span class="flow-tag">Click fuera: limpiar</span>
      </div>
      <dl class="flow-inspector-fields">
        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Ajustar vista” para ver todos los contenedores.</dd></div>
      </dl>
    `;
    inicializarMinimapPlanoBodega();
    programarActualizacionMinimapPlanoBodega();
    actualizarModoManoPlanoBodegaUI();
    return;
  }

  const etiquetaBase = item.tipo === "deposito" ? "Dep" : item.tipo === "mastelone" ? "Mas" : "Bar";
  const etiqueta = item.codigo ? `${etiquetaBase} ${item.codigo}` : `${etiquetaBase} #${item.id}`;
  const subtitulo = item.tipo === "deposito" ? "Depósito" : item.tipo === "mastelone" ? "Mastelone" : "Barrica";
  const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
  const volumen = item.volumen != null ? Number(item.volumen) : 0;
  const libre = capacidad && capacidad > 0 ? Math.max(capacidad - volumen, 0) : null;
  const porcentaje =
    capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

  const estadoTexto =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? obtenerInfoEstadoDeposito(item.estado)?.descripcion || ""
      : "";
  const vinoTipo = item.variedadNodo || item.vino_tipo || "";
  const vinoAnio = item.vino_anio || "";

  const tags = [
    `Tipo: ${subtitulo}`,
    capacidad && capacidad > 0 ? `Llenado: ${porcentaje}%` : "Sin capacidad",
    item.enMapa ? "Fuente: mapa de nodos" : "Fuente: ficha",
  ];

  const filas = [
    { label: "Código", value: etiqueta },
    { label: "Capacidad", value: capacidad != null ? formatearLitrosPlano(capacidad) : "—" },
    { label: "Contenido", value: formatearLitrosPlano(volumen) },
    { label: "Libre", value: libre != null ? formatearLitrosPlano(libre) : "—" },
    vinoTipo ? { label: "Vino", value: vinoTipo } : null,
    vinoAnio ? { label: "Añada", value: vinoAnio } : null,
    estadoTexto ? { label: "Estado", value: estadoTexto } : null,
    item.tipo !== "barrica" && item.contenido ? { label: "Material", value: item.contenido } : null,
    item.tipo !== "barrica" && item.elaboracion ? { label: "Elaboración", value: item.elaboracion } : null,
    item.tipo === "barrica" && item.detalle ? { label: "Roble / tostado", value: item.detalle } : null,
    item.tipo === "barrica" && item.marca ? { label: "Marca", value: item.marca } : null,
    item.tipo === "barrica" && item.anio ? { label: "Año barrica", value: item.anio } : null,
    item.tipo !== "barrica" && item.detalle ? { label: "Notas", value: item.detalle } : null,
  ].filter(Boolean);

  panel.innerHTML = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🧭</div>
      <div>
        <div class="flow-inspector-title">${escapeHtml(etiqueta)}</div>
        <div class="flow-inspector-sub">${escapeHtml(subtitulo)}</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="centrarSeleccionPlanoBodega()">Centrar</button>
      <button class="btnPrimario" type="button" onclick="abrirSeleccionPlanoBodega()">Abrir ficha</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
    <div class="flow-inspector-tags">${tags.map(t => `<span class="flow-tag">${escapeHtml(t)}</span>`).join("")}</div>
    <dl class="flow-inspector-fields">${filas
      .map(
        item =>
          `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
      )
      .join("")}</dl>
  `;
  inicializarMinimapPlanoBodega();
  programarActualizacionMinimapPlanoBodega();
  actualizarModoManoPlanoBodegaUI();
}

function renderPlano() {
  const canvas = document.getElementById("planoCanvas");
  const mensaje = document.getElementById("planoMensaje");
  if (!canvas || !mensaje) return;

  const canvasWidth = canvas.clientWidth || canvas.offsetWidth || 600;
  const canvasHeight = canvas.clientHeight || canvas.offsetHeight || 400;
  const cardWidth = PLANO_CARD_WIDTH;
  const offsetXPercent = (cardWidth / canvasWidth) * 100;
  const offsetYPercent = (PLANO_CARD_HEIGHT_MAX / canvasHeight) * 100;

  canvas.innerHTML = "";
  const elementos = [
    ...cacheDepositos.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "deposito",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
    ...cacheMastelones.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "mastelone",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
	    ...cacheBarricas.map(b => {
	      const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
	      const volumenNodo =
	        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(b.composicionVariedades || b.composicion_variedades) ||
        (esVariedadGenerica(b.vino_tipo) ? "" : (b.vino_tipo || ""));
	      return {
	        tipo: "barrica",
	        id: b.id,
	        codigo: b.codigo,
	        pos_x: b.pos_x,
	        pos_y: b.pos_y,
	        capacidad: b.capacidad_l ?? null,
	        // Si la barrica no está representada en el mapa de nodos, no mostramos contenido “fantasma”.
	        volumen: volumenNodo != null ? volumenNodo : estadoNodo ? b.litros_actuales ?? 0 : 0,
	        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
	        variedadNodo: variedades,
	        detalle: [b.tipo_roble, b.tostado].filter(Boolean).join(" · "),
	        vino_tipo: b.vino_tipo || "",
        vino_anio: b.vino_anio || "",
        marca: b.marca || "",
        anio: b.anio || "",
        colorReferencia: b.vino_tipo || "",
      };
    }),
  ];

  if (!elementos.length) {
    mensaje.textContent = "Añade depósitos, mastelones o barricas para empezar.";
    limpiarSeleccionPlanoBodega();
    const placeholder = document.createElement("div");
    placeholder.className = "plano-placeholder";
    placeholder.textContent = "Sin elementos todavía";
    canvas.appendChild(placeholder);
    return;
  }

  mensaje.textContent = "Arrastra las tarjetas para guardar su posición.";
  let seleccionEncontrada = false;
  elementos.forEach((item, idx) => {
    const bloque = document.createElement("div");
    bloque.className = `plano-item ${item.tipo}`;
    bloque.dataset.id = String(item.id);
    bloque.dataset.tipo = item.tipo;
    if (item.codigo != null) bloque.dataset.codigo = String(item.codigo);
    if (planoSeleccion && planoSeleccion.tipo === item.tipo && String(planoSeleccion.id) === String(item.id)) {
      bloque.classList.add("seleccionado");
      seleccionEncontrada = true;
      planoSeleccionItemActual = item;
    }
    const etiqueta = item.codigo ? String(item.codigo) : String(item.id);
    const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
    const volumen = item.volumen != null ? Number(item.volumen) : 0;
    const porcentaje =
      capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

    const header = document.createElement("div");
    header.className = "plano-card-header";
    const subtitulo =
      item.tipo === "deposito"
        ? "Depósito"
        : item.tipo === "mastelone"
        ? "Mastelone"
        : "Barrica";
    header.innerHTML = `
      <div class="plano-card-title-row">
        <span class="plano-card-dot" aria-hidden="true"></span>
        <span class="plano-card-code">${etiqueta}</span>
        <span class="plano-card-pct" title="Porcentaje de llenado">${porcentaje}%</span>
      </div>
      <small><span class="plano-card-material-dot" aria-hidden="true"></span>${subtitulo}</small>
    `;
    const estaVacio = !Number.isFinite(volumen) || volumen <= 0;
    bloque.appendChild(header);

    const body = document.createElement("div");
    body.className = "plano-card-body";
    const materialColor = obtenerColorMaterialContenedor(
      item.tipo === "barrica" ? "Madera" : item.contenido || item.detalle || "",
      item.tipo
    );

    const info = document.createElement("div");
    info.className = "plano-card-info";
    info.innerHTML = `
      <div>
        <small>Capacidad</small>
        <strong>${formatearLitrosPlano(capacidad)}</strong>
      </div>
      <div>
        <small>Contenido</small>
        <strong>${formatearLitrosPlano(volumen)}</strong>
      </div>
    `;
    const visual = document.createElement("div");
    visual.className = "plano-card-visual";
    visual.appendChild(info);
    body.appendChild(visual);

    const colorTarjeta = materialColor || "#8f97a8";
    const colorPuntoVino = obtenerColorPuntoVinoPlano(item.variedadNodo || item.vino_tipo || "");
    try {
      const acento = colorTarjeta.toString();
      const acentoMaterial = (materialColor || acento).toString();
      bloque.style.setProperty("--plano-accent", acento);
      bloque.style.setProperty("--plano-accent-soft", mezclarHexConBlanco(acento, 0.10, 0.62));
      bloque.style.setProperty("--plano-accent-wash", mezclarHexConBlanco(acento, 0.18, 0.46));
      bloque.style.setProperty("--plano-material", acentoMaterial);
      bloque.style.setProperty("--plano-material-wash", mezclarHexConBlanco(acentoMaterial, 0.18, 0.40));
      bloque.style.setProperty("--plano-wine-dot", colorPuntoVino);
      const pastel = mezclarHexConBlanco(acento, 0.40, 0.72);
      const pastel2 = mezclarHexConBlanco(acento, 0.34, 0.58);
      const pastelMaterial = mezclarHexConBlanco(acentoMaterial, 0.38, 0.52);
      const glow = mezclarHexConBlanco(acento, 0.52, 0.38);
      bloque.style.setProperty(
        "--plano-card-bg",
        `radial-gradient(circle at 14% 10%, ${pastel} 0%, rgba(255,255,255,0) 58%),` +
          `radial-gradient(circle at 88% 86%, ${pastel2} 0%, rgba(255,255,255,0) 62%),` +
          `radial-gradient(circle at 12% 92%, ${pastelMaterial} 0%, rgba(255,255,255,0) 64%),` +
          `linear-gradient(180deg, rgba(255,255,255,0.88), rgba(255,255,255,0.68))`
      );
      bloque.style.setProperty("--plano-card-glow", glow);
    } catch (e) {
      // noop
    }
    const progress = document.createElement("div");
    progress.className = "plano-card-progress";
    const barra = document.createElement("div");
    barra.className = "plano-card-progress-bar";
    barra.style.background = colorTarjeta;
    const alturaBarra = capacidad && capacidad > 0 ? porcentaje : 0;
    barra.style.height = `${alturaBarra}%`;
    const etiquetaPorcentaje = document.createElement("span");
    etiquetaPorcentaje.textContent = `${porcentaje}%`;
    progress.appendChild(barra);
    progress.appendChild(etiquetaPorcentaje);

    bloque.appendChild(progress);
    bloque.appendChild(body);

    const extra = document.createElement("div");
    extra.className = "plano-card-extra";
    const uvasTexto = (item.variedadNodo || item.vino_tipo || "").toString();
    const anioTxt = (item.vino_anio || "").toString().trim();

    if (estaVacio) {
      const estadoInfo = obtenerInfoEstadoDeposito("vacio");
      const vacioBtn = document.createElement("button");
      vacioBtn.type = "button";
      vacioBtn.className = `plano-card-vacio estado-pill estado-${estadoInfo.id}`;
      vacioBtn.textContent = estadoInfo.label;
      vacioBtn.title = "Vacío";
      vacioBtn.addEventListener("click", ev => {
        ev.stopPropagation();
        seleccionarPlanoBodega(item, bloque);
      });
      extra.appendChild(vacioBtn);
    } else {
      if (anioTxt) {
        const anada = document.createElement("div");
        anada.className = "plano-card-anada";
        anada.textContent = anioTxt;
        anada.title = "Añada";
        extra.appendChild(anada);
      }

      const uvas = document.createElement("div");
      uvas.className = "plano-card-uvas";
      const lineas = (uvasTexto || "")
        .toString()
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(Boolean);
      const visibles = lineas.length ? lineas : ["Sin uva"];
      visibles.forEach(txt => {
        const chip = document.createElement("span");
        chip.className = "plano-card-uva-chip";
        chip.textContent = txt;
        uvas.appendChild(chip);
      });
      uvas.title = uvasTexto || "";
      extra.appendChild(uvas);
    }
    bloque.appendChild(extra);

    // Altura base (luego se ajusta con el contenido real tras insertarla en el DOM).
    bloque.style.setProperty("--plano-card-h", `${PLANO_CARD_HEIGHT_BASE}px`);

  const defaultX = 6 + (idx * 13) % 80;
  const defaultY = 8 + (idx * 17) % 70;
  const x = item.pos_x != null ? item.pos_x : defaultX;
  const y = item.pos_y != null ? item.pos_y : defaultY;

  const clampedX = Math.max(0, Math.min(100 - offsetXPercent, x));
  const clampedY = Math.max(0, Math.min(100 - offsetYPercent, y));
    bloque.style.left = `${clampedX}%`;
    bloque.style.top = `${clampedY}%`;
  bloque.dataset.posx = clampedX;
  bloque.dataset.posy = clampedY;
  bloque.addEventListener("dblclick", () => irAlContenedor(item));

  bloque.addEventListener("pointerdown", ev => iniciarArrastrePlano(ev, item, bloque), { capture: true });
  canvas.appendChild(bloque);

  // Ajuste de altura: crece si el contenido no cabe (variedades, añada, etc.).
  // Antes sólo se ajustaba cuando había saltos de línea en variedades; si una variedad era larga (wrap)
  // o el contenido excedía por tipografía/dispositivo, se quedaba cortado por el overflow.
  if (!estaVacio) {
    const altoNecesario = bloque.scrollHeight || PLANO_CARD_HEIGHT_BASE;
    if (altoNecesario > PLANO_CARD_HEIGHT_BASE) {
      const alto = Math.min(PLANO_CARD_HEIGHT_MAX, Math.max(PLANO_CARD_HEIGHT_BASE, altoNecesario));
      bloque.style.setProperty("--plano-card-h", `${alto}px`);
    }
  }
});

  if (planoSeleccion && !seleccionEncontrada) {
    planoSeleccion = null;
    planoSeleccionItemActual = null;
  }
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarArrastrePlano(ev, item, elemento) {
  const editor = document.getElementById("planoEditor");
  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanSpace || boton === 1);
  if (esPan && editor) {
    ev.stopPropagation();
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  ev.stopPropagation();
  ev.preventDefault();
  const canvas = document.getElementById("planoCanvas");
  if (!canvas) return;
  seleccionarPlanoBodega(item, elemento);
  const rect = elemento.getBoundingClientRect();

  planoDrag = {
    item,
    elemento,
    pointerId: ev.pointerId,
    canvas,
    offsetX: ev.clientX - rect.left,
    offsetY: ev.clientY - rect.top,
    startClientX: ev.clientX,
    startClientY: ev.clientY,
    moved: false,
    startPos: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
    current: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
  };

  try {
    elemento.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  window.addEventListener("pointermove", moverElementoPlano);
  window.addEventListener("pointerup", soltarElementoPlano);
  window.addEventListener("pointercancel", cancelarArrastrePlano);
}

function moverElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  const { canvas, elemento, offsetX, offsetY } = planoDrag;
  const rect = canvas.getBoundingClientRect();
  const elRect = elemento.getBoundingClientRect();

  if (!planoDrag.moved) {
    const dx = ev.clientX - (planoDrag.startClientX || 0);
    const dy = ev.clientY - (planoDrag.startClientY || 0);
    if (Math.hypot(dx, dy) < PLANO_DRAG_THRESHOLD_PX) return;
    planoDrag.moved = true;
    elemento.classList.add("arrastrando");
  }

  let px = ev.clientX - rect.left - offsetX;
  let py = ev.clientY - rect.top - offsetY;

  const maxX = rect.width - elRect.width;
  const maxY = rect.height - elRect.height;

  px = Math.max(0, Math.min(maxX, px));
  py = Math.max(0, Math.min(maxY, py));

  const xPercent = (px / rect.width) * 100;
  const yPercent = (py / rect.height) * 100;

  elemento.style.left = `${xPercent}%`;
  elemento.style.top = `${yPercent}%`;
  elemento.dataset.posx = xPercent;
  elemento.dataset.posy = yPercent;
  planoDrag.current = { x: xPercent, y: yPercent };
}

function soltarElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  finalizarArrastrePlano(true);
}

function cancelarArrastrePlano() {
  finalizarArrastrePlano(false);
}

function finalizarArrastrePlano(guardar) {
  if (!planoDrag) return;
  window.removeEventListener("pointermove", moverElementoPlano);
  window.removeEventListener("pointerup", soltarElementoPlano);
  window.removeEventListener("pointercancel", cancelarArrastrePlano);

  if (planoDrag.elemento) {
    try {
      planoDrag.elemento.releasePointerCapture(planoDrag.pointerId);
    } catch (e) {
      // noop
    }
    planoDrag.elemento.classList.remove("arrastrando");
  }

  if (!planoDrag.moved) {
    planoDrag = null;
    return;
  }

  if (guardar && planoDrag.current) {
    guardarPosicionPlano(planoDrag.item, planoDrag.current.x, planoDrag.current.y);
  } else {
    renderPlano();
  }

  planoDrag = null;
}

async function guardarPosicionPlano(item, x, y) {
  const url =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? `/api/depositos/${item.id}/posicion`
      : `/api/barricas/${item.id}/posicion`;
  const pos = {
    pos_x: Math.round(x * 100) / 100,
    pos_y: Math.round(y * 100) / 100,
  };

  try {
    const res = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pos),
    });
    if (!res.ok) {
      let detalle = "";
      try {
        const data = await res.json();
        detalle = data && data.error ? `: ${data.error}` : "";
      } catch (e) {
        // noop
      }
      throw new Error(`Error HTTP ${res.status}${detalle}`);
    }
    actualizarCachePlano(item, pos.pos_x, pos.pos_y);
  } catch (err) {
    console.error("Error guardando posición:", err);
    const texto = err && err.message ? err.message : "Error desconocido";
    alert(`No se pudo guardar la nueva ubicación (${texto}). Se restaurará la vista.`);
    renderPlano();
  }
}

function actualizarCachePlano(item, x, y) {
  if (item.tipo === "deposito") {
    const dep = cacheDepositos.find(d => d.id === item.id);
    if (dep) {
      dep.pos_x = x;
      dep.pos_y = y;
    }
  } else if (item.tipo === "mastelone") {
    const mas = cacheMastelones.find(d => d.id === item.id);
    if (mas) {
      mas.pos_x = x;
      mas.pos_y = y;
    }
  } else {
    const bar = cacheBarricas.find(b => b.id === item.id);
    if (bar) {
      bar.pos_x = x;
      bar.pos_y = y;
    }
  }
}

// ---------- Resumen (bodega) ----------
async function cargarResumen() {
  try {
    const resumenKilos = document.getElementById("resumenKilos");
    const resumenDepositos = document.getElementById("resumenDepositos");
    const resumenBarricas = document.getElementById("resumenBarricas");
    // 1) Resumen principal (kilos, depósitos, barricas)
    const res = await fetch("/api/resumen");
    if (!res.ok) return;
    const data = await res.json();
    const calculado = calcularLitrosResumenDesdeCaches();
    if (resumenKilos) {
      resumenKilos.textContent =
        (Number(calculado.kilos_entrados || 0) || Number(data.kilos_entrados || 0) || 0).toFixed(0) + " kg";
    }
    if (resumenDepositos) {
      resumenDepositos.textContent = data.depositos || 0;
    }
    if (resumenBarricas) {
      resumenBarricas.textContent = data.barricas || 0;
    }
    actualizarGraficosResumen({ ...data, ...calculado });

  } catch (err) {
    console.error("Error cargando resumen:", err);
  }
}
        // ---------- Entradas de uva ----------
        async function cargarEntradas() {
            try {
                mostrarSkeletonTabla("tablaEntradas", 15, 4);
                const res = await fetch("/api/entradas-uva");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEntradas = datos;

                const tbody = document.getElementById("tablaEntradas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="15">No hay entradas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const anada = e.anada || obtenerAnadaDesdeFecha(e.fecha || "");
                    const fechaEntrada = formatearFechaCorta(e.fecha);
                    const densidad = formatearDensidad(e.densidad);
                    const temperaturaVal = Number(e.temperatura);
                    const temperatura = Number.isFinite(temperaturaVal) ? temperaturaVal.toFixed(1) : "";
                    const phVal = Number(e.ph);
                    const ph = Number.isFinite(phVal) ? phVal.toFixed(2) : "";
                    const acidezVal = Number(e.acidez_total);
                    const acidez = Number.isFinite(acidezVal) ? acidezVal.toFixed(2) : "";
                    const cajasVal = Number(e.cajas_total ?? e.cajas);
                    const cajasTexto = Number.isFinite(cajasVal) && cajasVal > 0 ? cajasVal : "—";
                    let variedadTexto = e.variedad || "";
                    const esMixto = Number(e.mixto || 0) === 1 || String(variedadTexto).toUpperCase() === "MIXTO";
                    if (esMixto) {
                        let contador = Number(e.lineas_count || 0) || 0;
                        if (!contador && typeof e.observaciones === "string") {
                            const linea = e.observaciones.split("\n").find(l => l.startsWith("LINEAS_JSON="));
                            if (linea) {
                                try {
                                    const json = linea.replace("LINEAS_JSON=", "");
                                    const lineas = JSON.parse(json);
                                    if (Array.isArray(lineas)) contador = lineas.length;
                                } catch (_err) {
                                    contador = 0;
                                }
                            }
                        }
                        variedadTexto = contador ? `MIXTO (${contador})` : "MIXTO";
                    }
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${e.id}</td>
                        <td>${fechaEntrada}</td>
                        <td>${anada}</td>
                        <td>${variedadTexto}</td>
                        <td>${e.viticultor || ""}</td>
                        <td>${e.tipo_suelo || ""}</td>
                        <td>${e.parcela || ""}</td>
                        <td>${e.anos_vid || ""}</td>
                        <td>${e.kilos ?? ""}</td>
                        <td>${cajasTexto}</td>
                        <td>${densidad}</td>
                        <td>${temperatura}</td>
                        <td>${ph}</td>
                        <td>${acidez}</td>
                        <td>
                            <button class="small-btn" style="margin-right:6px;"
                                onclick="editarEntradaUva(${e.id})">
                                Editar
                            </button>
                            <button class="small-btn" style="background:#c00; color:#fff;"
                                onclick="eliminarEntradaUva(${e.id})">
                                Borrar
                            </button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
                renderResumenParcelas();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
                renderFlowNodes();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando entradas:", err);
            }
        }

function renderResumenParcelas() {
            const tbody = document.getElementById("tablaResumenParcelas");
            if (!tbody) return;
            tbody.innerHTML = "";

            if (!cacheEntradas.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin datos todavía.</td>';
                tbody.appendChild(tr);
                return;
            }

            const resumen = {};
            cacheEntradas.forEach(e => {
                const parcela = (e.parcela || "Sin nombre").trim() || "Sin nombre";
                if (!resumen[parcela]) {
                    resumen[parcela] = { viajes: 0, kilos: 0, ultima: null };
                }
                resumen[parcela].viajes += 1;
                const kilos = Number(e.kilos || 0);
                resumen[parcela].kilos += Number.isNaN(kilos) ? 0 : kilos;
                const fecha = e.fecha || "";
                if (!resumen[parcela].ultima || fecha > resumen[parcela].ultima) {
                    resumen[parcela].ultima = fecha;
                }
            });

            Object.entries(resumen).forEach(([parcela, info]) => {
                const fecha = info.ultima ? new Date(info.ultima) : null;
                const fechaStr = formatearFechaCorta(info.ultima);
                const horaStr =
                    fecha && !Number.isNaN(fecha)
                        ? fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })
                        : "";
                const kilosValor = Number(info.kilos || 0);
                const kilosTexto =
                    kilosValor > 0
                        ? `${kilosValor.toLocaleString("es-ES", { minimumFractionDigits: 0 })} kg`
                        : "0 kg";
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${parcela}</td>
                    <td>${info.viajes}</td>
                    <td>${kilosTexto}</td>
                    <td>${fechaStr}</td>
                    <td>${horaStr}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function cancelarEdicionEntrada() {
            entradaEditandoId = null;
            const form = document.getElementById("formEntradaUva");
            if (form) form.reset();
            limpiarLineasEntrada();
            const mixto = document.getElementById("entradaMixto");
            if (mixto) mixto.checked = false;
            const modo = document.getElementById("entradaModoKilos");
            if (modo) modo.value = "total";
            actualizarEntradaMixtoUI();
            establecerFechaEntradaActual();
            actualizarAnadaEntrada();
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Registrar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "none";
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        function establecerFechaEntradaActual() {
            const campoFecha = document.getElementById("entradaFecha");
            if (!campoFecha) return;
            const ahora = new Date();
            campoFecha.value = formatearFechaParaInput(ahora);
            campoFecha.disabled = false;
            actualizarAnadaEntrada();
            actualizarResumenAdministracion();
        }

        function actualizarEntradaMixtoUI() {
            const mixto = document.getElementById("entradaMixto");
            const modo = document.getElementById("entradaModoKilos");
            const wrapVariedad = document.getElementById("entradaVariedadWrap");
            const wrapKilos = document.getElementById("entradaKilosWrap");
            const wrapLineas = document.getElementById("entradaLineasWrap");
            const wrapModo = document.getElementById("entradaModoKilosWrap");
            const inputVariedad = document.getElementById("entradaVariedad");
            const inputKilos = document.getElementById("entradaKilos");
            const modoSeleccionado = modo ? modo.value : "total";
            const activo = mixto ? mixto.checked : false;

            if (wrapVariedad) wrapVariedad.style.display = activo ? "none" : "";
            if (wrapLineas) wrapLineas.style.display = activo ? "block" : "none";
            if (wrapModo) wrapModo.style.display = activo ? "block" : "none";
            if (wrapKilos) wrapKilos.style.display = !activo || modoSeleccionado === "total" ? "block" : "none";
            if (inputVariedad) inputVariedad.required = !activo;
            if (inputKilos) inputKilos.required = !activo || modoSeleccionado === "total";

            document.querySelectorAll("#entradaLineas .entrada-linea").forEach(linea => {
                const inputK = linea.querySelector(".entrada-linea-kilos");
                if (!inputK) return;
                if (modoSeleccionado === "por_variedad") {
                    inputK.style.display = "";
                    linea.style.gridTemplateColumns = "minmax(0,1fr) 90px 90px 110px 36px";
                } else {
                    inputK.style.display = "none";
                    linea.style.gridTemplateColumns = "minmax(0,1fr) 90px 110px 36px";
                }
            });
            actualizarResumenAdministracion();
        }

        function crearLineaEntradaUI(data = {}) {
            const contenedor = document.getElementById("entradaLineas");
            if (!contenedor) return;
            const fila = document.createElement("div");
            fila.className = "entrada-linea";
            fila.style.display = "grid";
            fila.style.gap = "6px";
            fila.style.alignItems = "center";
            fila.style.padding = "8px";
            fila.style.border = "1px dashed #ddd";
            fila.style.borderRadius = "10px";

            const inputVariedad = document.createElement("input");
            inputVariedad.type = "text";
            inputVariedad.placeholder = "Variedad";
            inputVariedad.value = data.variedad || "";
            inputVariedad.className = "entrada-linea-variedad";

            const inputCajas = document.createElement("input");
            inputCajas.type = "number";
            inputCajas.placeholder = "Cajas";
            inputCajas.value = data.cajas != null ? data.cajas : "";
            inputCajas.className = "entrada-linea-cajas";

            const inputKilos = document.createElement("input");
            inputKilos.type = "number";
            inputKilos.step = "0.1";
            inputKilos.placeholder = "Kilos";
            inputKilos.value = data.kilos != null ? data.kilos : "";
            inputKilos.className = "entrada-linea-kilos";

            const selectTipo = document.createElement("select");
            selectTipo.className = "entrada-linea-tipo";
            const opciones = ["", "10", "12", "15", "18", "Otro"];
            opciones.forEach(valor => {
                const option = document.createElement("option");
                option.value = valor;
                option.textContent = valor ? valor : "Tipo caja";
                selectTipo.appendChild(option);
            });
            selectTipo.value = data.tipo_caja || document.getElementById("entradaTipoCaja").value || "";

            const btnEliminar = document.createElement("button");
            btnEliminar.type = "button";
            btnEliminar.textContent = "✕";
            btnEliminar.style.border = "none";
            btnEliminar.style.background = "#f3f3f3";
            btnEliminar.style.borderRadius = "8px";
            btnEliminar.style.cursor = "pointer";
            btnEliminar.style.padding = "8px";
            btnEliminar.addEventListener("click", () => {
                fila.remove();
                recalcularResumenLineas();
            });

            [inputVariedad, inputCajas, inputKilos, selectTipo].forEach(input => {
                input.addEventListener("input", recalcularResumenLineas);
                input.addEventListener("change", recalcularResumenLineas);
            });

            fila.appendChild(inputVariedad);
            fila.appendChild(inputCajas);
            fila.appendChild(inputKilos);
            fila.appendChild(selectTipo);
            fila.appendChild(btnEliminar);
            contenedor.appendChild(fila);
            actualizarEntradaMixtoUI();
            recalcularResumenLineas();
        }

        function limpiarLineasEntrada() {
            const contenedor = document.getElementById("entradaLineas");
            if (contenedor) contenedor.innerHTML = "";
            const resumen = document.getElementById("entradaResumenLineas");
            if (resumen) resumen.textContent = "";
            actualizarResumenAdministracion();
        }

        function obtenerLineasEntrada() {
            const modo = document.getElementById("entradaModoKilos").value || "total";
            const filas = Array.from(document.querySelectorAll("#entradaLineas .entrada-linea"));
            return filas.map(fila => {
                const variedad = (fila.querySelector(".entrada-linea-variedad")?.value || "").trim();
                const cajas = Number(fila.querySelector(".entrada-linea-cajas")?.value || 0);
                const kilosInput = fila.querySelector(".entrada-linea-kilos");
                const kilos = modo === "por_variedad" ? Number(kilosInput?.value || 0) : null;
                const tipo_caja = fila.querySelector(".entrada-linea-tipo")?.value || "";
                return { variedad, cajas, kilos, tipo_caja: tipo_caja || null };
            });
        }

        function recalcularResumenLineas() {
            const resumen = document.getElementById("entradaResumenLineas");
            const mixto = document.getElementById("entradaMixto").checked;
            if (!resumen || !mixto) {
                if (resumen) resumen.textContent = "";
                actualizarResumenAdministracion();
                return;
            }
            const modo = document.getElementById("entradaModoKilos").value || "total";
            const cajasTotal = Number(document.getElementById("entradaCajas").value || 0);
            const kilosTotal = Number(document.getElementById("entradaKilos").value || 0);
            const lineas = obtenerLineasEntrada();
            const cajasLineas = lineas.reduce((sum, l) => sum + (Number(l.cajas) || 0), 0);
            const kilosLineas = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
            let texto = `Cajas líneas: ${cajasLineas || 0} / Cajas total: ${Number.isFinite(cajasTotal) && cajasTotal > 0 ? cajasTotal : "-"}`;
            if (modo === "por_variedad") {
                const kilosTexto = kilosLineas > 0 ? kilosLineas.toFixed(1) : "0";
                texto += ` — Kilos líneas: ${kilosTexto} / Kilos total: ${kilosTexto}`;
            } else {
                texto += ` — Kilos total: ${Number.isFinite(kilosTotal) && kilosTotal > 0 ? kilosTotal : "-"}`;
            }
            resumen.textContent = texto;
            actualizarResumenAdministracion();
        }

        async function cargarLineasEntradaUI(entradaId) {
            limpiarLineasEntrada();
            if (!entradaId) return;
            try {
                const res = await fetch(`/api/entradas-uva/${entradaId}/lineas`);
                if (!res.ok) return;
                const data = await res.json();
                const lineas = Array.isArray(data.lineas) ? data.lineas : [];
                if (!lineas.length) {
                    crearLineaEntradaUI();
                    return;
                }
                lineas.forEach(linea => {
                    crearLineaEntradaUI({
                        variedad: linea.variedad,
                        cajas: linea.cajas,
                        kilos: linea.kilos,
                        tipo_caja: linea.tipo_caja,
                    });
                });
            } catch (err) {
                console.error("Error cargando líneas de entrada:", err);
            }
        }

        function initEntradaMixtoUI() {
            const checkMixto = document.getElementById("entradaMixto");
            const selectModo = document.getElementById("entradaModoKilos");
            const btnAgregar = document.getElementById("btnEntradaAgregarLinea");
            const inputCajas = document.getElementById("entradaCajas");
            const inputKilos = document.getElementById("entradaKilos");
            const selectTipoCaja = document.getElementById("entradaTipoCaja");

            if (checkMixto) {
                checkMixto.addEventListener("change", () => {
                    if (checkMixto.checked && !document.querySelector("#entradaLineas .entrada-linea")) {
                        crearLineaEntradaUI();
                    }
                    actualizarEntradaMixtoUI();
                    recalcularResumenLineas();
                });
            }
            if (selectModo) {
                selectModo.addEventListener("change", () => {
                    actualizarEntradaMixtoUI();
                    recalcularResumenLineas();
                });
            }
            if (btnAgregar) {
                btnAgregar.addEventListener("click", () => {
                    crearLineaEntradaUI();
                });
            }
            if (inputCajas) {
                inputCajas.addEventListener("input", recalcularResumenLineas);
            }
            if (inputKilos) {
                inputKilos.addEventListener("input", recalcularResumenLineas);
            }
            if (selectTipoCaja) {
                selectTipoCaja.addEventListener("change", () => {
                    const valor = selectTipoCaja.value;
                    if (!valor) return;
                    document.querySelectorAll("#entradaLineas select").forEach(select => {
                        if (!select.value) select.value = valor;
                    });
                });
            }

            actualizarEntradaMixtoUI();
            establecerFechaEntradaActual();
        }

        const PLANTILLAS_PROCEDENCIA_KEY = "plantillas_procedencia_uva";

        function normalizarRc(valor) {
            return (valor || "").toString().toUpperCase().replace(/[^0-9A-Z]/g, "");
        }

        function descomponerContactoProveedor(valor) {
            const raw = (valor || "").toString().trim();
            if (!raw) return { telefono: "", email: "" };
            let telefono = "";
            let email = "";
            const partes = raw.split(/\s*\|\s*/).map(p => p.trim()).filter(Boolean);
            const limpiarPrefijo = (texto) =>
                texto.replace(/^(tel[eé]fono|tel|email|e-?mail)\s*[:\-]\s*/i, "").trim();
            const asignar = (texto) => {
                const limpio = limpiarPrefijo(texto);
                if (!limpio) return;
                if (!email && /@/.test(limpio)) {
                    email = limpio;
                    return;
                }
                if (!telefono) {
                    telefono = limpio;
                }
            };
            if (partes.length) {
                partes.forEach(asignar);
            } else {
                asignar(raw);
            }
            if (!email && /@/.test(raw)) email = limpiarPrefijo(raw);
            if (!telefono && !email) telefono = limpiarPrefijo(raw);
            return { telefono, email };
        }

        function construirContactoProveedorDesdeForm() {
            const telefono = (document.getElementById("entradaViticultorTelefono")?.value || "").toString().trim();
            const email = (document.getElementById("entradaViticultorEmail")?.value || "").toString().trim();
            if (telefono && email) return `Tel: ${telefono} | Email: ${email}`;
            if (telefono) return `Tel: ${telefono}`;
            if (email) return `Email: ${email}`;
            return "";
        }

        function obtenerDatosProcedenciaForm() {
            return {
                catastro_rc: normalizarRc(document.getElementById("entradaRc")?.value || ""),
                catastro_provincia: (document.getElementById("entradaProvincia")?.value || "").toString().trim(),
                catastro_municipio: (document.getElementById("entradaMunicipio")?.value || "").toString().trim(),
                catastro_poligono: (document.getElementById("entradaPoligono")?.value || "").toString().trim(),
                catastro_parcela: (document.getElementById("entradaParcelaCat")?.value || "").toString().trim(),
                catastro_recinto: (document.getElementById("entradaRecinto")?.value || "").toString().trim(),
                parcela: (document.getElementById("entradaParcela")?.value || "").toString().trim(),
                viticultor: (document.getElementById("entradaViticultor")?.value || "").toString().trim(),
                viticultor_nif: (document.getElementById("entradaViticultorNif")?.value || "").toString().trim(),
                viticultor_contacto: construirContactoProveedorDesdeForm(),
            };
        }

        function aplicarDatosProcedenciaForm(data = {}) {
            const contacto = descomponerContactoProveedor(data.viticultor_contacto || "");
            const map = {
                entradaRc: data.catastro_rc || "",
                entradaProvincia: data.catastro_provincia || "",
                entradaMunicipio: data.catastro_municipio || "",
                entradaPoligono: data.catastro_poligono || "",
                entradaParcelaCat: data.catastro_parcela || "",
                entradaRecinto: data.catastro_recinto || "",
                entradaParcela: data.parcela || "",
                entradaViticultor: data.viticultor || "",
                entradaViticultorNif: data.viticultor_nif || "",
                entradaViticultorTelefono: contacto.telefono || "",
                entradaViticultorEmail: contacto.email || "",
            };
            Object.entries(map).forEach(([id, valor]) => {
                const input = document.getElementById(id);
                if (input) input.value = valor;
            });
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        function leerPlantillasProcedencia() {
            try {
                const raw = localStorage.getItem(PLANTILLAS_PROCEDENCIA_KEY);
                const data = JSON.parse(raw || "[]");
                return Array.isArray(data) ? data : [];
            } catch (_err) {
                return [];
            }
        }

        function guardarPlantillasProcedencia(lista) {
            localStorage.setItem(PLANTILLAS_PROCEDENCIA_KEY, JSON.stringify(lista));
        }

        function sugerirNombrePlantilla(data) {
            const viticultor = data.viticultor || "Procedencia";
            const municipio = data.catastro_municipio || data.catastro_provincia || "";
            const rc = data.catastro_rc ? `RC ${data.catastro_rc.slice(-6)}` : "";
            const polPar = data.catastro_poligono || data.catastro_parcela
                ? `P${data.catastro_poligono || "-"} ${data.catastro_parcela || "-"}`
                : "";
            const partes = [viticultor, municipio, rc || polPar].filter(Boolean);
            return partes.join(" · ") || "Procedencia";
        }

        function actualizarPlantillasSelect() {
            const select = document.getElementById("entradaPlantillaSelect");
            if (!select) return;
            const actual = select.value;
            const plantillas = leerPlantillasProcedencia();
            select.innerHTML = '<option value="">(Sin plantilla)</option>';
            plantillas.forEach((plantilla, idx) => {
                const option = document.createElement("option");
                option.value = String(idx);
                option.textContent = plantilla.nombre || `Plantilla ${idx + 1}`;
                select.appendChild(option);
            });
            if (actual) select.value = actual;
        }

        function guardarPlantillaProcedencia() {
            const data = obtenerDatosProcedenciaForm();
            if (!data.catastro_rc && !data.catastro_municipio && !data.catastro_parcela && !data.parcela) {
                mostrarAviso("Completa algún dato de procedencia antes de guardar la plantilla.", "info");
                return;
            }
            const sugerido = sugerirNombrePlantilla(data);
            const nombre = prompt("Nombre de la plantilla", sugerido);
            if (!nombre) return;
            const plantillas = leerPlantillasProcedencia();
            plantillas.push({ nombre: nombre.trim(), data });
            guardarPlantillasProcedencia(plantillas);
            actualizarPlantillasSelect();
            mostrarAviso("Plantilla guardada.", "success");
        }

        function cargarPlantillaProcedencia() {
            const select = document.getElementById("entradaPlantillaSelect");
            const idx = select?.value;
            if (!select || !idx) return;
            const plantillas = leerPlantillasProcedencia();
            const plantilla = plantillas[Number(idx)];
            if (!plantilla) return;
            aplicarDatosProcedenciaForm(plantilla.data || {});
            mostrarAviso("Procedencia cargada.", "success");
        }

        function actualizarAvisoRc(rc) {
            const aviso = document.getElementById("entradaRcAviso");
            if (!aviso) return;
            if (!rc) {
                aviso.textContent = "";
                return;
            }
            aviso.textContent = rc.length === 20 ? "" : "La RC suele tener 20 caracteres.";
        }

        function construirUrlCatastroConsultaBase() {
            return "https://www1.sedecatastro.gob.es/CYCBienInmueble/OVCBusqueda.aspx";
        }

        function construirUrlCatastroRc(rc) {
            const base = "https://www1.sedecatastro.gob.es/CYCBienInmueble/OVCBusqueda.aspx";
            const limpio = normalizarRc(rc);
            const rcFull = limpio.length > 20 ? limpio.slice(0, 20) : limpio;
            const params = new URLSearchParams();
            if (rcFull) {
                params.set("RC", rcFull);
                params.set("rc", rcFull);
                params.set("RefCat", rcFull);
                params.set("refcat", rcFull);
            }
            return `${base}?${params.toString()}`;
        }

        function construirUrlCatastroParcela({ provincia, municipio, poligono, parcela, recinto }) {
            const base = "https://www1.sedecatastro.gob.es/CYCBienInmueble/OVCBusqueda.aspx";
            const params = new URLSearchParams();
            params.set("provincia", provincia || "");
            params.set("municipio", municipio || "");
            params.set("poligono", poligono || "");
            params.set("parcela", parcela || "");
            params.set("Provincia", provincia || "");
            params.set("Municipio", municipio || "");
            params.set("Poligono", poligono || "");
            params.set("Parcela", parcela || "");
            params.set("del", provincia || "");
            params.set("mun", municipio || "");
            params.set("pol", poligono || "");
            params.set("par", parcela || "");
            params.set("busqueda", "poligono");
            if (recinto) {
                params.set("recinto", recinto);
                params.set("Recinto", recinto);
            }
            return `${base}?${params.toString()}`;
        }

        function abrirUrlSeguro(url) {
            const win = window.open(url, "_blank", "noopener");
            if (win) {
                win.focus?.();
                return;
            }
            window.location.href = url;
        }

        function actualizarCatastroUI() {
            const datos = obtenerDatosProcedenciaForm();
            const btnRc = document.getElementById("btnCatastroRc");
            const btnParcela = document.getElementById("btnCatastroParcela");
            const hint = document.getElementById("entradaCatastroHint");
            const linkRc = document.getElementById("entradaCatastroLinkRc");
            const linkParcela = document.getElementById("entradaCatastroLinkParcela");
            const tieneRc = Boolean(datos.catastro_rc);
            const tieneParcela = Boolean(
                datos.catastro_provincia &&
                datos.catastro_municipio &&
                datos.catastro_poligono &&
                datos.catastro_parcela
            );
            if (btnRc) btnRc.disabled = !tieneRc;
            if (btnParcela) btnParcela.disabled = !tieneParcela;
            if (hint) {
                if (tieneRc || tieneParcela) {
                    hint.textContent = "Listo para abrir Catastro.";
                } else {
                    hint.textContent = "Faltan datos para abrir Catastro.";
                }
            }
            if (linkRc) {
                linkRc.href = tieneRc ? construirUrlCatastroRc(datos.catastro_rc) : "#";
                linkRc.setAttribute("aria-disabled", tieneRc ? "false" : "true");
            }
            if (linkParcela) {
                linkParcela.href = tieneParcela
                    ? construirUrlCatastroParcela({
                        provincia: datos.catastro_provincia,
                        municipio: datos.catastro_municipio,
                        poligono: datos.catastro_poligono,
                        parcela: datos.catastro_parcela,
                        recinto: datos.catastro_recinto,
                    })
                    : "#";
                linkParcela.setAttribute("aria-disabled", tieneParcela ? "false" : "true");
            }
            actualizarAvisoRc(datos.catastro_rc);
        }

        function abrirCatastroRc() {
            const rc = normalizarRc(document.getElementById("entradaRc")?.value || "");
            if (!rc) {
                mostrarAviso("Introduce una RC valida para abrir Catastro.", "info");
                return;
            }
            abrirUrlSeguro(construirUrlCatastroRc(rc));
        }

        function abrirCatastroParcela() {
            const datos = obtenerDatosProcedenciaForm();
            if (!datos.catastro_provincia || !datos.catastro_municipio || !datos.catastro_poligono || !datos.catastro_parcela) {
                mostrarAviso("Completa provincia, municipio, poligono y parcela para abrir Catastro.", "info");
                return;
            }
            const url = construirUrlCatastroParcela({
                provincia: datos.catastro_provincia,
                municipio: datos.catastro_municipio,
                poligono: datos.catastro_poligono,
                parcela: datos.catastro_parcela,
                recinto: datos.catastro_recinto,
            });
            abrirUrlSeguro(url);
        }

        function construirResumenAdministracion() {
            const fechaRaw = document.getElementById("entradaFecha")?.value || "";
            const fecha = fechaRaw ? new Date(fechaRaw) : null;
            const fechaTexto = fecha && !Number.isNaN(fecha.getTime())
                ? fecha.toLocaleString("es-ES", { dateStyle: "medium", timeStyle: "short" })
                : "";
            const observaciones = (document.getElementById("entradaObservaciones")?.value || "").toString().trim();
            const mixto = document.getElementById("entradaMixto")?.checked;
            const modoKilos = document.getElementById("entradaModoKilos")?.value || "total";
            const variedad = (document.getElementById("entradaVariedad")?.value || "").toString().trim();

            const datos = obtenerDatosProcedenciaForm();
            const cajasTotal = Number(document.getElementById("entradaCajas")?.value || 0);
            let kilosTotal = Number(document.getElementById("entradaKilos")?.value || 0);
            if (mixto && modoKilos === "por_variedad") {
                const lineas = obtenerLineasEntrada();
                kilosTotal = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
            }

            let variedadesTexto = "";
            if (mixto) {
                const lineas = obtenerLineasEntrada();
                const totalKilos = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
                const partes = lineas.map(linea => {
                    const nombre = linea.variedad || "Variedad";
                    if (modoKilos === "por_variedad" && totalKilos > 0) {
                        const kilos = Number(linea.kilos) || 0;
                        const pct = Math.round((kilos / totalKilos) * 100);
                        return `${nombre} ${pct}% (${kilos.toFixed(1)} kg)`;
                    }
                    const cajas = Number(linea.cajas) || 0;
                    return `${nombre} (${cajas} cajas)`;
                });
                variedadesTexto = partes.length ? `MIXTO · ${partes.join(" · ")}` : "MIXTO";
            } else {
                variedadesTexto = variedad;
            }

            const partes = [];
            if (fechaTexto) partes.push(`Fecha entrada: ${fechaTexto}`);
            if (datos.viticultor) partes.push(`Proveedor/viticultor: ${datos.viticultor}`);
            if (datos.catastro_rc) partes.push(`Referencia Catastral (RC): ${datos.catastro_rc}`);
            if (datos.catastro_provincia || datos.catastro_municipio) {
                partes.push(`Provincia / Municipio: ${datos.catastro_provincia || "—"} / ${datos.catastro_municipio || "—"}`);
            }
            if (datos.catastro_poligono || datos.catastro_parcela || datos.catastro_recinto) {
                const pol = datos.catastro_poligono || "—";
                const par = datos.catastro_parcela || "—";
                const rec = datos.catastro_recinto ? ` / Recinto ${datos.catastro_recinto}` : "";
                partes.push(`Polígono / Parcela: ${pol} / ${par}${rec}`);
            }
            if (variedadesTexto) partes.push(`Variedades: ${variedadesTexto}`);
            const kilosTexto = kilosTotal ? `${kilosTotal.toFixed(1)} kg` : "—";
            const cajasTexto = cajasTotal ? `${cajasTotal} cajas` : "—";
            partes.push(`Kilos / cajas: ${kilosTexto} / ${cajasTexto}`);
            if (observaciones) partes.push(`Observaciones: ${observaciones}`);
            return partes.join("\n");
        }

        function actualizarResumenAdministracion() {
            const textarea = document.getElementById("entradaResumenAdminTexto");
            if (!textarea) return;
            textarea.value = construirResumenAdministracion();
        }

        function copiarResumenAdministracion() {
            const texto = construirResumenAdministracion();
            if (!texto) return;
            if (navigator.clipboard?.writeText) {
                navigator.clipboard.writeText(texto).then(() => {
                    mostrarAviso("Resumen copiado.", "success");
                }).catch(() => {
                    mostrarAviso("No se pudo copiar el resumen.", "error");
                });
                return;
            }
            const textarea = document.getElementById("entradaResumenAdminTexto");
            if (textarea) {
                textarea.focus();
                textarea.select();
                document.execCommand("copy");
                mostrarAviso("Resumen copiado.", "success");
            }
        }

        function initEntradaProcedenciaUI() {
            const rcInput = document.getElementById("entradaRc");
            const inputs = [
                "entradaFecha",
                "entradaRc",
                "entradaProvincia",
                "entradaMunicipio",
                "entradaPoligono",
                "entradaParcelaCat",
                "entradaRecinto",
                "entradaParcela",
                "entradaViticultor",
                "entradaViticultorNif",
                "entradaViticultorTelefono",
                "entradaViticultorEmail",
                "entradaVariedad",
                "entradaKilos",
                "entradaCajas",
                "entradaDensidad",
                "entradaTemperatura",
                "entradaPh",
                "entradaAcidezTotal",
                "entradaObservaciones",
            ];
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (!input) return;
                const handler = () => {
                    if (id === "entradaRc" && rcInput) {
                        const normalizado = normalizarRc(rcInput.value);
                        if (rcInput.value !== normalizado) rcInput.value = normalizado;
                    }
                    if (id === "entradaFecha") {
                        actualizarAnadaEntrada();
                    }
                    actualizarCatastroUI();
                    actualizarResumenAdministracion();
                };
                input.addEventListener("input", handler);
                input.addEventListener("change", handler);
            });

            const btnRc = document.getElementById("btnCatastroRc");
            if (btnRc) btnRc.addEventListener("click", abrirCatastroRc);
            const btnParcela = document.getElementById("btnCatastroParcela");
            if (btnParcela) btnParcela.addEventListener("click", abrirCatastroParcela);

            const selectPlantilla = document.getElementById("entradaPlantillaSelect");
            if (selectPlantilla) {
                selectPlantilla.addEventListener("change", cargarPlantillaProcedencia);
            }
            const btnAplicar = document.getElementById("btnAplicarPlantilla");
            if (btnAplicar) btnAplicar.addEventListener("click", cargarPlantillaProcedencia);
            const btnGuardar = document.getElementById("btnGuardarPlantilla");
            if (btnGuardar) btnGuardar.addEventListener("click", guardarPlantillaProcedencia);

            const btnCopiar = document.getElementById("btnCopiarResumenEntrada");
            if (btnCopiar) btnCopiar.addEventListener("click", copiarResumenAdministracion);

            actualizarPlantillasSelect();
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        async function crearEntradaUva(ev) {
            ev.preventDefault();
            setFormFeedback("feedbackEntradaUva", "");
            const fecha = document.getElementById("entradaFecha").value;
            const variedad = document.getElementById("entradaVariedad").value.trim();
            const viticultor = document.getElementById("entradaViticultor").value.trim();
            const parcela = document.getElementById("entradaParcela").value.trim();
            const catastro_rc = normalizarRc(document.getElementById("entradaRc").value);
            const catastro_provincia = document.getElementById("entradaProvincia").value.trim();
            const catastro_municipio = document.getElementById("entradaMunicipio").value.trim();
            const catastro_poligono = document.getElementById("entradaPoligono").value.trim();
            const catastro_parcela = document.getElementById("entradaParcelaCat").value.trim();
            const catastro_recinto = document.getElementById("entradaRecinto").value.trim();
            const viticultor_nif = document.getElementById("entradaViticultorNif").value.trim();
            const viticultor_contacto = construirContactoProveedorDesdeForm();
            const tipo_suelo = document.getElementById("entradaSuelo").value;
            const anos_vid = document.getElementById("entradaAnosVid").value;
            const observaciones = document.getElementById("entradaObservaciones").value.trim();
            const mixto = document.getElementById("entradaMixto").checked;
            const modo_kilos = document.getElementById("entradaModoKilos").value || "total";
            const tipo_caja = document.getElementById("entradaTipoCaja").value;
            const parseValor = (id) => {
                const raw = (document.getElementById(id).value || "").toString().trim();
                if (!raw) return null;
                const limpio = raw.replace(",", ".");
                const num = parseFloat(limpio);
                return Number.isFinite(num) ? num : null;
            };
            const parseEntero = (id) => {
                const raw = (document.getElementById(id).value || "").toString().trim();
                if (!raw) return null;
                const limpio = raw.replace(",", ".");
                const num = Number(limpio);
                return Number.isInteger(num) ? num : null;
            };
            const kilos = parseValor("entradaKilos") || 0;
            const cajas = parseEntero("entradaCajas") || 0;
            const densidad = parseValor("entradaDensidad");
            const temperatura = parseValor("entradaTemperatura");
            const ph = parseValor("entradaPh");
            const acidez_total = parseValor("entradaAcidezTotal");

            if (!fecha) {
                setFormFeedback("feedbackEntradaUva", "La fecha es obligatoria.", "error");
                return;
            }
            if (!cajas) {
                setFormFeedback("feedbackEntradaUva", "Las cajas son obligatorias.", "error");
                return;
            }
            if (!mixto || modo_kilos === "total") {
                if (!kilos) {
                    setFormFeedback("feedbackEntradaUva", "Los kilos son obligatorios.", "error");
                    return;
                }
            }
            if (!mixto && !variedad) {
                setFormFeedback("feedbackEntradaUva", "La variedad es obligatoria.", "error");
                return;
            }
            try {
                const mensajePorDefecto = entradaEditandoId
                    ? "Error al actualizar la entrada de uva."
                    : "Error al registrar la entrada de uva.";
                const body = {
                    parcela: parcela || null,
                    viticultor,
                    viticultor_nif: viticultor_nif || null,
                    viticultor_contacto: viticultor_contacto || null,
                    tipo_suelo,
                    anos_vid,
                    densidad,
                    temperatura,
                    ph,
                    acidez_total,
                    observaciones: observaciones || null,
                    catastro_rc: catastro_rc || null,
                    catastro_provincia: catastro_provincia || null,
                    catastro_municipio: catastro_municipio || null,
                    catastro_poligono: catastro_poligono || null,
                    catastro_parcela: catastro_parcela || null,
                    catastro_recinto: catastro_recinto || null,
                    cajas_total: cajas,
                    tipo_caja: tipo_caja || null,
                    mixto,
                    modo_kilos: mixto ? modo_kilos : "total",
                };
                if (!mixto || modo_kilos === "total") {
                    body.kilos_total = kilos;
                }
                if (!mixto) {
                    body.variedad = variedad;
                } else {
                    const lineas = obtenerLineasEntrada();
                    if (!lineas.length) {
                        setFormFeedback("feedbackEntradaUva", "Añade al menos una variedad.", "error");
                        return;
                    }
                    for (const [idx, linea] of lineas.entries()) {
                        if (!linea.variedad) {
                            setFormFeedback("feedbackEntradaUva", `Variedad obligatoria en la línea ${idx + 1}.`, "error");
                            return;
                        }
                        if (!Number.isFinite(linea.cajas) || linea.cajas <= 0 || !Number.isInteger(linea.cajas)) {
                            setFormFeedback("feedbackEntradaUva", `Cajas inválidas en la línea ${idx + 1}.`, "error");
                            return;
                        }
                        if (modo_kilos === "por_variedad") {
                            if (!Number.isFinite(linea.kilos) || linea.kilos <= 0) {
                                setFormFeedback("feedbackEntradaUva", `Kilos inválidos en la línea ${idx + 1}.`, "error");
                                return;
                            }
                        }
                    }
                    const sumaCajas = lineas.reduce((sum, l) => sum + l.cajas, 0);
                    if (sumaCajas !== cajas) {
                        setFormFeedback("feedbackEntradaUva", "Las cajas de las líneas no cuadran con el total.", "error");
                        return;
                    }
                    if (modo_kilos === "por_variedad") {
                        const sumaKilos = lineas.reduce((sum, l) => sum + l.kilos, 0);
                        if (!sumaKilos) {
                            setFormFeedback("feedbackEntradaUva", "Los kilos por variedad son obligatorios.", "error");
                            return;
                        }
                        body.kilos_total = sumaKilos;
                    }
                    body.lineas = lineas;
                }
                if (fecha) {
                    body.fecha = fecha;
                }
                const url = entradaEditandoId ? `/api/entradas-uva/${entradaEditandoId}` : "/api/entradas-uva";
                const metodo = entradaEditandoId ? "PUT" : "POST";
                const res = await fetch(url, {
                    method: metodo,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) {
                    let mensaje = mensajePorDefecto;
                    try {
                        const data = await res.json();
                        if (data?.error) mensaje = data.error;
                    } catch (_err) {
                        // Si falla el parseo, dejamos el mensaje por defecto.
                    }
                    throw new Error(mensaje);
                }

                cancelarEdicionEntrada();
                await Promise.all([
                    cargarEntradas(),
                    cargarResumen(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarMovimientos(),
                ]);
                setFormFeedback("feedbackEntradaUva", "Entrada registrada correctamente.", "success");
                mostrarAviso("Entrada registrada en la bodega.", "success");
            } catch (err) {
                console.error("Error creando entrada:", err);
                const mensaje = err?.message || "Error al registrar la entrada de uva.";
                setFormFeedback("feedbackEntradaUva", mensaje, "error");
                mostrarAviso(mensaje, "error");
            }
        }

        async function editarEntradaUva(id) {
            const entrada = cacheEntradas.find(e => e.id === id);
            if (!entrada) {
                mostrarAviso("No encuentro esa entrada.", "error");
                return;
            }
            entradaEditandoId = id;
            const campoFecha = document.getElementById("entradaFecha");
            if (campoFecha) {
                campoFecha.disabled = false;
                campoFecha.value = formatearFechaParaInput(entrada.fecha);
            }
            document.getElementById("entradaVariedad").value = entrada.variedad || "";
            document.getElementById("entradaParcela").value = entrada.parcela || "";
            document.getElementById("entradaViticultor").value = entrada.viticultor || "";
            document.getElementById("entradaViticultorNif").value = entrada.viticultor_nif || "";
            const contactoProveedor = descomponerContactoProveedor(entrada.viticultor_contacto || "");
            document.getElementById("entradaViticultorTelefono").value = contactoProveedor.telefono || "";
            document.getElementById("entradaViticultorEmail").value = contactoProveedor.email || "";
            document.getElementById("entradaRc").value = normalizarRc(entrada.catastro_rc || "");
            document.getElementById("entradaProvincia").value = entrada.catastro_provincia || "";
            document.getElementById("entradaMunicipio").value = entrada.catastro_municipio || "";
            document.getElementById("entradaPoligono").value = entrada.catastro_poligono || "";
            document.getElementById("entradaParcelaCat").value = entrada.catastro_parcela || "";
            document.getElementById("entradaRecinto").value = entrada.catastro_recinto || "";
            document.getElementById("entradaSuelo").value = entrada.tipo_suelo || "";
            document.getElementById("entradaAnosVid").value = entrada.anos_vid || "";
            document.getElementById("entradaKilos").value = entrada.kilos ?? "";
            document.getElementById("entradaCajas").value = entrada.cajas_total ?? entrada.cajas ?? "";
            document.getElementById("entradaDensidad").value = entrada.densidad ?? "";
            document.getElementById("entradaTemperatura").value = entrada.temperatura ?? "";
            document.getElementById("entradaPh").value = entrada.ph ?? "";
            document.getElementById("entradaAcidezTotal").value = entrada.acidez_total ?? "";
            document.getElementById("entradaObservaciones").value = entrada.observaciones || "";
            document.getElementById("entradaTipoCaja").value = "";

            const esMixto = Number(entrada.mixto || 0) === 1 || String(entrada.variedad || "").toUpperCase() === "MIXTO";
            const modo = entrada.modo_kilos || "total";
            const checkMixto = document.getElementById("entradaMixto");
            if (checkMixto) checkMixto.checked = esMixto;
            const selectModo = document.getElementById("entradaModoKilos");
            if (selectModo) selectModo.value = modo;

            if (esMixto) {
                await cargarLineasEntradaUI(id);
            } else {
                limpiarLineasEntrada();
            }
            actualizarEntradaMixtoUI();
            recalcularResumenLineas();

            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Actualizar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "inline-flex";
            document.getElementById("entradas").scrollIntoView({ behavior: "smooth", block: "start" });
            actualizarAnadaEntrada();
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        async function eliminarEntradaUva(id) {
            if (!confirm("¿Seguro que quieres borrar esta entrada de uva?")) return;
            try {
                const res = await fetch(`/api/entradas-uva/${id}`, { method: "DELETE" });
                if (!res.ok) throw new Error();
                if (entradaEditandoId === id) {
                    cancelarEdicionEntrada();
                }
                await Promise.all([cargarEntradas(), cargarResumen(), cargarDepositos(), cargarBarricas(), cargarMovimientos()]);
            } catch (err) {
                console.error("Error borrando entrada:", err);
                alert("No se pudo borrar la entrada.");
            }
        }
// ---------- Depósitos (con edición de volumen, contenido y fecha) ----------
async function cargarDepositos() {
  try {
    mostrarSkeletonTabla("tablaDepositos", 10);
    const res = await fetch("/api/depositos");
    if (!res.ok) {
      console.error("Error HTTP al cargar depósitos:", res.status);
      return;
    }

    const datos = await res.json();
    const separados = datos.reduce(
      (acc, item) => {
        const clase = (item.clase || "deposito").toLowerCase();
        if (clase === "mastelone") {
          acc.mastelones.push(item);
        } else {
          acc.depositos.push(item);
        }
        return acc;
      },
      { depositos: [], mastelones: [] }
    );

	    cacheDepositos = separados.depositos;
	    cacheMastelones = separados.mastelones;
	    // Volúmenes desde nodos (último eslabón)
	    cacheDepositos.forEach(d => {
	      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
	      const volActual = normalizarNumeroFlexible(d.litros_actuales);
	      const tieneActual = Number.isFinite(volActual) && volActual > 0;
	      if (Number.isFinite(volNodo) && (volNodo > 0 || !tieneActual)) {
	        d.litros_actuales = Math.max(0, volNodo);
	      }
	    });
	    cacheMastelones.forEach(d => {
	      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
	      const volActual = normalizarNumeroFlexible(d.litros_actuales);
	      const tieneActual = Number.isFinite(volActual) && volActual > 0;
	      if (Number.isFinite(volNodo) && (volNodo > 0 || !tieneActual)) {
	        d.litros_actuales = Math.max(0, volNodo);
	      }
	    });
    mapaDepositosPorId = new Map(cacheDepositos.map(d => [d.id, d]));
    mapaMastelonesPorId = new Map(cacheMastelones.map(d => [d.id, d]));
    if (typeof poblarSelectBitacoraContenedores === "function") {
      poblarSelectBitacoraContenedores();
    } else if (!window.__bitacoraSelectWarned) {
      console.warn("[bitacora] falta poblarSelectBitacoraContenedores; se omite para no cortar carga");
      window.__bitacoraSelectWarned = true;
    }

    const listaTabla = [...cacheDepositos, ...cacheMastelones];
    renderTablaContenedores(listaTabla, "tablaDepositos", "No hay depósitos ni mastelones.");
    renderPlano();
    renderAnalisisLab();
    actualizarIndicadores();
    refrescarGraficosResumenDesdeCaches();
    actualizarAprovechamientoAnual();
    actualizarMapaFlujo();
    renderCatas();
    programarActualizacionCopiloto();
  } catch (err) {
    console.error("Error cargando depósitos:", err);
  }
}

function renderTablaContenedores(lista, tablaId, mensajeVacio) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  tbody.innerHTML = "";

  if (!lista.length) {
    tbody.innerHTML = `<tr><td colspan="10">${mensajeVacio}</td></tr>`;
    return;
  }

  lista.forEach(d => {
    const estadoVisual = resolverEstadoVisualContenedor("deposito", d);
    const variedadVisible = estadoVisual.variedadVisible;
    const volumenVisible = estadoVisual.volumenVisible;
    const volumenParaEliminar = estadoVisual.volumenFinal;
    const capacidad =
      d.capacidad_l != null
        ? Number(d.capacidad_l).toFixed(0)
        : d.capacidad_hl != null
        ? Number(d.capacidad_hl * 100).toFixed(0)
        : "";
    const material = d.material || d.contenido || "";
    const tipoBitacora = (d.clase || "deposito").toLowerCase() === "mastelone" ? "mastelone" : "deposito";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${d.id}</td>
      <td>${d.codigo || ""}${d.alias ? ` — ${d.alias}` : ""}</td>
      <td>${capacidad}</td>
      <td>${d.tipo || ""}</td>
      <td>${material}</td>
      <td>${variedadVisible}</td>
      <td>${volumenVisible}</td>
      <td>
        <button class="small-btn"
          onclick="editarDepositoDatos(${d.id})">
          Editar
        </button>
      </td>
      <td>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button class="small-btn"
            onclick="abrirBitacoraContenedor('${tipoBitacora}', ${d.id})">
            Bitácora
          </button>
        </div>
      </td>
      <td>
        <button
          onclick="eliminarDeposito(${d.id}, ${volumenParaEliminar})"
          style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
          Borrar
        </button>
      </td>
    `;
    tbody.appendChild(tr);
  });
}
function abrirBitacoraContenedor(tipo, id) {
  const tipoNorm = (tipo || "").toString().trim().toLowerCase();
  const idNum = Number(id);
  if (!tipoNorm || !Number.isFinite(idNum)) return;
  let nombre = "";
  if (tipoNorm === "deposito") {
    nombre = obtenerNombreDeposito(idNum);
  } else if (tipoNorm === "mastelone") {
    nombre = obtenerNombreMastelone(idNum);
  } else if (tipoNorm === "barrica") {
    nombre = obtenerNombreBarrica(idNum);
  } else {
    nombre = `Contenedor ${idNum}`;
  }
  if (typeof window.abrirModalBitacora !== "function") {
    mostrarAviso("No se pudo abrir la bitácora.", "error");
    return;
  }
  window.abrirModalBitacora({ contenedorTipo: tipoNorm, contenedorId: idNum, nombre });
}
  // No dejar borrar si tiene vino dentro
async function eliminarDeposito(id, volumen) {
  const registro =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  const clase = registro ? (registro.clase || "deposito") : "deposito";
  const etiqueta = clase === "mastelone" ? "mastelone" : "depósito";

  if (volumen > 0) {
    alert(`No puedes borrar un ${etiqueta} que todavía tiene vino. Pon el volumen a 0 primero.`);
    return;
  }

  const ok = confirm(`¿Seguro que quieres borrar este ${etiqueta}?`);
  if (!ok) return;

  try {
    const res = await fetch(`/api/depositos/${id}`, {
      method: "DELETE"
    });

    if (!res.ok) {
      alert("Error borrando el depósito.");
      console.error("Error HTTP al borrar depósito:", res.status);
      return;
    }

    alert("Depósito borrado.");
    cargarDepositos();
  } catch (err) {
    console.error("Error borrando depósito:", err);
    alert("Error borrando el depósito (mira la consola del servidor).");
  }
}

function mostrarModalUsarContenedorExistente({ tipo, existing }) {
  return new Promise(resolve => {
    const tipoLabel = tipo === "barrica" ? "barrica" : "depósito";
    const codigo = existing?.codigo || "#";
    const titulo = "Ya existe";
    const mensaje = `El ${tipoLabel} ${codigo} ya existe en esta bodega.`;
    const detalle = "Puedes usar el existente en lugar de crear otro.";

    const overlay = document.createElement("div");
    overlay.className = "flow-modal visible";
    overlay.innerHTML = `
      <div class="flow-modal-content" style="max-width:460px;">
        <h3 style="margin-top:0;">${titulo}</h3>
        <p style="margin:0 0 6px;">${mensaje}</p>
        <p style="margin:0 0 14px; opacity:.8;">${detalle}</p>
        <div class="flow-modal-actions" style="justify-content:flex-end; gap:8px;">
          <button type="button" class="btnSecundario" data-cancelar>Cancelar</button>
          <button type="button" class="btnPrimario" data-usar>Usar este ${codigo}</button>
        </div>
      </div>
    `;
    const cerrar = valor => {
      overlay.remove();
      resolve(Boolean(valor));
    };
    overlay.querySelector("[data-cancelar]")?.addEventListener("click", () => cerrar(false));
    overlay.querySelector("[data-usar]")?.addEventListener("click", () => cerrar(true));
    overlay.addEventListener("click", ev => {
      if (ev.target === overlay) cerrar(false);
    });
    document.body.appendChild(overlay);
  });
}

function seleccionarValorSiExiste(select, value) {
  if (!select) return false;
  const existe = Array.from(select.options || []).some(opt => String(opt.value) === String(value));
  if (!existe) return false;
  select.value = String(value);
  select.dispatchEvent(new Event("change", { bubbles: true }));
  return true;
}

async function usarContenedorExistenteEnUI(tipo, existing) {
  const id = Number(existing?.id);
  if (!Number.isFinite(id) || id <= 0) return;
  await Promise.all([cargarDepositos(), cargarBarricas()]);

  if (typeof poblarSelectCopilotoNotaContenedores === "function") poblarSelectCopilotoNotaContenedores();
  if (typeof poblarSelectCopilotoTimelineContenedores === "function") poblarSelectCopilotoTimelineContenedores();

  const key = `${tipo}:${id}`;
  const selectsConKey = [
    "copilotoToolsContainer",
    "copilotoNotaContenedor",
    "copilotoTimelineContenedor",
    "expressCtrlContenedor",
    "expressMovOrigen",
    "expressMovDestino",
    "expressBotOrigen",
  ];
  selectsConKey.forEach(selectId => {
    const sel = document.getElementById(selectId);
    seleccionarValorSiExiste(sel, key);
  });

  const tipoUso = document.getElementById("usoProductoDestinoTipo");
  const selectUso = document.getElementById("usoProductoDestinoId");
  if (tipoUso && selectUso && (tipo === "deposito" || tipo === "barrica" || tipo === "mastelone")) {
    tipoUso.value = tipo;
    if (typeof actualizarOpcionesDestinoUsoProducto === "function") {
      actualizarOpcionesDestinoUsoProducto();
    }
    seleccionarValorSiExiste(selectUso, String(id));
  }
}

async function crearDeposito(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackDepositos", "");

  const codigo = document.getElementById("depCodigo").value.trim();
  const tipo = document.getElementById("depTipo").value;
  const clase = (tipo || "").trim().toLowerCase() === "mastelone" ? "mastelone" : "deposito";
  const capacidad_l = Number(document.getElementById("depCapacidad").value || 0);
  const estado = "vacio";
  const material = document.getElementById("depMaterial").value;
  const vino_tipo = "";
  const vino_anio = "";
  const elaboracion = "";
  const fecha_uso = null;
  if (!codigo) {
    setFormFeedback("feedbackDepositos", "El código del contenedor es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackDepositos", "Introduce una capacidad válida en litros.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackDepositos", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackDepositos", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch("/api/depositos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        clase,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        vino_tipo,
        vino_anio,
        elaboracion,
        fecha_uso,
        estado,
      }),
    });
    if (res.status === 409) {
      const data = await res.json().catch(() => ({}));
      if (data?.error === "YA_EXISTE" && data?.existing) {
        const usar = await mostrarModalUsarContenedorExistente({
          tipo: "deposito",
          existing: data.existing,
        });
        if (usar) {
          await usarContenedorExistenteEnUI("deposito", data.existing);
          document.getElementById("formDeposito")?.reset();
          setFormFeedback("feedbackDepositos", "Usando depósito existente.", "success");
          mostrarAviso(`Usando depósito existente ${data.existing.codigo || ""}.`, "info");
        }
        return;
      }
    }
    const ok = await manejarRespuesta(res, "Error creando depósito");
    if (!ok) return;

    // Limpia el formulario
    document.getElementById("formDeposito").reset();
    // Vuelve a cargar la tabla
    await Promise.all([cargarDepositos(), cargarResumen()]);
    setFormFeedback("feedbackDepositos", "Contenedor creado correctamente.", "success");
    mostrarAviso("Nuevo contenedor registrado.", "success");
  } catch (err) {
    console.error("Error creando depósito:", err);
    setFormFeedback("feedbackDepositos", "Error creando depósito.", "error");
    mostrarAviso("No se pudo crear el contenedor.", "error");
  }
}
function editarDepositoDatos(id) {
  const dep =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  if (!dep) {
    mostrarAviso("No encuentro ese depósito.", "error");
    return;
  }
  abrirModalDeposito(dep);
}

function abrirModalDeposito(dep) {
  depositoEditando = { ...dep };
  const modal = document.getElementById("modalDeposito");
  if (!modal) return;
  const capacidad =
    dep.capacidad_l != null
      ? Number(dep.capacidad_l)
      : dep.capacidad_hl != null
      ? Number(dep.capacidad_hl * 100)
      : "";
  const campos = {
    depCodigoEdit: dep.codigo || "",
    depCapacidadEdit: capacidad || "",
    depVolumenEdit: dep.litros_actuales != null ? Number(dep.litros_actuales).toFixed(1) : "0",
  };
  Object.entries(campos).forEach(([id, valor]) => {
    const input = document.getElementById(id);
    if (input) input.value = valor ?? "";
  });
  const tipoSelect = document.getElementById("depTipoEdit");
  if (tipoSelect) {
    tipoSelect.value = dep.tipo || "";
  }
  const materialSelect = document.getElementById("depMaterialEdit");
  if (materialSelect) {
    materialSelect.value = dep.material || dep.contenido || "";
  }
  const estadoSelect = document.getElementById("depEstadoEdit");
  if (estadoSelect) {
    estadoSelect.value = dep.estado || "vacio";
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    const estadoNodo = obtenerEstadoDepositoDesdeNodo(dep.id);
    const enMapa = Boolean(estadoNodo && estadoNodo.enMapa);
    const volumenActual = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : null;
    const tieneVino = enMapa && volumenActual != null && volumenActual > 0;
    const variedadNodo = formatearVariedadLinea(estadoNodo?.variedad || "");
    if (tieneVino) {
      variedadInfo.textContent = variedadNodo || "Sin variedad";
    } else {
      variedadInfo.textContent = enMapa ? "Vacío" : "Sin vino";
    }
  }
  setFormFeedback("feedbackEditarDeposito", "");
  modal.classList.add("visible");
}

function cerrarModalDeposito() {
  depositoEditando = null;
  const modal = document.getElementById("modalDeposito");
  if (modal) {
    modal.classList.remove("visible");
  }
  const form = document.getElementById("formEditarDeposito");
  if (form) {
    form.reset();
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = "—";
  }
  setFormFeedback("feedbackEditarDeposito", "");
}

async function guardarEdicionDeposito(ev) {
  ev.preventDefault();
  if (!depositoEditando) return;
  const codigo = document.getElementById("depCodigoEdit").value.trim();
  const capacidad_l = Number(document.getElementById("depCapacidadEdit").value || 0);
  const volumenNuevo = Number(document.getElementById("depVolumenEdit").value || 0);
  const tipo = document.getElementById("depTipoEdit").value;
  const material = document.getElementById("depMaterialEdit").value;
  const estado = document.getElementById("depEstadoEdit").value || "vacio";
  const vinoTipo = volumenNuevo > 0 ? depositoEditando.vino_tipo : "";

  if (!codigo) {
    setFormFeedback("feedbackEditarDeposito", "El código es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackEditarDeposito", "Introduce una capacidad válida.", "error");
    return;
  }
  if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
    setFormFeedback("feedbackEditarDeposito", "El volumen debe ser un número positivo.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch(`/api/depositos/${depositoEditando.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        elaboracion: depositoEditando.elaboracion,
        vino_tipo: vinoTipo,
        vino_anio: depositoEditando.vino_anio,
        fecha_uso: depositoEditando.fecha_uso,
        clase: depositoEditando.clase || "deposito",
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo actualizar el depósito.");
    if (!ok) return;
    await aplicarAjusteDeposito(
      depositoEditando.id,
      Number(depositoEditando.litros_actuales || 0),
      volumenNuevo,
      depositoEditando.clase || "deposito"
    );
    await Promise.all([cargarDepositos(), cargarMovimientos(), cargarResumen()]);
    mostrarAviso("Depósito actualizado.", "success");
    cerrarModalDeposito();
  } catch (err) {
    console.error("Error actualizando depósito:", err);
    setFormFeedback("feedbackEditarDeposito", "No se pudo actualizar el depósito.", "error");
  }
}
async function aplicarAjusteDeposito(id, volumenActual, nuevo, clase = "deposito") {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const tipoMovimiento = clase === "mastelone" ? "mastelone" : "deposito";
  const etiqueta = tipoMovimiento === "mastelone" ? "mastelone" : "depósito";
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: tipoMovimiento,
        destino_id: id,
        litros: delta,
        perdida_litros: null,
        nota: `Ajuste de volumen desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: tipoMovimiento,
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        perdida_litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste de volumen:", err);
    alert("No se pudo registrar el ajuste de volumen.");
  }
}

// ---------- Catas sensoriales ----------
async function cargarCatas() {
  try {
    const res = await fetch("/api/catas");
    if (!res.ok) return;
    cacheCatas = await res.json();
    renderCatas();
  } catch (err) {
    console.error("Error cargando catas:", err);
  }
}

function recortarTexto(texto, max = 120) {
  if (!texto) return "";
  const limpio = texto.toString().trim();
  if (limpio.length <= max) return limpio;
  return `${limpio.slice(0, max).trim()}…`;
}

function resumenCata(cata) {
  if (!cata) return "Sin catas todavía.";
  const partes = [cata.vista, cata.nariz, cata.boca, cata.equilibrio, cata.defectos]
    .map(p => (p || "").toString().trim())
    .filter(Boolean);
  const base = partes.join(" · ");
  const nota = cata.nota ? cata.nota.toString().trim() : "";
  return recortarTexto(base || nota || "Cata registrada.");
}

function formatearFechaHoraLarga(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
  return `${fecha.toLocaleDateString("es-ES")} ${hora}`;
}

function renderCatas() {
  renderCatasEnGrid(
    [...(cacheDepositos || []), ...(cacheMastelones || [])],
    "cataGrid",
    cont => ((cont.clase || "").toLowerCase() === "mastelone" ? "mastelone" : "deposito"),
    "No hay depósitos todavía."
  );
  renderCatasEnGrid(cacheBarricas || [], "cataGridBarricas", () => "barrica", "No hay barricas todavía.");
}

function renderCatasEnGrid(contenedores, gridId, resolverTipo, mensajeVacio) {
  const grid = document.getElementById(gridId);
  if (!grid) return;
  grid.innerHTML = "";
  if (!contenedores.length) {
    grid.appendChild(crearElementoCopilotoEmpty(mensajeVacio || "Sin datos."));
    return;
  }

  contenedores.forEach(cont => {
    const tipo = typeof resolverTipo === "function" ? resolverTipo(cont) : resolverTipo;
    const id = cont.id;
    const codigo = cont.codigo || "";
    const contenedorRef = { ...cont, tipo, id, codigo };
    const catas = (cacheCatas || [])
      .filter(c => c.contenedor_tipo === tipo && Number(c.contenedor_id) === id)
      .sort((a, b) => {
        const aMs = parseFechaMs(a.fecha) || 0;
        const bMs = parseFechaMs(b.fecha) || 0;
        return bMs - aMs;
      });
    const ultima = catas[0] || null;

    const card = document.createElement("div");
    card.className = "cata-card";

    const header = document.createElement("div");
    header.className = "cata-card-header";
    const title = document.createElement("div");
    title.className = "cata-card-title";
    const tipoLabel =
      tipo === "barrica" ? "Barrica" : tipo === "mastelone" ? "Mastelone" : "Depósito";
    title.textContent = `${tipoLabel} ${codigo || "#" + id}`;
    const estado = document.createElement("div");
    estado.className = "cata-card-meta";
    const capacidad =
      cont.capacidad_l != null
        ? Number(cont.capacidad_l)
        : cont.capacidad_hl != null
        ? Number(cont.capacidad_hl * 100)
        : null;
    const estadoNodo =
      tipo === "barrica" ? obtenerEstadoBarricaDesdeNodo(cont.id) : obtenerEstadoDepositoDesdeNodo(cont.id);
    const volumenActual = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : cont.litros_actuales;
    estado.textContent = `${formatearLitrosPlano(volumenActual)} / ${capacidad ? formatearLitrosPlano(capacidad) : "—"}`;
    header.appendChild(title);
    header.appendChild(estado);

    const meta = document.createElement("div");
    meta.className = "cata-card-meta";
    const fechaTxt = ultima?.fecha ? formatearFechaCorta(ultima.fecha) : "Sin cata";
    meta.textContent = `Última cata: ${fechaTxt}`;

    const resumen = document.createElement("div");
    resumen.className = "cata-card-meta";
    resumen.textContent = resumenCata(ultima);

    const acciones = document.createElement("div");
    acciones.className = "cata-card-actions";
    const nuevaBtn = document.createElement("button");
    nuevaBtn.type = "button";
    nuevaBtn.className = "btnPrimario";
    nuevaBtn.textContent = "Nueva cata";
    nuevaBtn.addEventListener("click", () => abrirModalCata(tipo, id));
    const verBtn = document.createElement("button");
    verBtn.type = "button";
    verBtn.className = "btnSecundario";
    verBtn.textContent = tipo === "barrica" ? "Ver barrica" : "Ver depósito";
    verBtn.addEventListener("click", () => irAlContenedor({ tipo, id, codigo }));
    acciones.appendChild(nuevaBtn);
    acciones.appendChild(verBtn);
    if (ultima) {
      acciones.appendChild(crearBotonPdfCata(ultima, contenedorRef, "PDF última cata", "btnSecundario"));
    }

    card.appendChild(header);
    card.appendChild(meta);
    card.appendChild(resumen);
    card.appendChild(acciones);

    if (catas.length) {
      const historial = document.createElement("details");
      historial.className = "cata-history";
      const summary = document.createElement("summary");
      summary.textContent = `Historial (${catas.length})`;
      const lista = document.createElement("ul");
      catas.forEach(cata => {
        const li = document.createElement("li");
        const fila = document.createElement("div");
        fila.style.display = "flex";
        fila.style.alignItems = "center";
        fila.style.justifyContent = "space-between";
        fila.style.gap = "10px";
        const texto = document.createElement("span");
        const fecha = cata.fecha ? formatearFechaCorta(cata.fecha) : "—";
        const intensidad = cata.intensidad ? ` · ${cata.intensidad}` : "";
        texto.textContent = `${fecha}${intensidad} · ${resumenCata(cata)}`;
        fila.appendChild(texto);
        fila.appendChild(crearBotonPdfCata(cata, contenedorRef, "PDF", "small-btn"));
        li.appendChild(fila);
        lista.appendChild(li);
      });
      historial.appendChild(summary);
      historial.appendChild(lista);
      card.appendChild(historial);
    }

    grid.appendChild(card);
  });
}

function crearBotonPdfCata(cata, contenedorRef, label = "PDF", clase = "small-btn") {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = clase;
  btn.textContent = label;
  btn.addEventListener("click", () => exportarCataPDF(cata, contenedorRef));
  return btn;
}

async function exportarCataPDF(cata, contenedorRef) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se cargó). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const tipoLabel =
      contenedorRef.tipo === "barrica"
        ? "Barrica"
        : contenedorRef.tipo === "mastelone"
        ? "Mastelone"
        : "Depósito";
    const info = obtenerInfoContenedor(contenedorRef.tipo, contenedorRef.id) || contenedorRef;
    const codigo = info.codigo || contenedorRef.codigo || `#${contenedorRef.id}`;
    const variedad = info.vino_tipo || contenedorRef.vino_tipo || "";
    const anada = info.vino_anio || contenedorRef.vino_anio || "";
    const capacidadRaw =
      info.capacidad_l != null
        ? Number(info.capacidad_l)
        : info.capacidad_hl != null
        ? Number(info.capacidad_hl * 100)
        : null;
    const estadoNodo =
      contenedorRef.tipo === "barrica"
        ? obtenerEstadoBarricaDesdeNodo(contenedorRef.id)
        : obtenerEstadoDepositoDesdeNodo(contenedorRef.id);
    const volumenRaw = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : info.litros_actuales;
    const capacidad = Number.isFinite(capacidadRaw) ? formatearLitrosPlano(capacidadRaw) : "—";
    const volumen = Number.isFinite(Number(volumenRaw)) ? formatearLitrosPlano(volumenRaw) : "—";
    const fecha = formatearFechaHoraLarga(cata.fecha) || "—";

    doc.setFontSize(16);
    doc.text(`Hoja de cata · ${tipoLabel} ${codigo}`, 14, 18);
    doc.setFontSize(11);
    let y = 26;
    const lineas = [
      `Fecha: ${fecha}`,
      `Variedad / vino: ${variedad || "—"}`,
      `Añada: ${anada || "—"}`,
      `Capacidad: ${capacidad}`,
      `Volumen: ${volumen}`,
      `Intensidad: ${cata.intensidad || "—"}`,
    ];
    lineas.forEach(linea => {
      doc.text(linea, 14, y);
      y += 6;
    });

    const pageHeight = doc.internal.pageSize.getHeight
      ? doc.internal.pageSize.getHeight()
      : doc.internal.pageSize.height;
    const maxWidth = (doc.internal.pageSize.getWidth
      ? doc.internal.pageSize.getWidth()
      : doc.internal.pageSize.width) - 28;
    const escribirBloque = (titulo, texto) => {
      if (y > pageHeight - 24) {
        doc.addPage();
        y = 18;
      }
      doc.setFont(undefined, "bold");
      doc.text(titulo, 14, y);
      y += 6;
      doc.setFont(undefined, "normal");
      const contenido = (texto || "").toString().trim() || "—";
      const lineasTexto = doc.splitTextToSize ? doc.splitTextToSize(contenido, maxWidth) : [contenido];
      lineasTexto.forEach(linea => {
        if (y > pageHeight - 14) {
          doc.addPage();
          y = 18;
        }
        doc.text(linea, 14, y);
        y += 6;
      });
      y += 4;
    };

    escribirBloque("Vista", cata.vista);
    escribirBloque("Nariz", cata.nariz);
    escribirBloque("Boca", cata.boca);
    escribirBloque("Equilibrio", cata.equilibrio);
    escribirBloque("Defectos / alertas", cata.defectos);
    escribirBloque("Nota general", cata.nota);

    const safeTipo = tipoLabel
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    const safeCodigo = codigo.toString().replace(/[^a-z0-9_-]+/gi, "-");
    const nombreArchivo = `cata-${safeTipo}-${safeCodigo || contenedorRef.id}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de cata:", err);
    alert("No se pudo generar el PDF.");
  }
}

function abrirModalCata(tipo, id) {
  const modal = document.getElementById("modalCata");
  if (!modal) return;
  const info = obtenerInfoContenedor(tipo, id);
  const etiqueta = info?.codigo ? info.codigo : `#${id}`;
  const contenedorTxt =
    tipo === "mastelone"
      ? `Mastelone ${etiqueta}`
      : tipo === "barrica"
      ? `Barrica ${etiqueta}`
      : `Depósito ${etiqueta}`;
  const infoTexto = info ? describirContenedor(info, contenedorTxt) : contenedorTxt;
  const label = document.getElementById("cataContenedorInfo");
  if (label) label.textContent = infoTexto;
  const form = document.getElementById("formCata");
  if (form) form.reset();
  const fechaInput = document.getElementById("cataFecha");
  if (fechaInput) fechaInput.value = formatearFechaParaInput(new Date());
  const tipoInput = document.getElementById("cataTipo");
  const idInput = document.getElementById("cataId");
  if (tipoInput) tipoInput.value = tipo;
  if (idInput) idInput.value = id;
  setFormFeedback("feedbackCata", "");
  modal.classList.add("visible");
}

function cerrarModalCata() {
  const modal = document.getElementById("modalCata");
  if (modal) modal.classList.remove("visible");
  const form = document.getElementById("formCata");
  if (form) form.reset();
  const label = document.getElementById("cataContenedorInfo");
  if (label) label.textContent = "";
  setFormFeedback("feedbackCata", "");
}

async function guardarCata(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackCata", "");
  const contenedor_tipo = document.getElementById("cataTipo").value;
  const contenedor_id = Number(document.getElementById("cataId").value);
  const fecha = document.getElementById("cataFecha").value;
  const vista = document.getElementById("cataVista").value.trim();
  const nariz = document.getElementById("cataNariz").value.trim();
  const boca = document.getElementById("cataBoca").value.trim();
  const equilibrio = document.getElementById("cataEquilibrio").value.trim();
  const defectos = document.getElementById("cataDefectos").value.trim();
  const intensidad = document.getElementById("cataIntensidad").value;
  const nota = document.getElementById("cataNota").value.trim();

  if (!contenedor_tipo || !contenedor_id || !fecha) {
    setFormFeedback("feedbackCata", "Faltan datos: contenedor y fecha.", "error");
    return;
  }

  try {
    const res = await fetch("/api/catas", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contenedor_tipo,
        contenedor_id,
        fecha,
        vista,
        nariz,
        boca,
        equilibrio,
        defectos,
        intensidad,
        nota,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo guardar la cata.");
    if (!ok) return;
    cerrarModalCata();
    await cargarCatas();
    mostrarAviso("Cata registrada.", "success");
  } catch (err) {
    console.error("Error guardando cata:", err);
    setFormFeedback("feedbackCata", "Error al guardar la cata.", "error");
  }
}

function abrirModalBarrica(bar) {
  barricaEditando = { ...bar };
  const modal = document.getElementById("modalBarrica");
  if (!modal) return;
  const campos = {
    barEditId: bar.id || "",
    barEditCodigo: bar.codigo || "",
    barEditCapacidad: bar.capacidad_l != null ? Number(bar.capacidad_l) : "",
    barEditVolumen: bar.litros_actuales != null ? Number(bar.litros_actuales).toFixed(1) : "0",
    barEditTipoRoble: bar.tipo_roble || "",
    barEditTostado: bar.tostado || "",
    barEditMarca: bar.marca || "",
    barEditAnio: bar.anio || "",
    barEditVinoAnio: bar.vino_anio || "",
    barEditVinoTipo: bar.vino_tipo || "",
  };
  Object.entries(campos).forEach(([id, valor]) => {
    const input = document.getElementById(id);
    if (input) input.value = valor ?? "";
  });
  setFormFeedback("feedbackEditarBarrica", "");
  modal.classList.add("visible");
}

function cerrarModalBarrica() {
  barricaEditando = null;
  const modal = document.getElementById("modalBarrica");
  if (modal) modal.classList.remove("visible");
  const form = document.getElementById("formEditarBarrica");
  if (form) form.reset();
  setFormFeedback("feedbackEditarBarrica", "");
}

async function guardarEdicionBarrica(ev) {
  ev.preventDefault();
  if (!barricaEditando) return;

  const codigo = document.getElementById("barEditCodigo").value.trim();
  const capacidad_l = Number(document.getElementById("barEditCapacidad").value || 0);
  const volumenNuevo = Number(document.getElementById("barEditVolumen").value || 0);
  const tipo_roble = document.getElementById("barEditTipoRoble").value.trim() || null;
  const tostado = document.getElementById("barEditTostado").value.trim() || null;
  const marca = document.getElementById("barEditMarca").value.trim() || null;
  const anio = document.getElementById("barEditAnio").value.trim() || null;
  const vino_anio = document.getElementById("barEditVinoAnio").value.trim() || null;
  const vinoInput = document.getElementById("barEditVinoTipo").value;
  const vino_tipo = normalizarTipoVino(vinoInput, barricaEditando.vino_tipo) || null;

  if (!codigo) {
    setFormFeedback("feedbackEditarBarrica", "El código es obligatorio.", "error");
    return;
  }
  if (!Number.isFinite(capacidad_l) || capacidad_l <= 0) {
    setFormFeedback("feedbackEditarBarrica", "Introduce una capacidad válida.", "error");
    return;
  }
  if (!Number.isFinite(volumenNuevo) || volumenNuevo < 0) {
    setFormFeedback("feedbackEditarBarrica", "Introduce un volumen válido.", "error");
    return;
  }

  try {
    const res = await fetch(`/api/barricas/${barricaEditando.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        capacidad_l,
        tipo_roble,
        tostado,
        marca,
        anio,
        vino_anio,
        vino_tipo,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo actualizar la barrica.");
    if (!ok) return;
    await aplicarAjusteBarrica(
      barricaEditando.id,
      Number(barricaEditando.litros_actuales || 0),
      volumenNuevo
    );
    await Promise.all([cargarBarricas(), cargarMovimientos(), cargarResumen()]);
    mostrarAviso("Barrica actualizada.", "success");
    cerrarModalBarrica();
  } catch (err) {
    console.error("Error actualizando barrica:", err);
    setFormFeedback("feedbackEditarBarrica", "No se pudo actualizar la barrica.", "error");
  }
}

async function editarBarricaDatos(id) {
  const bar = cacheBarricas.find(b => b.id === id);
  if (!bar) {
    mostrarAviso("No encuentro esa barrica.", "error");
    return;
  }
  abrirModalBarrica(bar);
}

async function eliminarBarrica(id, volumen) {
    if (volumen > 0) {
        mostrarAviso("No puedes borrar una barrica que aún tiene vino. Ajusta el volumen a 0 primero.", "error");
        return;
    }

    if (!confirm("¿Seguro que quieres borrar esta barrica?")) return;

    try {
        const res = await fetch(`/api/barricas/${id}`, { method: "DELETE" });
        if (!res.ok) throw new Error();
        mostrarAviso("Barrica borrada.", "success");
        await cargarBarricas();
        await cargarResumen();
    } catch (err) {
        console.error("Error borrando barrica:", err);
        mostrarAviso("No se pudo borrar la barrica.", "error");
    }
}
async function aplicarAjusteBarrica(id, volumenActual, nuevo) {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: "barrica",
        destino_id: id,
        litros: delta,
        nota: `Ajuste de volumen en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: "barrica",
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste en barrica:", err);
    mostrarAviso("No se pudo registrar el ajuste de volumen en la barrica.", "error");
  }
}

function formatContainerLabel(item, { tipo = "", withType = false } = {}) {
  if (!item) return "";
  const codigoRaw = (item.codigo || item.nombre || item.etiqueta || "").toString().trim();
  const codigo = codigoRaw || (item.id != null ? `#${item.id}` : "");
  const alias = (item.alias || "").toString().trim();
  const base = alias && codigo ? `${codigo} — ${alias}` : (codigo || alias);
  if (!withType) return base || "";
  const tipoNorm = (tipo || item.tipo || "").toString().toLowerCase();
  const tipoLabel =
    tipoNorm === "barrica"
      ? "Barrica"
      : tipoNorm === "mastelone"
      ? "Mastelone"
      : "Depósito";
  return `${tipoLabel} ${base || `#${item.id}`}`.trim();
}

function filterByCodeOrAlias(item, rawNeedle) {
  const needle = (rawNeedle || "").toString().trim().toLowerCase();
  if (!needle || !item) return false;
  const codigo = (item.codigo || "").toString().trim().toLowerCase();
  const alias = (item.alias || "").toString().trim().toLowerCase();
  const etiqueta = formatContainerLabel(item).toLowerCase();
  return (
    codigo === needle ||
    alias === needle ||
    codigo.includes(needle) ||
    alias.includes(needle) ||
    etiqueta.includes(needle)
  );
}

function obtenerNombreDeposito(id) {
  const dep = mapaDepositosPorId.get(id);
  if (!dep) return `Depósito ${id}`;
  return formatContainerLabel(dep, { tipo: "deposito" }) || `Depósito ${id}`;
}

function obtenerNombreMastelone(id) {
  const mas = mapaMastelonesPorId.get(id);
  if (!mas) return `Mastelone ${id}`;
  return formatContainerLabel(mas, { tipo: "mastelone" }) || `Mastelone ${id}`;
}

function obtenerNombreBarrica(id) {
  const bar = mapaBarricasPorId.get(id);
  if (!bar) return `Barrica ${id}`;
  return formatContainerLabel(bar, { tipo: "barrica" }) || `Barrica ${id}`;
}

function formatearUbicacionMovimiento(tipo, id) {
  if (!tipo || !id) return "";
  if (tipo === "deposito") {
    return obtenerNombreDeposito(Number(id));
  }
  if (tipo === "mastelone") {
    return obtenerNombreMastelone(Number(id));
  }
  if (tipo === "barrica") {
    return obtenerNombreBarrica(Number(id));
  }
  return `${tipo.charAt(0).toUpperCase() + tipo.slice(1)} ${id}`;
}

function formatearLitrosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} L`;
}

function formatearFechaCorta(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  return fecha.toLocaleDateString("es-ES");
}

function formatearFechaParaInput(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const pad = numero => numero.toString().padStart(2, "0");
  const año = fecha.getFullYear();
  const mes = pad(fecha.getMonth() + 1);
  const dia = pad(fecha.getDate());
  const horas = pad(fecha.getHours());
  const minutos = pad(fecha.getMinutes());
  return `${año}-${mes}-${dia}T${horas}:${minutos}`;
}

function obtenerColorVinoReferencia(texto) {
  if (!texto) return null;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (t.includes("blanc")) return "#f5d372";
  if (t.includes("ros") || t.includes("clarete")) return "#f48fb1";
  if (t.includes("tinto") || t.includes("red") || t.includes("tannat")) return "#7b1b47";
  return null;
}

function obtenerColorMaterialContenedor(material, tipo = "") {
  const base = (material || tipo || "")
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();

  if (!base && tipo === "barrica") return "#c69c6d"; // madera (por defecto)

  if (base.includes("inox")) return "#c0c7d1"; // plata
  if (base.includes("fibra")) return "#ff8a3d"; // anaranjado
  if (base.includes("cement")) return "#4a4f59"; // gris oscuro
  if (base.includes("barro") || base.includes("anfora") || base.includes("tinaja")) return "#8a5a3c"; // marrón
  if (base.includes("madera") || base.includes("roble") || base.includes("wood")) return "#c69c6d"; // marrón claro
  if (base.includes("cristal") || base.includes("vidrio") || base.includes("glass")) return "#8fd3ff"; // azul claro
  if (base.includes("plast") || base.includes("plastico")) return "#7b1b47"; // granate

  // fallback por tipo
  if (tipo === "barrica") return "#c69c6d";
  return "#8f97a8";
}

function obtenerColorPuntoVinoPlano(variedadTexto) {
  const granate = "#7b1b47";
  const amarillo = "#f3c77b";
  if (!variedadTexto) return "rgba(143,151,168,0.95)";
  const lineas = variedadTexto
    .toString()
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean);
  let hayBlancas = false;
  let hayTintas = false;
  lineas.forEach(linea => {
    const sinPct = linea.replace(/^\d+(?:[.,]\d+)?%\s*/g, "").trim();
    if (!sinPct) return;
    sinPct
      .split(/[\/·,]/)
      .map(p => p.trim())
      .filter(Boolean)
      .forEach(part => {
        const base = part.replace(/^\d+(?:[.,]\d+)?%?\s*/g, "").trim();
        if (!base || esVariedadGenerica(base)) return;
        const norm = normalizarTextoUva(base);
        if (esVariedadBlanca(norm)) hayBlancas = true;
        else hayTintas = true;
      });
  });
  if (hayBlancas && hayTintas) return mezclarHexConBlanco(granate, 0.5, 1);
  if (hayBlancas) return amarillo;
  if (hayTintas) return granate;
  return "rgba(143,151,168,0.95)";
}

function esColorOscuroHex(hex) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  if (!match) return false;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const luminancia = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminancia < 0.55;
}

function mezclarHexConBlanco(hex, factorBlanco = 0.75, alpha = 0.32) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  const f = Number(factorBlanco);
  const factor = Number.isFinite(f) ? Math.max(0, Math.min(1, f)) : 0.75;
  const a = Number(alpha);
  const opacidad = Number.isFinite(a) ? Math.max(0, Math.min(1, a)) : 0.32;
  if (!match) return `rgba(255,255,255,${opacidad})`;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const rr = Math.round(r + (255 - r) * factor);
  const gg = Math.round(g + (255 - g) * factor);
  const bb = Math.round(b + (255 - b) * factor);
  return `rgba(${rr},${gg},${bb},${opacidad})`;
}

function esVariedadGenerica(texto) {
  if (!texto) return false;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();
  if (!t) return false;
  if (t === "tinto" || t === "vino tinto") return true;
  if (t === "blanco" || t === "vino blanco") return true;
  if (t === "rosado" || t === "vino rosado") return true;
  if (t === "clarete" || t === "vino clarete") return true;
  if (t.includes("vino rosado") && t.includes("clarete")) return true;
  if (t === "vino rosado / clarete") return true;
  return false;
}

function filtrarVariedadesMultilinea(texto) {
  if (!texto) return "";
  const lineas = texto
    .toString()
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => {
      const sinPct = l.replace(/^\d+(?:[.,]\d+)?%\s*/g, "").trim();
      return !esVariedadGenerica(sinPct);
    });
  return lineas.join("\n");
}

function formatearVariedadLinea(texto) {
  if (!texto) return "";
  const limpio = filtrarVariedadesMultilinea(texto);
  if (!limpio) return "";
  return limpio
    .split(/\r?\n/)
    .map(linea => linea.trim())
    .filter(Boolean)
    .join("/");
}

function formatearVariedadesMultilinea(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = (item?.nombre || item?.variedad || "").toString().trim();
      if (!nombre || esVariedadGenerica(nombre)) return "";
      const porcentaje = Number.isFinite(item?.porcentaje) ? item.porcentaje : Number(item?.pct);
      const pct = formatearPctVariedad(Number(porcentaje));
      return pct && pct !== "0%" ? `${pct} ${nombre}` : nombre;
    })
    .filter(Boolean)
    .join("\n");
}

function normalizarListaVariedadesContenedor(raw) {
  if (Array.isArray(raw)) return raw;
  if (typeof raw !== "string") return [];
  const txt = raw.trim();
  if (!txt) return [];
  try {
    const parsed = JSON.parse(txt);
    return Array.isArray(parsed) ? parsed : [];
  } catch (_err) {
    return [];
  }
}

function obtenerVariedadPersistidaContenedor(item) {
  if (!item) return "";
  const listaVarPrimaria = normalizarListaVariedadesContenedor(item.composicionVariedades);
  const listaVarSecundaria = normalizarListaVariedadesContenedor(item.composicion_variedades);
  const listaVar = listaVarPrimaria.length ? listaVarPrimaria : listaVarSecundaria;
  const mixTxt = formatearVariedadLinea(formatearVariedadesMultilinea(listaVar));
  if (mixTxt) return mixTxt;
  const vinoTipo = formatearVariedadLinea(item.vino_tipo || "");
  if (vinoTipo) return vinoTipo;
  const variedadTexto = formatearVariedadLinea(item.variedad || "");
  if (variedadTexto) return variedadTexto;
  return "";
}

function resolverEstadoVisualContenedor(tipo, item) {
  const estadoNodo =
    tipo === "barrica"
      ? obtenerEstadoBarricaDesdeNodo(item?.id)
      : obtenerEstadoDepositoDesdeNodo(item?.id);
  const enMapa = Boolean(estadoNodo && estadoNodo.enMapa);
  const volumenNodo = Number.isFinite(estadoNodo?.volumen) ? Number(estadoNodo.volumen) : null;
  const volumenPersistidoRaw = normalizarNumeroFlexible(item?.litros_actuales ?? item?.volumen);
  const volumenPersistido = Number.isFinite(volumenPersistidoRaw) ? Number(volumenPersistidoRaw) : 0;
  let volumenFinal = 0;
  if (enMapa && volumenNodo != null && volumenNodo > 0) {
    volumenFinal = Math.max(0, volumenNodo);
  } else if (volumenPersistido > 0) {
    volumenFinal = Math.max(0, volumenPersistido);
  } else if (enMapa && volumenNodo != null) {
    volumenFinal = Math.max(0, volumenNodo);
  } else {
    volumenFinal = Math.max(0, volumenPersistido);
  }
  const tieneVino = volumenFinal > 0;
  const variedadNodo = formatearVariedadLinea(estadoNodo?.variedad || "");
  const variedadPersistida = obtenerVariedadPersistidaContenedor(item);
  const variedadVisible = tieneVino
    ? (variedadNodo || variedadPersistida || "—")
    : (enMapa ? "Vacío" : "Sin vino");
  return {
    enMapa,
    volumenFinal,
    variedadVisible,
    volumenVisible: formatearLitrosPlano(volumenFinal),
  };
}

function normalizarTipoVino(entrada, actual = "") {
  if (entrada == null) return actual || "";
  const textoOriginal = entrada.toString().trim();
  if (!textoOriginal) return actual || "";
  const limpio = textoOriginal
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();

  if (["1", "tinto", "vino tinto"].includes(limpio)) return "Vino tinto";
  if (["2", "blanco", "vino blanco"].includes(limpio)) return "Vino blanco";
  if (
    ["3", "rosado", "rosa", "clarete", "vino rosado", "vino clarete"].includes(limpio)
  ) {
    return "Vino rosado / Clarete";
  }
  return textoOriginal;
}

function obtenerAnadaDesdeFecha(fecha) {
  return obtenerAnadaVitivinicolaDesdeFecha(fecha);
}

function actualizarAnadaEntrada() {
  const fecha = document.getElementById("entradaFecha");
  const campo = document.getElementById("entradaAnada");
  if (!campo) return;
  campo.value = fecha ? obtenerAnadaDesdeFecha(fecha.value) : "";
  const lectura = document.getElementById("entradaFechaLectura");
  if (lectura) {
    if (fecha && fecha.value) {
      const fechaValor = new Date(fecha.value);
      lectura.textContent = Number.isNaN(fechaValor.getTime())
        ? "Fecha —"
        : fechaValor.toLocaleString("es-ES", { dateStyle: "medium", timeStyle: "short" });
    } else {
      lectura.textContent = "Fecha —";
    }
  }
  const chip = document.getElementById("entradaChipAnada");
  if (chip) {
    chip.textContent = campo.value ? `Vendimia ${campo.value}` : "Vendimia —";
  }
}

function resolverContenedorId(tipo, valor) {
  if (!valor) return null;
  if (/^\d+$/.test(valor)) {
    return Number(valor);
  }
  const normalizado = String(valor).trim().toLowerCase();
  if (tipo === "deposito") {
    const dep = cacheDepositos.find(d => filterByCodeOrAlias(d, normalizado));
    return dep ? dep.id : null;
  }
  if (tipo === "mastelone") {
    const mas = cacheMastelones.find(m => filterByCodeOrAlias(m, normalizado));
    return mas ? mas.id : null;
  }
  if (tipo === "barrica") {
    const bar = cacheBarricas.find(b => filterByCodeOrAlias(b, normalizado));
    return bar ? bar.id : null;
  }
  return null;
}

function irAlContenedor(item) {
  if (!item || !item.tipo) return;
  if (item.tipo === "deposito" || item.tipo === "mastelone") {
    mostrarSeccion("depositos");
    scrollToContenedor("tablaDepositos", dep => dep.codigo === item.codigo || dep.id === item.id);
  } else if (item.tipo === "barrica") {
    mostrarSeccion("barricas");
    scrollToContenedor("tablaBarricas", bar => bar.codigo === item.codigo || bar.id === item.id);
  }
}

function scrollToContenedor(tablaId, predicate) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  const filas = Array.from(tbody.querySelectorAll("tr"));
  const target = filas.find(tr => {
    const celdas = tr.querySelectorAll("td");
    if (!celdas.length) return false;
    const id = Number(celdas[0].textContent.trim());
    const codigo = celdas[1] ? celdas[1].textContent.trim() : "";
    return predicate({ id, codigo });
  });
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    target.classList.add("resaltado");
    setTimeout(() => target.classList.remove("resaltado"), 1500);
  }
}

function obtenerMovimientosFiltrados() {
  let datos = Array.isArray(cacheMovimientos) ? [...cacheMovimientos] : [];
  const { tipo, desde, hasta, contenedor, contenedor_tipo } = filtrosMovimientos;
  if (tipo) {
    const filtroTipo = tipo.toLowerCase();
    datos = datos.filter(m => (m.tipo || "").toLowerCase() === filtroTipo);
  }

  const fechaDesde = desde ? new Date(desde) : null;
  const fechaHasta = hasta ? new Date(hasta) : null;

  if (fechaDesde instanceof Date && !Number.isNaN(fechaDesde.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp >= fechaDesde.getTime();
    });
  }

  if (fechaHasta instanceof Date && !Number.isNaN(fechaHasta.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp <= fechaHasta.getTime();
    });
  }

  if (contenedor) {
    const valor = contenedor.trim();
    const candidatos = [];
    if (!contenedor_tipo || contenedor_tipo === "deposito") {
      const idDep = resolverContenedorId("deposito", valor);
      if (idDep) candidatos.push({ tipo: "deposito", id: idDep });
    }
    if (!contenedor_tipo || contenedor_tipo === "mastelone") {
      const idMas = resolverContenedorId("mastelone", valor);
      if (idMas) candidatos.push({ tipo: "mastelone", id: idMas });
    }
    if (!contenedor_tipo || contenedor_tipo === "barrica") {
      const idBar = resolverContenedorId("barrica", valor);
      if (idBar) candidatos.push({ tipo: "barrica", id: idBar });
    }
    if (!candidatos.length) {
      return [];
    }
    datos = datos.filter(m =>
      candidatos.some(
        info =>
          (m.origen_tipo === info.tipo && Number(m.origen_id) === info.id) ||
          (m.destino_tipo === info.tipo && Number(m.destino_id) === info.id)
      )
    );
  }

  return datos;
}

function renderMovimientos() {
  const tbody = document.getElementById("tablaMovimientos");
  if (!tbody) return;
  const datos = obtenerMovimientosFiltrados();
  tbody.innerHTML = "";

  if (!datos.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="8">No hay movimientos registrados.</td>';
    tbody.appendChild(tr);
    return;
  }

  datos.forEach(m => {
    const fecha = m.fecha || m.fecha_hora || "";
    const fechaTexto = formatearFechaCorta(fecha);
    const litros = m.litros != null ? m.litros : m.volumen_l ?? "";
    const origen = formatearUbicacionMovimiento(m.origen_tipo, m.origen_id);
    const destino = formatearUbicacionMovimiento(m.destino_tipo, m.destino_id);
    const tr = document.createElement("tr");
    tr.innerHTML = `
        <td>${fechaTexto}</td>
        <td>${m.tipo || ""}</td>
        <td>${litros}</td>
        <td>${m.perdida_litros != null ? m.perdida_litros : ""}</td>
        <td>${origen.trim()}</td>
        <td>${destino.trim()}</td>
        <td>${m.nota || ""}</td>
        <td><button class="small-btn" style="background:#c04b4b; color:#fff;" onclick="eliminarMovimiento(${m.id})">Borrar</button></td>
    `;
    tbody.appendChild(tr);
  });
}

async function limpiarHistorialMovimientos() {
  const confirmar = confirm(
    "¿Seguro que quieres borrar todo el historial de movimientos? Esta acción no se puede deshacer."
  );
  if (!confirmar) return;

  try {
    const res = await fetch("/api/movimientos", { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo limpiar el historial.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error limpiando historial de movimientos:", err);
    alert("Error al limpiar el historial de movimientos.");
  }
}

async function eliminarMovimiento(id) {
  const confirmar = confirm("¿Borrar este movimiento? Esta acción no se puede deshacer.");
  if (!confirmar) return;
  try {
    const res = await fetch(`/api/movimientos/${id}`, { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo borrar el movimiento.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error borrando movimiento:", err);
    alert("No se pudo borrar el movimiento.");
  }
}

function aplicarFiltrosMovimientos() {
  filtrosMovimientos = {
    tipo: (document.getElementById("filtroMovTipo").value || "").toLowerCase(),
    desde: document.getElementById("filtroMovDesde").value || "",
    hasta: document.getElementById("filtroMovHasta").value || "",
    contenedor: document.getElementById("filtroMovContenedor").value.trim(),
    contenedor_tipo: document.getElementById("filtroMovContTipo").value || "",
  };
  renderMovimientos();
}

function limpiarFiltrosMovimientos() {
  document.getElementById("filtroMovTipo").value = "";
  document.getElementById("filtroMovDesde").value = "";
  document.getElementById("filtroMovHasta").value = "";
  document.getElementById("filtroMovContenedor").value = "";
  document.getElementById("filtroMovContTipo").value = "";
  filtrosMovimientos = { tipo: "", desde: "", hasta: "", contenedor: "", contenedor_tipo: "" };
  renderMovimientos();
}

async function exportarMovimientosCSV() {
  try {
    const res = await fetch("/api/export/movimientos");
    if (!res.ok) throw new Error();
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const enlace = document.createElement("a");
    const fecha = new Date().toISOString().slice(0, 10);
    enlace.href = url;
    enlace.download = `movimientos-${fecha}.csv`;
    document.body.appendChild(enlace);
    enlace.click();
    enlace.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Error exportando movimientos:", err);
    alert("No se pudo exportar el historial de movimientos.");
  }
}

async function obtenerHistorialCompleto(tipo, id) {
  try {
    const res = await fetch(`/api/contenedores/${tipo}/${id}/historial`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (err) {
    console.warn("Fallo al usar endpoint combinado, usando modo local:", err);
    return await construirHistorialLocal(tipo, id);
  }
}

async function construirHistorialLocal(tipo, id) {
  const registrosRes = await fetch(`/api/registros/${tipo}/${id}`);
  if (!registrosRes.ok) throw new Error("No se pudieron obtener registros analíticos");
  const registros = await registrosRes.json();

  let movimientos = cacheMovimientos;
  if (!movimientos || !movimientos.length) {
    const movRes = await fetch("/api/movimientos");
    if (!movRes.ok) throw new Error("No se pudieron obtener movimientos");
    movimientos = await movRes.json();
  }

  const analiticosNormalizados = registros.map(r => ({
    categoria: "analitico",
    fecha: r.fecha_hora,
    densidad: r.densidad,
    temperatura_c: r.temperatura_c,
    nota_sensorial: r.nota_sensorial,
    nota: r.nota,
  }));

  const movimientosRelacionados = movimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .map(m => ({
      categoria: "movimiento",
      fecha: m.fecha,
      tipo: m.tipo,
      litros: m.litros,
      origen_tipo: m.origen_tipo,
      origen_id: m.origen_id,
      destino_tipo: m.destino_tipo,
      destino_id: m.destino_id,
      nota: m.nota,
    }));

  return [...analiticosNormalizados, ...movimientosRelacionados].sort(
    (a, b) => new Date(b.fecha || 0) - new Date(a.fecha || 0)
  );
}
        // ---------- Barricas ----------
        async function cargarBarricas() {
            try {
                mostrarSkeletonTabla("tablaBarricas", 12);
                const res = await fetch("/api/barricas");
                if (!res.ok) return;
                const datos = await res.json();
	                cacheBarricas = datos;
	                cacheBarricas.forEach(b => {
	                    const volNodo = obtenerVolumenFinalNodoContenedor("barrica", b.id);
	                    const volActual = normalizarNumeroFlexible(b.litros_actuales);
	                    const tieneActual = Number.isFinite(volActual) && volActual > 0;
	                    if (Number.isFinite(volNodo) && (volNodo > 0 || !tieneActual)) {
	                        b.litros_actuales = Math.max(0, volNodo);
	                    }
	                });
                mapaBarricasPorId = new Map(datos.map(b => [b.id, b]));
                if (typeof poblarSelectBitacoraContenedores === "function") {
                    poblarSelectBitacoraContenedores();
                } else if (!window.__bitacoraSelectWarned) {
                    console.warn("[bitacora] falta poblarSelectBitacoraContenedores; se omite para no cortar carga");
                    window.__bitacoraSelectWarned = true;
                }
                renderPlano();

                const tbody = document.getElementById("tablaBarricas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="12">No hay barricas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

	               datos.forEach(b => {
                    const estadoVisual = resolverEstadoVisualContenedor("barrica", b);
                    const variedadVisible = estadoVisual.variedadVisible;
                    const volumenVisible = estadoVisual.volumenVisible;
                    const volumenParaEliminar = estadoVisual.volumenFinal;
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
        <td>${b.id}</td>
        <td>${b.codigo || ""}${b.alias ? ` — ${b.alias}` : ""}</td>
        <td>${b.capacidad_l ?? ""}</td>
        <td>${(b.tipo_roble || "")} ${b.tostado || ""}</td>
        <td>${b.marca || ""}</td>
        <td>${b.anio || ""}</td>
        <td>${b.vino_anio || ""}</td>
        <td>${variedadVisible}</td>
        <td>${volumenVisible}</td>
        <td>
            <button class="small-btn"
                onclick="editarBarricaDatos(${b.id})">
                Editar
            </button>
        </td>
        <td>
            <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <button class="small-btn"
                    onclick="abrirBitacoraContenedor('barrica', ${b.id})">
                    Bitácora
                </button>
            </div>
        </td>
        <td>
            <button
                onclick="eliminarBarrica(${b.id}, ${volumenParaEliminar})"
                style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                Borrar
            </button>
        </td>
    `;
                    tbody.appendChild(tr);
});
                actualizarIndicadores();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando barricas:", err);
            }
        }

        async function crearBarrica(ev) {
            ev.preventDefault();
            const codigo = document.getElementById("barCodigo").value;
            const capacidad_l = parseFloat(document.getElementById("barCapacidad").value || "0");
            const tipo_roble = document.getElementById("barTipo").value;
            const tostado = document.getElementById("barTostado").value;
            const marca = document.getElementById("barMarca").value;
            const anio = document.getElementById("barAnio").value;
            const vino_anio = document.getElementById("barVinoAnio").value;
            const vino_tipo = document.getElementById("barVinoTipo").value;

            if (!codigo || !capacidad_l) {
                alert("Faltan datos de la barrica (código, capacidad).");
                return;
            }

            try {
                const body = { codigo, capacidad_l, tipo_roble, tostado, marca, anio, vino_anio, vino_tipo };
        const res = await fetch("/api/barricas", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (res.status === 409) {
                    const data = await res.json().catch(() => ({}));
                    if (data?.error === "YA_EXISTE" && data?.existing) {
                        const usar = await mostrarModalUsarContenedorExistente({
                            tipo: "barrica",
                            existing: data.existing,
                        });
                        if (usar) {
                            await usarContenedorExistenteEnUI("barrica", data.existing);
                            document.getElementById("formBarrica")?.reset();
                            mostrarAviso(`Usando barrica existente ${data.existing.codigo || ""}.`, "info");
                        }
                        return;
                    }
                }
                const ok = await manejarRespuesta(res, "Error al crear la barrica.");
                if (!ok) return;

                document.getElementById("formBarrica").reset();
                cargarBarricas();
                cargarResumen();
            } catch (err) {
                console.error("Error creando barrica:", err);
            }
        }

        // ---------- Almacén de limpieza ----------
        async function cargarLimpieza() {
            try {
                const res = await fetch("/api/limpieza");
                if (!res.ok) return;
                const datos = await res.json();
                cacheLimpieza = datos;

                const tbody = document.getElementById("tablaLimpieza");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoLimpieza(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos de limpieza:", err);
            }
        }

        async function crearProductoLimpieza(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("limNombre").value.trim();
            const lote = document.getElementById("limLote").value.trim();
            const cantidad = parseFloat(document.getElementById("limCantidad").value || "0");
            const unidad = document.getElementById("limUnidad").value.trim();
            const nota = document.getElementById("limNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/limpieza", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formLimpieza").reset();
                cargarLimpieza();
            } catch (err) {
                console.error("Error creando producto de limpieza:", err);
            }
        }

        function obtenerMetaUsoProducto(tipo) {
            if (tipo === "limpieza") {
                return {
                    endpoint: "/api/limpieza/consumos",
                    etiqueta: "limpieza",
                    cache: cacheLimpieza,
                    refrescar: cargarLimpieza,
                };
            }
            if (tipo === "enologico") {
                return {
                    endpoint: "/api/enologicos/consumos",
                    etiqueta: "enológico",
                    cache: cacheEnologicos,
                    refrescar: cargarEnologicos,
                };
            }
            return null;
        }

        function opcionesDestinoUsoProducto(tipoDestino) {
            if (tipoDestino === "deposito") {
                return cacheDepositos
                    .map(dep => ({ id: dep.id, nombre: formatContainerLabel(dep, { tipo: "deposito" }) || `Depósito ${dep.id}` }))
                    .sort((a, b) => a.nombre.localeCompare(b.nombre, "es"));
            }
            if (tipoDestino === "barrica") {
                return cacheBarricas
                    .map(bar => ({ id: bar.id, nombre: formatContainerLabel(bar, { tipo: "barrica" }) || `Barrica ${bar.id}` }))
                    .sort((a, b) => a.nombre.localeCompare(b.nombre, "es"));
            }
            if (tipoDestino === "mastelone") {
                return cacheMastelones
                    .map(mas => ({ id: mas.id, nombre: formatContainerLabel(mas, { tipo: "mastelone" }) || `Mastelone ${mas.id}` }))
                    .sort((a, b) => a.nombre.localeCompare(b.nombre, "es"));
            }
            return [];
        }

        function actualizarOpcionesDestinoUsoProducto() {
            const tipoDestino = document.getElementById("usoProductoDestinoTipo")?.value || "";
            const selectDestino = document.getElementById("usoProductoDestinoId");
            if (!selectDestino) return;
            selectDestino.innerHTML = '<option value="">Selecciona contenedor</option>';
            if (!tipoDestino) {
                selectDestino.disabled = true;
                return;
            }
            const opciones = opcionesDestinoUsoProducto(tipoDestino);
            opciones.forEach(op => {
                const option = document.createElement("option");
                option.value = String(op.id);
                option.textContent = op.nombre;
                selectDestino.appendChild(option);
            });
            selectDestino.disabled = opciones.length === 0;
        }

        function cerrarModalUsoProducto() {
            usoProductoContexto = null;
            const modal = document.getElementById("modalUsoProducto");
            if (modal) modal.classList.remove("visible");
            const form = document.getElementById("formUsoProducto");
            if (form) form.reset();
            const info = document.getElementById("usoProductoInfo");
            if (info) info.textContent = "";
            const titulo = document.getElementById("usoProductoTitulo");
            if (titulo) titulo.textContent = "Registrar uso";
            const destino = document.getElementById("usoProductoDestinoId");
            if (destino) {
                destino.innerHTML = '<option value="">Selecciona contenedor</option>';
                destino.disabled = true;
            }
            setFormFeedback("feedbackUsoProducto", "");
        }

        function abrirModalUsoProducto(tipo, id) {
            const meta = obtenerMetaUsoProducto(tipo);
            if (!meta) return;
            const prod = meta.cache.find(p => p.id === id);
            if (!prod) {
                mostrarAviso("Producto no encontrado.", "error");
                return;
            }
            usoProductoContexto = { tipo, id };
            const modal = document.getElementById("modalUsoProducto");
            if (!modal) return;
            const titulo = document.getElementById("usoProductoTitulo");
            if (titulo) titulo.textContent = `Registrar uso (${meta.etiqueta})`;
            const disponible = Number(prod.cantidad_disponible ?? 0);
            const info = document.getElementById("usoProductoInfo");
            if (info) {
                info.textContent = `${prod.nombre || "Producto"} · Lote ${prod.lote || "—"} · Disponible ${disponible.toFixed(2)} ${prod.unidad || ""}`.trim();
            }
            const cantidad = document.getElementById("usoProductoCantidad");
            if (cantidad) {
                cantidad.value = "";
                cantidad.placeholder = `Máximo ${disponible.toFixed(2)} ${prod.unidad || ""}`.trim();
                cantidad.focus();
            }
            const tipoDestino = document.getElementById("usoProductoDestinoTipo");
            if (tipoDestino) tipoDestino.value = "";
            const nota = document.getElementById("usoProductoNota");
            if (nota) nota.value = "";
            actualizarOpcionesDestinoUsoProducto();
            setFormFeedback("feedbackUsoProducto", "");
            modal.classList.add("visible");
        }

        async function guardarUsoProducto(ev) {
            ev.preventDefault();
            if (!usoProductoContexto) return;
            const meta = obtenerMetaUsoProducto(usoProductoContexto.tipo);
            if (!meta) return;
            const prod = meta.cache.find(p => p.id === usoProductoContexto.id);
            if (!prod) {
                setFormFeedback("feedbackUsoProducto", "Producto no encontrado.", "error");
                return;
            }
            const cantidad = Number(document.getElementById("usoProductoCantidad").value || 0);
            const disponible = Number(prod.cantidad_disponible ?? 0);
            if (!Number.isFinite(cantidad) || cantidad <= 0) {
                setFormFeedback("feedbackUsoProducto", "Cantidad inválida.", "error");
                return;
            }
            if (cantidad > disponible) {
                setFormFeedback("feedbackUsoProducto", "La cantidad supera el stock disponible.", "error");
                return;
            }
            const destino_tipo = document.getElementById("usoProductoDestinoTipo").value || null;
            const destinoValor = document.getElementById("usoProductoDestinoId").value;
            const destino_id = destino_tipo && destinoValor ? Number(destinoValor) : null;
            if (destino_tipo && !destino_id) {
                setFormFeedback("feedbackUsoProducto", "Selecciona un contenedor destino válido.", "error");
                return;
            }
            const nota = document.getElementById("usoProductoNota").value.trim();
            try {
                const res = await fetch(meta.endpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: usoProductoContexto.id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                cerrarModalUsoProducto();
                await meta.refrescar();
                mostrarAviso("Consumo registrado.", "success");
            } catch (err) {
                console.error("Error registrando consumo:", err);
                setFormFeedback("feedbackUsoProducto", "No se pudo registrar el consumo.", "error");
            }
        }

        async function registrarUsoLimpieza(id) {
            abrirModalUsoProducto("limpieza", id);
        }

        // ---------- Productos enológicos ----------
        async function cargarEnologicos() {
            try {
                const res = await fetch("/api/enologicos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEnologicos = datos;
                const tbody = document.getElementById("tablaEnologicos");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoEnologico(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos enológicos:", err);
            }
        }

        async function crearProductoEnologico(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("enoNombre").value.trim();
            const lote = document.getElementById("enoLote").value.trim();
            const cantidad = parseFloat(document.getElementById("enoCantidad").value || "0");
            const unidad = document.getElementById("enoUnidad").value.trim();
            const nota = document.getElementById("enoNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/enologicos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formEnologicos").reset();
                cargarEnologicos();
            } catch (err) {
                console.error("Error creando producto enológico:", err);
            }
        }

async function registrarUsoEnologico(id) {
            abrirModalUsoProducto("enologico", id);
        }

        // ---------- Movimientos ----------
        async function cargarMovimientos() {
            try {
                mostrarSkeletonTabla("tablaMovimientos", 8, 4);
                const res = await fetch("/api/movimientos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheMovimientos = datos;
                renderMovimientos();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando movimientos:", err);
            }
        }

        function actualizarCamposMovimiento() {
            const tipoSelect = document.getElementById("movTipo");
            const origenTipo = document.getElementById("movOrigenTipo");
            const origenId = document.getElementById("movOrigenId");
            const origenNota = document.getElementById("movOrigenNota");
            const esPrensado = tipoSelect && tipoSelect.value === "prensado";

            if (esPrensado) {
                if (origenTipo) {
                    origenTipo.value = "";
                    origenTipo.disabled = true;
                }
                if (origenId) {
                    origenId.value = "";
                    origenId.disabled = true;
                }
                if (origenNota) {
                    origenNota.style.display = "block";
                }
            } else {
                if (origenTipo) {
                    origenTipo.disabled = false;
                }
                if (origenId) {
                    origenId.disabled = false;
                }
                if (origenNota) {
                    origenNota.style.display = "none";
                }
            }
        }

        async function crearMovimiento(ev) {
            ev.preventDefault();
            let fecha = document.getElementById("movFecha").value;
            if (!fecha) {
                fecha = new Date().toISOString();
            }
            const fecha_hora = fecha;

            const tipo = document.getElementById("movTipo").value;
            const destino_tipo = document.getElementById("movDestinoTipo").value || null;
            const origenTipoEl = document.getElementById("movOrigenTipo");
            const origenIdEl = document.getElementById("movOrigenId");
            let origen_tipo = origenTipoEl ? (origenTipoEl.value || null) : null;
            const origenRaw = origenIdEl ? origenIdEl.value.trim() : "";
            const destinoRaw = document.getElementById("movDestinoId").value.trim();

            let origen_id = null;
            let destino_id = null;
            const esPrensado = tipo === "prensado";

            if (!esPrensado && origenRaw) {
                if (/^\d+$/.test(origenRaw)) {
                    origen_id = parseInt(origenRaw, 10);
                } else if (origen_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => filterByCodeOrAlias(d, origenRaw));
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = dep.id;
                } else if (origen_tipo === "mastelone") {
                    const mas = cacheMastelones.find(m => filterByCodeOrAlias(m, origenRaw));
                    if (!mas) {
                        setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = mas.id;
                } else if (origen_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => filterByCodeOrAlias(b, origenRaw));
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = bar.id;
                } else {
                    setFormFeedback("feedbackMovimientos", "Para usar un código como origen, el tipo debe ser depósito, mastelone o barrica.", "error");
                    return;
                }
            }

            if (esPrensado) {
                origen_tipo = null;
                origen_id = null;
            }

            if (destinoRaw) {
                if (/^\d+$/.test(destinoRaw)) {
                    destino_id = parseInt(destinoRaw, 10);
                } else if (destino_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => filterByCodeOrAlias(d, destinoRaw));
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = dep.id;
                } else if (destino_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => filterByCodeOrAlias(b, destinoRaw));
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = bar.id;
                } else if (destino_tipo === "mastelone") {
        const mas = cacheMastelones.find(m => filterByCodeOrAlias(m, destinoRaw));
        if (!mas) {
          setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + destinoRaw, "error");
          return;
        }
        destino_id = mas.id;
    } else {
        setFormFeedback("feedbackMovimientos", "Para usar un código como destino, el tipo debe ser depósito, mastelone o barrica.", "error");
        return;
    }
}

            const litros = parseFloat(document.getElementById("movLitros").value || "0");
            const perdida_litros = document.getElementById("movPerdida").value
                ? parseFloat(document.getElementById("movPerdida").value)
                : null;
            const nota = document.getElementById("movNota").value;

            if (!litros || litros <= 0) {
                setFormFeedback("feedbackMovimientos", "Los litros deben ser mayores que 0.", "error");
                return;
            }

            const body = {
                fecha,
                fecha_hora,
                tipo,
                origen_tipo,
                origen_id,
                destino_tipo,
                destino_id,
                litros,
                perdida_litros,
                nota,
            };

            try {
                const res = await fetch("/api/movimientos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al guardar el movimiento.");
                if (!ok) return;

                document.getElementById("formMovimiento").reset();
                actualizarCamposMovimiento();
                await Promise.all([
                    cargarMovimientos(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarResumen(),
                ]);
                setFormFeedback("feedbackMovimientos", "Movimiento registrado.", "success");
                mostrarAviso("Movimiento registrado.", "success");
            } catch (err) {
                console.error("Error creando movimiento:", err);
                setFormFeedback("feedbackMovimientos", "No se pudo crear el movimiento.", "error");
                mostrarAviso("Error al crear el movimiento.", "error");
            }
        }

        // ---------- Embotellado ----------
        let embotelladoFormatos = [];

        function parsearFormatosEmbotellado(valor) {
            if (!valor) return [];
            if (Array.isArray(valor)) return valor;
            if (typeof valor === "string") {
                try {
                    const parsed = JSON.parse(valor);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (err) {
                    return [];
                }
            }
            return [];
        }

        function obtenerFormatosEmbotelladoFormulario() {
            const lista = normalizarFormatosBotellaLista(embotelladoFormatos);
            return lista.map(item => ({ formato: item.formato, botellas: item.botellas }));
        }

        function actualizarEstadoFormularioEmbotellado() {
            const resumen = calcularResumenFormatosBotellaDesdeLista(embotelladoFormatos);
            const botellasInput = document.getElementById("embBotellas");
            const formatoSelect = document.getElementById("embFormato");
            if (botellasInput) {
                if (resumen.totalBotellas > 0) {
                    botellasInput.value = resumen.totalBotellas;
                    botellasInput.readOnly = true;
                    botellasInput.classList.add("field-readonly");
                } else {
                    botellasInput.readOnly = false;
                    botellasInput.classList.remove("field-readonly");
                }
            }
            if (formatoSelect) {
                formatoSelect.disabled = resumen.totalBotellas > 0;
            }
        }

        function renderFormatosEmbotelladoFormulario() {
            const wrapper = document.getElementById("embFormatosWrapper");
            if (!wrapper) return;
            wrapper.innerHTML = "";
            const tabla = document.createElement("table");
            const thead = document.createElement("thead");
            thead.innerHTML = `
                <tr>
                    <th>Formato</th>
                    <th>Botellas</th>
                    <th>L calc.</th>
                    <th></th>
                </tr>`;
            tabla.appendChild(thead);
            const tbody = document.createElement("tbody");
            tabla.appendChild(tbody);
            const resumenEl = document.createElement("div");
            resumenEl.className = "tabla-formatos-resumen";
            const formatosDisponibles = Object.keys(VOLUMEN_BOTELLA_L);

            const calcularLitrosTexto = registro => {
                if (!registro) return "";
                const formato = registro.formato;
                const botellasRaw = normalizarNumero(registro.botellas);
                const botellas = Number.isFinite(botellasRaw) ? Math.max(0, Math.floor(botellasRaw)) : 0;
                const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
                if (volBotella > 0 && botellas > 0) {
                    return (botellas * volBotella).toFixed(2);
                }
                return "";
            };

            const actualizarResumen = () => {
                const resumen = calcularResumenFormatosBotellaDesdeLista(embotelladoFormatos);
                const botellasTxt = resumen.totalBotellas
                    ? `${resumen.totalBotellas.toLocaleString("es-ES")} botellas`
                    : "0 botellas";
                const litrosTxt = resumen.totalLitros
                    ? ` · ${resumen.totalLitros.toFixed(2)} L`
                    : "";
                resumenEl.textContent = `Total: ${botellasTxt}${litrosTxt}`;
                actualizarEstadoFormularioEmbotellado();
            };

            const renderFilas = () => {
                tbody.innerHTML = "";
                if (!embotelladoFormatos.length) {
                    const fila = document.createElement("tr");
                    fila.innerHTML = `<td colspan="4" style="text-align:center; color:#777;">Sin formatos mixtos</td>`;
                    tbody.appendChild(fila);
                    actualizarResumen();
                    return;
                }
                embotelladoFormatos.forEach((registro, index) => {
                    const tr = document.createElement("tr");
                    const tdFormato = document.createElement("td");
                    const select = document.createElement("select");
                    select.dataset.index = index;
                    select.dataset.campo = "formato";
                    const placeholder = document.createElement("option");
                    placeholder.value = "";
                    placeholder.textContent = "Selecciona formato";
                    if (!registro.formato) placeholder.selected = true;
                    select.appendChild(placeholder);
                    formatosDisponibles.forEach(op => {
                        const option = document.createElement("option");
                        option.value = op;
                        option.textContent = op;
                        select.appendChild(option);
                    });
                    if (registro.formato) select.value = registro.formato;
                    tdFormato.appendChild(select);
                    const tdBotellas = document.createElement("td");
                    const input = document.createElement("input");
                    input.type = "number";
                    input.min = "0";
                    input.step = "1";
                    input.dataset.index = index;
                    input.dataset.campo = "botellas";
                    input.value = registro.botellas != null ? registro.botellas : "";
                    tdBotellas.appendChild(input);
                    const tdLitros = document.createElement("td");
                    tdLitros.dataset.index = index;
                    tdLitros.dataset.campo = "litros";
                    tdLitros.textContent = calcularLitrosTexto(registro);
                    const tdAccion = document.createElement("td");
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "small-btn";
                    btn.textContent = "✕";
                    btn.dataset.index = index;
                    btn.dataset.accion = "eliminar";
                    tdAccion.appendChild(btn);
                    tr.appendChild(tdFormato);
                    tr.appendChild(tdBotellas);
                    tr.appendChild(tdLitros);
                    tr.appendChild(tdAccion);
                    tbody.appendChild(tr);
                });
                actualizarResumen();
            };

            tbody.addEventListener("input", e => {
                const target = e.target;
                const index = target.dataset.index;
                const campo = target.dataset.campo;
                if (index == null || !campo) return;
                if (!embotelladoFormatos[index]) return;
                embotelladoFormatos[index][campo] = target.value;
                const litrosCell = tbody.querySelector(
                    `td[data-index="${index}"][data-campo="litros"]`
                );
                if (litrosCell) {
                    litrosCell.textContent = calcularLitrosTexto(embotelladoFormatos[index]);
                }
                actualizarResumen();
            });

            tbody.addEventListener("change", e => {
                const target = e.target;
                const index = target.dataset.index;
                const campo = target.dataset.campo;
                if (index == null || !campo) return;
                if (!embotelladoFormatos[index]) return;
                embotelladoFormatos[index][campo] = target.value;
                const litrosCell = tbody.querySelector(
                    `td[data-index="${index}"][data-campo="litros"]`
                );
                if (litrosCell) {
                    litrosCell.textContent = calcularLitrosTexto(embotelladoFormatos[index]);
                }
                actualizarResumen();
            });

            tbody.addEventListener("click", e => {
                const btn = e.target.closest("button[data-accion='eliminar']");
                if (!btn) return;
                const index = Number(btn.dataset.index);
                if (!Number.isFinite(index)) return;
                embotelladoFormatos.splice(index, 1);
                renderFilas();
            });

            const btnAdd = document.createElement("button");
            btnAdd.type = "button";
            btnAdd.className = "btnSecundario";
            btnAdd.style.marginTop = "8px";
            btnAdd.textContent = "+ Añadir formato";
            btnAdd.addEventListener("click", () => {
                const formatoSelect = document.getElementById("embFormato");
                const formatoBase =
                    (formatoSelect &&
                    formatoSelect.value &&
                    VOLUMEN_BOTELLA_L[formatoSelect.value] != null)
                        ? formatoSelect.value
                        : formatosDisponibles[0];
                embotelladoFormatos.push({ formato: formatoBase || "", botellas: "" });
                renderFilas();
            });

            renderFilas();
            wrapper.appendChild(tabla);
            wrapper.appendChild(btnAdd);
            wrapper.appendChild(resumenEl);
        }

        function limpiarFormatosEmbotelladoFormulario() {
            embotelladoFormatos = [];
            renderFormatosEmbotelladoFormulario();
        }

        function construirEmbotelladosVirtualesDesdeFlujo() {
            const nodos = Array.isArray(flujoNodos) ? flujoNodos : [];
            const embotellados = nodos.filter(n => n && n.tipo === "embotellado");
            return embotellados
                .map((nodo, idx) => {
                    const botellas = obtenerBotellasNodoEmbotellado(nodo);
                    if (!(botellas > 0)) return null;
                    const fecha = nodo?.datos?.fecha || nodo?.datos?.fecha_operacion || "";
                    const formatosBase = normalizarFormatosBotellaLista(nodo?.datos?.formatos_botella);
                    const formatos = formatosBase.length
                        ? formatosBase
                        : (nodo?.datos?.botella
                            ? [{ formato: nodo.datos.botella, botellas }]
                            : []);
                    const predecesores = obtenerPredecesores(nodo.id) || [];
                    const origen = predecesores.find(pre => pre && ["deposito", "barrica", "mastelone"].includes(pre.tipo)) || predecesores[0] || null;
                    return {
                        id: `flow-emb-${nodo.id || idx}`,
                        fecha: fecha || null,
                        contenedor_tipo: origen?.tipo || "",
                        contenedor_id: origen?.id || "",
                        botellas,
                        lote: (nodo?.datos?.lote || "").toString().trim() || "VACIO",
                        nota: "Registro desde mapa de nodos",
                        formatos: formatos.length ? JSON.stringify(formatos) : null,
                        _virtual: true,
                    };
                })
                .filter(Boolean);
        }

        async function cargarEmbotellados() {
            try {
                const res = await fetch("/api/embotellados");
                const datosApi = res.ok ? await res.json() : [];
                const datos = Array.isArray(datosApi) ? [...datosApi] : [];
                const virtuales = construirEmbotelladosVirtualesDesdeFlujo();
                if (virtuales.length) {
                    const claveLoteFecha = item =>
                        `${String(item?.lote || "").trim().toLowerCase()}|${String(item?.fecha || "").slice(0, 10)}`;
                    const idxPorClave = new Map();
                    datos.forEach((item, idx) => idxPorClave.set(claveLoteFecha(item), idx));
                    virtuales.forEach(v => {
                        const key = claveLoteFecha(v);
                        if (idxPorClave.has(key)) {
                            const idx = idxPorClave.get(key);
                            const base = datos[idx] || {};
                            datos[idx] = {
                                ...base,
                                ...v,
                                id: base.id || v.id,
                                nota: base.nota || v.nota,
                            };
                        } else {
                            idxPorClave.set(key, datos.length);
                            datos.push(v);
                        }
                    });
                }
                datos.sort((a, b) => {
                    const ta = new Date(a?.fecha || 0).getTime();
                    const tb = new Date(b?.fecha || 0).getTime();
                    return tb - ta;
                });
                cacheEmbotellados = datos;
                const tbody = document.getElementById("tablaEmbotellados");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="6">Aún no hay embotellados registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                const crearCelda = (texto, title = "") => {
                    const td = document.createElement("td");
                    td.textContent = texto || "";
                    if (title) td.title = title;
                    return td;
                };

                datos.forEach(e => {
                    const origen = formatearUbicacionMovimiento(e.contenedor_tipo, e.contenedor_id);
                    const fecha = formatearFechaCorta(e.fecha);
                    const formatos = parsearFormatosEmbotellado(e.formatos);
                    const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
                    const formatosResumen = formatearResumenFormatosEmbotellado(formatos) || "—";
                    const formatosDetalle = construirDetalleFormatosBotella(formatos);
                    const botellasTxt = e.botellas != null
                        ? String(e.botellas)
                        : resumen.totalBotellas > 0
                        ? String(resumen.totalBotellas)
                        : "";
                    const tr = document.createElement("tr");
                    tr.appendChild(crearCelda(fecha));
                    tr.appendChild(crearCelda(origen));
                    tr.appendChild(crearCelda(botellasTxt));
                    tr.appendChild(crearCelda(formatosResumen, formatosDetalle));
                    tr.appendChild(crearCelda(e.lote || ""));
                    tr.appendChild(crearCelda(e.nota || ""));
                    tbody.appendChild(tr);
                });
                actualizarIndicadores();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando embotellados:", err);
            }
        }

        function formatoMlAlmacenTexto(valor) {
            const ml = Number(valor);
            if (!Number.isFinite(ml) || ml <= 0) return "—";
            const litros = ml / 1000;
            const decimales = litros >= 1 ? 2 : 3;
            const txt = litros.toFixed(decimales).replace(/0+$/, "").replace(/\.$/, "");
            return `${txt.replace(".", ",")} L`;
        }

        function normalizarUnidadesCaja(valor, fallback = 6) {
            const num = Number(valor);
            if (Number.isFinite(num) && num > 0) return Math.max(1, Math.floor(num));
            return fallback;
        }

        function resumenCajasDesdeBotellas(botellas, unidadesCaja) {
            const botellasNum = Number(botellas);
            const unidades = normalizarUnidadesCaja(unidadesCaja, 6);
            const total = Number.isFinite(botellasNum) && botellasNum > 0 ? Math.floor(botellasNum) : 0;
            const cajas = Math.floor(total / unidades);
            const resto = total % unidades;
            return { total, unidades, cajas, resto };
        }

        function formatearCajasDesdeBotellas(botellas, unidadesCaja) {
            const info = resumenCajasDesdeBotellas(botellas, unidadesCaja);
            if (info.total <= 0) return `0 cajas · ${info.unidades} botellas/caja`;
            const restoTxt = info.resto > 0 ? ` + ${info.resto} botellas` : "";
            return `${info.cajas.toLocaleString("es-ES")} cajas · ${info.unidades} botellas/caja${restoTxt}`;
        }

        function lotesAlmacenReales() {
            return (cacheAlmacenVino || []).filter(l => {
                const id = String(l?.id || "");
                return id && !id.startsWith("flow:");
            });
        }

        function initEventosModalAlmacen() {
            const form = document.getElementById("formAlmacenAccionModal");
            if (!form || form.dataset.bound === "1") return;
            form.dataset.bound = "1";
            form.addEventListener("submit", guardarModalAccionAlmacen);
            const tipoSel = document.getElementById("almAccTipo");
            if (tipoSel) {
                tipoSel.addEventListener("change", actualizarFormularioAccionAlmacen);
            }
        }

        function initEventosModalEditarLoteAlmacen() {
            const form = document.getElementById("formAlmacenEditarLoteModal");
            if (!form || form.dataset.bound === "1") return;
            form.dataset.bound = "1";
            form.addEventListener("submit", guardarModalEditarLoteAlmacen);
        }

        function actualizarFormularioAccionAlmacen() {
            const tipo = (document.getElementById("almAccTipo")?.value || "SALIDA").toUpperCase();
            const inputBotellas = document.getElementById("almAccBotellas");
            const inputCliente = document.getElementById("almAccCliente");
            const labelCliente = document.getElementById("almAccClienteLabel");
            if (inputBotellas && tipo === "AJUSTE") {
                inputBotellas.min = "-1000000";
                inputBotellas.placeholder = "Ej. -24 o 24";
            } else if (inputBotellas) {
                inputBotellas.min = "1";
                inputBotellas.placeholder = "Ej. 120";
            }
            if (labelCliente) labelCliente.style.opacity = tipo === "SALIDA" ? "1" : "0.7";
            if (inputCliente) inputCliente.placeholder = tipo === "SALIDA" ? "Cliente / distribuidor" : "Opcional";
        }

        function abrirModalAccionAlmacen(tipo) {
            initEventosModalAlmacen();
            const modal = document.getElementById("almacenAccionModal");
            if (!modal) return;
            almacenAccionTipoActual = (tipo || "SALIDA").toString().toUpperCase();
            const titulo = document.getElementById("almacenAccionTitulo");
            const tipoInput = document.getElementById("almAccTipo");
            const selectLote = document.getElementById("almAccLote");
            const inputBotellas = document.getElementById("almAccBotellas");
            const inputCliente = document.getElementById("almAccCliente");
            const docNumero = document.getElementById("almAccDocNumero");
            const nota = document.getElementById("almAccNota");
            if (titulo) titulo.textContent = "Registrar movimiento de almacén";
            if (tipoInput) tipoInput.value = almacenAccionTipoActual;
                if (selectLote) {
                    selectLote.innerHTML = "";
                    lotesAlmacenReales().forEach(lote => {
                        const option = document.createElement("option");
                        option.value = String(lote.id);
                        const nombre = obtenerNombreComercialLote(lote);
                        const codigo = obtenerCodigoVisibleLote(lote);
                        option.textContent = codigo ? `${nombre} · ${codigo}` : nombre;
                        selectLote.appendChild(option);
                    });
                    if (almacenVinoLoteSeleccionado) {
                    const existe = Array.from(selectLote.options).some(o => o.value === String(almacenVinoLoteSeleccionado));
                    if (existe) selectLote.value = String(almacenVinoLoteSeleccionado);
                }
            }
            actualizarFormularioAccionAlmacen();
            if (inputBotellas) inputBotellas.value = "";
            if (inputCliente) inputCliente.value = "";
            if (docNumero) docNumero.value = "";
            if (nota) nota.value = "";
            if (typeof modal.showModal === "function") {
                modal.showModal();
            } else {
                modal.setAttribute("open", "open");
            }
        }

        function cerrarModalAccionAlmacen() {
            const modal = document.getElementById("almacenAccionModal");
            if (!modal) return;
            if (typeof modal.close === "function") {
                modal.close();
            } else {
                modal.removeAttribute("open");
            }
        }

        function cerrarModalEditarLoteAlmacen() {
            const modal = document.getElementById("almacenEditarLoteModal");
            if (!modal) return;
            if (typeof modal.close === "function") {
                modal.close();
            } else {
                modal.removeAttribute("open");
            }
            almacenLoteEditandoId = null;
        }

        async function guardarModalAccionAlmacen(ev) {
            ev.preventDefault();
            const tipo = (document.getElementById("almAccTipo")?.value || almacenAccionTipoActual || "SALIDA").toUpperCase();
            const loteId = (document.getElementById("almAccLote")?.value || "").trim();
            const botellas = Number(document.getElementById("almAccBotellas")?.value || 0);
            const cliente = (document.getElementById("almAccCliente")?.value || "").trim();
            const docNumero = (document.getElementById("almAccDocNumero")?.value || "").trim();
            const docTipo = (document.getElementById("almAccDocTipo")?.value || "OTRO").trim();
            const nota = (document.getElementById("almAccNota")?.value || "").trim();
            if (!loteId) {
                mostrarAviso("Selecciona un lote.", "error");
                return;
            }
            try {
                let docId = null;
                if (docNumero) {
                    const resDoc = await fetch("/api/docs", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            tipo: docTipo || "OTRO",
                            numero: docNumero || null,
                            fecha: new Date().toISOString(),
                            tercero: cliente || null,
                            note: nota || null,
                        }),
                    });
                    const dataDoc = await resDoc.json();
                    if (!resDoc.ok || !dataDoc?.ok) {
                        mostrarAviso(dataDoc?.error || "No se pudo guardar el documento.", "error");
                        return;
                    }
                    docId = dataDoc.doc?.id || null;
                }
                if (!(botellas > 0) && tipo !== "AJUSTE") {
                    mostrarAviso("Indica botellas > 0.", "error");
                    return;
                }
                if (tipo === "AJUSTE" && !Number.isFinite(botellas)) {
                    mostrarAviso("Indica botellas para ajuste.", "error");
                    return;
                }
                if (tipo === "AJUSTE" && !nota) {
                    mostrarAviso("En ajuste es obligatorio indicar motivo.", "error");
                    return;
                }
                if (tipo === "SALIDA" && !cliente) {
                    mostrarAviso("En salida indica cliente.", "error");
                    return;
                }
                if (tipo === "SALIDA" && !docNumero && !nota) {
                    mostrarAviso("En salida indica documento o nota.", "error");
                    return;
                }
                const body = {
                    lot_ref: loteId,
                    event_type: tipo,
                    qty_value: Math.round(botellas),
                    cliente_nombre: cliente || null,
                    doc_id: docId,
                    note: nota || null,
                    reason: tipo === "AJUSTE" || tipo === "CANCEL" ? (nota || "Ajuste manual") : null,
                };
                const res = await fetch("/api/warehouse/move", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const data = await res.json();
                if (!res.ok || !data?.ok) {
                    mostrarAviso(data?.error || "No se pudo registrar el movimiento.", "error");
                    return;
                }
                cerrarModalAccionAlmacen();
                await cargarAlmacenVino();
                await cargarResumen();
                mostrarAviso("Movimiento registrado.", "success");
            } catch (err) {
                console.error("Error guardando acción de almacén:", err);
                mostrarAviso("No se pudo registrar la acción.", "error");
            }
        }

        function esLoteFlowId(id) {
            return String(id || "").trim().startsWith("flow:");
        }

        function obtenerNombreComercialLote(lote) {
            const nombre = (lote?.nombre || lote?.nombre_comercial || "").toString().trim();
            if (/^lote\s*mapa\b/i.test(nombre)) return "VACIO";
            return nombre || "VACIO";
        }

        function obtenerCodigoVisibleLote(lote) {
            const idTxt = String(lote?.id || "").trim();
            if (!idTxt || esLoteFlowId(idTxt)) return "";
            return idTxt;
        }

        function obtenerSubtituloLote(lote) {
            const nombre = obtenerNombreComercialLote(lote);
            const partida = (lote?.partida_nombre || lote?.vino || "").toString().trim();
            if (partida && partida !== nombre) return partida;
            const codigo = obtenerCodigoVisibleLote(lote);
            if (codigo) return `ID ${codigo}`;
            return "Lote del mapa";
        }

        async function guardarModalEditarLoteAlmacen(ev) {
            ev.preventDefault();
            const idTxt = String(almacenLoteEditandoId || "").trim();
            if (!idTxt) {
                mostrarAviso("No hay lote seleccionado para editar.", "error");
                return;
            }
            const lote = (cacheAlmacenVino || []).find(item => String(item?.id || "") === idTxt);
            if (!lote) {
                mostrarAviso("No se encontró el lote para editar.", "error");
                return;
            }
            const nombreInput = (document.getElementById("almEditNombre")?.value || "").trim();
            const nombreFinal = nombreInput || (lote.nombre || "").toString().trim() || "Lote";
            const unidadesRaw = document.getElementById("almEditCajaUnidades")?.value || String(lote.caja_unidades || 6);
            const unidades = normalizarUnidadesCaja(unidadesRaw, normalizarUnidadesCaja(lote.caja_unidades, 6));
            if (![3, 6, 12].includes(unidades)) {
                mostrarAviso("Las unidades por caja deben ser 3, 6 o 12.", "error");
                return;
            }

            if (idTxt.startsWith("flow:")) {
                const embId = idTxt.slice(5);
                const embNode = buscarNodoPorId(embId);
                if (!embNode) {
                    mostrarAviso("No se encontró el nodo de embotellado.", "error");
                    return;
                }
                embNode.datos = embNode.datos || {};
                embNode.datos.lote = nombreFinal;
                const tipoCaja = `${unidades} botellas`;
                const destinos = (embNode.targets || [])
                    .map(id => buscarNodoPorId(id))
                    .filter(Boolean);
                const almacenes = destinos.filter(n => n.tipo === "almacen");
                const salidasDirectas = destinos.filter(n => n.tipo === "salida");
                almacenes.forEach(alm => {
                    alm.datos = alm.datos || {};
                    alm.datos.caja_botellas = tipoCaja;
                    actualizarResumenCajasAlmacen(alm);
                });
                const salidas = [...salidasDirectas];
                almacenes.forEach(alm => {
                    (alm.targets || [])
                        .map(id => buscarNodoPorId(id))
                        .filter(n => n && n.tipo === "salida")
                        .forEach(s => salidas.push(s));
                });
                const vistos = new Set();
                salidas.forEach(salida => {
                    const sid = normalizarIdNodo(salida);
                    if (!sid || vistos.has(sid)) return;
                    vistos.add(sid);
                    salida.datos = salida.datos || {};
                    salida.datos.cajas_tipo = tipoCaja;
                    actualizarBotellasTotalesSalida(salida);
                });
                guardarEstadoNodos();
                renderFlowNodes();
                await cargarAlmacenVino();
                cerrarModalEditarLoteAlmacen();
                mostrarAviso("Lote actualizado en mapa y trazabilidad.", "success");
                return;
            }

            const stockRaw = document.getElementById("almEditStock")?.value || "";
            const stockNum = Number(stockRaw);
            if (!Number.isFinite(stockNum) || stockNum < 0) {
                mostrarAviso("Stock inválido.", "error");
                return;
            }
            try {
                const res = await fetch(`/api/almacen-vino/lotes/${idTxt}`, {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        nombre: nombreFinal,
                        caja_unidades: unidades,
                        botellas_actuales: Math.floor(stockNum),
                    }),
                });
                const ok = await manejarRespuesta(res, "No se pudo actualizar el lote.");
                if (!ok) return;
                cerrarModalEditarLoteAlmacen();
                await cargarAlmacenVino();
                mostrarAviso("Lote actualizado.", "success");
            } catch (err) {
                console.error("Error actualizando lote:", err);
                mostrarAviso("Error actualizando lote.", "error");
            }
        }

        function renderTrazabilidadLoteVino(data) {
            const panel = document.getElementById("almacenTrazabilidadPanel");
            if (!panel) return;
            if (!data || !data.lote) {
                panel.textContent = "No hay datos de trazabilidad para este lote.";
                return;
            }
            const esc = valor =>
                String(valor ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/\"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            const lote = data.lote || {};
            const resumen = data.resumen || {};
            const origenes = Array.isArray(data.origenes) ? data.origenes : [];
            const docs = Array.isArray(data.docs) ? data.docs : [];
            const forward = Array.isArray(data.forward) ? data.forward : [];
            const back = Array.isArray(data.back) ? data.back : [];
            const timeline = Array.isArray(data.timeline) ? data.timeline : [];
            const nombreLote = obtenerNombreComercialLote(lote);
            let campania = lote.campania_anio ? String(lote.campania_anio) : "";
            if (!campania) {
                const pasoEntrada = timeline.find(paso => {
                    const tipo = String(paso?.tipo || "").toLowerCase();
                    const titulo = String(paso?.titulo || "").toLowerCase();
                    return tipo.includes("entrada") || titulo.includes("entrada");
                });
                campania = obtenerAnadaDesdeFecha(pasoEntrada?.fecha || "");
            }
            if (!campania) campania = "—";
            const partida = lote.partida_nombre || lote.partida || "—";
            const formato = formatoMlAlmacenTexto(lote.formato_ml);
            const entradas = Number(resumen.entradas || 0).toLocaleString("es-ES");
            const salidas = Number(resumen.salidas || 0).toLocaleString("es-ES");
            const mermas = Number(resumen.mermas || 0).toLocaleString("es-ES");
            const saldo = Number(resumen.saldo || lote.botellas_actuales || 0).toLocaleString("es-ES");
            const unidadesCaja = normalizarUnidadesCaja(lote.caja_unidades, 6);
            const saldoNum = Math.max(0, Math.floor(Number(resumen.saldo || lote.botellas_actuales || 0)));
            const saldoCajas = formatearCajasDesdeBotellas(saldoNum, unidadesCaja);
            const origenHtml = origenes.length
                ? origenes
                    .map(item => {
                        const origen = item.contenedor_codigo
                            ? `${item.contenedor_tipo || ""} ${item.contenedor_codigo}`
                            : `${item.contenedor_tipo || "contenedor"} ${item.contenedor_id || "?"}`;
                        const fecha = formatearFechaCorta(item.fecha || "");
                        return `<div style="margin-top:6px;">${esc(fecha)} · ${esc(origen)} · ${Number(item.botellas || 0).toLocaleString("es-ES")} botellas</div>`;
                    })
                    .join("")
                : `<div style="margin-top:6px; color:#5d5366;">Sin origen directo identificado.</div>`;
            const docsHtml = docs.length
                ? `<ul style="margin:8px 0 0 18px; padding:0;">
                    ${docs
                        .map(d => {
                            const numero = d.numero || `DOC-${d.id}`;
                            const fecha = formatearFechaCorta(d.fecha || "");
                            const tercero = d.tercero || "—";
                            return `<li>${esc(numero)} · ${esc(d.tipo || "OTRO")} · ${esc(fecha)} · ${esc(tercero)}</li>`;
                        })
                        .join("")}
                  </ul>`
                : `<div style="margin-top:8px; color:#5d5366;">Sin documentos asociados.</div>`;
            const backHtml = back.length
                ? `<ul style="margin:8px 0 0 18px; padding:0;">
                    ${back
                        .map(b => {
                            const fecha = b.fecha ? ` · ${esc(formatearFechaCorta(b.fecha))}` : "";
                            const nota = b.nota ? ` · ${esc(b.nota)}` : "";
                            const boton = b.accion === "ver_contenedor"
                                ? ` <button type="button" class="almacen-traza-btn" data-traza-contenedor="${esc(b.valor || "")}">Ver contenedor</button>`
                                : "";
                            return `<li>${esc(b.tipo || "referencia")}: ${esc(b.valor || b.ref || "—")}${fecha}${nota}${boton}</li>`;
                        })
                        .join("")}
                  </ul>`
                : `<div style="margin-top:8px; color:#5d5366;">Sin referencias hacia atrás disponibles.</div>`;
            const forwardHtml = forward.length
                ? `<ul style="margin:8px 0 0 18px; padding:0;">
                    ${forward
                        .map(f => {
                            const botellas = Number(f.botellas || 0).toLocaleString("es-ES");
                            return `<li>${esc(f.cliente || "—")} · ${esc(f.documento || "—")} · ${botellas} botellas</li>`;
                        })
                        .join("")}
                  </ul>`
                : `<div style="margin-top:8px; color:#5d5366;">Sin salidas registradas a cliente.</div>`;
            const timelineHtml = timeline.length
                ? `<ol style="margin:10px 0 0 18px; padding:0;">
                    ${timeline
                        .map(step => {
                            const fecha = formatearFechaCorta(step.fecha || "");
                            return `<li style="margin-bottom:8px;"><strong>${esc(step.titulo || step.tipo || "Paso")}</strong><br><small>${esc(fecha)} · ${esc(step.detalle || "")}</small></li>`;
                        })
                        .join("")}
                  </ol>`
                : `<div style="margin-top:8px; color:#5d5366;">No hay pasos suficientes para reconstruir la traza completa.</div>`;

            panel.innerHTML = `
                <div class="flow-inspector-header">
                    <div class="flow-inspector-icon">📦</div>
                    <div>
                        <div class="flow-inspector-title">Trazabilidad de lote: ${esc(nombreLote)}</div>
                        <div class="flow-inspector-sub">Añada ${esc(campania)} · Partida ${esc(partida)} · Formato ${esc(formato)}</div>
                    </div>
                </div>
                <div class="flow-inspector-tags">
                    <span class="flow-tag">Entradas: ${esc(entradas)}</span>
                    <span class="flow-tag">Salidas: ${esc(salidas)}</span>
                    <span class="flow-tag">Mermas: ${esc(mermas)}</span>
                    <span class="flow-tag">Saldo: ${esc(saldo)}</span>
                    <span class="flow-tag">Stock cajas: ${esc(saldoCajas)}</span>
                </div>
                <div class="almacen-traza-layout">
                    <div class="almacen-traza-main">
                        <div class="almacen-traza-section">
                            <div class="almacen-traza-section-title">Origen (embotellado)</div>
                            ${origenHtml}
                        </div>
                        <div class="almacen-traza-section">
                            <div class="almacen-traza-section-title">Trazabilidad completa (desde entrada de uva)</div>
                            ${timelineHtml}
                        </div>
                        <details class="almacen-traza-details">
                            <summary><strong>Detalle forward (clientes)</strong></summary>
                            ${forwardHtml}
                        </details>
                        <details class="almacen-traza-details">
                            <summary><strong>Detalle back (origen ampliado)</strong></summary>
                            ${backHtml}
                        </details>
                        <details class="almacen-traza-details">
                            <summary><strong>Documentos asociados</strong></summary>
                            ${docsHtml}
                        </details>
                    </div>
                </div>
            `;
        }

        function abrirContenedorDesdeTraza(ref) {
            const valor = String(ref || "").trim().toLowerCase();
            if (!valor) return;
            const [tipo, id] = valor.split(":");
            if (tipo === "barrica") {
                mostrarSeccion("barricas");
                mostrarAviso(`Origen en barrica ${id || "—"}.`, "success");
                return;
            }
            if (tipo === "deposito" || tipo === "mastelone") {
                mostrarSeccion("depositos");
                mostrarAviso(`Origen en ${tipo} ${id || "—"}.`, "success");
                return;
            }
            mostrarAviso(`Origen: ${ref}`, "success");
        }

        async function cargarTrazabilidadLoteVino(loteId, silencioso = false) {
            const panel = document.getElementById("almacenTrazabilidadPanel");
            const loteKey = String(loteId || "").trim();
            if (!loteKey) {
                if (panel) panel.textContent = "Selecciona un lote para ver su trazabilidad.";
                return;
            }
            if (panel && !silencioso) {
                panel.textContent = "Cargando trazabilidad del lote...";
            }
            if (loteKey.startsWith("flow:")) {
                let dataVirtual = cacheAlmacenVinoTrazasVirtuales.get(loteKey) || null;
                if (!dataVirtual) {
                    construirLotesVirtualesDesdeFlujo();
                    dataVirtual = cacheAlmacenVinoTrazasVirtuales.get(loteKey) || null;
                }
                almacenVinoLoteSeleccionado = loteKey;
                renderTrazabilidadLoteVino(dataVirtual);
                document.querySelectorAll(".almacen-traza-btn").forEach(btn => {
                    const idBtn = String(btn.dataset.loteId || "");
                    btn.classList.toggle("is-active", idBtn === String(almacenVinoLoteSeleccionado));
                });
                if (panel && !silencioso) {
                    panel.scrollIntoView({ behavior: "smooth", block: "start" });
                }
                return;
            }
            try {
                const res = await fetch(`/api/almacen-vino/lotes/${encodeURIComponent(loteKey)}/trazabilidad`);
                if (!res.ok) {
                    if (panel) panel.textContent = "No se pudo cargar la trazabilidad de este lote.";
                    return;
                }
                const data = await res.json();
                almacenVinoLoteSeleccionado = String(loteKey);
                renderTrazabilidadLoteVino(data);
                document.querySelectorAll(".almacen-traza-btn").forEach(btn => {
                    const idBtn = String(btn.dataset.loteId || "");
                    btn.classList.toggle("is-active", idBtn === String(almacenVinoLoteSeleccionado));
                });
                if (panel && !silencioso) {
                    panel.scrollIntoView({ behavior: "smooth", block: "start" });
                }
            } catch (err) {
                if (!silencioso) {
                    console.error("Error cargando trazabilidad del lote:", err);
                }
                if (panel) panel.textContent = "Error cargando trazabilidad del lote.";
            }
        }

        function initEventosTrazabilidadAlmacen() {
            const enlazarContenedor = contenedor => {
                if (!contenedor || contenedor.dataset.trazaBound === "1") return;
                contenedor.dataset.trazaBound = "1";
                contenedor.addEventListener("click", ev => {
                    const btn = ev.target.closest(".almacen-traza-btn");
                    if (btn) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        const loteId = btn.dataset.loteId;
                        cargarTrazabilidadLoteVino(loteId);
                        return;
                    }
                    const btnEditar = ev.target.closest(".almacen-edit-btn");
                    if (!btnEditar) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    const loteId = btnEditar.dataset.loteId;
                    abrirEditorLoteAlmacen(loteId);
                });
            };
            enlazarContenedor(document.getElementById("tablaAlmacenVino"));
            enlazarContenedor(document.getElementById("almacenEstanteriaDesktop"));
            enlazarContenedor(document.getElementById("almacenEstanteriaMobile"));
            const panel = document.getElementById("almacenTrazabilidadPanel");
            if (panel && panel.dataset.backBound !== "1") {
                panel.dataset.backBound = "1";
                panel.addEventListener("click", ev => {
                    const btn = ev.target.closest("[data-traza-contenedor]");
                    if (!btn) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    abrirContenedorDesdeTraza(btn.dataset.trazaContenedor);
                });
            }
        }

        async function abrirEditorLoteAlmacen(loteId) {
            const idTxt = String(loteId || "").trim();
            if (!idTxt) return;
            const lote = (cacheAlmacenVino || []).find(item => String(item?.id || "") === idTxt);
            if (!lote) {
                mostrarAviso("No se encontró el lote para editar.", "error");
                return;
            }
            initEventosModalEditarLoteAlmacen();
            const modal = document.getElementById("almacenEditarLoteModal");
            if (!modal) return;
            const esFlow = idTxt.startsWith("flow:");
            const nombreActual = (lote.nombre || "").toString().trim();
            const unidadesActuales = normalizarUnidadesCaja(lote.caja_unidades, 6);
            const stockActual = Math.max(0, Math.floor(Number(lote.botellas_actuales || 0)));
            almacenLoteEditandoId = idTxt;
            const inputId = document.getElementById("almEditLoteId");
            const inputNombre = document.getElementById("almEditNombre");
            const inputCaja = document.getElementById("almEditCajaUnidades");
            const inputStock = document.getElementById("almEditStock");
            const stockWrap = document.getElementById("almEditStockWrap");
            const ayuda = document.getElementById("almEditAyuda");
            if (inputId) inputId.value = idTxt;
            if (inputNombre) inputNombre.value = nombreActual || idTxt;
            if (inputCaja) inputCaja.value = String(unidadesActuales);
            if (inputStock) inputStock.value = String(stockActual);
            if (stockWrap) stockWrap.style.display = esFlow ? "none" : "";
            if (ayuda) {
                ayuda.textContent = esFlow
                    ? "Lote del mapa: se actualizan nombre y tipo de caja. El stock lo calcula el flujo."
                    : "Lote persistido: puedes ajustar nombre, cajas y stock.";
            }
            if (typeof modal.showModal === "function") {
                modal.showModal();
            } else {
                modal.setAttribute("open", "open");
            }
        }

        function calcularBotellasSalidaDesdeNodo(salidaNodo) {
            if (!salidaNodo || salidaNodo.tipo !== "salida") return 0;
            const cajasRaw = normalizarNumero(salidaNodo?.datos?.cajas_cantidad);
            const cajas = Number.isFinite(cajasRaw) && cajasRaw > 0 ? Math.floor(cajasRaw) : 0;
            const tamCaja = obtenerTamanoCaja(salidaNodo?.datos?.cajas_tipo || "6 botellas");
            const total = cajas * tamCaja;
            return Number.isFinite(total) && total > 0 ? total : 0;
        }

        function obtenerBotellasNodoAlmacen(almacenNodo) {
            if (!almacenNodo || almacenNodo.tipo !== "almacen") return 0;
            const directas = normalizarNumero(almacenNodo?.datos?.botellas_resultantes);
            if (Number.isFinite(directas) && directas > 0) {
                return Math.floor(directas);
            }
            const cajas = normalizarNumero(almacenNodo?.datos?.cajas_resultantes);
            if (Number.isFinite(cajas) && cajas > 0) {
                const tamCaja = obtenerTamanoCaja(almacenNodo?.datos?.caja_botellas || "6 botellas");
                return Math.floor(cajas) * tamCaja;
            }
            const padres = obtenerPredecesores(almacenNodo.id) || [];
            const desdeEmbotellado = padres
                .filter(n => n && n.tipo === "embotellado")
                .reduce((acc, emb) => acc + obtenerBotellasNodoEmbotellado(emb), 0);
            return Number.isFinite(desdeEmbotellado) && desdeEmbotellado > 0 ? Math.floor(desdeEmbotellado) : 0;
        }

        function limpiarVariedadTimelineMapa(texto) {
            return String(texto || "")
                .replace(/\r?\n/g, "/")
                .replace(/\s*\/\s*/g, "/")
                .trim();
        }

        function construirPasoTimelineMapa(nodo, sourceIndexMap) {
            if (!nodo) return null;
            const tipo = String(nodo.tipo || "").toLowerCase();
            const tipoLabel = (FLOW_NODE_TYPES[nodo.tipo]?.label || nodo.tipo || "Nodo").toString();
            const titulo =
                tipo === "entrada"
                    ? (buildCompactTitleParts(nodo, { sourceIndexMap })?.title || obtenerEtiquetaNodoMapa(nodo))
                    : describirNodoMapaNodos(nodo);
            const detallePartes = [tipoLabel];
            const variedad = limpiarVariedadTimelineMapa(obtenerVariedadVisibleNodo(nodo));
            if (variedad) detallePartes.push(variedad);
            const volumen = obtenerTextoVolumenNodo(nodo);
            if (volumen && volumen !== "—") detallePartes.push(volumen);
            if (tipo === "salida") {
                const salida = obtenerResumenSalidaNodo(nodo);
                if (salida.cajas > 0) {
                    detallePartes.push(`${salida.cajas} cajas (${salida.tipoCaja})`);
                }
            }
            return {
                tipo: tipo || "nodo",
                titulo: titulo || tipoLabel,
                fecha: obtenerFechaEventoNodo(nodo) || null,
                detalle: detallePartes.join(" · "),
            };
        }

        function construirTimelineLoteVirtualDesdeMapa(embNode) {
            if (!embNode) return [];
            const embId = normalizarIdNodo(embNode);
            if (!embId) return [];
            const sourceIndexMap = construirIndicesEntradaFlow(flujoNodos);
            const nodosPorId = new Map(
                (Array.isArray(flujoNodos) ? flujoNodos : [])
                    .map(n => [normalizarIdNodo(n), n])
                    .filter(([id]) => Boolean(id))
            );
            const pesoNodo = nodo => {
                if (!nodo) return 0;
                const y = Number.isFinite(Number(nodo.y)) ? Number(nodo.y) : 0;
                const x = Number.isFinite(Number(nodo.x)) ? Number(nodo.x) : 0;
                return y * 10000 + x;
            };
            const backwardDepth = new Map([[embId, 0]]);
            const colaBack = [embId];
            const visitadosBack = new Set([embId]);
            while (colaBack.length) {
                const actualId = colaBack.shift();
                const actualDepth = backwardDepth.get(actualId) || 0;
                const padres = obtenerPredecesores(actualId) || [];
                padres.forEach(pre => {
                    const preId = normalizarIdNodo(pre);
                    if (!preId) return;
                    if (visitadosBack.has(preId)) return;
                    visitadosBack.add(preId);
                    backwardDepth.set(preId, actualDepth + 1);
                    colaBack.push(preId);
                });
            }
            const forwardDepth = new Map();
            const colaFwd = [{ id: embId, depth: 0 }];
            const visitadosFwd = new Set([embId]);
            while (colaFwd.length) {
                const actual = colaFwd.shift();
                const nodo = nodosPorId.get(actual.id);
                if (!nodo) continue;
                const targets = Array.isArray(nodo.targets) ? nodo.targets : [];
                targets.forEach(targetId => {
                    const tid = normalizarIdNodo(targetId);
                    if (!tid) return;
                    const depth = actual.depth + 1;
                    const previo = forwardDepth.get(tid);
                    if (previo == null || depth < previo) {
                        forwardDepth.set(tid, depth);
                    }
                    if (!visitadosFwd.has(tid)) {
                        visitadosFwd.add(tid);
                        colaFwd.push({ id: tid, depth });
                    }
                });
            }
            const ancestros = [...backwardDepth.entries()]
                .filter(([id, depth]) => id !== embId && depth > 0)
                .map(([id, depth]) => ({ id, depth, nodo: nodosPorId.get(id) }))
                .filter(item => item.nodo)
                .sort((a, b) => b.depth - a.depth || pesoNodo(a.nodo) - pesoNodo(b.nodo));
            const descendientes = [...forwardDepth.entries()]
                .map(([id, depth]) => ({ id, depth, nodo: nodosPorId.get(id) }))
                .filter(item => item.nodo)
                .sort((a, b) => a.depth - b.depth || pesoNodo(a.nodo) - pesoNodo(b.nodo));
            const timeline = [];
            ancestros.forEach(item => {
                const paso = construirPasoTimelineMapa(item.nodo, sourceIndexMap);
                if (paso) timeline.push(paso);
            });
            const pasoEmbotellado = construirPasoTimelineMapa(embNode, sourceIndexMap);
            if (pasoEmbotellado) timeline.push(pasoEmbotellado);
            descendientes.forEach(item => {
                const paso = construirPasoTimelineMapa(item.nodo, sourceIndexMap);
                if (paso) timeline.push(paso);
            });
            return timeline;
        }

        function construirLotesVirtualesDesdeFlujo() {
            cacheAlmacenVinoTrazasVirtuales = new Map();
            const nodos = Array.isArray(flujoNodos) ? flujoNodos : [];
            const embotellados = nodos.filter(n => n && n.tipo === "embotellado");
            const lotes = [];

            embotellados.forEach((embNode) => {
                const loteKey = `flow:${embNode.id}`;
                const botellasEntradaRaw = obtenerBotellasNodoEmbotellado(embNode);
                const botellasEntrada = Number.isFinite(botellasEntradaRaw) && botellasEntradaRaw > 0
                    ? Math.floor(botellasEntradaRaw)
                    : 0;
                const fechaEntrada = embNode?.datos?.fecha || embNode?.datos?.fecha_operacion || "";
                const formatoLitros = VOLUMEN_BOTELLA_L[embNode?.datos?.botella] || 0.75;
                const formatoMl = Math.round(formatoLitros * 1000);
                const nombreLote = (embNode?.datos?.lote || "").toString().trim() || "VACIO";
                const partidaNombre =
                    (embNode?.datos?.nombre_vino || embNode?.datos?.nombre_blend || "Mapa de nodos").toString().trim();
                const timeline = construirTimelineLoteVirtualDesdeMapa(embNode);
                const pasoEntrada = timeline.find(paso => String(paso?.tipo || "").toLowerCase() === "entrada");
                const campaniaAnio =
                    obtenerAnadaDesdeFecha(pasoEntrada?.fecha || "") ||
                    obtenerAnadaDesdeFecha(fechaEntrada) ||
                    embNode?.datos?.anada ||
                    "—";

                let botellasSalida = 0;
                let botellasStockAlmacen = 0;
                const movimientos = [];

                const destinos = (embNode.targets || [])
                    .map(id => buscarNodoPorId(id))
                    .filter(Boolean);
                const almacenes = destinos.filter(n => n.tipo === "almacen");
                const salidasDirectas = destinos.filter(n => n.tipo === "salida");
                const tipoCajaAlmacen = (almacenes[0]?.datos?.caja_botellas || "").toString();
                const tipoCajaSalida = (salidasDirectas[0]?.datos?.cajas_tipo || "").toString();
                const unidadesCaja = normalizarUnidadesCaja(
                    obtenerTamanoCaja(tipoCajaAlmacen || tipoCajaSalida || "6 botellas"),
                    6
                );

                almacenes.forEach(almNode => {
                    botellasStockAlmacen += obtenerBotellasNodoAlmacen(almNode);
                    const salidas = (almNode.targets || [])
                        .map(id => buscarNodoPorId(id))
                        .filter(n => n && n.tipo === "salida");
                    salidas.forEach(salidaNode => {
                        const botellasOut = calcularBotellasSalidaDesdeNodo(salidaNode);
                        if (!(botellasOut > 0)) return;
                        botellasSalida += botellasOut;
                        movimientos.push({
                            tipo: "SALIDA",
                            botellas: botellasOut,
                            fecha: salidaNode?.datos?.fecha || salidaNode?.datos?.fecha_operacion || null,
                            nota: salidaNode?.datos?.cliente
                                ? `Cliente: ${salidaNode.datos.cliente}`
                                : "Salida desde nodo de salida",
                        });
                    });
                });

                salidasDirectas.forEach(salidaNode => {
                    const botellasOut = calcularBotellasSalidaDesdeNodo(salidaNode);
                    if (!(botellasOut > 0)) return;
                    botellasSalida += botellasOut;
                    movimientos.push({
                        tipo: "SALIDA",
                        botellas: botellasOut,
                        fecha: salidaNode?.datos?.fecha || salidaNode?.datos?.fecha_operacion || null,
                        nota: salidaNode?.datos?.cliente
                            ? `Cliente: ${salidaNode.datos.cliente}`
                            : "Salida directa desde embotellado",
                    });
                });

                const entradaAjustada = Math.max(botellasEntrada, botellasStockAlmacen + botellasSalida, botellasSalida);
                if (entradaAjustada > 0) {
                    movimientos.unshift({
                        tipo: "ENTRADA",
                        botellas: entradaAjustada,
                        fecha: fechaEntrada || null,
                        nota: "Entrada desde embotellado (mapa de nodos)",
                    });
                }
                const saldo = Math.max(entradaAjustada - botellasSalida, 0);
                if (entradaAjustada <= 0 && botellasSalida <= 0) return;

                const origenesBase = (obtenerPredecesores(embNode.id) || [])
                    .map(pre => ({
                        fecha: fechaEntrada || null,
                        contenedor_tipo: pre.tipo || "origen",
                        contenedor_id: pre.id || null,
                        contenedor_codigo: pre?.datos?.codigo || pre?.titulo || "",
                        botellas: entradaAjustada,
                        nota: "Origen detectado desde el mapa de nodos",
                    }))
                    .filter(Boolean);
                const origenes = origenesBase.length
                    ? origenesBase
                    : [{
                        fecha: fechaEntrada || null,
                        contenedor_tipo: "embotellado",
                        contenedor_id: embNode.id || null,
                        contenedor_codigo: embNode?.titulo || "Embotellado",
                        botellas: entradaAjustada,
                        nota: "Origen en mapa de nodos",
                    }];

                const dataTraza = {
                    lote: {
                        id: loteKey,
                        nombre: nombreLote,
                        campania_anio: campaniaAnio,
                        partida_nombre: partidaNombre,
                        formato_ml: formatoMl,
                        botellas_actuales: saldo,
                        caja_unidades: unidadesCaja,
                    },
                    resumen: {
                        entradas: entradaAjustada,
                        salidas: botellasSalida,
                        saldo,
                    },
                    origenes,
                    movimientos,
                    timeline,
                };
                cacheAlmacenVinoTrazasVirtuales.set(loteKey, dataTraza);
                lotes.push({
                    id: loteKey,
                    nombre: nombreLote,
                    campania_anio: campaniaAnio,
                    partida_nombre: partidaNombre,
                    formato_ml: formatoMl,
                    botellas_actuales: saldo,
                    botellas_entrada: entradaAjustada,
                    botellas_salida: botellasSalida,
                    caja_unidades: unidadesCaja,
                    _virtual: true,
                });
            });

            return lotes;
        }

        function construirChipsCajasAlmacen(botellasNum, unidadesCaja) {
            const totalBotellas = Math.max(0, Math.floor(Number(botellasNum || 0)));
            const unidades = normalizarUnidadesCaja(unidadesCaja, 6);
            const cajasEnteras = unidades > 0 ? Math.floor(totalBotellas / unidades) : 0;
            const maxVisual = 24;
            const visible = Math.max(8, Math.min(maxVisual, cajasEnteras));
            let html = "";
            for (let i = 0; i < visible; i += 1) {
                const clase = i < cajasEnteras ? "almacen-caja-chip" : "almacen-caja-chip is-empty";
                html += `<span class="${clase}"></span>`;
            }
            return { cajasEnteras, html };
        }

        function renderEstanteriaAlmacenVino(lotes) {
            const desktop = document.getElementById("almacenEstanteriaDesktop");
            const mobile = document.getElementById("almacenEstanteriaMobile");
            if (!desktop && !mobile) return;
            const esc = value =>
                String(value ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/\"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            const lista = Array.isArray(lotes) ? lotes : [];
            if (desktop) desktop.innerHTML = "";
            if (mobile) mobile.innerHTML = "";
            if (!lista.length) {
                const msg = `<div class="almacen-estante-row"><div class="almacen-estante-items"></div></div>`;
                if (desktop) desktop.innerHTML = msg;
                if (mobile) {
                    mobile.innerHTML = `<div class="almacen-lote-mobile">Aún no hay lotes con stock.</div>`;
                }
                return;
            }

            const estados = [
                { key: "LIBERADO", label: "Lotes listos" },
                { key: "CUARENTENA", label: "Lotes en cuarentena" },
                { key: "BLOQUEADO", label: "Lotes bloqueados" },
            ];
            const lotesPorEstado = new Map(estados.map(e => [e.key, []]));
            lista.forEach(lote => {
                const status = (lote?.status || "LIBERADO").toString().toUpperCase();
                if (!lotesPorEstado.has(status)) lotesPorEstado.set(status, []);
                lotesPorEstado.get(status).push(lote);
            });

            if (desktop) {
                estados.forEach(def => {
                    const lotesEstado = lotesPorEstado.get(def.key) || [];
                    const row = document.createElement("div");
                    row.className = "almacen-estante-row";
                    const head = document.createElement("div");
                    head.className = "almacen-estante-head";
                    head.innerHTML = `
                        <div class="almacen-estante-title">${def.label}</div>
                        <div class="almacen-estante-count">${lotesEstado.length} lote${lotesEstado.length === 1 ? "" : "s"}</div>
                    `;
                    const items = document.createElement("div");
                    items.className = "almacen-estante-items";
                    lotesEstado.forEach(lote => {
                        const loteId = lote.id || "—";
                        const nombreComercial = obtenerNombreComercialLote(lote);
                        const subtitulo = obtenerSubtituloLote(lote);
                        const status = (lote.status || "LIBERADO").toString().toUpperCase();
                        const statusClass = status.toLowerCase();
                        const stockBotellasNum = Math.max(0, Math.floor(Number(lote.botellas_actuales || 0)));
                        const unidadesCaja = normalizarUnidadesCaja(lote.caja_unidades, 6);
                        const resumenCajas = resumenCajasDesdeBotellas(stockBotellasNum, unidadesCaja);
                        const stockCajas = `${resumenCajas.cajas.toLocaleString("es-ES")} cajas`;
                        const stockBotellasTxt = `${stockBotellasNum.toLocaleString("es-ES")} botellas`;
                        const cajaVisual = construirChipsCajasAlmacen(stockBotellasNum, unidadesCaja);
                        const card = document.createElement("article");
                        card.className = "almacen-lote-crate";
                        card.innerHTML = `
                            <div class="almacen-lote-crate-header">
                                <div class="almacen-lote-id">${esc(nombreComercial)}</div>
                                <span class="almacen-status-chip ${statusClass}">${esc(status)}</span>
                            </div>
                            <div class="almacen-lote-vino">${esc(subtitulo)}</div>
                            <div class="almacen-lote-kpis">
                                <div class="almacen-lote-kpi"><strong>Cajas:</strong> ${esc(stockCajas)}</div>
                                <div class="almacen-lote-kpi"><strong>Botellas/caja:</strong> ${esc(unidadesCaja)}</div>
                                <div class="almacen-lote-kpi"><strong>Stock:</strong> ${esc(stockBotellasTxt)}</div>
                            </div>
                            <div class="almacen-cajas-stack">${cajaVisual.html}</div>
                            <div class="almacen-lote-actions">
                                <button type="button" class="almacen-traza-btn ${String(loteId) === String(almacenVinoLoteSeleccionado) ? "is-active" : ""}" data-lote-id="${esc(loteId)}">Ver traza</button>
                                <button type="button" class="almacen-edit-btn" data-lote-id="${esc(loteId)}">Editar</button>
                            </div>
                        `;
                        items.appendChild(card);
                    });
                    row.appendChild(head);
                    row.appendChild(items);
                    desktop.appendChild(row);
                });
            }

            if (mobile) {
                lista.forEach(lote => {
                    const loteId = lote.id || "—";
                    const nombreComercial = obtenerNombreComercialLote(lote);
                    const subtitulo = obtenerSubtituloLote(lote);
                    const status = (lote.status || "LIBERADO").toString().toUpperCase();
                    const statusClass = status.toLowerCase();
                    const stockBotellasNum = Math.max(0, Math.floor(Number(lote.botellas_actuales || 0)));
                    const unidadesCaja = normalizarUnidadesCaja(lote.caja_unidades, 6);
                    const resumenCajas = resumenCajasDesdeBotellas(stockBotellasNum, unidadesCaja);
                    const stockCajas = `${resumenCajas.cajas.toLocaleString("es-ES")} cajas`;
                    const stockBotellasTxt = `${stockBotellasNum.toLocaleString("es-ES")} botellas`;
                    const card = document.createElement("article");
                    card.className = "almacen-lote-mobile";
                    card.innerHTML = `
                        <div class="almacen-lote-mobile-head">
                            <div class="almacen-lote-mobile-name">${esc(nombreComercial)}</div>
                            <span class="almacen-status-chip ${statusClass}">${esc(status)}</span>
                        </div>
                        <div class="almacen-lote-mobile-kpi">${esc(subtitulo)}</div>
                        <div class="almacen-lote-mobile-kpi"><strong>Cajas:</strong> ${esc(stockCajas)}</div>
                        <div class="almacen-lote-mobile-kpi"><strong>Botellas/caja:</strong> ${esc(unidadesCaja)}</div>
                        <div class="almacen-lote-mobile-kpi"><strong>Stock:</strong> ${esc(stockBotellasTxt)}</div>
                        <div class="almacen-lote-actions">
                            <button type="button" class="almacen-traza-btn ${String(loteId) === String(almacenVinoLoteSeleccionado) ? "is-active" : ""}" data-lote-id="${esc(loteId)}">Ver traza</button>
                            <button type="button" class="almacen-edit-btn" data-lote-id="${esc(loteId)}">Editar</button>
                        </div>
                    `;
                    mobile.appendChild(card);
                });
            }
        }

	        async function cargarAlmacenVino() {
	            try {
                initEventosTrazabilidadAlmacen();
                initEventosModalAlmacen();
                initEventosModalEditarLoteAlmacen();
                const resLotes = await fetch("/api/almacen-vino/lotes");
                const lotesApiRaw = resLotes.ok ? await resLotes.json() : [];
                const lotesApi = Array.isArray(lotesApiRaw)
                    ? lotesApiRaw.map(l => ({
                        id: l.id,
                        nombre: (() => {
                            const nombre = (l.nombre || l.nombre_comercial || "").toString().trim();
                            return /^lote\s*mapa\b/i.test(nombre) ? "VACIO" : (nombre || "VACIO");
                        })(),
                        campania_anio: l.campania_anio || l.anada || null,
                        partida_nombre: l.partida_nombre || l.partida || l.vino || "—",
                        formato_ml: l.formato_ml,
                        botellas_actuales: Number(l.botellas_actuales || l.stock_botellas || 0),
                        botellas_entrada: Number(l.botellas_entrada || l.entradas_bot || 0),
                        botellas_salida: Number(l.botellas_salida || l.salidas_bot || 0),
                        botellas_merma: Number(l.botellas_merma || l.mermas_bot || 0),
                        status: l.status || "LIBERADO",
                        caja_unidades: Number(l.caja_unidades || 6),
                    }))
                    : [];
                if (lotesApi.length) {
                    cacheAlmacenVino = lotesApi;
                    cacheAlmacenVinoTrazasVirtuales = new Map();
                } else {
                    const lotesVirtuales = construirLotesVirtualesDesdeFlujo();
                    cacheAlmacenVino = lotesVirtuales;
                }
                const tbody = document.getElementById("tablaAlmacenVino");
                if (tbody) {
                    tbody.innerHTML = "";
                    if (!cacheAlmacenVino.length) {
                        const tr = document.createElement("tr");
                        tr.innerHTML = '<td colspan="8">Aún no hay stock embotellado.</td>';
                        tbody.appendChild(tr);
                        const panel = document.getElementById("almacenTrazabilidadPanel");
                        if (panel) {
                            panel.textContent = "Cuando tengas lotes en stock, aquí verás su trazabilidad completa.";
                        }
                        renderEstanteriaAlmacenVino(cacheAlmacenVino);
                    } else {
                        cacheAlmacenVino.forEach(lote => {
                            const tr = document.createElement("tr");
                            tr.dataset.loteId = String(lote.id);
                            const loteId = lote.id || "—";
                            const nombreLote = obtenerNombreComercialLote(lote);
                            const codigoLote = obtenerCodigoVisibleLote(lote);
                            const subtituloLote = codigoLote || obtenerSubtituloLote(lote);
                            const campania = lote.campania_anio ? String(lote.campania_anio) : "—";
                            const partida = lote.partida_nombre || lote.nombre || "—";
                            const formato = formatoMlAlmacenTexto(lote.formato_ml);
                            const stockBotellasNum = lote.botellas_actuales != null ? Number(lote.botellas_actuales) : 0;
                            const botellas = Number.isFinite(stockBotellasNum)
                                ? stockBotellasNum.toLocaleString("es-ES")
                                : "0";
                            const unidadesCaja = normalizarUnidadesCaja(lote.caja_unidades, 6);
                            const stockCajas = formatearCajasDesdeBotellas(stockBotellasNum, unidadesCaja);
                            const entradas = Number(lote.botellas_entrada || 0).toLocaleString("es-ES");
                            const salidas = Number(lote.botellas_salida || 0).toLocaleString("es-ES");
                            const mermas = Number(lote.botellas_merma || 0).toLocaleString("es-ES");
                            const status = (lote.status || "LIBERADO").toString().toUpperCase();
                            const statusClass = status.toLowerCase();

                            tr.innerHTML = `
                                <td><strong>${nombreLote}</strong><br><small>${subtituloLote}</small></td>
                                <td>${campania}</td>
                                <td>${partida}</td>
                                <td>${formato}</td>
                                <td>${botellas} botellas<br><small>${stockCajas}</small></td>
                                <td>${entradas} / ${salidas} / ${mermas}</td>
                                <td><span class="almacen-status-chip ${statusClass}">${status}</span></td>
                                <td></td>`;
                            const tdAccion = tr.querySelector("td:last-child");
                            const acciones = document.createElement("div");
                            acciones.className = "almacen-lote-actions";
                            const btnTraza = document.createElement("button");
                            btnTraza.type = "button";
                            btnTraza.className = "almacen-traza-btn";
                            btnTraza.textContent = "Ver traza";
                            btnTraza.dataset.loteId = String(lote.id);
                            if (String(lote.id) === String(almacenVinoLoteSeleccionado)) {
                                btnTraza.classList.add("is-active");
                            }
                            const btnEditar = document.createElement("button");
                            btnEditar.type = "button";
                            btnEditar.className = "almacen-edit-btn";
                            btnEditar.textContent = "Editar";
                            btnEditar.dataset.loteId = String(lote.id);
                            acciones.appendChild(btnTraza);
                            acciones.appendChild(btnEditar);
                            tdAccion.appendChild(acciones);
                            tbody.appendChild(tr);
                        });
                        renderEstanteriaAlmacenVino(cacheAlmacenVino);
                        const loteActivo =
                            cacheAlmacenVino.find(l => String(l.id) === String(almacenVinoLoteSeleccionado)) ||
                            cacheAlmacenVino[0];
                        if (loteActivo?.id) {
                            await cargarTrazabilidadLoteVino(loteActivo.id, true);
                        }
                    }
                }
	                actualizarIndicadores();
	            } catch (err) {
	                console.error("Error cargando almacén de vino:", err);
	            }
	        }

        async function crearEmbotellado(ev) {
            ev.preventDefault();
            const fecha = document.getElementById("embFecha").value;
            const contenedor_tipo = document.getElementById("embTipo").value;
            const contenedorValor = document.getElementById("embContenedor").value.trim();
            const botellasInput = parseInt(document.getElementById("embBotellas").value || "0", 10) || null;
            const formatoUnico = document.getElementById("embFormato").value;
            const lote = document.getElementById("embLote").value.trim();
            const nota = document.getElementById("embNota").value.trim();
            if (!lote) {
                alert("El nombre del lote es obligatorio.");
                return;
            }

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id) {
                alert("No encuentro ese contenedor.");
                return;
            }

            const formatosFormulario = obtenerFormatosEmbotelladoFormulario();
            let botellas = botellasInput;
            let litros = 0;
            let formatosPayload = [];
            if (formatosFormulario.length) {
                const resumen = calcularResumenFormatosBotellaDesdeLista(formatosFormulario);
                botellas = resumen.totalBotellas || null;
                litros = resumen.totalLitros || 0;
                formatosPayload = formatosFormulario;
            } else {
                if (!botellas || botellas <= 0) {
                    alert("Las botellas deben ser mayores que 0.");
                    return;
                }
                const volBotella = VOLUMEN_BOTELLA_L[formatoUnico] || 0;
                if (!(volBotella > 0)) {
                    alert("Selecciona un formato de botella válido.");
                    return;
                }
                litros = botellas * volBotella;
                formatosPayload = [{ formato: formatoUnico, botellas }];
            }

            if (!botellas || botellas <= 0) {
                alert("Las botellas deben ser mayores que 0.");
                return;
            }
            if (!(litros > 0)) {
                alert("No se pudo calcular litros para el embotellado.");
                return;
            }

            const body = {
                fecha,
                contenedor_tipo,
                contenedor_id,
                litros: Number(litros.toFixed(3)),
                botellas,
                lote,
                nota,
                formatos: formatosPayload,
            };

            try {
                const res = await fetch("/api/embotellados", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el embotellado.");
                if (!ok) return;
                document.getElementById("formEmbotellado").reset();
                limpiarFormatosEmbotelladoFormulario();
                await Promise.all([
                    cargarEmbotellados(),
                    cargarBarricas(),
                    cargarDepositos(),
                    cargarMovimientos(),
                    cargarResumen(),
                    cargarAlmacenVino(),
                ]);
            } catch (err) {
                console.error("Error creando embotellado:", err);
            }
        }

        // ---------- Registros analíticos ----------
        async function crearRegistroAnalitico(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("regTipo").value;
            const contenedorValor = document.getElementById("regId").value.trim();
            const fecha_hora = document.getElementById("regFecha").value;
            const densidad = document.getElementById("regDensidad").value
                ? parseFloat(document.getElementById("regDensidad").value)
                : null;
            const temperatura_c = document.getElementById("regTemperatura").value
                ? parseFloat(document.getElementById("regTemperatura").value)
                : null;
            const nota_sensorial = document.getElementById("regNotaSensorial").value;
            const nota = document.getElementById("regNota").value;

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id || !fecha_hora) {
                alert("Indica un contenedor válido y la fecha/hora.");
                return;
            }

            const body = {
                contenedor_tipo,
                contenedor_id,
                fecha_hora,
                densidad,
                temperatura_c,
                nota_sensorial,
                nota,
            };

            try {
                const res = await fetch("/api/registros", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                document.getElementById("formAnalitico").reset();
                cargarResumen();
                copilotoAnaliticosCache.clear();
                copilotoAnaliticosTs.clear();
                programarActualizacionCopiloto(true);
                alert("Registro analítico guardado.");
            } catch (err) {
                console.error("Error guardando registro analítico:", err);
                alert("Error al guardar el registro analítico.");
            }
        }

        async function cargarHistorialAnalitico() {
            const tipo = document.getElementById("histTipo").value;
            const valor = document.getElementById("histId").value.trim();
            const id = resolverContenedorId(tipo, valor);
            const tbody = document.getElementById("tablaRegistros");
            tbody.innerHTML = "";

            if (!id) {
                alert("Indica un contenedor válido (número o código).");
                return;
            }

            try {
                const datos = await obtenerHistorialCompleto(tipo, id);

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="4">No hay registros para este contenedor.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(r => {
                    const tr = document.createElement("tr");
                    const fecha = formatearFechaCorta(r.fecha || r.fecha_hora);
                    let evento = "";
                    let detalle = "";

                    if (r.categoria === "analitico") {
                        evento = "Registro analítico";
                        const partes = [];
                        if (r.densidad != null) partes.push(`Densidad: ${r.densidad}`);
                        if (r.temperatura_c != null) partes.push(`Temp: ${r.temperatura_c} °C`);
                        detalle = partes.join(" · ");
                    } else if (r.categoria === "movimiento") {
                        evento = `Movimiento: ${r.tipo || ""}`;
                        const origen = formatearUbicacionMovimiento(r.origen_tipo, r.origen_id);
                        const destino = formatearUbicacionMovimiento(r.destino_tipo, r.destino_id);
                        detalle = `${r.litros || 0} L · ${origen || "—"} → ${destino || "—"}`;
                    } else {
                        evento = "Evento";
                        detalle = "";
                    }
                    const notas = [];
                    if (r.nota_sensorial) {
                        notas.push(`Sensorial: ${r.nota_sensorial}`);
                    }
                    if (r.nota) {
                        const textoNota = r.categoria === "analitico" ? `Nota: ${r.nota}` : r.nota;
                        notas.push(textoNota);
                    }
                    const notaTexto = notas.join(" · ");

                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${evento}</td>
                        <td>${detalle}</td>
                        <td>${notaTexto}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando historial analítico:", err);
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="4">Error al cargar el historial.</td>';
                tbody.appendChild(tr);
            }
        }

        // ---------- Análisis Laboratorio ----------
        async function crearAnalisisLab(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("labTipoContenedor").value;
            const depositoValor = document.getElementById("labDeposito").value.trim();
            const contenedor_id = resolverContenedorId(contenedor_tipo, depositoValor);
            const fecha = document.getElementById("labFecha").value;
            const laboratorio = document.getElementById("labLaboratorio").value;
            const descripcion = document.getElementById("labDescripcion").value;
            const archivoInput = document.getElementById("labArchivo");
            const archivo = archivoInput.files[0];
            const mensaje = document.getElementById("labMensaje");

            if (!contenedor_id) {
                mensaje.textContent = "Indica un contenedor válido.";
                return;
            }
            if (!archivo) {
                mensaje.textContent = "Selecciona un PDF.";
                return;
            }
            if (archivo.type && archivo.type !== "application/pdf") {
                mensaje.textContent = "Solo se permiten PDF.";
                return;
            }

            try {
                mensaje.textContent = "Subiendo PDF...";
                const archivo_base64 = await leerArchivoBase64(archivo);
                const body = {
                    contenedor_id,
                    contenedor_tipo,
                    fecha,
                    laboratorio,
                    descripcion,
                    archivo_nombre: archivo.name,
                    archivo_base64,
                };
                const res = await fetch("/api/analisis-lab", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al subir el análisis.");
                if (!ok) {
                    mensaje.textContent = "No se pudo guardar.";
                    return;
                }
                document.getElementById("formAnalisisLab").reset();
                mensaje.textContent = "Análisis guardado correctamente.";
                await cargarAnalisisLab(filtroAnalisisDeposito);
                setTimeout(() => (mensaje.textContent = ""), 3000);
            } catch (err) {
                console.error("Error subiendo PDF:", err);
                mensaje.textContent = "Error al guardar el análisis.";
            }
        }

        async function cargarAnalisisLab(nuevoFiltro) {
            if (arguments.length > 0) {
                filtroAnalisisDeposito = nuevoFiltro;
            }
            const filtroActual = filtroAnalisisDeposito;
            mostrarSkeletonTabla("tablaAnalisisLab", 5);
            try {
                let url = "/api/analisis-lab";
                if (filtroActual && (filtroActual.id || filtroActual.tipo)) {
                    const params = new URLSearchParams();
                    if (filtroActual.id) params.set("contenedor_id", filtroActual.id);
                    if (filtroActual.tipo) params.set("tipo", filtroActual.tipo);
                    const qs = params.toString();
                    if (qs) {
                        url += `?${qs}`;
                    }
                }
                const res = await fetch(url);
                if (!res.ok) throw new Error();
                cacheAnalisisLab = await res.json();
                renderAnalisisLab();
            } catch (err) {
                console.error("Error cargando análisis:", err);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="5">No se pudieron cargar los análisis.</td></tr>';
                }
            }
        }

        function renderAnalisisLab() {
            const tbody = document.getElementById("tablaAnalisisLab");
            if (!tbody) return;
            tbody.innerHTML = "";
            if (!cacheAnalisisLab.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin análisis registrados todavía.</td>';
                tbody.appendChild(tr);
                return;
            }
            cacheAnalisisLab.forEach(reg => {
                const tr = document.createElement("tr");
                const fecha = reg.fecha ? formatearFechaCorta(reg.fecha) : "—";
                const tipoCont = reg.contenedor_tipo || "deposito";
                const contenedor =
                    formatearUbicacionMovimiento(tipoCont, reg.contenedor_id) ||
                    `${tipoCont} ${reg.contenedor_id}`;
                const laboratorio = reg.laboratorio || "—";
                const descripcion = reg.descripcion || "—";
                const archivo =
                    reg.archivo_url
                        ? `<a href="${reg.archivo_url}" target="_blank" rel="noopener">Descargar PDF</a>`
                        : "—";
                tr.innerHTML = `
                    <td>${fecha}</td>
                    <td>${contenedor}</td>
                    <td>${laboratorio}</td>
                    <td>${descripcion}</td>
                    <td>${archivo}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function aplicarFiltroAnalisisLab() {
            const valor = document.getElementById("labFiltroDeposito").value.trim();
            const tipoSelect = document.getElementById("labFiltroTipo").value;
            if (!valor && !tipoSelect) {
                await cargarAnalisisLab(null);
                return;
            }
            let filtro = null;
            if (valor) {
                let tipoCont = tipoSelect || "";
                let id = null;
                if (tipoCont) {
                    id = resolverContenedorId(tipoCont, valor);
                } else {
                    id = resolverContenedorId("deposito", valor);
                    tipoCont = id ? "deposito" : "";
                    if (!id) {
                        id = resolverContenedorId("mastelone", valor);
                        if (id) tipoCont = "mastelone";
                    }
                }
                if (!id) {
                    alert("No encuentro un contenedor con ese código/ID.");
                    return;
                }
                filtro = { id, tipo: tipoCont };
            } else if (tipoSelect) {
                filtro = { id: null, tipo: tipoSelect };
            }
            await cargarAnalisisLab(filtro);
        }

        async function limpiarFiltroAnalisisLab() {
            document.getElementById("labFiltroDeposito").value = "";
            document.getElementById("labFiltroTipo").value = "";
            await cargarAnalisisLab(null);
        }

function leerArchivoBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error("No se pudo leer el archivo"));
                reader.readAsDataURL(file);
            });
        }

        // ---------- Demo ligera de drag & drop de tanques/barricas ----------
        const tanques = [
            { id: "T101", tipo: "Tanque", vino: "Tempranillo", volumen: 8000, capacidad: 10000, estado: "FA", x: 80, y: 60 },
            { id: "B045", tipo: "Barrica", vino: "Crianza Lote 5", volumen: 225, capacidad: 225, estado: "Reposo", x: 320, y: 120 },
            { id: "T204", tipo: "Tanque", vino: "Garnacha", volumen: 5200, capacidad: 8000, estado: "FML", x: 180, y: 200 },
        ];
        let demoDrag = null;

        function renderDemoFlow() {
            const stage = document.getElementById("demoFlowStage");
            if (!stage) return;
            stage.innerHTML = "";
            tanques.forEach((nodo, idx) => {
                const el = document.createElement("div");
                el.className = "flow-node demo-flow-node";
                el.style.left = `${nodo.x}px`;
                el.style.top = `${nodo.y}px`;
                el.dataset.index = idx;
                el.innerHTML = `
                    <h4 style="margin:0 0 4px;">${nodo.id}</h4>
                    <div class="flow-node-subtitle">${nodo.tipo} · ${nodo.vino}</div>
                    <div class="flow-node-subtitle">Volumen ${nodo.volumen} / ${nodo.capacidad}</div>
                    <div class="estado-pill estado-${(nodo.estado || "").toLowerCase()}" style="margin-top:6px;">${nodo.estado}</div>
                `;
                el.addEventListener("pointerdown", ev => startDemoDrag(ev, idx));
                stage.appendChild(el);
            });
        }

        function startDemoDrag(ev, idx) {
            const stage = document.getElementById("demoFlowStage");
            const nodeEl = ev.currentTarget;
            if (!stage || !nodeEl) return;
            const rect = stage.getBoundingClientRect();
            demoDrag = {
                idx,
                nodeEl,
                stage,
                pointerId: ev.pointerId,
                offsetX: ev.clientX - rect.left - tanques[idx].x,
                offsetY: ev.clientY - rect.top - tanques[idx].y,
            };
            nodeEl.setPointerCapture(ev.pointerId);
            nodeEl.classList.add("dragging");
            nodeEl.addEventListener("pointermove", moveDemoDrag);
            nodeEl.addEventListener("pointerup", endDemoDrag);
            nodeEl.addEventListener("pointercancel", endDemoDrag);
        }

        function moveDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { stage, nodeEl, idx, offsetX, offsetY } = demoDrag;
            const stageRect = stage.getBoundingClientRect();
            const nodeRect = nodeEl.getBoundingClientRect();
            let x = ev.clientX - stageRect.left - offsetX;
            let y = ev.clientY - stageRect.top - offsetY;
            const maxX = stageRect.width - nodeRect.width;
            const maxY = stageRect.height - nodeRect.height;
            x = Math.max(0, Math.min(maxX, x));
            y = Math.max(0, Math.min(maxY, y));
            tanques[idx].x = Math.round(x);
            tanques[idx].y = Math.round(y);
            nodeEl.style.left = `${tanques[idx].x}px`;
            nodeEl.style.top = `${tanques[idx].y}px`;
        }

        function endDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { nodeEl, pointerId } = demoDrag;
            try {
                nodeEl.releasePointerCapture(pointerId);
            } catch (e) {
                // noop
            }
            nodeEl.classList.remove("dragging");
            nodeEl.removeEventListener("pointermove", moveDemoDrag);
            nodeEl.removeEventListener("pointerup", endDemoDrag);
            nodeEl.removeEventListener("pointercancel", endDemoDrag);
            demoDrag = null;
        }

        // ---------- Bitácora ----------
        let bitacoraEntries = [];
        let bitacoraCargando = false;
        let bitacoraCampanias = [];
        let bitacoraCampaniaActivaId = null;
        let bitacoraCampaniaSeleccionadaId = null;
        let bitacoraSoloLectura = false;

        function obtenerNombreBitacoraDeposito(id) {
            const dep = buscarDepositoPorId ? buscarDepositoPorId(Number(id)) : null;
            if (dep) return obtenerNombreDeposito(Number(id));
            const mast = (cacheMastelones || []).find(item => String(item.id) === String(id));
            if (mast) return obtenerNombreMastelone(Number(id));
            return `Depósito ${id}`;
        }

        function obtenerNombreBitacoraMadera(id) {
            return obtenerNombreBarrica ? obtenerNombreBarrica(Number(id)) : `Barrica ${id}`;
        }

        function setEstadoBitacora(texto) {
            const estado = document.getElementById("bitacoraEstado");
            if (estado) estado.textContent = texto || "";
        }

        function obtenerCampaniaPorId(id) {
            return (bitacoraCampanias || []).find(c => Number(c.id) === Number(id)) || null;
        }

        function actualizarResumenBitacora(contador) {
            const resumen = document.getElementById("bitacoraResumen");
            if (!resumen) return;
            const campania = obtenerCampaniaPorId(bitacoraCampaniaSeleccionadaId);
            const etiqueta = campania?.anio ? `Libro ${campania.anio}` : "Libro";
            const total = Number.isFinite(contador) ? contador : (bitacoraEntries || []).length;
            resumen.textContent = `Mostrando: ${etiqueta} · Entradas: ${total}`;
        }

        function actualizarEstadoLibroBitacora() {
            const badge = document.getElementById("bitacoraSoloLectura");
            const campania = obtenerCampaniaPorId(bitacoraCampaniaSeleccionadaId);
            const etiqueta = campania?.anio ? `Libro ${campania.anio}` : "Libro";
            bitacoraSoloLectura =
                bitacoraCampaniaActivaId != null &&
                bitacoraCampaniaSeleccionadaId != null &&
                Number(bitacoraCampaniaSeleccionadaId) !== Number(bitacoraCampaniaActivaId);
            if (badge) {
                if (bitacoraSoloLectura) {
                    badge.textContent = `Solo lectura (${etiqueta})`;
                    badge.style.display = "inline-flex";
                } else {
                    badge.style.display = "none";
                    badge.textContent = "";
                }
            }
            actualizarResumenBitacora();
        }

        function poblarSelectorBitacoraLibro() {
            const select = document.getElementById("bitacoraLibroSelect");
            if (!select) return;
            select.innerHTML = "";
            const opciones = [...(bitacoraCampanias || [])];
            opciones.sort((a, b) => (Number(b.anio) || 0) - (Number(a.anio) || 0));
            opciones.forEach(campania => {
                const option = document.createElement("option");
                option.value = campania.id;
                if (campania.anio) {
                    option.textContent = `Añada ${campania.anio}`;
                } else if (campania.nombre) {
                    option.textContent = String(campania.nombre).replace(/campaña/gi, "Añada");
                } else {
                    option.textContent = "Añada";
                }
                if (Number(campania.id) === Number(bitacoraCampaniaSeleccionadaId)) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        async function cargarCampaniasBitacora({ forzar = false } = {}) {
            if (bitacoraCampanias.length && !forzar) return;
            try {
                const res = await fetch("/api/campanias");
                if (!res.ok) throw new Error();
                const data = await res.json();
                bitacoraCampanias = Array.isArray(data.campanias) ? data.campanias : [];
                bitacoraCampaniaActivaId = data.activa_id ?? null;
                if (!bitacoraCampaniaSeleccionadaId) {
                    bitacoraCampaniaSeleccionadaId = bitacoraCampaniaActivaId;
                }
                poblarSelectorBitacoraLibro();
                actualizarEstadoLibroBitacora();
            } catch (err) {
                console.error("Error cargando añadas de bitácora:", err);
            }
        }

        function normalizarTipoContenedorBitacora(valor) {
            const limpio = (valor || "").toString().trim().toLowerCase();
            return ["deposito", "mastelone", "barrica"].includes(limpio) ? limpio : "";
        }

        function formatearTimestampBitacora(valor) {
            if (!valor) return "";
            const fecha = new Date(valor);
            if (Number.isNaN(fecha.getTime())) return "";
            const dia = fecha.toLocaleDateString("es-ES", {
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
            });
            const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
            return `${dia} ${hora}`;
        }

        function textoPlanoBitacora(valor) {
            if (valor === null || valor === undefined) return "";
            if (typeof valor === "number" && Number.isFinite(valor)) return String(valor);
            return String(valor).trim();
        }

        function textoConFallbackBitacora(valor, fallback) {
            const texto = textoPlanoBitacora(valor);
            return texto ? texto : fallback;
        }

        function textoSiNoBitacora(valor) {
            const limpio = textoPlanoBitacora(valor).toLowerCase();
            if (valor === true || valor === 1 || limpio === "si" || limpio === "sí") return "sí";
            if (valor === false || valor === 0 || limpio === "no") return "no";
            return "no registrado";
        }

        function normalizarTimestampClaveBitacora(valor) {
            if (!valor) return "";
            const fecha = new Date(valor);
            if (Number.isNaN(fecha.getTime())) return "";
            return fecha.toISOString().slice(0, 16);
        }

        function obtenerTipoMovimientoBitacora(entry) {
            return textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["tipo_movimiento", "movimiento_tipo", "tipo"])
            ).toLowerCase();
        }

        function obtenerCampoBitacora(evento, claves) {
            const fuentes = [evento?.payload, evento?.meta, evento];
            for (const fuente of fuentes) {
                if (!fuente) continue;
                for (const clave of claves) {
                    const valor = fuente[clave];
                    if (valor !== undefined && valor !== null && String(valor).trim() !== "") {
                        return valor;
                    }
                }
            }
            return null;
        }

        function resolverDosisBitacora(evento) {
            const dosis = obtenerCampoBitacora(evento, ["dosis"]);
            if (dosis && typeof dosis === "object" && !Array.isArray(dosis)) {
                return {
                    cantidad: dosis.cantidad ?? dosis.valor ?? dosis.cant ?? null,
                    unidad: (dosis.unidad ?? dosis.unid ?? "").toString().trim(),
                };
            }
            return {
                cantidad: obtenerCampoBitacora(evento, ["dosis_cantidad", "dosisCantidad", "dosis"]),
                unidad: (obtenerCampoBitacora(evento, ["dosis_unidad", "dosisUnidad", "unidad"]) || "").toString().trim(),
            };
        }

        function etiquetaContenedorPlano(tipo) {
            if (tipo === "barrica") return "Barrica";
            if (tipo === "mastelone") return "Mastelone";
            return "Depósito";
        }

        function formatearContenedorPlano(tipo, id) {
            if (!id) return "";
            return `${etiquetaContenedorPlano(tipo)} ${id}`.trim();
        }

        function extraerLineasTexto(texto) {
            return (texto || "")
                .toString()
                .split(/\r?\n/)
                .map(linea => linea.trim())
                .filter(Boolean);
        }

        function detectarTipoEventoBitacora(evento) {
            const tipoMeta = textoPlanoBitacora(
                obtenerCampoBitacora(evento, ["tipo_evento", "tipoEvento", "event_type", "eventType", "evento"])
            ).toLowerCase();
            if (tipoMeta) {
                if (tipoMeta === "conexion" || tipoMeta === "desconexion" || tipoMeta === "mapa_nodos") {
                    return "movimiento";
                }
                return tipoMeta;
            }

            const tipoBase = textoPlanoBitacora(evento?.tipo).toLowerCase();
            const accion = textoPlanoBitacora(obtenerCampoBitacora(evento, ["accion"])).toLowerCase();
            const texto = [
                evento?.resumen,
                evento?.detalle,
                evento?.texto,
                evento?.text
            ].filter(Boolean).join(" ").toLowerCase();

            if (texto.includes("entrada de uva")) return "entrada_uva";
            if (texto.includes("recuento")) return "recuento";
            if (texto.includes("despalillado")) return "despalillado";
            if (texto.includes("descube")) return "descube";
            if (texto.includes("prensado")) return "prensado";
            if (texto.includes("coupage")) return "coupage";
            if (texto.includes("clarificacion") || texto.includes("clarificación") ||
                texto.includes("filtracion") || texto.includes("filtración")) {
                return "clarificacion_filtracion";
            }
            if (texto.includes("embotellado")) return "embotellado";
            if (texto.includes("entrada en barrica") || texto.includes("entrada barrica")) return "entrada_barrica";
            if (texto.includes("relleno de barrica") || texto.includes("relleno barrica")) return "relleno_barrica";
            if (texto.includes("trasvase") || texto.includes("trasiego")) return "trasvase";
            if (texto.includes("fermentación") && texto.includes("inicio")) return "inicio_fermentacion";

            if (tipoBase === "entrada_uva") return "entrada_uva";
            if (tipoBase === "entrada") return "entrada_uva";
            if (tipoBase === "embotellado") return "embotellado";
            if (tipoBase === "movimiento") {
                const tipoMov = obtenerTipoMovimientoBitacora(evento);
                if (tipoMov === "trasiego" || tipoMov === "trasvase") return "trasvase";
                if (tipoMov === "prensado") return "prensado";
                if (tipoMov === "descube") return "descube";
                if (tipoMov === "embotellado") return "embotellado";
                if (tipoMov === "merma" || tipoMov === "ajuste" || tipoMov === "salida") return "recuento";
                return "movimiento";
            }
            if (accion === "mapa_nodos") return "movimiento";
            if (tipoBase === "fermentacion") {
                if (obtenerCampoBitacora(evento, ["bazuqueo"]) || obtenerCampoBitacora(evento, ["remontado"])) {
                    return "bazuqueo_remontado";
                }
                if (obtenerCampoBitacora(evento, ["densidad"]) || obtenerCampoBitacora(evento, ["temperatura", "temperatura_c"])) {
                    return "medicion";
                }
                if (obtenerCampoBitacora(evento, ["levadura"])) return "inicio_fermentacion";
                return "nota";
            }
            if (tipoBase === "crianza") {
                if (obtenerCampoBitacora(evento, ["trasiego"])) return "trasvase";
                if (obtenerCampoBitacora(evento, ["so2"])) return "adicion";
                return "nota";
            }

            if (accion === "bazuqueo" || accion === "remontado" || accion === "bazuqueo_remontado") {
                return "bazuqueo_remontado";
            }
            if (accion === "trasiego" || accion === "trasvase") return "trasvase";
            if (accion === "relleno" && normalizarTipoContenedorBitacora(evento?.contenedor_tipo) === "barrica") {
                return "relleno_barrica";
            }
            if (accion === "sulfitado" || accion === "correccion" || accion === "tratamiento" || accion === "so2") {
                return "adicion";
            }
            if (accion === "densidad" || accion === "temperatura" || accion === "densidad_temperatura" || tipoBase === "analitica") {
                return "medicion";
            }
            if (tipoBase === "nota") return "nota";
            return "nota";
        }

        function puntuarEventoBitacora(entry) {
            let score = Number(entry?.prioridad) || 0;
            const payload = entry?.payload && typeof entry.payload === "object" ? Object.keys(entry.payload).length : 0;
            const meta = entry?.meta && typeof entry.meta === "object" ? Object.keys(entry.meta).length : 0;
            if (payload) score += 6;
            if (meta) score += 4;
            if (entry?.detalle || entry?.resumen || entry?.texto || entry?.text) score += 2;
            return score;
        }

        function construirClaveBitacora(entry) {
            if (!entry) return "";
            const tipo = detectarTipoEventoBitacora(entry);
            const ts = normalizarTimestampClaveBitacora(entry.ts || entry.created_at || entry.fecha_hora || entry.fecha);
            const contTipo = normalizarTipoContenedorBitacora(entry.contenedor_tipo || entry.entidad_tipo);
            const contId = entry.contenedor_id || entry.entidad_id;
            const contenedor = contTipo && contId ? `${contTipo}:${contId}` : "";
            const origen = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["origen_tipo", "origen_id", "origen"])
            ).toLowerCase();
            const destino = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["destino_tipo", "destino_id", "destino"])
            ).toLowerCase();
            const cantidad = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["kilos", "litros", "botellas", "valor_nuevo"])
            );
            const texto = textoPlanoBitacora(
                entry.texto || entry.text || entry.resumen || entry.detalle
            ).toLowerCase().slice(0, 80);
            const partesBase = [tipo, ts, contenedor, origen, destino, cantidad];
            const base = partesBase.filter(Boolean).join("|");
            const baseTieneDatos = contenedor || origen || destino || cantidad;
            if (!base && texto) return `texto|${texto}`;
            if (!baseTieneDatos && texto) return `${base}|${texto}`;
            return base;
        }

        function deduplicarBitacora(entries) {
            const mapa = new Map();
            const sinClave = [];
            entries.forEach(entry => {
                const clave = construirClaveBitacora(entry);
                if (!clave) {
                    sinClave.push(entry);
                    return;
                }
                const score = puntuarEventoBitacora(entry);
                const existente = mapa.get(clave);
                if (!existente || score > existente.score) {
                    mapa.set(clave, { entry, score });
                }
            });
            return [...mapa.values().map(item => item.entry), ...sinClave];
        }

        function construirLineasBitacora(entry) {
            const lineas = [];
            if (!entry) return lineas;
            const tipoEvento = detectarTipoEventoBitacora(entry);
            const ts = formatearTimestampBitacora(entry.ts || entry.created_at || entry.fecha_hora || entry.fecha) || "—";
            const contenedorTipo = normalizarTipoContenedorBitacora(entry.contenedor_tipo || entry.entidad_tipo);
            const contenedorId = entry.contenedor_id || entry.entidad_id;
            const ubicacion = contenedorTipo && contenedorId
                ? formatearContenedorPlano(contenedorTipo, contenedorId)
                : "no registrado";
            const depositoId = contenedorTipo && contenedorTipo !== "barrica"
                ? contenedorId
                : obtenerCampoBitacora(entry, ["deposito_id", "depositoId"]);
            const barricaId = contenedorTipo === "barrica"
                ? contenedorId
                : obtenerCampoBitacora(entry, ["madera_id", "maderaId", "barrica_id", "barricaId"]);
            const tipoMovimiento = obtenerTipoMovimientoBitacora(entry);
            const perdidaLitros = obtenerCampoBitacora(entry, ["perdida_litros", "perdidaLitros"]);

            const resolverOrigen = () => {
                const tipo = normalizarTipoContenedorBitacora(obtenerCampoBitacora(entry, ["origen_tipo", "origenTipo"]));
                const id = obtenerCampoBitacora(entry, ["origen_id", "origenId"]);
                if (tipo && id) return formatearContenedorPlano(tipo, id);
                const texto = obtenerCampoBitacora(entry, ["origen"]);
                if (texto) return textoPlanoBitacora(texto);
                return ubicacion !== "no registrado" ? ubicacion : "no registrado";
            };

            const resolverDestino = () => {
                const tipo = normalizarTipoContenedorBitacora(obtenerCampoBitacora(entry, ["destino_tipo", "destinoTipo"]));
                const id = obtenerCampoBitacora(entry, ["destino_id", "destinoId"]);
                if (tipo && id) return formatearContenedorPlano(tipo, id);
                const texto = obtenerCampoBitacora(entry, ["destino"]);
                if (texto) return textoPlanoBitacora(texto);
                if (["merma", "ajuste", "salida"].includes(tipoMovimiento)) return "Salida de bodega";
                return "no registrado";
            };

            if (tipoEvento === "entrada_uva") {
                const mixto = obtenerCampoBitacora(entry, ["mixto"]);
                const totalVariedades = obtenerCampoBitacora(entry, ["lineas_count", "lineasCount", "variedades_count"]);
                let variedad = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["variedad", "variedades", "uva_variedad", "uva"]),
                    "no registrado"
                );
                if (mixto === 1 || mixto === true || String(mixto).toLowerCase() === "true") {
                    const totalTxt = Number(totalVariedades) > 0 ? ` (${totalVariedades} variedades)` : "";
                    variedad = `Mixto${totalTxt}`;
                }
                const kilos = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["kilos", "kg", "peso", "uva_kilos", "uva_kg"]),
                    "no registrado"
                );
                const cajas = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["cajas", "cajas_total", "cajas_uva"]),
                    "no registrado"
                );
                const estado = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["estado_uva", "estado", "uva_estado"]),
                    "no registrado"
                );
                const destino = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const so2 = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["so2_g", "so2", "metabisulfito", "so2_metabisulfito"]),
                    "no registrado"
                );
                const nota = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["nota", "observacion", "observaciones", "detalle", "resumen"]),
                    "no registrado"
                );
                lineas.push(
                    ts,
                    "Entrada de uva",
                    `Variedad: ${variedad} – ${kilos} kg`,
                    `Cajas: ${cajas}`,
                    `Estado: ${estado}`,
                    `Destino: ${destino}`,
                    `SO2: ${so2} g metabisulfito`,
                    `Observación: ${nota}`
                );
                return lineas;
            }

            if (tipoEvento === "recuento") {
                const elemento = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["elemento", "tipo"]), "no registrado");
                const anterior = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["valor_anterior", "anterior"]), "no registrado");
                const nuevoBase = obtenerCampoBitacora(entry, ["valor_nuevo", "nuevo"]);
                const litros = obtenerCampoBitacora(entry, ["litros"]);
                const nuevo = textoConFallbackBitacora(nuevoBase ?? litros, "no registrado");
                const motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota"]), "no registrado");
                lineas.push(
                    ts,
                    "Recuento",
                    `Elemento: ${elemento}`,
                    `Valor anterior: ${anterior}`,
                    `Valor nuevo: ${nuevo}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "despalillado") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const raspon = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["raspon", "raspón"]), "no registrado");
                const nota = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["nota", "detalle"]), "no registrado");
                lineas.push(
                    ts,
                    "Despalillado",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Raspón: ${raspon}`,
                    `Observación: ${nota}`
                );
                return lineas;
            }

            if (tipoEvento === "adicion") {
                const producto = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["producto", "productos", "producto_nombre"]),
                    "no registrado"
                );
                const dosis = resolverDosisBitacora(entry);
                const dosisTxt = textoConFallbackBitacora(dosis.cantidad, "no registrado");
                const unidadTxt = textoPlanoBitacora(dosis.unidad) || "no registrado";
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota", "observacion"]), "no registrado");
                lineas.push(
                    ts,
                    "Adición",
                    `Producto: ${producto}`,
                    `Dosis: ${dosisTxt} ${unidadTxt}`,
                    `Destino: ${destino}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "medicion") {
                const densidad = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["densidad"]), "no registrado");
                const temperatura = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["temperatura_c", "temperatura"]),
                    "no registrado"
                );
                const ph = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["ph", "pH"]), "no registrado");
                const so2Libre = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["so2_libre", "so2Libre"]), "no registrado");
                lineas.push(
                    ts,
                    "Medición",
                    `Ubicación: ${ubicacion}`,
                    `Densidad: ${densidad}`,
                    `Temperatura: ${temperatura} ºC`,
                    `pH: ${ph}`,
                    `SO2 Libre: ${so2Libre} mg/L`
                );
                return lineas;
            }

            if (tipoEvento === "inicio_fermentacion") {
                const levadura = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["levadura"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                lineas.push(
                    ts,
                    "Fermentación",
                    "Inicio fermentación alcohólica",
                    `Depósito: ${depositoTxt}`,
                    `Levadura: ${levadura}`
                );
                return lineas;
            }

            if (tipoEvento === "bazuqueo_remontado") {
                const bazuqueo = obtenerCampoBitacora(entry, ["bazuqueo"]);
                const remontado = obtenerCampoBitacora(entry, ["remontado"]);
                const operacion = bazuqueo && remontado
                    ? "bazuqueo + remontado"
                    : bazuqueo
                    ? "bazuqueo"
                    : remontado
                    ? "remontado"
                    : textoConFallbackBitacora(obtenerCampoBitacora(entry, ["operacion", "accion"]), "no registrado");
                const duracion = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["duracion", "minutos"]), "no registrado");
                const intensidad = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["intensidad"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                lineas.push(
                    ts,
                    "Acción",
                    `Operación: ${operacion}`,
                    `Depósito: ${depositoTxt}`,
                    `Duración: ${duracion}`,
                    `Intensidad: ${intensidad}`
                );
                return lineas;
            }

            if (tipoEvento === "movimiento") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]);
                const kilos = obtenerCampoBitacora(entry, ["kilos", "kg", "peso"]);
                const cantidadMeta = obtenerCampoBitacora(entry, ["cantidad"]);
                let cantidadTxt = "no registrado";
                if (litros !== null && litros !== undefined && String(litros).trim() !== "") {
                    cantidadTxt = `${textoPlanoBitacora(litros)} L`;
                } else if (kilos !== null && kilos !== undefined && String(kilos).trim() !== "") {
                    cantidadTxt = `${textoPlanoBitacora(kilos)} kg`;
                } else if (cantidadMeta !== null && cantidadMeta !== undefined && String(cantidadMeta).trim() !== "") {
                    cantidadTxt = textoPlanoBitacora(cantidadMeta);
                }
                const observacion = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["motivo", "nota", "observacion", "detalle"]),
                    "no registrado"
                );
                lineas.push(
                    ts,
                    "Movimiento",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Cantidad: ${cantidadTxt}`,
                    `Observación: ${observacion}`
                );
                return lineas;
            }

            if (tipoEvento === "trasvase") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const filtrado = textoSiNoBitacora(obtenerCampoBitacora(entry, ["filtrado", "filtro"]));
                let motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota"]), "no registrado");
                const perdidaNumero = Number(perdidaLitros);
                if (Number.isFinite(perdidaNumero) && perdidaNumero > 0) {
                    const perdidaTxt = `${perdidaNumero} L pérdida`;
                    motivo = motivo === "no registrado" ? perdidaTxt : `${motivo} · ${perdidaTxt}`;
                }
                lineas.push(
                    ts,
                    "Trasvase",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Volumen: ${litros} L`,
                    `Filtrado: ${filtrado}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "prensado") {
                const origenIdRaw = obtenerCampoBitacora(entry, ["origen_id", "origenId"]);
                const origenId = textoConFallbackBitacora(
                    origenIdRaw ?? (tipoMovimiento === "prensado" ? null : depositoId),
                    "no registrado"
                );
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const volumenEntrada = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["volumen_entrada", "entrada", "volumenEntrada"]),
                    ""
                );
                const mermaAbs = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["merma_abs", "mermaAbs", "merma_litros"]),
                    ""
                );
                const mermaPct = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["merma_pct", "mermaPct", "merma_pct"]),
                    ""
                );
                const fraccion = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["fraccion", "fracción"]), "no registrado");
                lineas.push(
                    ts,
                    "Prensado",
                    `Origen: Depósito ${origenId}`,
                    `Destino: ${destino}`,
                    `Entrada: ${volumenEntrada ? `${volumenEntrada} L` : "no registrado"}`,
                    `Salida: ${litros} L`,
                    `Merma: ${mermaAbs ? `${mermaAbs} L` : "no registrado"}${mermaPct ? ` (${mermaPct}%)` : ""}`,
                    `Fracción: ${fraccion}`,
                    "Nota: (auto) Ejecutado desde mapa de nodos"
                );
                return lineas;
            }

            if (tipoEvento === "descube") {
                const origenId = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["origen_id", "origenId"]) || depositoId, "no registrado");
                const destinoId = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["destino_id", "destinoId"]), "no registrado");
                const litrosVino = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_vino", "volumen_vino"]), "no registrado");
                const litrosPastas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_pastas", "volumen_pastas"]), "no registrado");
                lineas.push(
                    ts,
                    "Descube",
                    `Origen: Depósito ${origenId}`,
                    `Destino: Depósito ${destinoId}`,
                    `Volumen vino: ${litrosVino} L`,
                    `Volumen lías/pastas: ${litrosPastas} L`
                );
                return lineas;
            }

            if (tipoEvento === "entrada_barrica") {
                const barricaTxt = barricaId ? `${barricaId}` : "no registrado";
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                lineas.push(
                    ts,
                    "Madera",
                    "Entrada en barrica",
                    `Barrica: ${barricaTxt}`,
                    `Origen: ${origen}`,
                    `Volumen: ${litros} L`
                );
                return lineas;
            }

            if (tipoEvento === "relleno_barrica") {
                const barricaTxt = barricaId ? `${barricaId}` : "no registrado";
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const gas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["gas", "gas_inerte", "gasInerte"]), "no registrado");
                lineas.push(
                    ts,
                    "Madera",
                    "Relleno de barrica",
                    `Barrica: ${barricaTxt}`,
                    `Volumen añadido: ${litros} L`,
                    `Gas inerte: ${gas}`
                );
                return lineas;
            }

            if (tipoEvento === "coupage") {
                let origen1 = obtenerCampoBitacora(entry, ["origen1", "origen_1"]);
                let litros1 = obtenerCampoBitacora(entry, ["litros1", "litros_1"]);
                let origen2 = obtenerCampoBitacora(entry, ["origen2", "origen_2"]);
                let litros2 = obtenerCampoBitacora(entry, ["litros2", "litros_2"]);
                const componentes = obtenerCampoBitacora(entry, ["componentes"]);
                if (Array.isArray(componentes) && componentes.length) {
                    const primero = componentes[0] || {};
                    const segundo = componentes[1] || {};
                    origen1 = origen1 || primero.origen || primero.nombre;
                    litros1 = litros1 || primero.litros;
                    origen2 = origen2 || segundo.origen || segundo.nombre;
                    litros2 = litros2 || segundo.litros;
                }
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const total = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_total", "total_litros", "litros"]), "no registrado");
                lineas.push(
                    ts,
                    "Coupage",
                    `Destino: ${destino}`,
                    "Componentes:",
                    `- ${textoConFallbackBitacora(origen1, "no registrado")}: ${textoConFallbackBitacora(litros1, "no registrado")} L`,
                    `- ${textoConFallbackBitacora(origen2, "no registrado")}: ${textoConFallbackBitacora(litros2, "no registrado")} L`,
                    `Resultado: ${total} L`
                );
                return lineas;
            }

            if (tipoEvento === "clarificacion_filtracion") {
                const producto = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["producto", "productos"]), "no registrado");
                const dosis = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["dosis", "dosis_cantidad", "dosisCantidad"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const reposo = textoSiNoBitacora(obtenerCampoBitacora(entry, ["reposo_frio", "reposoFrio"]));
                lineas.push(
                    ts,
                    "Clarificación / Filtración",
                    `Producto: ${producto}`,
                    `Dosis: ${dosis}`,
                    `Depósito: ${depositoTxt}`,
                    `Reposo en frío: ${reposo}`
                );
                return lineas;
            }

            if (tipoEvento === "embotellado") {
                const linea = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["linea_id", "lineaId"]), "no registrado");
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const botellas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["botellas"]), "no registrado");
                const formato = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["formato"]), "no registrado");
                const cierre = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["cierre"]), "no registrado");
                const so2 = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["so2", "so2_pre"]), "no registrado");
                const lote = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["lote"]), "no registrado");
                lineas.push(
                    ts,
                    "Embotellado",
                    `Línea de vino: ${linea}`,
                    `Origen: ${origen}`,
                    `Botellas: ${botellas}`,
                    `Formato: ${formato}`,
                    `Cierre: ${cierre}`,
                    `SO2 pre-embotellado: ${so2}`,
                    `Lote: ${lote}`
                );
                return lineas;
            }

            const textoNota = textoConFallbackBitacora(
                obtenerCampoBitacora(entry, ["texto", "text", "nota", "detalle", "resumen"]),
                "no registrado"
            );
            lineas.push(ts, "Nota");
            extraerLineasTexto(textoNota).forEach(linea => lineas.push(linea));
            return lineas;
        }

        function claseCabeceraBitacora(tipoEvento) {
            const mapa = {
                entrada_uva: "entrada",
                recuento: "recuento",
                despalillado: "accion",
                adicion: "adicion",
                medicion: "medicion",
                inicio_fermentacion: "fermentacion",
                bazuqueo_remontado: "accion",
                trasvase: "trasvase",
                prensado: "prensado",
                descube: "descube",
                entrada_barrica: "madera",
                relleno_barrica: "madera",
                coupage: "coupage",
                clarificacion_filtracion: "clarificacion",
                embotellado: "embotellado",
                movimiento: "movimiento",
                nota: "nota",
            };
            return mapa[tipoEvento] || "accion";
        }

        function obtenerDeleteInfoBitacora(entry) {
            if (!entry) return null;
            const id = entry.id;
            if (id === undefined || id === null || id === "") return null;
            const idTxt = encodeURIComponent(String(id));
            switch (entry.fuente) {
                case "contenedor":
                    return { url: `/api/eventos/${idTxt}?scope=contenedor` };
                case "bodega":
                    return { url: `/api/eventos/${idTxt}?scope=bodega` };
                case "movimiento":
                    return { url: `/api/movimientos/${idTxt}` };
                case "entrada_uva":
                    return { url: `/api/entradas_uva/${idTxt}` };
                case "embotellado":
                    return { url: `/api/embotellados/${idTxt}` };
                case "nota":
                case "mapa_nodos":
                    return { url: `/api/bitacora/${idTxt}` };
                default:
                    return null;
            }
        }

        async function eliminarEntradaBitacora(entry) {
            const info = obtenerDeleteInfoBitacora(entry);
            if (!info) return;
            const confirmado = window.confirm("Eliminar esta entrada de la bitacora?");
            if (!confirmado) return;
            setEstadoBitacora("Eliminando...");
            try {
                const res = await fetch(info.url, { method: "DELETE" });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) {
                    throw new Error(data?.error || "No se pudo eliminar la entrada.");
                }
                bitacoraEntries = bitacoraEntries.filter(item => {
                    return !(item.fuente === entry.fuente && String(item.id) === String(entry.id));
                });
                setEstadoBitacora("");
                aplicarFiltroBitacora();
            } catch (err) {
                console.error("Error eliminando bitacora:", err);
                setEstadoBitacora(err?.message || "No se pudo eliminar la entrada.");
            }
        }

        function crearLineaBitacora(
            texto,
            { esTs = false, esCabecera = false, tipoCabecera = "", onDelete = null } = {}
        ) {
            const line = document.createElement("div");
            line.className = "bitacora-line";
            if (!texto) {
                line.classList.add("bitacora-line--blank");
                return line;
            }
            if (esTs) {
                line.classList.add("bitacora-line--ts");
                line.textContent = texto;
                return line;
            }
            if (esCabecera) {
                line.classList.add("bitacora-line--header");
                const tag = document.createElement("span");
                tag.className = `bitacora-tag bitacora-tag--${tipoCabecera || "accion"}`;
                tag.textContent = texto;
                line.appendChild(tag);
                if (typeof onDelete === "function") {
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "bitacora-delete";
                    btn.textContent = "Eliminar";
                    btn.addEventListener("click", onDelete);
                    line.appendChild(btn);
                }
                return line;
            }
            line.textContent = texto;
            return line;
        }

        function renderBitacoraEntries(entries) {
            const salida = document.getElementById("bitacoraTexto");
            if (!salida) return;
            salida.innerHTML = "";
            if (!entries.length) {
                salida.textContent = "Sin registros.";
                return;
            }
            const fragment = document.createDocumentFragment();
            entries.forEach((entry, idx) => {
                const lineasEntrada = construirLineasBitacora(entry);
                if (!lineasEntrada.length) return;
                const tipoCabecera = claseCabeceraBitacora(detectarTipoEventoBitacora(entry));
                const deleteInfo = bitacoraSoloLectura ? null : obtenerDeleteInfoBitacora(entry);
                lineasEntrada.forEach((linea, lineaIdx) => {
                    if (lineaIdx === 0) {
                        fragment.appendChild(crearLineaBitacora(linea, { esTs: true }));
                        return;
                    }
                    if (lineaIdx === 1) {
                        fragment.appendChild(crearLineaBitacora(linea, {
                            esCabecera: true,
                            tipoCabecera,
                            onDelete: deleteInfo ? () => eliminarEntradaBitacora(entry) : null,
                        }));
                        return;
                    }
                    fragment.appendChild(crearLineaBitacora(linea));
                });
                if (idx < entries.length - 1) {
                    fragment.appendChild(crearLineaBitacora(""));
                }
            });
            salida.appendChild(fragment);
        }

        function aplicarFiltroBitacora() {
            const input = document.getElementById("bitacoraBuscar");
            const termino = (input?.value || "").trim().toLowerCase();
            if (!termino) {
                renderBitacoraEntries(bitacoraEntries);
                actualizarResumenBitacora(bitacoraEntries.length);
                return;
            }
            const filtradas = bitacoraEntries.filter(entry => {
                const texto = construirLineasBitacora(entry).join(" ").toLowerCase();
                return texto.includes(termino);
            });
            renderBitacoraEntries(filtradas);
            actualizarResumenBitacora(filtradas.length);
        }

        async function cargarBitacora() {
            if (bitacoraCargando) return;
            bitacoraCargando = true;
            setEstadoBitacora("Cargando bitácora...");
            try {
                await cargarCampaniasBitacora();
                const campaniaId = bitacoraCampaniaSeleccionadaId || bitacoraCampaniaActivaId;
                const params = new URLSearchParams({ limit: "300" });
                if (campaniaId) params.set("campania_libro_id", String(campaniaId));
                const [resNotas, resMovs, resEmbotellados] = await Promise.all([
                    fetch(`/api/bitacora?${params.toString()}`),
                    fetch(campaniaId ? `/api/movimientos?campania_libro_id=${campaniaId}` : "/api/movimientos"),
                    fetch(campaniaId ? `/api/embotellados?campania_libro_id=${campaniaId}` : "/api/embotellados"),
                ]);

                const dataNotas = resNotas.ok ? await resNotas.json().catch(() => ({})) : {};
                const dataMovs = resMovs.ok ? await resMovs.json().catch(() => ([])) : [];
                const dataEmbotellados = resEmbotellados.ok ? await resEmbotellados.json().catch(() => ([])) : [];

                if (dataNotas?.campania_activa_id != null) {
                    bitacoraCampaniaActivaId = dataNotas.campania_activa_id;
                }
                if (!bitacoraCampaniaSeleccionadaId && dataNotas?.campania_libro_id != null) {
                    bitacoraCampaniaSeleccionadaId = dataNotas.campania_libro_id;
                }
                poblarSelectorBitacoraLibro();
                actualizarEstadoLibroBitacora();

                const entradas = Array.isArray(dataNotas.entries) ? dataNotas.entries : [];
                const entradasManual = entradas.filter(entry => entry?.origin === "bitacora");
                const entradasMapa = entradas.filter(entry => entry?.origin === "mapa_nodos");
                const movimientos = Array.isArray(dataMovs) ? dataMovs : [];
                const embotellados = Array.isArray(dataEmbotellados) ? dataEmbotellados : [];

                const normalizados = [
                    ...movimientos.slice(0, 500).map(mov => ({
                        fuente: "movimiento",
                        id: mov.id,
                        prioridad: 85,
                        ts: mov.fecha,
                        tipo: "movimiento",
                        resumen: mov.tipo ? `Movimiento ${mov.tipo}` : "Movimiento",
                        payload: (() => {
                            const tipoMov = (mov.tipo || "").toString().trim().toLowerCase();
                            const payload = {
                                tipo: mov.tipo,
                                litros: mov.litros,
                                perdida_litros: mov.perdida_litros,
                                nota: mov.nota,
                                origen_tipo: mov.origen_tipo,
                                origen_id: mov.origen_id,
                                destino_tipo: mov.destino_tipo,
                                destino_id: mov.destino_id,
                            };
                            if (["merma", "ajuste", "salida"].includes(tipoMov)) {
                                payload.elemento = "litros";
                                payload.valor_nuevo = mov.litros;
                                payload.motivo = tipoMov;
                            }
                            return payload;
                        })(),
                        contenedor_tipo: mov.origen_tipo || mov.destino_tipo,
                        contenedor_id: mov.origen_id || mov.destino_id,
                        campania_libro_id: mov.campania_libro_id ?? null,
                    })),
                    ...embotellados.slice(0, 400).map(emb => ({
                        fuente: "embotellado",
                        id: emb.id,
                        prioridad: 88,
                        ts: emb.fecha,
                        tipo: "embotellado",
                        resumen: "Embotellado",
                        payload: {
                            litros: emb.litros,
                            botellas: emb.botellas,
                            lote: emb.lote,
                            formatos: emb.formatos,
                            nota: emb.nota,
                            origen_tipo: emb.contenedor_tipo,
                            origen_id: emb.contenedor_id,
                        },
                        contenedor_tipo: emb.contenedor_tipo,
                        contenedor_id: emb.contenedor_id,
                        campania_libro_id: emb.campania_libro_id ?? null,
                    })),
                    ...entradasManual.map(entry => ({
                        fuente: "nota",
                        id: entry.id,
                        prioridad: 60,
                        ts: entry.created_at,
                        tipo: "nota",
                        texto: entry.text,
                        deposito_id: entry.deposito_id,
                        madera_id: entry.madera_id,
                        linea_id: entry.linea_id,
                        variedades: entry.variedades,
                        origin: entry.origin,
                        note_type: entry.note_type,
                        campania_libro_id: entry.campania_libro_id ?? null,
                    })),
                    ...entradasMapa.map(entry => ({
                        fuente: "mapa_nodos",
                        id: entry.id,
                        prioridad: 50,
                        ts: entry.created_at,
                        tipo: "nota",
                        texto: entry.text,
                        deposito_id: entry.deposito_id,
                        madera_id: entry.madera_id,
                        linea_id: entry.linea_id,
                        variedades: entry.variedades,
                        origin: entry.origin,
                        note_type: entry.note_type,
                        campania_libro_id: entry.campania_libro_id ?? null,
                    })),
                ];

                const campaniaFiltro = bitacoraCampaniaSeleccionadaId;
                const filtrados = campaniaFiltro
                    ? normalizados.filter(item =>
                        item.campania_libro_id &&
                        Number(item.campania_libro_id) === Number(campaniaFiltro))
                    : normalizados;

                bitacoraEntries = deduplicarBitacora(filtrados)
                    .filter(item => item.ts)
                    .sort((a, b) => {
                        const aTs = new Date(a.ts).getTime() || 0;
                        const bTs = new Date(b.ts).getTime() || 0;
                        return bTs - aTs;
                    });
            } catch (err) {
                console.error("Error cargando bitácora:", err);
                setEstadoBitacora("No se pudo cargar la bitácora.");
                bitacoraCargando = false;
                return;
            }
            setEstadoBitacora("");
            bitacoraCargando = false;
            aplicarFiltroBitacora();
        }

        async function exportarBitacoraAnadaPdf() {
            const entradas = Array.isArray(bitacoraEntries) ? bitacoraEntries : [];
            if (!entradas.length) {
                setEstadoBitacora("No hay registros para exportar en esta añada.");
                return;
            }

            const jsPDF = await asegurarJsPDF();
            if (!jsPDF) {
                setEstadoBitacora("No se pudo cargar el motor PDF.");
                return;
            }

            const campania =
                obtenerCampaniaPorId(bitacoraCampaniaSeleccionadaId) ||
                obtenerCampaniaPorId(bitacoraCampaniaActivaId) ||
                null;
            const anadaTxt = campania?.anio ? String(campania.anio) : "sin-anada";
            const tituloAnada = campania?.anio ? `Añada ${campania.anio}` : "Añada no definida";

            const doc = new jsPDF({ unit: "mm", format: "a4" });
            doc.setFontSize(16);
            doc.text("Bitácora de bodega", 14, 16);
            doc.setFontSize(11);
            doc.text(tituloAnada, 14, 23);
            doc.setFontSize(9);
            doc.text(`Generado: ${new Date().toLocaleString("es-ES")}`, 14, 28);
            doc.text(`Registros: ${entradas.length}`, 14, 33);

            const filas = entradas.map(entry => {
                const lineas = construirLineasBitacora(entry);
                const fecha = lineas[0] || "—";
                const tipo = lineas[1] || "Evento";
                const detalle = lineas.slice(2).join("\n") || "—";
                return [fecha, tipo, detalle];
            });

            const autoTableFn = (window.jspdf && window.jspdf.autoTable) || doc.autoTable;
            if (typeof autoTableFn === "function") {
                autoTableFn.call(doc, {
                    startY: 38,
                    head: [["Fecha", "Tipo", "Detalle"]],
                    body: filas,
                    styles: { fontSize: 8.6, cellPadding: 2.2, valign: "top" },
                    headStyles: { fillColor: [90, 24, 55], textColor: 255 },
                    columnStyles: {
                        0: { cellWidth: 36 },
                        1: { cellWidth: 34 },
                        2: { cellWidth: "auto" },
                    },
                });
            } else {
                let y = 40;
                doc.setFontSize(10);
                filas.forEach(row => {
                    const bloque = `${row[0]} | ${row[1]} | ${row[2]}`;
                    const wrapped = doc.splitTextToSize(bloque, 182);
                    if (y + wrapped.length * 5 > 285) {
                        doc.addPage();
                        y = 16;
                    }
                    doc.text(wrapped, 14, y);
                    y += wrapped.length * 5 + 2;
                });
            }

            const nombreArchivo = `bitacora-anada-${anadaTxt}.pdf`
                .replace(/[^\w.-]+/g, "-")
                .replace(/-+/g, "-");
            doc.save(nombreArchivo);
            setEstadoBitacora("PDF descargado correctamente.");
        }

        function initBitacoraIndomitaUI() {
            const input = document.getElementById("bitacoraBuscar");
            if (input) input.addEventListener("input", aplicarFiltroBitacora);
            const select = document.getElementById("bitacoraLibroSelect");
            if (select) {
                select.addEventListener("change", () => {
                    const nuevoId = Number(select.value);
                    bitacoraCampaniaSeleccionadaId = Number.isFinite(nuevoId) ? nuevoId : null;
                    actualizarEstadoLibroBitacora();
                    cargarBitacora();
                });
            }
            const btnActiva = document.getElementById("bitacoraLibroActiva");
            if (btnActiva) {
                btnActiva.addEventListener("click", () => {
                    if (!bitacoraCampaniaActivaId) return;
                    bitacoraCampaniaSeleccionadaId = bitacoraCampaniaActivaId;
                    poblarSelectorBitacoraLibro();
                    actualizarEstadoLibroBitacora();
                    cargarBitacora();
                });
            }
            const btnAnterior = document.getElementById("bitacoraLibroAnterior");
            if (btnAnterior) {
                btnAnterior.addEventListener("click", () => {
                    if (!bitacoraCampanias.length || !bitacoraCampaniaActivaId) return;
                    const ordenadas = [...bitacoraCampanias].sort(
                        (a, b) => (Number(b.anio) || 0) - (Number(a.anio) || 0)
                    );
                    const idx = ordenadas.findIndex(
                        campania => Number(campania.id) === Number(bitacoraCampaniaActivaId)
                    );
                    const anterior = idx >= 0 ? ordenadas[idx + 1] : null;
                    if (!anterior) return;
                    bitacoraCampaniaSeleccionadaId = anterior.id;
                    poblarSelectorBitacoraLibro();
                    actualizarEstadoLibroBitacora();
                    cargarBitacora();
                });
            }
            const btnDescargarPdf = document.getElementById("bitacoraLibroDescargarPdf");
            if (btnDescargarPdf) {
                btnDescargarPdf.addEventListener("click", () => exportarBitacoraAnadaPdf());
            }
            const link = document.querySelector('[data-section="bitacora"]');
            if (link) link.addEventListener("click", () => cargarBitacora());
            cargarCampaniasBitacora();
        }

        function abrirCuadernoContenedor(_tipo, _id) {
            mostrarSeccion("bitacora");
            cargarBitacora();
        }

        function abrirCuadernoDesdeNodo(nodo) {
            if (!nodo) return;
            const contenedor = resolverContenedorDesdeNodoControl(nodo);
            if (!contenedor) {
                mostrarAviso("Asigna un contenedor para abrir el cuaderno.", "error");
                return;
            }
            mostrarSeccion("bitacora");
            cargarBitacora();
        }

        // ---------- EXPRESS MANGUERA ----------
        const EXPRESS_MX = {
            tab: "uva",
            action: {
                uva: "entrada",
                control: "medicion",
                movimiento: "trasiego",
                botellas: "embotellar",
            },
            lastPayload: null,
            dangerArmKey: "",
            lotesCache: [],
        };

        function expressMxInjectStyles() {
            if (document.getElementById("express-mx-styles")) return;
            const style = document.createElement("style");
            style.id = "express-mx-styles";
            style.textContent = `
                #express-fab {
                    position: fixed;
                    right: 16px;
                    bottom: 16px;
                    z-index: 999995;
                    background: linear-gradient(135deg, #9e1f53, #5c1231);
                    color: #fff;
                    border: 1px solid rgba(255,255,255,0.25);
                    border-radius: 999px;
                    padding: 14px 18px;
                    font-weight: 800;
                    cursor: pointer;
                    box-shadow: 0 12px 30px rgba(46,9,25,.38);
                }
                #express-fab-overlay {
                    position: fixed;
                    inset: 0;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    padding: 16px;
                    background: rgba(12, 14, 18, 0.18);
                    z-index: 999996;
                }
                #express-fab-modal {
                    width: min(96vw, 820px);
                    max-height: 88vh;
                    overflow: hidden;
                    border-radius: 20px;
                    background: #fff;
                    border: 1px solid #d9d4da;
                    color: #2b1320;
                    box-shadow: 0 20px 44px rgba(22, 16, 24, 0.22);
                    display: flex;
                    flex-direction: column;
                }
                .express-mx-head {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                    padding: 14px 16px 10px;
                    border-bottom: 1px solid #e8ccd7;
                }
                .express-mx-title {
                    margin: 0;
                    color: #4a0c26;
                    font-size: 20px;
                }
                .express-mx-close {
                    border: 1px solid #d8b7c4;
                    background: #fff0f6;
                    color: #4a0c26;
                    border-radius: 10px;
                    padding: 8px 12px;
                    font-weight: 700;
                    cursor: pointer;
                }
                .express-mx-tabs {
                    display: grid;
                    grid-template-columns: repeat(4, minmax(0,1fr));
                    gap: 8px;
                    padding: 10px 16px;
                }
                .express-mx-tab {
                    border: 1px solid #d8b7c4;
                    background: #fff2f8;
                    color: #4a0c26;
                    border-radius: 12px;
                    padding: 10px 12px;
                    font-weight: 700;
                    cursor: pointer;
                }
                .express-mx-tab.is-active {
                    background: linear-gradient(135deg,#8f1c4a,#5b112f);
                    color: #fff;
                }
                .express-mx-body {
                    overflow: auto;
                    padding: 12px 16px 0;
                    display: grid;
                    gap: 12px;
                }
                .express-mx-pane {
                    display: none;
                    gap: 10px;
                }
                .express-mx-pane.is-active {
                    display: grid;
                }
                .express-mx-actions {
                    display: flex;
                    gap: 8px;
                    flex-wrap: wrap;
                }
                .express-mx-action {
                    border: 1px solid #c986a3;
                    background: #fff0f6;
                    color: #4a0c26;
                    border-radius: 999px;
                    padding: 8px 12px;
                    font-weight: 700;
                    cursor: pointer;
                }
                .express-mx-action.is-active {
                    background: linear-gradient(135deg,#8f1c4a,#5b112f);
                    color: #fff;
                }
                .express-mx-grid-2 {
                    display: grid;
                    grid-template-columns: repeat(2, minmax(0, 1fr));
                    gap: 10px;
                }
                .express-mx-grid-3 {
                    display: grid;
                    grid-template-columns: repeat(3, minmax(0, 1fr));
                    gap: 10px;
                }
                .express-mx-field label {
                    display: block;
                    font-weight: 700;
                    color: #4a0c26;
                    margin-bottom: 6px;
                    letter-spacing: .02em;
                }
                .express-mx-field input,
                .express-mx-field select,
                .express-mx-field textarea {
                    width: 100%;
                    padding: 10px;
                    border: 1px solid #ba89a2;
                    background: #fff;
                    border-radius: 10px;
                    color: #1f1220;
                    font-size: 14px;
                }
                .express-mx-field select {
                    font-weight: 700;
                }
                .express-mx-field select option {
                    background: #fff;
                    color: #1f1220;
                }
                .express-mx-field input:focus,
                .express-mx-field select:focus,
                .express-mx-field textarea:focus {
                    outline: none;
                    border-color: #8f1c4a;
                    box-shadow: 0 0 0 2px rgba(143, 28, 74, 0.15);
                }
                .express-mx-field textarea {
                    min-height: 70px;
                    resize: vertical;
                }
                .express-mx-chip-row {
                    display: flex;
                    gap: 6px;
                    flex-wrap: wrap;
                }
                .express-mx-chip {
                    border: 1px solid #c986a3;
                    background: #fff0f6;
                    color: #4a0c26;
                    border-radius: 999px;
                    padding: 4px 10px;
                    font-size: 12px;
                    font-weight: 700;
                    cursor: pointer;
                }
                .express-mx-details {
                    border: 1px dashed #d8b7c4;
                    border-radius: 12px;
                    padding: 8px 10px;
                    background: #fff7fb;
                }
                .express-mx-details summary {
                    font-weight: 700;
                    color: #4a0c26;
                    cursor: pointer;
                }
                .express-mx-impact {
                    margin: 6px 16px 0;
                    border: 1px dashed #d8b7c4;
                    background: #fff1f6;
                    color: #6f123a;
                    border-radius: 10px;
                    padding: 8px 10px;
                    font-weight: 700;
                    font-size: 13px;
                }
                .express-mx-foot {
                    position: sticky;
                    bottom: 0;
                    z-index: 2;
                    border-top: 1px solid #e8ccd7;
                    background: linear-gradient(180deg, rgba(255,255,255,.4), #fff7fb);
                    padding: 10px 16px 12px;
                    display: flex;
                    gap: 8px;
                    justify-content: flex-end;
                }
                .express-mx-save {
                    border: 1px solid rgba(255,255,255,.2);
                    background: linear-gradient(135deg,#9e1f53,#5c1231);
                    color: #fff;
                    border-radius: 12px;
                    padding: 11px 14px;
                    font-weight: 800;
                    cursor: pointer;
                    box-shadow: 0 10px 24px rgba(74,12,38,.25);
                }
                .express-mx-status {
                    margin: 0 16px;
                    font-weight: 700;
                    min-height: 20px;
                }
                .express-mx-recent {
                    margin: 0 16px 14px;
                    border-top: 1px solid #ead6de;
                    padding-top: 10px;
                    display: grid;
                    gap: 8px;
                }
                .express-mx-recent-item {
                    border: 1px solid #d8b7c4;
                    border-radius: 12px;
                    background: #fff7fb;
                    padding: 8px 10px;
                }
                .express-mx-recent-top {
                    display: flex;
                    justify-content: space-between;
                    gap: 8px;
                    font-size: 12px;
                    opacity: .8;
                }
                .express-mx-recent-summary {
                    font-weight: 700;
                }
                .express-mx-recent-actions {
                    margin-top: 6px;
                    display: flex;
                    gap: 6px;
                }
                .express-mx-mini-btn {
                    border: 1px solid #c986a3;
                    background: #fff0f6;
                    color: #4a0c26;
                    border-radius: 999px;
                    padding: 4px 9px;
                    font-size: 12px;
                    font-weight: 700;
                    cursor: pointer;
                }
                .express-mx-mini-btn.is-danger {
                    border-color: #d87091;
                    color: #8a123f;
                    background: #ffe9f1;
                }
                .express-mx-hidden {
                    display: none !important;
                }
                @media (max-width: 780px) {
                    .express-mx-tabs { grid-template-columns: repeat(2, minmax(0,1fr)); }
                    .express-mx-grid-2, .express-mx-grid-3 { grid-template-columns: minmax(0,1fr); }
                }
            `;
            document.head.appendChild(style);
        }

        function expressMxGetContenedores() {
            if (typeof obtenerContenedoresCopiloto === "function") {
                const lista = obtenerContenedoresCopiloto();
                if (Array.isArray(lista)) {
                    return lista.map(item => {
                        const tipo = (item?.tipo || "").toString().trim().toLowerCase();
                        const id = Number(item?.id);
                        const volumen = Number(item?.volumen || 0);
                        const codigo = (item?.codigo || "").toString().trim();
                        const alias = (item?.alias || "").toString().trim();
                        if (!["deposito", "barrica", "mastelone"].includes(tipo)) return null;
                        if (!Number.isFinite(id) || id <= 0) return null;
                        const etiqueta = formatContainerLabel(
                          { id, codigo, alias, tipo },
                          { tipo, withType: false }
                        );
                        return {
                            key: `${tipo}:${id}`,
                            tipo,
                            id,
                            codigo: codigo || `#${id}`,
                            alias,
                            nombre: etiqueta,
                            volumen: Number.isFinite(volumen) ? volumen : 0,
                        };
                    }).filter(Boolean);
                }
            }
            return [];
        }

        function expressMxGetAnada() {
            const anadas = (Array.isArray(cacheEntradas) ? cacheEntradas : [])
                .map(e => (e?.anada || "").toString().trim())
                .filter(Boolean);
            if (anadas.length) return anadas[0];
            return obtenerAnadaVitivinicolaDesdeFecha(new Date().toISOString());
        }

        function expressMxSetStatus(msg, tone = "info") {
            const el = document.getElementById("expressMxStatus");
            if (!el) return;
            el.textContent = msg || "";
            if (tone === "error") el.style.color = "#b00020";
            else if (tone === "success") el.style.color = "#0a7a00";
            else if (tone === "warn") el.style.color = "#b26a00";
            else el.style.color = "#6f123a";
        }

        function expressMxToNum(v) {
            if (v == null) return NaN;
            const t = String(v).trim().replace(",", ".");
            if (!t) return NaN;
            const n = Number(t);
            return Number.isFinite(n) ? n : NaN;
        }

        function expressMxFmtDate(iso) {
            if (!iso) return "—";
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return String(iso);
            return d.toLocaleString("es-ES");
        }

        function expressMxPopulateContainerSelect(selectId, { onlyWithWine = false } = {}) {
            const sel = document.getElementById(selectId);
            if (!sel) return [];
            const lista = expressMxGetContenedores().filter(c => !onlyWithWine || c.volumen > 0);
            const prev = sel.value;
            sel.innerHTML = `<option value="">Selecciona contenedor</option>`;
            lista.forEach(c => {
                const opt = document.createElement("option");
                opt.value = c.key;
                const litros = Number(c.volumen || 0);
                opt.textContent = `${c.nombre}${litros > 0 ? ` · ${litros.toFixed(1)} L` : ""}`;
                sel.appendChild(opt);
            });
            if (prev && Array.from(sel.options).some(o => o.value === prev)) {
                sel.value = prev;
            }
            return lista;
        }

        async function expressMxFetchJson(url, options = {}) {
            const res = await fetch(url, {
                credentials: "same-origin",
                headers: { "Content-Type": "application/json", ...(options.headers || {}) },
                ...options,
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                const err = data?.error || `Error ${res.status}`;
                throw new Error(err);
            }
            return data;
        }

        function expressMxGetSelectedAction(tab) {
            return EXPRESS_MX.action[tab] || "";
        }

        function expressMxSetTab(tab) {
            EXPRESS_MX.tab = tab;
            document.querySelectorAll(".express-mx-tab").forEach(btn => {
                btn.classList.toggle("is-active", btn.dataset.tab === tab);
            });
            document.querySelectorAll(".express-mx-pane").forEach(p => {
                p.classList.toggle("is-active", p.dataset.tabPane === tab);
            });
            expressMxSetAction(tab, expressMxGetSelectedAction(tab));
            expressMxUpdateImpact();
        }

        function expressMxSetAction(tab, action) {
            EXPRESS_MX.action[tab] = action;
            document.querySelectorAll(`.express-mx-action[data-tab="${tab}"]`).forEach(btn => {
                btn.classList.toggle("is-active", btn.dataset.action === action);
            });
            document.querySelectorAll(`[data-action-form="${tab}"]`).forEach(block => {
                block.classList.toggle("express-mx-hidden", block.dataset.action !== action);
            });
            if (tab === "movimiento") {
                const isTrasiego = action === "trasiego";
                const isDanger = action === "merma" || action === "ajuste";
                const destinoWrap = document.getElementById("expressMovDestinoWrap");
                if (destinoWrap) destinoWrap.classList.toggle("express-mx-hidden", !isTrasiego);
                const reasonWrap = document.getElementById("expressMovReasonWrap");
                if (reasonWrap) reasonWrap.classList.toggle("express-mx-hidden", !isDanger);
            }
            if (tab === "botellas") {
                const isStore = action === "almacen";
                const loteWrap = document.getElementById("expressBotLoteSelectWrap");
                if (loteWrap) loteWrap.classList.toggle("express-mx-hidden", !isStore);
            }
            EXPRESS_MX.dangerArmKey = "";
            expressMxUpdateImpact();
        }

        async function expressMxLoadLotes() {
            try {
                const lotes = await expressMxFetchJson("/api/bottle-lots");
                EXPRESS_MX.lotesCache = Array.isArray(lotes) ? lotes : [];
                const sel = document.getElementById("expressBotLoteSelect");
                if (sel) {
                    const prev = sel.value;
                    sel.innerHTML = `<option value="">Selecciona lote</option>`;
                    EXPRESS_MX.lotesCache.forEach(lote => {
                        const opt = document.createElement("option");
                        opt.value = lote.id;
                        opt.textContent = `${lote.id} · stock ${Number(lote.stock_botellas || 0)} bot`;
                        sel.appendChild(opt);
                    });
                    if (prev && Array.from(sel.options).some(o => o.value === prev)) sel.value = prev;
                }
            } catch (_err) {
                // noop
            }
        }

        async function expressMxLoadRecent() {
            const list = document.getElementById("expressMxRecentList");
            if (!list) return;
            list.innerHTML = "<div style='opacity:.7'>Cargando…</div>";
            try {
                const data = await expressMxFetchJson("/api/express/recent?limit=20");
                const items = Array.isArray(data?.items) ? data.items : [];
                if (!items.length) {
                    list.innerHTML = "<div style='opacity:.7'>Sin eventos recientes.</div>";
                    return;
                }
                list.innerHTML = "";
                items.forEach(item => {
                    const card = document.createElement("div");
                    card.className = "express-mx-recent-item";
                    card.innerHTML = `
                        <div class="express-mx-recent-top">
                            <span>${item.kind || "Evento"}</span>
                            <span>${expressMxFmtDate(item.created_at)}</span>
                        </div>
                        <div class="express-mx-recent-summary">${item.summary || item.action || "Evento"}</div>
                        <div style="font-size:12px;opacity:.82;">${item.note || ""}</div>
                    `;
                    const row = document.createElement("div");
                    row.className = "express-mx-recent-actions";
                    if (item.payload_for_repeat) {
                        const rep = document.createElement("button");
                        rep.type = "button";
                        rep.className = "express-mx-mini-btn";
                        rep.textContent = "Repetir";
                        rep.addEventListener("click", () => expressMxApplyRepeat(item.payload_for_repeat));
                        row.appendChild(rep);
                    }
                    if (item.payload_for_inverse) {
                        const inv = document.createElement("button");
                        inv.type = "button";
                        inv.className = "express-mx-mini-btn is-danger";
                        inv.textContent = "Invertir";
                        inv.addEventListener("click", async () => {
                            try {
                                await expressMxFetchJson("/api/express/invert", {
                                    method: "POST",
                                    body: JSON.stringify(item.payload_for_inverse),
                                });
                                expressMxSetStatus("Evento invertido correctamente.", "success");
                                await expressMxLoadLotes();
                                await expressMxLoadRecent();
                            } catch (err) {
                                expressMxSetStatus(err.message || "No se pudo invertir.", "error");
                            }
                        });
                        row.appendChild(inv);
                    }
                    card.appendChild(row);
                    list.appendChild(card);
                });
            } catch (err) {
                list.innerHTML = `<div style="color:#b00020;">${err.message || "No se pudieron cargar recientes."}</div>`;
            }
        }

        function expressMxApplyRepeat(payload) {
            if (!payload || typeof payload !== "object") return;
            const tab = payload.tab || EXPRESS_MX.tab;
            expressMxSetTab(tab);
            if (payload.action) expressMxSetAction(tab, payload.action);
            Object.entries(payload).forEach(([key, val]) => {
                if (key === "tab" || key === "action") return;
                const el = document.querySelector(`[data-repeat-key="${key}"]`);
                if (!el) return;
                el.value = val == null ? "" : String(val);
            });
            expressMxUpdateImpact();
            expressMxSetStatus("Formulario rellenado desde evento reciente.", "info");
        }

        function expressMxGetContByKey(key) {
            return expressMxGetContenedores().find(c => c.key === key) || null;
        }

        function expressMxUpdateImpact() {
            const target = document.getElementById("expressMxImpact");
            if (!target) return;
            const tab = EXPRESS_MX.tab;
            const action = expressMxGetSelectedAction(tab);
            let txt = "Se registrará: —";
            if (tab === "uva") {
                const variedad = (document.getElementById("expressUvaVariedad")?.value || "—").trim();
                const kilos = expressMxToNum(document.getElementById("expressUvaKilos")?.value);
                txt = `Se registrará: ENTRADA UVA · ${variedad} · ${Number.isFinite(kilos) ? `${kilos} kg` : "kg —"}`;
            } else if (tab === "control") {
                const cont = document.getElementById("expressCtrlContenedor")?.value || "—";
                txt = `Se registrará: CONTROL ${action.toUpperCase()} · ${cont}`;
            } else if (tab === "movimiento") {
                const litros = expressMxToNum(document.getElementById("expressMovLitros")?.value);
                const origen = document.getElementById("expressMovOrigen")?.value || "—";
                const destino = document.getElementById("expressMovDestino")?.value || "—";
                txt = `Se registrará: ${action.toUpperCase()} ${Number.isFinite(litros) ? litros : "—"} L · ${origen}${action === "trasiego" ? ` -> ${destino}` : ""}`;
            } else if (tab === "botellas") {
                if (action === "embotellar") {
                    const lote = (document.getElementById("expressBotLote")?.value || "—").trim();
                    const bot = expressMxToNum(document.getElementById("expressBotBotellas")?.value);
                    txt = `Se registrará: IN ${Number.isFinite(bot) ? Math.round(bot) : "—"} BOT · Lote ${lote}`;
                } else {
                    const lote = document.getElementById("expressBotLoteSelect")?.value || "—";
                    const tipo = document.getElementById("expressBotMovTipo")?.value || "OUT";
                    const bot = expressMxToNum(document.getElementById("expressBotMovQty")?.value);
                    txt = `Se registrará: ${tipo} ${Number.isFinite(bot) ? Math.round(bot) : "—"} BOT · Lote ${lote}`;
                }
            }
            target.textContent = txt;
        }

        async function expressMxGuardarUva() {
            const proveedor = (document.getElementById("expressUvaProveedor")?.value || "").trim();
            const variedad = (document.getElementById("expressUvaVariedad")?.value || "").trim();
            const mixto = document.getElementById("expressUvaMixto")?.checked === true;
            const kilos = expressMxToNum(document.getElementById("expressUvaKilos")?.value);
            const cajas = Math.round(expressMxToNum(document.getElementById("expressUvaCajas")?.value));
            const fecha = formatearFechaParaInput(new Date());
            const nota = (document.getElementById("expressUvaNota")?.value || "").trim();
            const parcela = (document.getElementById("expressUvaParcela")?.value || "").trim() || "EXPRESS";
            const tipoCaja = (document.getElementById("expressUvaTipoCaja")?.value || "").trim();
            const obsLarga = (document.getElementById("expressUvaObsLarga")?.value || "").trim();
            if (!variedad) throw new Error("Variedad obligatoria.");
            if (!Number.isFinite(kilos) || kilos <= 0) throw new Error("Kilos inválidos.");
            if (!Number.isFinite(cajas) || cajas <= 0) throw new Error("Cajas inválidas.");
            const payload = {
                fecha,
                parcela,
                viticultor: proveedor || null,
                variedad,
                kilos_total: Number(kilos.toFixed(2)),
                cajas_total: cajas,
                tipo_caja: tipoCaja || null,
                observaciones: [nota, obsLarga].filter(Boolean).join(" · ") || null,
                mixto,
                modo_kilos: "total",
            };
            if (mixto) {
                payload.lineas = [{
                    variedad,
                    cajas,
                    kilos: Number(kilos.toFixed(2)),
                    tipo_caja: tipoCaja || null,
                }];
            }
            await expressMxFetchJson("/api/entradas-uva/express", {
                method: "POST",
                body: JSON.stringify(payload),
            });
            if (proveedor) localStorage.setItem("mx:last:proveedor", proveedor);
        }

        function expressMxControlPayloadFromAction(action, cont) {
            const nota = (document.getElementById("expressCtrlNota")?.value || "").trim();
            if (action === "medicion") {
                const densidad = expressMxToNum(document.getElementById("expressCtrlDensidad")?.value);
                const temp = expressMxToNum(document.getElementById("expressCtrlTemp")?.value);
                if (!Number.isFinite(densidad) && !Number.isFinite(temp) && !nota) {
                    throw new Error("Añade densidad, temperatura o nota.");
                }
                return {
                    endpoint: "/api/registro-express",
                    body: {
                        tipo: "medicion",
                        contenedor_tipo: cont.tipo,
                        contenedor_id: cont.id,
                        densidad: Number.isFinite(densidad) ? Number(densidad.toFixed(3)) : null,
                        temperatura_c: Number.isFinite(temp) ? Number(temp.toFixed(1)) : null,
                        nota: nota || null,
                    },
                };
            }
            if (action === "so2") {
                const objetivo = expressMxToNum(document.getElementById("expressCtrlSo2Obj")?.value);
                const actual = expressMxToNum(document.getElementById("expressCtrlSo2Act")?.value);
                if (!Number.isFinite(objetivo) || objetivo <= 0) throw new Error("Objetivo SO₂ inválido.");
                let notaCalc = nota;
                if (Number.isFinite(actual) && objetivo > actual && Number.isFinite(cont.volumen) && cont.volumen > 0) {
                    const delta = objetivo - actual;
                    const gramos = (cont.volumen * delta) / 1000 / 0.57;
                    notaCalc = [notaCalc, `Meta SO2: +${delta.toFixed(1)} mg/L → ${gramos.toFixed(1)} g meta`].filter(Boolean).join(" · ");
                }
                return {
                    endpoint: "/api/eventos",
                    body: {
                        tipo: "crianza",
                        payload: {
                            contenedor_tipo: cont.tipo,
                            contenedor_id: cont.id,
                            so2: Number(objetivo.toFixed(1)),
                            nota: notaCalc || null,
                        },
                    },
                };
            }
            if (action === "llenado") {
                const nivel = expressMxToNum(document.getElementById("expressCtrlLlenado")?.value);
                if (!Number.isFinite(nivel) || nivel < 0 || nivel > 100) throw new Error("Nivel inválido (0-100).");
                return {
                    endpoint: "/api/eventos",
                    body: {
                        tipo: "crianza",
                        payload: {
                            contenedor_tipo: cont.tipo,
                            contenedor_id: cont.id,
                            nivel_llenado: Number(nivel.toFixed(1)),
                            nota: nota || null,
                        },
                    },
                };
            }
            if (action === "bazuqueo" || action === "remontado") {
                return {
                    endpoint: "/api/eventos",
                    body: {
                        tipo: "fermentacion",
                        payload: {
                            contenedor_tipo: cont.tipo,
                            contenedor_id: cont.id,
                            bazuqueo: action === "bazuqueo",
                            remontado: action === "remontado",
                            nota: nota || null,
                        },
                    },
                };
            }
            if (!nota) throw new Error("Escribe una nota.");
            return {
                endpoint: "/api/eventos",
                body: {
                    tipo: "crianza",
                    payload: {
                        contenedor_tipo: cont.tipo,
                        contenedor_id: cont.id,
                        nota,
                    },
                },
            };
        }

        async function expressMxGuardarControl() {
            const contKey = document.getElementById("expressCtrlContenedor")?.value || "";
            const cont = expressMxGetContByKey(contKey);
            if (!cont) throw new Error("Selecciona depósito/barrica.");
            const action = expressMxGetSelectedAction("control");
            const req = expressMxControlPayloadFromAction(action, cont);
            await expressMxFetchJson(req.endpoint, {
                method: "POST",
                body: JSON.stringify(req.body),
            });
            localStorage.setItem("mx:last:control", cont.key);
        }

        async function expressMxGuardarMovimiento() {
            const action = expressMxGetSelectedAction("movimiento");
            const origenKey = document.getElementById("expressMovOrigen")?.value || "";
            const destinoKey = document.getElementById("expressMovDestino")?.value || "";
            const litros = expressMxToNum(document.getElementById("expressMovLitros")?.value);
            const nota = (document.getElementById("expressMovNota")?.value || "").trim();
            const reason = (document.getElementById("expressMovReason")?.value || "").trim();
            const origen = expressMxGetContByKey(origenKey);
            const destino = expressMxGetContByKey(destinoKey);
            if (!origen) throw new Error("Selecciona origen.");
            if (!Number.isFinite(litros) || litros <= 0) throw new Error("Litros inválidos.");
            if (action === "trasiego" && !destino) throw new Error("Selecciona destino.");
            const esRoja = action === "merma" || action === "ajuste" || litros > (Number(origen.volumen) || 0);
            if (esRoja && !reason) throw new Error("Motivo obligatorio para esta acción.");
            const dangerKey = `${action}|${origen.key}|${destino ? destino.key : "-"}|${litros}|${reason}`;
            if (esRoja && EXPRESS_MX.dangerArmKey !== dangerKey) {
                EXPRESS_MX.dangerArmKey = dangerKey;
                throw new Error("Confirma de nuevo para registrar la acción crítica.");
            }
            const notaFinal = [nota, reason ? `Motivo: ${reason}` : ""].filter(Boolean).join(" · ");
            const payload = {
                tipo: "movimiento",
                contenedor_tipo: origen.tipo,
                contenedor_id: origen.id,
                movimiento_tipo: action,
                litros: Number(litros.toFixed(2)),
                origen_tipo: origen.tipo,
                origen_id: origen.id,
                destino_tipo: action === "trasiego" ? destino?.tipo : null,
                destino_id: action === "trasiego" ? destino?.id : null,
                nota: notaFinal || null,
            };
            await expressMxFetchJson("/api/registro-express", {
                method: "POST",
                body: JSON.stringify(payload),
            });
            localStorage.setItem("mx:last:mov:origen", origen.key);
            if (destino) localStorage.setItem("mx:last:mov:destino", destino.key);
            EXPRESS_MX.dangerArmKey = "";
        }

        async function expressMxGuardarBotellas() {
            const action = expressMxGetSelectedAction("botellas");
            if (action === "embotellar") {
                const loteInput = (document.getElementById("expressBotLote")?.value || "").trim();
                const vino = (document.getElementById("expressBotVino")?.value || "").trim();
                const contKey = document.getElementById("expressBotOrigen")?.value || "";
                const cont = expressMxGetContByKey(contKey);
                const cajas = expressMxToNum(document.getElementById("expressBotCajas")?.value);
                const bpc = expressMxToNum(document.getElementById("expressBotBpc")?.value);
                const sueltas = expressMxToNum(document.getElementById("expressBotSueltas")?.value) || 0;
                const formato = expressMxToNum(document.getElementById("expressBotFormato")?.value);
                const estado = (document.getElementById("expressBotEstado")?.value || "CUARENTENA").trim().toUpperCase();
                const nota = (document.getElementById("expressBotNota")?.value || "").trim();
                const docNumero = (document.getElementById("expressBotDocNumero")?.value || "").trim();
                const docTercero = (document.getElementById("expressBotDocTercero")?.value || "").trim();
                if (!cont) throw new Error("Selecciona contenedor origen.");
                if (!Number.isFinite(formato) || formato <= 0) throw new Error("Formato inválido.");
                const botellasCalc = Math.round((Number.isFinite(cajas) && Number.isFinite(bpc) ? cajas * bpc : 0) + (Number.isFinite(sueltas) ? sueltas : 0));
                if (!Number.isFinite(botellasCalc) || botellasCalc <= 0) throw new Error("Botellas inválidas.");
                const loteId = loteInput || `L-${new Date().toISOString().slice(0,10).replace(/-/g,"")}-${Math.random().toString(16).slice(2,6).toUpperCase()}`;
                let docId = null;
                if (docNumero || docTercero) {
                    const doc = await expressMxFetchJson("/api/docs", {
                        method: "POST",
                        body: JSON.stringify({
                            tipo: "EMBOTELLADO",
                            numero: docNumero || null,
                            tercero: docTercero || null,
                            note: `Express embotellado ${loteId}`,
                        }),
                    });
                    docId = doc?.doc?.id || null;
                }
                try {
                    await expressMxFetchJson("/api/bottle-lots", {
                        method: "POST",
                        body: JSON.stringify({
                            id: loteId,
                            partida: vino || loteId,
                            vino: vino || loteId,
                            nombre_comercial: vino || loteId,
                            anada: expressMxGetAnada(),
                            formato_ml: Math.round(formato),
                            status: estado || "CUARENTENA",
                            origin_container_id: cont.key,
                            origin_volume_l: Number(cont.volumen || 0),
                        }),
                    });
                } catch (err) {
                    if (!String(err.message || "").includes("LOTE_ID_DUPLICADO")) throw err;
                }
                await expressMxFetchJson("/api/warehouse/move", {
                    method: "POST",
                    body: JSON.stringify({
                        lot_ref: loteId,
                        event_type: "IN",
                        qty_value: botellasCalc,
                        src_ref: cont.key,
                        note: nota || `Embotellado express ${vino || loteId}`,
                        doc_id: docId,
                    }),
                });
                localStorage.setItem("mx:last:lote", loteId);
                localStorage.setItem("mx:last:bot:origen", cont.key);
            } else {
                const lotRef = (document.getElementById("expressBotLoteSelect")?.value || "").trim();
                const tipo = (document.getElementById("expressBotMovTipo")?.value || "OUT").trim().toUpperCase();
                const qty = Math.round(expressMxToNum(document.getElementById("expressBotMovQty")?.value));
                const cliente = (document.getElementById("expressBotCliente")?.value || "").trim();
                const docNumero = (document.getElementById("expressBotMovDoc")?.value || "").trim();
                const reason = (document.getElementById("expressBotReason")?.value || "").trim();
                const nota = (document.getElementById("expressBotMovNota")?.value || "").trim();
                if (!lotRef) throw new Error("Selecciona lote.");
                if (!Number.isFinite(qty) || qty <= 0) throw new Error("Cantidad inválida.");
                const lote = (EXPRESS_MX.lotesCache || []).find(x => x.id === lotRef);
                const stock = Number(lote?.stock_botellas || 0);
                const esRoja = tipo === "ADJUST" || qty > stock;
                if (esRoja && !reason) throw new Error("Motivo obligatorio para esta acción.");
                const dangerKey = `${tipo}|${lotRef}|${qty}|${reason}`;
                if (esRoja && EXPRESS_MX.dangerArmKey !== dangerKey) {
                    EXPRESS_MX.dangerArmKey = dangerKey;
                    throw new Error("Confirma de nuevo para registrar la acción crítica.");
                }
                let docId = null;
                if (docNumero) {
                    const doc = await expressMxFetchJson("/api/docs", {
                        method: "POST",
                        body: JSON.stringify({
                            tipo: "ALBARAN_SALIDA",
                            numero: docNumero,
                            tercero: cliente || null,
                            note: `Express almacén ${lotRef}`,
                        }),
                    });
                    docId = doc?.doc?.id || null;
                }
                await expressMxFetchJson("/api/warehouse/move", {
                    method: "POST",
                    body: JSON.stringify({
                        lot_ref: lotRef,
                        event_type: tipo,
                        qty_value: qty,
                        cliente_nombre: cliente || null,
                        doc_id: docId,
                        note: nota || null,
                        reason: reason || null,
                    }),
                });
                localStorage.setItem("mx:last:lote", lotRef);
                EXPRESS_MX.dangerArmKey = "";
            }
        }

        async function expressMxHandleSave() {
            try {
                expressMxSetStatus("Guardando...", "info");
                if (EXPRESS_MX.tab === "uva") {
                    await expressMxGuardarUva();
                } else if (EXPRESS_MX.tab === "control") {
                    await expressMxGuardarControl();
                } else if (EXPRESS_MX.tab === "movimiento") {
                    await expressMxGuardarMovimiento();
                } else if (EXPRESS_MX.tab === "botellas") {
                    await expressMxGuardarBotellas();
                }
                expressMxSetStatus("Guardado correctamente.", "success");
                await Promise.all([expressMxLoadLotes(), expressMxLoadRecent()]);
            } catch (err) {
                expressMxSetStatus(err.message || "No se pudo guardar.", "error");
            } finally {
                expressMxUpdateImpact();
            }
        }

        function expressMxBindEvents() {
            document.querySelectorAll(".express-mx-tab").forEach(btn => {
                btn.addEventListener("click", () => expressMxSetTab(btn.dataset.tab));
            });
            document.querySelectorAll(".express-mx-action").forEach(btn => {
                btn.addEventListener("click", () => expressMxSetAction(btn.dataset.tab, btn.dataset.action));
            });
            document.getElementById("expressMxClose")?.addEventListener("click", () => {
                document.getElementById("express-fab-overlay").style.display = "none";
            });
            document.getElementById("express-fab-overlay")?.addEventListener("click", e => {
                if (e.target && e.target.id === "express-fab-overlay") {
                    e.currentTarget.style.display = "none";
                }
            });
            document.getElementById("expressMxSave")?.addEventListener("click", expressMxHandleSave);
            document.querySelectorAll("#express-fab-modal input, #express-fab-modal select, #express-fab-modal textarea")
                .forEach(el => el.addEventListener("input", expressMxUpdateImpact));

            document.querySelectorAll("[data-chip-target]").forEach(btn => {
                btn.addEventListener("click", () => {
                    const target = document.getElementById(btn.dataset.chipTarget);
                    if (!target) return;
                    target.value = btn.dataset.value || "";
                    target.dispatchEvent(new Event("input", { bubbles: true }));
                });
            });

            document.getElementById("express-fab")?.addEventListener("click", async () => {
                document.getElementById("express-fab-overlay").style.display = "flex";
                expressMxPopulateContainerSelect("expressCtrlContenedor", { onlyWithWine: true });
                expressMxPopulateContainerSelect("expressMovOrigen", { onlyWithWine: true });
                expressMxPopulateContainerSelect("expressMovDestino", { onlyWithWine: false });
                expressMxPopulateContainerSelect("expressBotOrigen", { onlyWithWine: true });
                const lastControl = localStorage.getItem("mx:last:control");
                if (lastControl) {
                    const sel = document.getElementById("expressCtrlContenedor");
                    if (sel && Array.from(sel.options).some(o => o.value === lastControl)) sel.value = lastControl;
                }
                const lastMovO = localStorage.getItem("mx:last:mov:origen");
                if (lastMovO) {
                    const sel = document.getElementById("expressMovOrigen");
                    if (sel && Array.from(sel.options).some(o => o.value === lastMovO)) sel.value = lastMovO;
                }
                const lastMovD = localStorage.getItem("mx:last:mov:destino");
                if (lastMovD) {
                    const sel = document.getElementById("expressMovDestino");
                    if (sel && Array.from(sel.options).some(o => o.value === lastMovD)) sel.value = lastMovD;
                }
                const lastBotO = localStorage.getItem("mx:last:bot:origen");
                if (lastBotO) {
                    const sel = document.getElementById("expressBotOrigen");
                    if (sel && Array.from(sel.options).some(o => o.value === lastBotO)) sel.value = lastBotO;
                }
                const lastProv = localStorage.getItem("mx:last:proveedor");
                if (lastProv && !document.getElementById("expressUvaProveedor").value) {
                    document.getElementById("expressUvaProveedor").value = lastProv;
                }
                await Promise.all([expressMxLoadLotes(), expressMxLoadRecent()]);
                const lastLote = localStorage.getItem("mx:last:lote");
                const selLote = document.getElementById("expressBotLoteSelect");
                if (lastLote && selLote && Array.from(selLote.options).some(o => o.value === lastLote)) {
                    selLote.value = lastLote;
                }
                expressMxSetTab(EXPRESS_MX.tab);
                expressMxUpdateImpact();
            });
        }

        function initExpressMangueraUI() {
            expressMxInjectStyles();
            const prevFab = document.getElementById("express-fab");
            if (prevFab) prevFab.remove();
            const prevOverlay = document.getElementById("express-fab-overlay");
            if (prevOverlay) prevOverlay.remove();

            const fab = document.createElement("button");
            fab.id = "express-fab";
            fab.type = "button";
            fab.textContent = "⚡ Express";

            const overlay = document.createElement("div");
            overlay.id = "express-fab-overlay";
            overlay.innerHTML = `
                <div id="express-fab-modal" role="dialog" aria-modal="true" aria-labelledby="expressMxTitle">
                    <div class="express-mx-head">
                        <h2 class="express-mx-title" id="expressMxTitle">Express Manguera</h2>
                        <button type="button" class="express-mx-close" id="expressMxClose">Cerrar</button>
                    </div>
                    <div class="express-mx-tabs">
                        <button type="button" class="express-mx-tab" data-tab="uva">UVA</button>
                        <button type="button" class="express-mx-tab" data-tab="control">CONTROL</button>
                        <button type="button" class="express-mx-tab" data-tab="movimiento">MOVIMIENTO</button>
                        <button type="button" class="express-mx-tab" data-tab="botellas">BOTELLAS</button>
                    </div>
                    <div class="express-mx-body">
                        <section class="express-mx-pane" data-tab-pane="uva">
                            <div class="express-mx-actions">
                                <button type="button" class="express-mx-action" data-tab="uva" data-action="entrada">Entrada rápida</button>
                            </div>
                            <div data-action-form="uva" data-action="entrada">
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>Proveedor / Viticultor</label><input id="expressUvaProveedor" data-repeat-key="proveedor"></div>
                                    <div class="express-mx-field"><label>Variedad</label><input id="expressUvaVariedad" data-repeat-key="variedad"></div>
                                    <div class="express-mx-field"><label>Kilos totales</label><input id="expressUvaKilos" inputmode="decimal"></div>
                                    <div class="express-mx-field"><label>Cajas totales</label><input id="expressUvaCajas" inputmode="numeric"></div>
                                </div>
                                <div class="express-mx-field"><label>Nota corta</label><input id="expressUvaNota"></div>
                                <div style="margin-top:8px;"><label><input type="checkbox" id="expressUvaMixto"> Mixto</label></div>
                                <details class="express-mx-details" style="margin-top:8px;">
                                    <summary>+ Detalles</summary>
                                    <div class="express-mx-grid-3" style="margin-top:8px;">
                                        <div class="express-mx-field"><label>Parcela</label><input id="expressUvaParcela"></div>
                                        <div class="express-mx-field"><label>Tipo caja</label><input id="expressUvaTipoCaja"></div>
                                        <div class="express-mx-field"><label>Observación larga</label><input id="expressUvaObsLarga"></div>
                                    </div>
                                </details>
                            </div>
                        </section>

                        <section class="express-mx-pane" data-tab-pane="control">
                            <div class="express-mx-actions">
                                <button type="button" class="express-mx-action" data-tab="control" data-action="medicion">Medición</button>
                                <button type="button" class="express-mx-action" data-tab="control" data-action="so2">SO₂</button>
                                <button type="button" class="express-mx-action" data-tab="control" data-action="llenado">Llenado %</button>
                                <button type="button" class="express-mx-action" data-tab="control" data-action="bazuqueo">Bazuqueo</button>
                                <button type="button" class="express-mx-action" data-tab="control" data-action="remontado">Remontado</button>
                                <button type="button" class="express-mx-action" data-tab="control" data-action="nota">Nota</button>
                            </div>
                            <div class="express-mx-field"><label>Depósito/Barrica</label><select id="expressCtrlContenedor" data-repeat-key="contenedor"></select></div>
                            <div data-action-form="control" data-action="medicion">
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>Densidad</label><input id="expressCtrlDensidad"></div>
                                    <div class="express-mx-field"><label>Temperatura °C</label><input id="expressCtrlTemp"></div>
                                </div>
                                <div class="express-mx-chip-row">
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlDensidad" data-value="1090">1090</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlDensidad" data-value="1060">1060</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlDensidad" data-value="1030">1030</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlTemp" data-value="16">16°C</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlTemp" data-value="20">20°C</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlTemp" data-value="24">24°C</button>
                                </div>
                            </div>
                            <div data-action-form="control" data-action="so2" class="express-mx-hidden">
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>SO₂ objetivo (mg/L)</label><input id="expressCtrlSo2Obj"></div>
                                    <div class="express-mx-field"><label>SO₂ actual (mg/L)</label><input id="expressCtrlSo2Act"></div>
                                </div>
                            </div>
                            <div data-action-form="control" data-action="llenado" class="express-mx-hidden">
                                <div class="express-mx-field"><label>Nivel llenado %</label><input id="expressCtrlLlenado"></div>
                                <div class="express-mx-chip-row">
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlLlenado" data-value="90">90%</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlLlenado" data-value="95">95%</button>
                                    <button type="button" class="express-mx-chip" data-chip-target="expressCtrlLlenado" data-value="100">100%</button>
                                </div>
                            </div>
                            <div data-action-form="control" data-action="bazuqueo" class="express-mx-hidden"></div>
                            <div data-action-form="control" data-action="remontado" class="express-mx-hidden"></div>
                            <div data-action-form="control" data-action="nota" class="express-mx-hidden"></div>
                            <div class="express-mx-field"><label>Nota</label><input id="expressCtrlNota"></div>
                        </section>

                        <section class="express-mx-pane" data-tab-pane="movimiento">
                            <div class="express-mx-actions">
                                <button type="button" class="express-mx-action" data-tab="movimiento" data-action="trasiego">Trasiego A→B</button>
                                <button type="button" class="express-mx-action" data-tab="movimiento" data-action="merma">Merma litros</button>
                                <button type="button" class="express-mx-action" data-tab="movimiento" data-action="ajuste">Ajuste litros</button>
                            </div>
                            <div class="express-mx-grid-2">
                                <div class="express-mx-field"><label>Origen</label><select id="expressMovOrigen" data-repeat-key="origen"></select></div>
                                <div class="express-mx-field" id="expressMovDestinoWrap"><label>Destino</label><select id="expressMovDestino" data-repeat-key="destino"></select></div>
                            </div>
                            <div class="express-mx-field"><label>Litros</label><input id="expressMovLitros" data-repeat-key="litros"></div>
                            <div class="express-mx-chip-row">
                                <button type="button" class="express-mx-chip" data-chip-target="expressMovLitros" data-value="50">50</button>
                                <button type="button" class="express-mx-chip" data-chip-target="expressMovLitros" data-value="100">100</button>
                                <button type="button" class="express-mx-chip" data-chip-target="expressMovLitros" data-value="150">150</button>
                                <button type="button" class="express-mx-chip" data-chip-target="expressMovLitros" data-value="225">225</button>
                                <button type="button" class="express-mx-chip" data-chip-target="expressMovLitros" data-value="300">300</button>
                            </div>
                            <div class="express-mx-field"><label>Nota</label><input id="expressMovNota" data-repeat-key="note"></div>
                            <div class="express-mx-field express-mx-hidden" id="expressMovReasonWrap"><label>Motivo (obligatorio)</label><input id="expressMovReason"></div>
                        </section>

                        <section class="express-mx-pane" data-tab-pane="botellas">
                            <div class="express-mx-actions">
                                <button type="button" class="express-mx-action" data-tab="botellas" data-action="embotellar">Embotellar (crear lote + IN)</button>
                                <button type="button" class="express-mx-action" data-tab="botellas" data-action="almacen">Salida / Merma / Ajuste</button>
                            </div>
                            <div data-action-form="botellas" data-action="embotellar">
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>Lote</label><input id="expressBotLote"></div>
                                    <div class="express-mx-field"><label>Nombre vino</label><input id="expressBotVino"></div>
                                    <div class="express-mx-field"><label>Origen contenedor</label><select id="expressBotOrigen"></select></div>
                                    <div class="express-mx-field"><label>Formato (ml)</label><input id="expressBotFormato" value="750"></div>
                                </div>
                                <div class="express-mx-grid-3">
                                    <div class="express-mx-field"><label>Cajas</label><input id="expressBotCajas"></div>
                                    <div class="express-mx-field"><label>Botellas/caja</label><select id="expressBotBpc"><option value="3">3</option><option value="6" selected>6</option><option value="12">12</option></select></div>
                                    <div class="express-mx-field"><label>Sueltas</label><input id="expressBotSueltas"></div>
                                </div>
                                <div class="express-mx-field"><label>Estado lote</label><select id="expressBotEstado"><option value="CUARENTENA" selected>CUARENTENA</option><option value="LIBERADO">LIBERADO</option><option value="BLOQUEADO">BLOQUEADO</option></select></div>
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>Nº documento (opcional)</label><input id="expressBotDocNumero"></div>
                                    <div class="express-mx-field"><label>Tercero doc (opcional)</label><input id="expressBotDocTercero"></div>
                                </div>
                                <div class="express-mx-field"><label>Nota</label><input id="expressBotNota"></div>
                                <div class="express-mx-field"><label>Botellas calculadas</label><input id="expressBotBotellas" readonly></div>
                            </div>
                            <div data-action-form="botellas" data-action="almacen" class="express-mx-hidden">
                                <div class="express-mx-field express-mx-hidden" id="expressBotLoteSelectWrap"><label>Lote</label><select id="expressBotLoteSelect" data-repeat-key="lot_ref"></select></div>
                                <div class="express-mx-grid-2">
                                    <div class="express-mx-field"><label>Tipo</label><select id="expressBotMovTipo" data-repeat-key="event_type"><option value="OUT">OUT</option><option value="MERMA">MERMA</option><option value="ADJUST">ADJUST</option></select></div>
                                    <div class="express-mx-field"><label>Cantidad BOT</label><input id="expressBotMovQty" data-repeat-key="qty_value"></div>
                                    <div class="express-mx-field"><label>Cliente / destino</label><input id="expressBotCliente"></div>
                                    <div class="express-mx-field"><label>Documento (opcional)</label><input id="expressBotMovDoc"></div>
                                </div>
                                <div class="express-mx-field"><label>Motivo (obligatorio en ajuste/negativo)</label><input id="expressBotReason" data-repeat-key="reason"></div>
                                <div class="express-mx-field"><label>Nota</label><input id="expressBotMovNota" data-repeat-key="note"></div>
                            </div>
                        </section>
                    </div>
                    <div class="express-mx-impact" id="expressMxImpact">Se registrará: —</div>
                    <div class="express-mx-status" id="expressMxStatus"></div>
                    <div class="express-mx-foot">
                        <button type="button" class="express-mx-save" id="expressMxSave">Guardar en 10s</button>
                    </div>
                    <div class="express-mx-recent">
                        <strong style="color:#4a0c26;">Últimos eventos</strong>
                        <div id="expressMxRecentList"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(fab);
            document.body.appendChild(overlay);
            expressMxBindEvents();

            const recalcBotellas = () => {
                const cajas = expressMxToNum(document.getElementById("expressBotCajas")?.value);
                const bpc = expressMxToNum(document.getElementById("expressBotBpc")?.value);
                const sueltas = expressMxToNum(document.getElementById("expressBotSueltas")?.value) || 0;
                const total = Math.round((Number.isFinite(cajas) && Number.isFinite(bpc) ? cajas * bpc : 0) + (Number.isFinite(sueltas) ? sueltas : 0));
                const out = document.getElementById("expressBotBotellas");
                if (out) out.value = Number.isFinite(total) && total > 0 ? String(total) : "";
                expressMxUpdateImpact();
            };
            ["expressBotCajas", "expressBotBpc", "expressBotSueltas"].forEach(id => {
                document.getElementById(id)?.addEventListener("input", recalcBotellas);
            });
            expressMxSetTab("uva");
        }

        initExpressMangueraUI();

        // ---------- Inicialización ----------
        (async function init() {
            await cargarNodosGuardados();
            mostrarSeccion("bodega");
	            await Promise.all([
	                cargarResumen(),
	                cargarDepositos(),
	                cargarBarricas(),
	                cargarEntradas(),
	                cargarMovimientos(),
	                cargarLimpieza(),
	                cargarEnologicos(),
	                cargarEmbotellados(),
	                cargarAlmacenVino(),
	                cargarAnalisisLab(),
	                cargarCatas(),
	            ]);
            initBitacoraIndomitaUI();
            cargarBitacora();
            inicializarCopilotoUI();
            initCopilotoHerramientas();
            actualizarCopiloto(true);
            renderDemoFlow();

            const campoFechaEntrada = document.getElementById("entradaFecha");
            if (campoFechaEntrada) {
                campoFechaEntrada.addEventListener("change", actualizarAnadaEntrada);
                actualizarAnadaEntrada();
            }
            initEntradaMixtoUI();
            initEntradaProcedenciaUI();
            initHerramientasUI();
            const movTipoSelect = document.getElementById("movTipo");
            if (movTipoSelect) {
                movTipoSelect.addEventListener("change", actualizarCamposMovimiento);
                actualizarCamposMovimiento();
            }
        })();
    </script>
    <script type="module" src="/js/app.js"></script>
</body>
</html>
