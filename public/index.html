<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bodega serie -INDÓMITO-</title>

    <style>
        :root {
            --vino-oscuro: #140818;
            --vino: #783c7b;
            --magenta: #f3789c;
            --rose: #fff1f8;
            --arena: #f8f0ff;
            --oro: #f3c77b;
            --texto: #201024;
            --linea: rgba(255, 255, 255, 0.35);
            --accent: #c2a9ff;
            --gris-ligero: rgba(255,255,255,0.65);
        }

        * {
            box-sizing: border-box;
        }

body {
    margin: 0;
    padding: 0;
    font-family: "Inter", system-ui, -apple-system, Helvetica, Arial, sans-serif;
    background: radial-gradient(circle at 15% 20%, #2b1a36, #0b0511 55%);
    min-height: 100vh;
    color: var(--texto);
    position: relative;
}

body::before,
body::after {
    content: "";
    position: fixed;
    width: 520px;
    height: 520px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(195,168,255,0.25), transparent 70%);
    z-index: 0;
    filter: blur(18px);
}

body::before {
    top: -80px;
    right: -100px;
}

body::after {
    bottom: -200px;
    left: -120px;
}

        .topbar {
            width: 100%;
            background: transparent;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 5;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .user-chip {
            display: none;
        }

        .topbar-title {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            position: relative;
        }

        .topbar-title button {
            color: inherit;
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            border: 1px solid rgba(255,255,255,0.38);
            cursor: pointer;
            padding: 16px 26px;
            border-radius: 28px;
            transition: transform 0.18s ease, box-shadow 0.22s ease, background 0.2s ease;
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
            min-width: 260px;
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }

        .topbar-title .microbrand {
            font-size: 11px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.75);
            margin-bottom: 4px;
        }

.topbar-title button::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 32px;
            background: conic-gradient(from 120deg, rgba(243,199,123,0.35), rgba(195,169,255,0.35), rgba(243,199,123,0.35));
            opacity: 0.2;
            filter: blur(6px);
            z-index: -1;
        }

.topbar-title button::after {
            content: "";
            position: absolute;
            top: -190%;
            left: -70%;
            width: 180%;
            height: 500%;
            background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.52) 55%, transparent 100%);
            transform: rotate(12deg) translateX(-300%);
            opacity: 0;
            transition: opacity 0.25s ease;
        }

.topbar-title button:hover,
.topbar-title button.open {
            background:
              radial-gradient(circle at 30% 30%, rgba(255, 235, 200, 0.7), transparent 42%),
              linear-gradient(135deg, #ffd79c, #ff9fdc, #b07bff);
            box-shadow:
              0 26px 70px rgba(0,0,0,0.65),
              0 12px 28px rgba(0,0,0,0.4),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 10px rgba(255,255,255,0.08);
            transform: translateY(-4px) scale(1.01);
        }

.topbar-title button:hover::after,
.topbar-title button.open::after {
            opacity: 1;
            animation: shimmer 1s ease forwards;
        }

        .topbar-title .marca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 2.5px;
            text-transform: uppercase;
            font-size: 36px;
            color: #0b0b0b;
            background: none;
            background-clip: initial;
-webkit-background-clip: initial;
            text-shadow:
              0 8px 18px rgba(92, 14, 45, 0.4),
              0 4px 10px rgba(92, 14, 45, 0.25),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 14px rgba(92, 14, 45, 0.35);
            filter: drop-shadow(0 4px 10px rgba(92, 14, 45, 0.35));
        }

        .topbar-title .submarca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 6px;
            font-size: 20px;
            color: #1a1a1a;
            margin-top: 8px;
            text-shadow:
              0 6px 18px rgba(0,0,0,0.4),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 12px rgba(50, 0, 70, 0.45);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.32));
        }

        /* =====================
           Adaptación móvil
        ===================== */
        @media (max-width: 768px) {
            body {
                margin: 0;
            }

            .topbar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                padding: 12px;
            }

            .topbar-title {
                width: 100%;
            }

            .topbar-title button {
                width: 100%;
                min-width: 0;
                padding: 14px 18px;
            }

            .nav-dropdown-menu {
                position: relative;
                top: 8px;
                left: 0;
                right: 0;
                width: 100%;
                min-width: 0;
                box-shadow: 0 16px 40px rgba(0,0,0,0.35);
                border: 1px solid rgba(255,255,255,0.16);
                background: linear-gradient(145deg, rgba(20,10,30,0.92), rgba(8,4,16,0.9));
            }

            .content {
                padding: 12px;
            }

            .card {
                padding: 16px;
            }

            /* Botones de la toolbar de nodos a ancho completo en móvil */
            .flow-toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .flow-toolbar-group {
                width: 100%;
            }

            .flow-toolbar .btnPrimario,
            .flow-toolbar .btnSecundario {
                width: 100%;
                justify-content: center;
            }

            /* Formularios más cómodos */
            form input,
            form select,
            form button,
            form textarea {
                width: 100%;
                box-sizing: border-box;
                font-size: 16px;
            }

            form .btnPrimario,
            form .btnSecundario {
                justify-content: center;
            }
            
            .nav-dropdown-menu a {
                font-size: 16px;
                padding: 12px 18px;
            }

            .copiloto-shell {
                padding: 18px;
            }

            .copiloto-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .copiloto-title-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .copiloto-date {
                width: 100%;
                justify-content: space-between;
            }

            .copiloto-panel.wide {
                grid-column: auto;
            }

            .copiloto-actions {
                width: 100%;
                justify-content: flex-start;
            }

            .copiloto-actions-grid {
                grid-template-columns: 1fr;
            }

            .cata-grid {
                grid-template-columns: 1fr;
            }
        }

@keyframes shimmer {
        0% { transform: translateX(-300%) rotate(12deg); opacity: 0; }
        20% { opacity: 1; }
        100% { transform: translateX(300%) rotate(12deg); opacity: 0; }
}

        .topbar-title button .caret {
            margin-top: 6px;
            font-size: 14px;
            color: rgba(255,255,255,0.65);
            transition: transform 0.2s ease;
        }

        .topbar-title button.open .caret {
            transform: rotate(180deg);
        }

.nav-dropdown-menu {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            display: none;
            flex-direction: column;
            background: rgba(8, 4, 15, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 18px;
            padding: 12px;
            min-width: 230px;
            width: 240px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.45);
            backdrop-filter: blur(18px);
            z-index: 20;
        }

.nav-dropdown-menu.visible {
            display: flex;
        }

.nav-dropdown-menu a {
            display: flex;
            align-items: center;
            color: #f9e5ff;
            padding: 10px 18px;
            border-radius: 999px;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.9;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.04);
            margin: 4px 0;
            width: 100%;
            min-width: 210px;
            justify-content: flex-start;
            box-sizing: border-box;
            min-height: 44px;
        }

.nav-dropdown-menu a:hover {
            background: rgba(255,255,255,0.12);
            opacity: 1;
        }

.nav-dropdown-menu a .emoji-barrica-lateral {
            position: relative;
            width: 44px;
            height: 30px;
            margin-right: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-1px);
        }

        .emoji-barrica-lateral span {
            position: absolute;
            display: block;
        }

        .emoji-barrica-lateral .sobrio-shadow {
            inset: auto 10px -8px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.25), transparent 70%);
            filter: blur(2px);
        }

        .emoji-barrica-lateral .sobrio-body {
            inset: 4px 8px;
            border-radius: 20px / 13px;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #c08342, #7e4a1f 70%);
            box-shadow:
                inset 0 0 8px rgba(0,0,0,0.4),
                0 3px 5px rgba(0,0,0,0.25);
        }

        .emoji-barrica-lateral .sobrio-body::before {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: inherit;
            border: 1px solid rgba(255,255,255,0.15);
            opacity: 0.8;
        }

        .emoji-barrica-lateral .sobrio-ring {
            left: 14px;
            right: 14px;
            height: 3px;
            border-radius: 3px;
            background: linear-gradient(90deg, #bfc2c5, #7c8086);
            box-shadow:
                inset 0 0 1px rgba(0,0,0,0.5),
                0 0 1px rgba(0,0,0,0.3);
        }

        .emoji-barrica-lateral .sobrio-ring.superior { top: 9px; }
        .emoji-barrica-lateral .sobrio-ring.inferior { top: 18px; }

        .emoji-barrica-lateral .sobrio-head {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #d19b5e, #8a5021);
            box-shadow: inset -2px -2px 3px rgba(0,0,0,0.35);
        }

        .emoji-barrica-lateral .sobrio-head.front { right: 3px; z-index: 2; }
        .emoji-barrica-lateral .sobrio-head.back {
            left: 3px;
            filter: brightness(0.85);
        }

.nav-barricas-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            width: 230px;
            box-sizing: border-box;
            height: 40px;
            padding-top: 8px;
            padding-bottom: 8px;
        }

.nav-barricas-icon {
            width: 30px;
            height: 30px;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.35));
            background: transparent;
            mix-blend-mode: multiply;
        }

.nav-dropdown-menu a.activo {
            background: linear-gradient(120deg, rgba(241,92,146,0.9), rgba(95,44,130,0.9));
            color: #fff;
            opacity: 1;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 6px 18px rgba(241, 92, 146, 0.35);
        }

.nav-dropdown-menu a .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .icon-barrica {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: linear-gradient(180deg, #c07b45, #7a3f1b);
            border: 2px solid #51260f;
            position: relative;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        }

        .icon-barrica::before,
        .icon-barrica::after {
            content: "";
            position: absolute;
            left: 2px;
            right: 2px;
            height: 2px;
            background: rgba(81,38,15,0.8);
            border-radius: 2px;
        }

        .icon-barrica::before { top: 4px; }
        .icon-barrica::after { bottom: 4px; }

.h1-emoji {
            font-size: 36px;
            display: inline-block;
            margin-right: 10px;
        }

        .content {
            padding: 60px 70px 110px;
            min-height: 100vh;
            position: relative;
            z-index: 1;
            max-width: 1920px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .content {
                padding: 35px 24px 70px;
                max-width: 100%;
            }
        }

       h1 {
           margin: 0 0 15px;
           font-size: 32px;
           font-weight: 700;
           color: var(--vino-oscuro);
           letter-spacing: 0.4px;
       }

        h2 {
            color: var(--vino);
            margin-top: 0;
            letter-spacing: 0.2px;
        }

        .topbar h2 {
            color: #fff;
        }

        .card {
            background: rgba(255, 255, 255, 0.92);
            padding: 36px;
            border-radius: 30px;
            margin-bottom: 36px;
            box-shadow: 0 25px 60px rgba(11, 5, 21, 0.35);
            border: 1px solid rgba(255,255,255,0.45);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(12px);
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 20%, rgba(241,92,146,0.2), transparent 55%),
                        radial-gradient(circle at 80% 0%, rgba(95,44,130,0.16), transparent 60%);
            pointer-events: none;
        }

        .card > * {
            position: relative;
            z-index: 1;
        }

        .chart-card {
            margin-top: 25px;
            background: rgba(255,255,255,0.55);
            border-radius: 24px;
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.35);
            backdrop-filter: blur(8px);
        }

       .indicadores-grid {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
           gap: 18px;
           margin-top: 24px;
       }

        .indicador-card {
            background: rgba(255,255,255,0.85);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 10px 30px rgba(20,8,32,0.2);
        }

        .indicador-card h4 {
            margin: 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(47,31,59,0.8);
        }

        .indicador-card p {
            margin: 10px 0 4px;
            font-size: 32px;
            font-weight: 700;
            color: var(--vino-oscuro);
        }

        .indicador-card small {
            color: rgba(47,31,59,0.7);
            display: block;
            font-size: 12px;
        }

        .estado-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #fff;
            min-width: 48px;
            text-transform: uppercase;
        }

        .estado-fa { background: #d85c5c; }
        .estado-fml { background: #c47d21; }
        .estado-reposo { background: #8c6ff7; }
        .estado-limpio { background: #40a578; }
        .estado-vacio { background: #9ba1b0; }
        .estado-mantenimiento { background: #f0a500; }
        .estado-analitica { background: #ff7aa8; }

        .estado-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #fff;
            margin-top: 6px;
        }

        .estado-pill.mini {
            position: absolute;
            top: 8px;
            right: 0;
            font-size: 9px;
            padding: 3px 8px;
        }

        .plano-item .estado-pill.mini {
            right: 8px;
            top: 8px;
            padding: 3px 10px;
            letter-spacing: 0.06em;
            opacity: 0.92;
            backdrop-filter: blur(8px);
        }

        .acciones-rapidas {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 28px 0 10px;
        }

       .acciones-rapidas button {
           background: rgba(255,255,255,0.15);
           border: 1px solid rgba(255,255,255,0.4);
           padding: 10px 18px;
           border-radius: 999px;
           color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s;
        }

        .acciones-rapidas button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        section.card {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        section.card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .flow-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 6px;
            padding-bottom: 0;
        }

        .flow-toolbar-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        /* Botones del mapa de nodos (más grandes y cómodos) */
        .flow-toolbar .btnPrimario,
        .flow-toolbar .btnSecundario {
            font-size: 13px;
            padding: 9px 14px;
            border-radius: 12px;
            min-height: 38px;
        }

        .flow-toolbar .btnPrimario span,
        .flow-toolbar .btnPrimario img {
            vertical-align: middle;
        }

        .flow-zoom-controls {
            margin-left: auto;
        }

        .flow-toolbar .flow-zoom-btn {
            width: 38px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

	        .flow-toolbar .flow-zoom-label {
	            min-width: 70px;
	            text-align: center;
	            padding: 9px 12px;
	            font-weight: 800;
	        }

	        .flow-replay-bar {
	            display: none;
	            margin-top: 10px;
	            padding: 12px 14px;
	            border-radius: 18px;
	            border: 1px solid rgba(255,255,255,0.12);
	            background: rgba(255,255,255,0.08);
	            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
	            backdrop-filter: blur(12px);
	        }

	        .flow-replay-bar.visible {
	            display: block;
	        }

	        .flow-replay-top {
	            display: flex;
	            align-items: flex-start;
	            justify-content: space-between;
	            gap: 12px;
	        }

	        .flow-replay-title {
	            font-weight: 900;
	            letter-spacing: 0.2px;
	            color: rgba(255,255,255,0.95);
	        }

	        .flow-replay-sub {
	            font-size: 12px;
	            color: rgba(255,255,255,0.7);
	            margin-top: 2px;
	        }

	        .flow-replay-controls {
	            display: flex;
	            align-items: center;
	            gap: 8px;
	            margin-top: 10px;
	        }

	        .flow-replay-range {
	            flex: 1;
	            min-width: 200px;
	        }

	        .flow-replay-date {
	            min-width: 120px;
	            text-align: right;
	            font-size: 12px;
	            font-weight: 800;
	            color: rgba(255,255,255,0.9);
	        }

	        .flow-replay-hint {
	            margin-top: 8px;
	            font-size: 12px;
	            color: rgba(255,255,255,0.6);
	        }

	        .flow-editor {
	            position: relative;
	            border: 1px dashed rgba(255,255,255,0.25);
	            border-radius: 24px;
	            background: rgba(8,4,15,0.5);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
            margin-top: 4px;
        }

        .flow-stage {
            position: relative;
            width: 5000px;
            height: 3000px;
            min-width: 1400px;
            min-height: 640px;
            overflow: hidden;
        }

        .flow-world {
            position: absolute;
            left: 0;
            top: 0;
            width: 5000px;
            height: 3000px;
            transform-origin: 0 0;
            transform: scale(1);
        }

        .demo-flow-stage {
            position: relative;
            min-height: 320px;
            border: 1px dashed rgba(255,255,255,0.25);
            border-radius: 18px;
            background: radial-gradient(circle at 12% 18%, rgba(255,255,255,0.05), transparent 55%),
                        radial-gradient(circle at 80% 8%, rgba(255,255,255,0.04), transparent 60%),
                        rgba(12,6,18,0.6);
            overflow: hidden;
            margin-top: 14px;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.25);
        }

        .demo-flow-node {
            min-width: 160px;
            padding: 10px 12px 14px;
            border-radius: 16px;
        }

        .flow-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: default;
            background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .flow-connections {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .flow-node {
            position: absolute;
            min-width: 72px;
            background: rgba(40, 18, 52, 0.95);
            border-radius: 7px;
            box-shadow: 0 8px 14px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.08);
            padding: 4px 6px 24px;
            cursor: grab;
            color: #f5e9ff;
            text-transform: uppercase;
            font-weight: 400;
            letter-spacing: 0.3px;
            overflow: hidden;
            isolation: isolate;
        }

        .flow-node.menu-open {
            overflow: visible;
        }

        .flow-node.dragging {
            cursor: grabbing;
            box-shadow: 0 25px 50px rgba(0,0,0,0.35);
        }

        .flow-node h4 {
            margin: 0;
            font-size: 14px;
            color: #f7f2ff;
            text-align: right;
            font-weight: 700;
        }

        .flow-node-subtitle {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 1px;
            text-align: right;
        }
        .flow-node-subtitle.flow-node-metodo {
            font-weight: 700;
        }

        .flow-node-metrics {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-top: 4px;
            font-size: 10px;
            text-transform: none;
            justify-content: flex-end;
        }

        .flow-chip {
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            letter-spacing: 0.2px;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .flow-node .fill-level {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 0%;
            background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
            mix-blend-mode: screen;
            transition: height 0.35s ease, background 0.3s ease;
            z-index: -1;
        }

        .flow-node .fill-level.red {
            background: linear-gradient(180deg, rgba(255,88,120,0.15), rgba(255,88,120,0.35));
        }

        .flow-node .fill-level.white {
            background: linear-gradient(180deg, rgba(255,236,200,0.2), rgba(255,236,200,0.45));
        }

        .flow-node .fill-level.rosado {
            background: linear-gradient(180deg, rgba(245,139,181,0.18), rgba(245,139,181,0.42));
        }

        .flow-node.temp-alert {
            box-shadow: 0 0 14px rgba(255,90,90,0.8), 0 0 0 1px rgba(255,90,90,0.45);
            border-color: rgba(255,90,90,0.6);
        }

        .flow-state-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 6px;
            font-size: 14px;
            line-height: 1.2;
            letter-spacing: 0.4px;
            font-weight: 700;
            text-transform: uppercase;
            color: #ffd89c;
        }

        .flow-progress-ring {
            position: absolute;
            inset: -6px;
            border-radius: 14px;
            pointer-events: none;
            z-index: -2;
            opacity: 0.8;
            -webkit-mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
            mask: radial-gradient(closest-side, transparent calc(100% - 5px), #000 calc(100% - 4px));
        }

        .flow-node-icon {
            font-size: 15px;
        }

        .flow-tooltip {
            position: fixed;
            z-index: 9999;
            display: none;
            max-width: min(360px, calc(100vw - 24px));
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(18, 10, 30, 0.92);
            border: 1px solid rgba(255,255,255,0.16);
            box-shadow: 0 20px 45px rgba(0,0,0,0.45);
            color: rgba(255,255,255,0.92);
            font-size: 12px;
            line-height: 1.25;
            white-space: pre-line;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .grape-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.35), 0 1px 4px rgba(0,0,0,0.35);
            margin-left: 2px;
        }

        .grape-badge.red {
            background: radial-gradient(circle at 30% 30%, #ffb3c9, #d43c68 55%, #7a0f38 100%);
            color: #fff;
        }

        .grape-badge.white {
            background: radial-gradient(circle at 30% 30%, #fff7d1, #f9d66b 55%, #c99a2a 100%);
            color: #3a2a00;
        }

        .flow-node small {
            display: none;
        }

        .flow-node .flow-unit {
            display: inline-block;
            padding: 0;
            border-radius: 0;
            background: transparent;
            color: #fff;
            font-size: 9px;
            margin-top: 4px;
            letter-spacing: 0.4px;
        }

        .flow-node .flow-node-controls {
            position: absolute;
            bottom: 6px;
            right: 6px;
            display: flex;
            gap: 4px;
        }

        .flow-node .flow-node-controls button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .flow-node .flow-node-controls button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .flow-node .flow-node-controls button.blue::before {
            background: #2f7df0;
        }

        .flow-node .flow-node-controls button.green::before {
            background: #4caf50;
        }

        .flow-node .flow-node-controls button.red::before {
            background: #f44336;
        }
        .flow-node .flow-node-controls button.blue::after {
            content: "";
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.9);
            inset: 0;
            margin: auto;
        }

        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }
        .flow-node .flow-node-controls button.green::after {
            content: "➜";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }

        .flow-node .flow-node-controls button.red::after {
            content: "×";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 8px;
        }

        .flow-node .flow-node-controls button.menu::before {
            background: #8a93a4;
        }

        .flow-node .flow-node-controls button.menu::after {
            content: "⋯";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 10px;
            line-height: 1;
        }

        .flow-node .flow-node-menu {
            position: absolute;
            right: 4px;
            bottom: 22px;
            min-width: 150px;
            display: none;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(20, 12, 32, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 12px 24px rgba(0,0,0,0.35);
            z-index: 3;
        }

        .flow-node .flow-node-menu.visible {
            display: flex;
        }

        .flow-node .flow-node-menu button {
            width: 100%;
            border: none;
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-size: 12px;
            text-align: left;
            padding: 6px 8px;
            border-radius: 10px;
            cursor: pointer;
        }

        .flow-node .flow-node-menu button:hover {
            background: rgba(255,255,255,0.2);
        }

        .flow-node .flow-node-menu button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .flow-node .flow-node-controls button.conectando::before {
            box-shadow: 0 0 6px rgba(243,120,156,0.8);
        }

        .flow-node-body {
            width: 100%;
            align-items: flex-end;
            text-align: right;
            padding-right: 6px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }


	        .flow-connector-line {
	            stroke: rgba(255,255,255,0.65);
	            stroke-width: 1.6;
	            fill: none;
	            marker-end: url(#arrowHead);
	        }

	        .flow-connector-line.replay-future {
	            stroke: rgba(255,255,255,0.18);
	            stroke-dasharray: 6 6;
	        }

	        .flow-connector-line.replay-done {
	            stroke: rgba(255,255,255,0.55);
	        }

	        .flow-connector-line.replay-now {
	            stroke: rgba(255,215,155,0.9);
	            stroke-width: 2.6;
	        }

	        .flow-connector-line.replay-outside {
	            opacity: 0.18;
	        }

	        .flow-connector-label {
	            fill: rgba(255,255,255,0.85);
	            font-size: 11px;
	            font-family: "Inter", system-ui, sans-serif;
	            pointer-events: none;
	            text-shadow: 0 1px 4px rgba(0,0,0,0.55);
	        }

	        #flujo.replay-mode .flow-connections {
	            pointer-events: auto;
	        }

	        #flujo.replay-mode .flow-connector-line {
	            pointer-events: stroke;
	            cursor: help;
	        }

	        #flujo.replay-mode .flow-connector-label {
	            opacity: 0.16;
	        }

	        #flujo.replay-mode .flow-node {
	            cursor: default;
	        }

	        #flujo.replay-mode .flow-node.dragging {
	            cursor: default;
	        }

	        #flujo.replay-mode .flow-node .flow-node-controls button {
	            pointer-events: none;
	            opacity: 0.35;
	        }

	        #flujo.replay-mode .flow-node.replay-inactive {
	            opacity: 0.18;
	            filter: grayscale(0.35) saturate(0.85);
	        }

	        #flujo.replay-mode .flow-node.replay-outside {
	            opacity: 0.12;
	            filter: grayscale(0.45) saturate(0.75);
	        }

	        #flujo.replay-mode .flow-node.replay-current {
	            box-shadow: 0 0 0 2px rgba(255,215,155,0.35), 0 18px 35px rgba(0,0,0,0.35);
	            border-color: rgba(255,215,155,0.28);
	        }

        .flow-node-info {
            margin-top: 16px;
            padding: 14px 18px;
            border-radius: 16px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.05);
            min-height: 80px;
            font-size: 14px;
        }

        .flow-helper {
            margin-top: 14px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        .flow-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding: 140px 20px 40px;
            z-index: 12000;
            overflow-y: auto;
        }

        .flow-modal.visible {
            display: flex;
        }

        .flow-modal-content {
            background: #fff;
            border-radius: 18px;
            padding: 18px 20px;
            max-width: 450px;
            width: min(450px, 94%);
            box-shadow: 0 30px 60px rgba(0,0,0,0.35);
        }

        .flow-modal-content form label {
            margin-top: 10px;
            display: block;
            font-weight: 500;
        }

        .flow-modal-content form input,
        .flow-modal-content form textarea,
        .flow-modal-content form select {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 14px;
        }

        .field-readonly {
            background: rgba(0,0,0,0.05);
            color: #5c5c5c;
            cursor: not-allowed;
        }

        .flow-modal-content form textarea {
            min-height: 70px;
        }

        .campo-info {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(0,0,0,0.04);
            border: 1px dashed rgba(0,0,0,0.12);
            font-size: 13px;
            color: #444;
        }

        #entradas.entrada-page {
            padding: 18px 18px 24px;
        }

        #entradas .entrada-form {
            display: grid;
            gap: 18px;
        }

        #entradas .entrada-block {
            position: relative;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.08);
            border-left: 4px solid rgba(95,44,130,0.35);
            border-radius: 18px;
            padding: 16px;
            display: grid;
            gap: 12px;
            box-shadow: 0 14px 30px rgba(20, 8, 32, 0.08);
        }

        #entradas .entrada-block--hero {
            border-left-color: rgba(95,44,130,0.7);
            background: radial-gradient(circle at 18% 20%, rgba(255, 235, 200, 0.22), transparent 45%),
                        linear-gradient(180deg, rgba(255, 255, 255, 0.96), #fff);
            overflow: hidden;
        }

        #entradas .entrada-block--hero::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(120deg, rgba(241,92,146,0.6), rgba(95,44,130,0.7));
        }

        #entradas .entrada-block--admin {
            border-left-color: rgba(193, 131, 66, 0.75);
            background: linear-gradient(180deg, rgba(255, 214, 153, 0.24), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--identidad {
            border-left-color: rgba(109, 132, 108, 0.7);
            background: linear-gradient(180deg, rgba(189, 206, 184, 0.2), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--fisica {
            border-left-color: rgba(122, 15, 56, 0.75);
            background: linear-gradient(180deg, rgba(122, 15, 56, 0.12), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block--observaciones {
            border-left-color: rgba(125, 96, 166, 0.75);
            background: linear-gradient(180deg, rgba(155, 125, 210, 0.18), rgba(255,255,255,0.96));
        }

        #entradas .entrada-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        #entradas .entrada-title {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #7a0f38;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #entradas .entrada-title .h1-emoji {
            font-size: 1.3em;
        }

        #entradas .entrada-block-eyebrow,
        #entradas .entrada-block-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #6f685e;
            font-weight: 600;
        }

        #entradas .entrada-block-title {
            position: relative;
            padding-bottom: 2px;
        }

        #entradas .entrada-block-title::after {
            content: "";
            display: block;
            height: 1px;
            margin-top: 6px;
            background: linear-gradient(90deg, currentColor, transparent);
            opacity: 0.4;
        }

        #entradas .entrada-block--admin .entrada-block-title {
            color: #a46b2e;
        }

        #entradas .entrada-block--identidad .entrada-block-title {
            color: #5d6f5b;
        }

        #entradas .entrada-block--fisica .entrada-block-title {
            color: #7a0f38;
        }

        #entradas .entrada-block--observaciones .entrada-block-title {
            color: #6b4b87;
        }

        #entradas .entrada-block-subtitle {
            font-size: 12px;
            color: #7b756b;
        }

        #entradas .entrada-block--hero .entrada-block-subtitle {
            color: #7b4a6a;
            font-weight: 600;
        }

        #entradas .entrada-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(255,159,220,0.9), rgba(155,93,229,0.9));
            border: 1px solid rgba(255,255,255,0.55);
            color: #2b1736;
            font-size: 12px;
            font-weight: 700;
            box-shadow: 0 8px 18px rgba(95, 44, 130, 0.2);
        }

        #entradas .entrada-grid {
            display: grid;
            gap: 12px;
        }

        #entradas .entrada-grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        #entradas .entrada-grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        #entradas .entrada-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6d675e;
            margin-bottom: 4px;
        }

        #entradas input,
        #entradas select,
        #entradas textarea {
            padding: 7px 10px;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.14);
            font-size: 14px;
            background: rgba(255,255,255,0.92);
            box-shadow: none;
        }

        #entradaRc {
            background: rgba(255, 245, 230, 0.9);
            border-color: rgba(193, 131, 66, 0.45);
            font-weight: 600;
            letter-spacing: 0.04em;
            box-shadow: inset 0 0 0 1px rgba(193, 131, 66, 0.12);
        }

        #entradas .btnSecundario {
            background: #f3f1ed;
            color: #3a342d;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: none;
        }

        #entradas textarea {
            min-height: 90px;
        }

        #entradas .entrada-check {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #6d675e;
        }

        #entradas .entrada-lineas {
            margin-top: 4px;
        }

        .entrada-procedencia-grid {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .entrada-procedencia-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6d675e;
            margin-bottom: 4px;
        }

        .entrada-procedencia-field--wide {
            grid-column: span 2;
        }

        .entrada-chip-oficial {
            display: inline-block;
            margin-left: 6px;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            background: linear-gradient(135deg, #ffd79c, #c07b45);
            color: #3a1f06;
            letter-spacing: 0.04em;
        }

        .entrada-procedencia-extra {
            border: 1px dashed rgba(0,0,0,0.12);
            border-radius: 12px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.7);
        }

        .entrada-procedencia-extra summary {
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            color: #5f594f;
        }

        .entrada-catastro-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        #entradas .entrada-catastro-actions .btnPrimario,
        #entradas .entrada-catastro-actions .btnSecundario {
            background: #f7f4ef;
            color: #3a342d;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: none;
        }

        #entradas .entrada-catastro-actions .btnPrimario:disabled,
        #entradas .entrada-catastro-actions .btnSecundario:disabled {
            opacity: 0.55;
        }

        .entrada-catastro-links {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
            margin-top: 6px;
            font-size: 12px;
        }

        .entrada-catastro-links a {
            color: #3a342d;
            text-decoration: underline;
        }

        .entrada-catastro-links a[aria-disabled="true"] {
            opacity: 0.5;
            pointer-events: none;
            text-decoration: none;
        }

        .entrada-plantillas {
            display: grid;
            gap: 6px;
            padding: 10px;
            border-radius: 12px;
            border: 1px dashed rgba(0,0,0,0.12);
            background: rgba(255,255,255,0.6);
        }

        .entrada-plantillas-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #6f685e;
            font-weight: 600;
        }

        .entrada-plantillas-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .entrada-hint {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .entrada-lectura-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .entrada-lectura-row input {
            flex: 1;
        }

        .entrada-lectura input {
            font-size: 19px;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #6c2b52;
        }

        #entradaKilosWrap {
            background: rgba(122, 15, 56, 0.06);
            border: 1px solid rgba(122, 15, 56, 0.15);
            border-radius: 12px;
            padding: 10px;
        }

        #entradas .entrada-lectura {
            background: rgba(93, 47, 109, 0.06);
            border: 1px solid rgba(93, 47, 109, 0.15);
            border-radius: 12px;
            padding: 10px;
        }

        .entrada-unidad {
            font-size: 12px;
            color: #7b4a6a;
        }

        #entradaKilos {
            font-size: 20px;
            font-weight: 700;
            color: #7a0f38;
        }

        #entradaDensidad,
        #entradaTemperatura {
            color: #5d2f6d;
        }

        .entrada-resumen-admin {
            margin-top: 10px;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 14px;
            padding: 8px 10px;
            background: #fffdf7;
        }

        .entrada-resumen-admin summary {
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            color: #5c554b;
        }

        .entrada-resumen-body {
            display: grid;
            gap: 8px;
            margin-top: 8px;
        }

        #entradaResumenAdminTexto {
            min-height: 130px;
            resize: vertical;
            font-family: "Courier New", monospace;
            font-size: 12px;
        }

        #entradas .entrada-actions {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 4px;
        }

        #entradas .entrada-actions .btnPrimario {
            min-width: 220px;
            background: linear-gradient(120deg, rgba(241,92,146,0.95), rgba(95,44,130,0.95));
            color: #fff7fd;
            border: 1px solid rgba(255,255,255,0.45);
            box-shadow: 0 18px 36px rgba(95, 44, 130, 0.3);
        }

        #entradas .entrada-actions .btnSecundario {
            opacity: 0.75;
        }

        #entradas .entrada-historial {
            margin-top: 26px;
            padding: 18px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.08);
            background: #f2f1ed;
        }

        #entradas .entrada-historial h2 {
            margin-top: 0;
            font-size: 16px;
            color: #6b2f5b;
        }

        #entradas .entrada-historial table {
            box-shadow: none;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.08);
        }

        #entradas .entrada-historial th {
            background: linear-gradient(90deg, rgba(241,92,146,0.12), rgba(95,44,130,0.08));
            color: #5b2a48;
        }

        #entradas .entrada-historial .small-btn {
            background: #e7e3dc !important;
            color: #4a443c !important;
            box-shadow: none !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
        }

        #entradas .entrada-historial tbody tr {
            transition: background 0.2s ease;
        }

        #entradas .entrada-historial tbody tr:hover {
            background: rgba(241, 92, 146, 0.08);
        }

        @media (max-width: 720px) {
            #entradas .entrada-block-header {
                align-items: flex-start;
            }

            .entrada-procedencia-field--wide {
                grid-column: span 1;
            }

            #entradas .entrada-actions .btnPrimario {
                width: 100%;
            }
        }

        .tabla-control-fermentacion table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-control-fermentacion th,
        .tabla-control-fermentacion td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-control-fermentacion input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-control-fermentacion select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
            background: #fff;
        }

        .tabla-control-fermentacion th:nth-child(1),
        .tabla-control-fermentacion td:nth-child(1) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(2),
        .tabla-control-fermentacion td:nth-child(2) {
            width: 80px;
        }

        .tabla-control-fermentacion th:nth-child(3),
        .tabla-control-fermentacion td:nth-child(3) {
            width: 60px;
        }

        .tabla-control-fermentacion th:nth-child(4),
        .tabla-control-fermentacion td:nth-child(4) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(5),
        .tabla-control-fermentacion td:nth-child(5) {
            width: 160px;
        }

        .tabla-control-fermentacion tbody tr:last-child td {
            border-bottom: none;
        }

        .tabla-formatos-embotellado table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-formatos-embotellado th,
        .tabla-formatos-embotellado td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-formatos-embotellado input,
        .tabla-formatos-embotellado select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-formatos-embotellado .tabla-formatos-resumen {
            margin-top: 6px;
            font-size: 12px;
            color: #666;
        }

        .flow-modal-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .skeleton-line,
        .skeleton-block {
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .skeleton-line::before,
        .skeleton-block::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            animation: shimmer 1.3s infinite;
        }

        .skeleton-line {
            height: 10px;
            margin: 6px 0;
        }

        .skeleton-block {
            height: 36px;
            margin: 10px 0;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .form-feedback {
            margin-top: 12px;
            font-size: 13px;
            min-height: 18px;
            color: rgba(32, 16, 36, 0.7);
        }

        .form-feedback.success {
            color: #2f8f5b;
        }

        .form-feedback.error {
            color: #d95070;
        }
        .movimientos-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .movimientos-form {
            flex: 1.2;
            min-width: 320px;
        }

        .tabla-movimientos {
            flex: 1.6;
            min-width: 440px;
            min-height: 520px;
            overflow-x: auto;
            overflow-y: visible;
        }

        .movimientos-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            min-width: 760px;
        }

        .movimientos-table th,
        .movimientos-table td {
            font-size: 12px;
            white-space: nowrap;
            padding: 8px;
        }


        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 22px;
            margin-top: 16px;
        }

        .chart-item {
            background: linear-gradient(160deg, rgba(255,255,255,0.95), rgba(241,92,146,0.15));
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--vino);
        }

        .app-alerts {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .toast {
            min-width: 220px;
            background: rgba(15, 7, 20, 0.85);
            color: #fff;
            padding: 12px 18px;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.35);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(20px);
            animation: toast-in 0.25s forwards;
        }

        .toast.success { background: rgba(64, 165, 120, 0.9); }
        .toast.error { background: rgba(217, 80, 112, 0.9); }

        @keyframes toast-in {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chart-bar-bg {
            width: 100%;
            height: 12px;
            border-radius: 12px;
            background: rgba(75,15,77,0.15);
            overflow: hidden;
        }

        .chart-bar {
            height: 100%;
            border-radius: 12px;
            background: linear-gradient(90deg, #f76fb0, #5f2c82);
            width: 20%;
            transition: width 0.4s ease;
        }

        .chart-item small {
            display: block;
            margin-top: 8px;
            color: #6e5e6e;
        }

        .copiloto-shell {
            margin-top: 24px;
            padding: 26px;
            border-radius: 28px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(243,199,123,0.08));
            border: 1px solid rgba(255,255,255,0.6);
            box-shadow: 0 24px 60px rgba(15,7,20,0.18);
            position: relative;
            overflow: hidden;
        }

        .copiloto-shell::before {
            content: "";
            position: absolute;
            inset: 0;
            background:
              radial-gradient(circle at 85% 10%, rgba(255,214,168,0.45), transparent 55%),
              radial-gradient(circle at 10% 90%, rgba(195,169,255,0.35), transparent 60%);
            opacity: 0.45;
            pointer-events: none;
        }

        .copiloto-header {
            position: relative;
            z-index: 1;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .copiloto-header-main {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: min(420px, 100%);
        }

        .copiloto-title-row {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .copiloto-title {
            font-size: 26px;
            font-weight: 800;
            margin: 0;
            color: #1a0d22;
        }

        .copiloto-date {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: rgba(26,13,34,0.7);
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
        }

        .copiloto-campania {
            padding-left: 10px;
            border-left: 1px solid rgba(15,7,20,0.2);
        }

        .copiloto-subtitle {
            margin: 6px 0 0;
            color: rgba(26,13,34,0.7);
            font-size: 14px;
        }

        .copiloto-chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .copiloto-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
            font-size: 12px;
            font-weight: 600;
            color: rgba(20,10,30,0.85);
        }

        .copiloto-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .copiloto-grid {
            position: relative;
            z-index: 1;
            margin-top: 18px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .copiloto-grid-superior {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 16px;
            align-items: stretch;
        }

        .copiloto-panel-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
            min-height: 0;
            overflow: auto;
        }

        .copiloto-panel {
            background: rgba(255,255,255,0.8);
            border-radius: 20px;
            padding: 18px;
            border: 1px solid rgba(95,44,130,0.12);
            box-shadow: 0 16px 40px rgba(15,7,20,0.12);
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 160px;
        }

        .copiloto-grid-superior .copiloto-panel {
            min-height: 260px;
            max-height: 360px;
        }

        .copiloto-panel.wide {
            grid-column: span 2;
        }

        .copiloto-panel-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .copiloto-panel h3 {
            margin: 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.85);
        }

        .copiloto-panel-sub {
            margin: 4px 0 0;
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .copiloto-alerts,
        .copiloto-tareas,
        .copiloto-activity,
        .copiloto-live {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .copiloto-live-item {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.88);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .copiloto-live-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        .copiloto-live-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-live-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .copiloto-badge {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            padding: 3px 8px;
            border-radius: 999px;
            background: rgba(15,7,20,0.08);
            border: 1px solid rgba(15,7,20,0.12);
            color: rgba(20,10,30,0.85);
        }

        .copiloto-badge[data-estado="activo"] {
            background: rgba(255,203,120,0.45);
            border-color: rgba(255,203,120,0.7);
        }

        .copiloto-badge[data-estado="violento"] {
            background: rgba(255,143,143,0.45);
            border-color: rgba(255,143,143,0.7);
        }

        .copiloto-badge[data-estado="tranquilo"],
        .copiloto-badge[data-estado="equilibrado"] {
            background: rgba(130,205,170,0.4);
            border-color: rgba(130,205,170,0.7);
        }

        .copiloto-badge[data-estado="tenso"],
        .copiloto-badge[data-estado="inestable"] {
            background: rgba(255,199,143,0.5);
            border-color: rgba(255,199,143,0.7);
        }

        .copiloto-badge[data-estado="reductivo"],
        .copiloto-badge[data-estado="cerrado"] {
            background: rgba(188,196,255,0.45);
            border-color: rgba(188,196,255,0.7);
        }

        .copiloto-badge[data-origen="express"] {
            background: rgba(255,232,179,0.7);
            border-color: rgba(255,200,112,0.8);
        }

        .copiloto-badge[data-origen="control"] {
            background: rgba(200,230,255,0.7);
            border-color: rgba(150,200,255,0.8);
        }

        .copiloto-badge[data-origen="manual"] {
            background: rgba(220,220,220,0.6);
            border-color: rgba(190,190,190,0.8);
        }

        .copiloto-live-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-live-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .copiloto-action-express {
            background: #111;
            color: #fff;
            border-color: #111;
        }

        .copiloto-alert {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.85);
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }

        .copiloto-alert[data-level="alta"] {
            border-left: 4px solid rgba(217,80,112,0.9);
            background: linear-gradient(120deg, rgba(255, 230, 230, 0.8), rgba(255,255,255,0.9));
        }

        .copiloto-alert[data-level="media"] {
            border-left: 4px solid rgba(243,199,123,0.9);
            background: linear-gradient(120deg, rgba(255, 240, 215, 0.8), rgba(255,255,255,0.9));
        }

        .copiloto-alert[data-level="baja"] {
            border-left: 4px solid rgba(64,165,120,0.8);
        }

        .copiloto-alert-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .copiloto-alert-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-alert-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .copiloto-task {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(15,7,20,0.06);
            border: 1px solid rgba(15,7,20,0.08);
        }

        .copiloto-task small {
            color: rgba(40,18,52,0.6);
        }

        .copiloto-feed-item {
            padding: 12px 14px;
            border-radius: 18px;
            background: rgba(20,10,30,0.06);
            border: 1px dashed rgba(95,44,130,0.18);
        }

        .copiloto-activity-item {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.86);
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-activity-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px rgba(15,7,20,0.16);
        }

        .copiloto-activity-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .copiloto-activity-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
        }

        .copiloto-empty {
            padding: 14px;
            border-radius: 14px;
            text-align: center;
            font-size: 13px;
            color: rgba(40,18,52,0.6);
            background: rgba(255,255,255,0.7);
            border: 1px dashed rgba(95,44,130,0.18);
        }

        .copiloto-subpanel {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed rgba(95,44,130,0.2);
        }

        .copiloto-subpanel h4 {
            margin: 0 0 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-semaforo {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(15,7,20,0.06);
        }

        .copiloto-semaforo[data-level="mantener"] {
            background: rgba(140,215,185,0.45);
            border-color: rgba(100,190,155,0.65);
            color: rgba(24,78,60,0.9);
        }

        .copiloto-semaforo[data-level="observa"] {
            background: rgba(170,205,255,0.5);
            border-color: rgba(130,170,240,0.7);
            color: rgba(24,60,120,0.9);
        }

        .copiloto-semaforo[data-level="preparate"] {
            background: rgba(255,214,160,0.55);
            border-color: rgba(235,185,120,0.8);
            color: rgba(120,70,20,0.9);
        }

        .copiloto-semaforo[data-level="actua"] {
            background: rgba(255,170,170,0.6);
            border-color: rgba(235,130,130,0.85);
            color: rgba(120,30,30,0.9);
        }

        .copiloto-timeline-wrap {
            display: grid;
            grid-template-columns: minmax(240px, 280px) minmax(0, 1fr);
            gap: 18px;
            align-items: start;
        }

        .copiloto-timeline-side {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .copiloto-quicknote {
            display: grid;
            gap: 8px;
        }

        .copiloto-quicknote textarea {
            resize: vertical;
            min-height: 120px;
            line-height: 1.45;
        }

        .copiloto-note-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .copiloto-note-chip {
            cursor: pointer;
        }

        .copiloto-note-status {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
            min-height: 16px;
        }

        .copiloto-note-status.success {
            color: rgba(10,122,0,0.9);
        }

        .copiloto-note-status.error {
            color: rgba(176,0,32,0.9);
        }

        .copiloto-heatmap-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

        .copiloto-heatmap-head button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .copiloto-heatmap {
            display: grid;
            grid-template-columns: repeat(14, minmax(10px, 1fr));
            gap: 4px;
        }

        .copiloto-heatmap-cell {
            border-radius: 4px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(15,7,20,0.06);
            aspect-ratio: 1 / 1;
            padding: 0;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-heatmap-cell:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 14px rgba(15,7,20,0.16);
        }

        .copiloto-heatmap-cell.heat-1 {
            background: rgba(255,221,234,0.6);
            border-color: rgba(235,180,205,0.7);
        }

        .copiloto-heatmap-cell.heat-2 {
            background: rgba(238,180,210,0.7);
            border-color: rgba(215,150,190,0.75);
        }

        .copiloto-heatmap-cell.heat-3 {
            background: rgba(212,135,180,0.78);
            border-color: rgba(190,110,160,0.8);
        }

        .copiloto-heatmap-cell.heat-4 {
            background: rgba(180,90,150,0.88);
            border-color: rgba(150,60,120,0.9);
        }

        .copiloto-heatmap-cell.is-selected {
            box-shadow: 0 0 0 2px rgba(95,44,130,0.7);
        }

        .copiloto-timeline-head {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .copiloto-timeline-head h4 {
            margin: 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-timeline-sub {
            margin: 4px 0 0;
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .copiloto-timeline-filters {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .copiloto-filter-group {
            display: grid;
            gap: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.6);
        }

        .copiloto-filter-group select,
        .copiloto-filter-group input {
            font-size: 13px;
            text-transform: none;
            letter-spacing: normal;
        }

        .copiloto-filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .copiloto-filter-chips .copiloto-chip {
            cursor: pointer;
        }

        .copiloto-chip.is-active {
            background: rgba(95,44,130,0.16);
            border-color: rgba(95,44,130,0.35);
            color: rgba(56,20,88,0.95);
        }

        .copiloto-timeline {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .copiloto-timeline-item,
        .copiloto-timeline-card {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .copiloto-timeline-item:hover,
        .copiloto-timeline-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(15,7,20,0.16);
        }

        .copiloto-timeline-day {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .copiloto-timeline-day-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(40,18,52,0.55);
            margin-top: 6px;
        }

        .copiloto-card-top {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .copiloto-card-time {
            font-size: 18px;
            font-weight: 800;
            color: rgba(26,13,34,0.95);
            min-width: 64px;
        }

        .copiloto-card-main {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .copiloto-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-card-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-card-sub {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
        }

        .copiloto-card-note {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .copiloto-card-note.is-expanded {
            -webkit-line-clamp: initial;
        }

        .copiloto-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-top: 6px;
        }

        .copiloto-timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .copiloto-timeline-title {
            font-weight: 700;
            color: rgba(26,13,34,0.95);
        }

        .copiloto-timeline-detail {
            font-size: 12px;
            color: rgba(40,18,52,0.78);
        }

        .copiloto-timeline-vars {
            font-size: 12px;
            color: rgba(40,18,52,0.65);
        }

        .bitacora-indomita-layout {
            display: grid;
            grid-template-columns: minmax(280px, 340px) minmax(0, 1fr);
            gap: 18px;
            align-items: start;
        }

        .bitacora-panel {
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.9);
            padding: 14px;
        }

        .bitacora-panel h3 {
            margin-top: 0;
        }

        .bitacora-form {
            display: grid;
            gap: 10px;
        }

        .bitacora-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bitacora-row > div {
            flex: 1;
            min-width: 140px;
        }

        .bitacora-entry {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(15,7,20,0.08);
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .bitacora-entry-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .bitacora-badge {
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(15,7,20,0.06);
        }

        .bitacora-entry-text {
            font-size: 13px;
            color: rgba(26,13,34,0.95);
            line-height: 1.45;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .bitacora-entry-text.is-expanded {
            -webkit-line-clamp: initial;
        }

        .bitacora-entry-links {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 12px;
        }

        .bitacora-entry-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

        .bitacora-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 120px;
        }

        .bitacora-plain {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 14px;
            line-height: 1.55;
            color: #111;
        }

        .bitacora-line {
            white-space: pre-wrap;
        }

        .bitacora-line--header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bitacora-line--ts {
            font-weight: 600;
            color: rgba(20, 8, 24, 0.75);
        }

        .bitacora-line--blank {
            height: 10px;
        }

        .bitacora-delete {
            margin-left: auto;
            background: none;
            border: none;
            padding: 0;
            font-size: 12px;
            font-weight: 600;
            color: #7c1b1b;
            cursor: pointer;
        }

        .bitacora-delete:hover {
            text-decoration: underline;
        }

        .bitacora-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            border: 1px solid rgba(15, 7, 20, 0.15);
        }

        .bitacora-tag--movimiento {
            color: #6e3d12;
            background: rgba(243, 199, 123, 0.25);
            border-color: rgba(243, 199, 123, 0.6);
        }

        .bitacora-tag--medicion {
            color: #3a1a62;
            background: rgba(194, 169, 255, 0.25);
            border-color: rgba(194, 169, 255, 0.65);
        }

        .bitacora-tag--entrada {
            color: #7a2041;
            background: rgba(243, 120, 156, 0.22);
            border-color: rgba(243, 120, 156, 0.65);
        }

        .bitacora-tag--accion {
            color: #2a2a2a;
            background: rgba(255, 255, 255, 0.65);
            border-color: rgba(15, 7, 20, 0.2);
        }

        .bitacora-tag--fermentacion {
            color: #3d1c52;
            background: rgba(155, 93, 229, 0.18);
            border-color: rgba(155, 93, 229, 0.6);
        }

        .bitacora-tag--adicion {
            color: #6a3d0d;
            background: rgba(243, 199, 123, 0.22);
            border-color: rgba(243, 199, 123, 0.6);
        }

        .bitacora-tag--trasvase {
            color: #0f4b4c;
            background: rgba(144, 242, 201, 0.2);
            border-color: rgba(144, 242, 201, 0.7);
        }

        .bitacora-tag--prensado {
            color: #4a2e12;
            background: rgba(255, 215, 156, 0.22);
            border-color: rgba(255, 215, 156, 0.7);
        }

        .bitacora-tag--descube {
            color: #3a2d4d;
            background: rgba(176, 123, 255, 0.18);
            border-color: rgba(176, 123, 255, 0.6);
        }

        .bitacora-tag--madera {
            color: #5a3c22;
            background: rgba(255, 215, 156, 0.22);
            border-color: rgba(255, 215, 156, 0.7);
        }

        .bitacora-tag--coupage {
            color: #0f4b4c;
            background: rgba(144, 242, 201, 0.25);
            border-color: rgba(144, 242, 201, 0.7);
        }

        .bitacora-tag--clarificacion {
            color: #2f3d52;
            background: rgba(176, 196, 255, 0.2);
            border-color: rgba(176, 196, 255, 0.6);
        }

        .bitacora-tag--embotellado {
            color: #0f3f5a;
            background: rgba(126, 226, 255, 0.22);
            border-color: rgba(126, 226, 255, 0.7);
        }

        .bitacora-tag--recuento {
            color: #3c2b2b;
            background: rgba(201, 201, 201, 0.35);
            border-color: rgba(201, 201, 201, 0.8);
        }

        .bitacora-tag--nota {
            color: #3d2d3f;
            background: rgba(220, 214, 222, 0.45);
            border-color: rgba(220, 214, 222, 0.9);
        }

        .bitacora-filters {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .bitacora-filters .bitacora-row {
            gap: 8px;
        }

        .bitacora-filters small {
            color: rgba(40,18,52,0.65);
        }

        .bitacora-footer {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 12px;
        }

        @media (max-width: 1200px) {
            .copiloto-grid-superior {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 980px) {
            .copiloto-grid {
                grid-template-columns: 1fr;
            }

            .copiloto-grid-superior {
                grid-template-columns: 1fr;
            }

            .copiloto-panel.wide {
                grid-column: span 1;
            }

            .copiloto-timeline-wrap {
                grid-template-columns: 1fr;
            }

            .copiloto-timeline-filters {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .bitacora-indomita-layout {
                grid-template-columns: 1fr;
            }

            .bitacora-filters {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 640px) {
            .copiloto-timeline-filters {
                grid-template-columns: 1fr;
            }
        }

        .copiloto-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .copiloto-config-wrap {
            margin-top: 12px;
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px dashed rgba(95,44,130,0.2);
            background: rgba(255,255,255,0.6);
        }

        .copiloto-config-wrap summary {
            cursor: pointer;
            font-weight: 700;
            color: rgba(26,13,34,0.85);
            margin-bottom: 8px;
        }

        .copiloto-config {
            display: grid;
            gap: 12px;
            margin-top: 10px;
        }

        .copiloto-config-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .copiloto-config label {
            font-size: 11px;
        }

        .copiloto-config input {
            margin: 4px 0 0;
        }

        .copiloto-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(15,7,20,0.12);
            background: rgba(255,255,255,0.6);
            font-weight: 600;
            cursor: pointer;
        }

        .cata-section {
            margin-top: 32px;
        }

        .cata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .cata-card {
            background: rgba(255,255,255,0.88);
            border-radius: 20px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 16px 40px rgba(15,7,20,0.12);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cata-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .cata-card-title {
            font-weight: 700;
            color: rgba(26,13,34,0.9);
        }

        .cata-card-meta {
            font-size: 12px;
            color: rgba(40,18,52,0.7);
        }

        .cata-card-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .cata-history {
            font-size: 13px;
            color: rgba(26,13,34,0.7);
        }

        .cata-history summary {
            cursor: pointer;
            font-weight: 600;
        }

        .cata-history ul {
            padding-left: 18px;
            margin: 8px 0 0;
        }

        .cata-modal-content {
            max-width: 760px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
            background: rgba(255,255,255,0.95);
            border-radius: 22px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 10px 30px rgba(16,6,28,0.15);
        }

        th, td {
            padding: 13px;
            text-align: left;
        }

        th {
            border-bottom: 1px solid rgba(106,34,77,0.15);
            background: linear-gradient(90deg, rgba(95,44,130,0.15), rgba(241,92,146,0.15));
            font-weight: 600;
            color: var(--vino-oscuro);
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tbody tr:nth-child(even) {
            background: rgba(252,245,255,0.8);
        }

        tbody tr:hover {
            background-color: rgba(241, 92, 146, 0.08);
        }

        input, select {
            width: 100%;
            padding: 12px 14px;
            margin: 6px 0 14px;
            border-radius: 14px;
            border: 1px solid rgba(95,44,130,0.15);
            font-size: 14px;
            background: rgba(255, 255, 255, 0.85);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
            backdrop-filter: blur(4px);
        }

input:focus,
select:focus {
            outline: none;
            border-color: var(--magenta);
            box-shadow: 0 12px 25px rgba(241,92,146,0.2);
            transform: translateY(-1px);
        }

        button {
            padding: 12px 22px;
            border-radius: 14px;
            border: none;
            background: linear-gradient(120deg, #f76fb0, #5f2c82);
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            box-shadow: 0 15px 35px rgba(95, 44, 130, 0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 45px rgba(95, 44, 130, 0.4);
        }

        .small-btn {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 999px;
            background: rgba(95,44,130,0.15);
            color: var(--vino-oscuro);
            border: none;
            font-weight: 600;
            box-shadow: none;
        }

        .btnPrimario {
            width: fit-content;
        }

        .btnSecundario {
            background: transparent;
            color: var(--texto);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
        }

        .btnSecundario:hover {
            border-color: rgba(255, 255, 255, 0.7);
        }

        .btnActualizar {
            margin-bottom: 8px;
            background: var(--vino-oscuro);
            box-shadow: none;
        }

label {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: rgba(42,15,39,0.65);
}

.mensaje {
    font-size: 13px;
    color: var(--vino);
    min-height: 18px;
    margin-top: 4px;
}

.resaltado {
    animation: destello 1.5s ease;
}

@keyframes destello {
    0% { background-color: rgba(199, 144, 191, 0.3); }
    100% { background-color: transparent; }
}

        .filtros-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0 20px;
            background: rgba(255,255,255,0.65);
            padding: 22px;
            border-radius: 22px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 15px 40px rgba(17,7,30,0.12);
            backdrop-filter: blur(8px);
        }

        .filtros-movimientos > div {
            flex: 1;
            min-width: 160px;
        }

        .acciones-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
        }

        .grid-almacen {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            margin-top: 10px;
        }

        .grid-almacen > div {
            flex: 1;
            min-width: 280px;
        }

        .plano-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 360px;
            gap: 18px;
            margin-top: 14px;
            align-items: start;
        }

        .plano-editor {
            position: relative;
            border: 1px solid rgba(255,255,255,0.16);
            border-radius: 28px;
            background: linear-gradient(180deg, rgba(8,4,15,0.62), rgba(8,4,15,0.48));
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
                        inset 0 0 50px rgba(0,0,0,0.35);
            height: 80vh;
            min-height: 640px;
            overflow: auto;
        }

        .plano-editor.pan-activo {
            cursor: grab;
        }

        .plano-editor.pan-activo.panning {
            cursor: grabbing;
        }

        .plano-stage {
            position: relative;
            width: 2800px;
            height: 1600px;
            overflow: hidden;
        }

        .plano-canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 2800px;
            height: 1600px;
            transform-origin: 0 0;
            transform: scale(1);
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 24px;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.16) 1px, transparent 1px),
                linear-gradient(0deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(95,44,130,0.06) 1px, transparent 1px),
                radial-gradient(circle at 18% 22%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 82% 70%, rgba(195,169,255,0.10), transparent 60%);
            background-size: 24px 24px, 24px 24px, 120px 120px, 120px 120px, auto, auto;
            background-color: rgba(12,6,22,0.62);
            box-shadow: inset 0 0 32px rgba(0,0,0,0.28);
            backdrop-filter: blur(6px);
        }

        .plano-zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 12px 0 8px;
        }

        .plano-zoom-controls .plano-zoom-btn,
        .plano-zoom-controls .plano-zoom-label {
            border-radius: 12px;
            min-height: 38px;
        }

        .plano-zoom-controls .plano-zoom-btn {
            width: 40px;
            padding: 0;
            font-weight: 900;
            font-size: 16px;
            line-height: 1;
        }

        .plano-zoom-controls .plano-zoom-label {
            flex: 1;
            font-weight: 850;
            text-align: center;
            padding: 9px 12px;
        }

        .plano-zoom-range {
            width: 100%;
            margin: 0 0 12px;
        }

        .plano-inspector-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .plano-inspector-actions .btnSecundario,
        .plano-inspector-actions .btnPrimario {
            padding: 9px 12px;
            border-radius: 14px;
            font-size: 12px;
        }

        .plano-item.seleccionado {
            box-shadow:
                0 26px 70px rgba(0,0,0,0.40),
                0 0 0 5px rgba(243,120,156,0.16),
                0 26px 92px var(--plano-card-glow, rgba(195,169,255,0.16));
            transform: translateY(-2px);
            border-color: var(--plano-accent);
        }

        .plano-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.08);
            background:
                radial-gradient(circle at 14% 18%, rgba(243,120,156,0.12), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(195,169,255,0.10), transparent 60%),
                rgba(255,255,255,0.70);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.55);
        }

        .plano-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(47,31,59,0.12) 1px, transparent 1px),
                linear-gradient(90deg, rgba(47,31,59,0.12) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.35;
            pointer-events: none;
        }

        .plano-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .plano-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 14px rgba(0,0,0,0.20);
            border: 1px solid rgba(255,255,255,0.9);
            cursor: pointer;
            z-index: 1;
        }

        .plano-minimap-dot.deposito { background: rgba(79, 88, 104, 0.85); }
        .plano-minimap-dot.mastelone { background: rgba(139, 27, 43, 0.85); }
        .plano-minimap-dot.barrica { background: rgba(196, 138, 27, 0.90); }

        .plano-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.24), 0 0 0 6px rgba(243,120,156,0.14);
        }

        .plano-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(47,31,59,0.55);
            background: rgba(47,31,59,0.08);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.22);
            cursor: grab;
        }

        .plano-minimap-viewport:active {
            cursor: grabbing;
        }

        .plano-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(47,31,59,0.70);
        }

        .flow-minimap-world {
            position: relative;
            width: 100%;
            height: 170px;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.14);
            background:
                radial-gradient(circle at 14% 18%, rgba(176,123,255,0.18), transparent 55%),
                radial-gradient(circle at 80% 72%, rgba(255,142,199,0.16), transparent 60%),
                rgba(12,7,20,0.72);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.30);
            touch-action: none;
        }

        .flow-minimap-grid {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.10) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.10) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.28;
            pointer-events: none;
        }

        .flow-minimap-dots {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        .flow-minimap-dot {
            position: absolute;
            width: 7px;
            height: 7px;
            border-radius: 999px;
            transform: translate(-50%, -50%);
            box-shadow: 0 8px 18px rgba(0,0,0,0.30);
            border: 1px solid rgba(255,255,255,0.75);
            cursor: pointer;
            z-index: 1;
        }

        .flow-minimap-dot.entrada { background: var(--flow-accent-entrada); }
        .flow-minimap-dot.fermentacion { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.estilo { background: var(--flow-accent-estilo); }
        .flow-minimap-dot.deposito { background: var(--flow-accent-deposito); }
        .flow-minimap-dot.coupage { background: var(--flow-accent-coupage); }
        .flow-minimap-dot.barrica { background: var(--flow-accent-barrica); }
        .flow-minimap-dot.embotellado { background: var(--flow-accent-embotellado); }
        .flow-minimap-dot.almacen { background: var(--flow-accent-almacen); }
        .flow-minimap-dot.salida { background: var(--flow-accent-salida); }
        .flow-minimap-dot.prensado { background: var(--flow-accent-estilo); }

        .flow-minimap-dot.seleccionado {
            width: 10px;
            height: 10px;
            box-shadow: 0 12px 22px rgba(0,0,0,0.36), 0 0 0 6px rgba(243,120,156,0.16);
        }

        .flow-minimap-viewport {
            position: absolute;
            z-index: 2;
            border: 2px solid rgba(255,255,255,0.55);
            background: rgba(255,255,255,0.06);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.30);
            cursor: grab;
        }

        .flow-minimap-viewport:active {
            cursor: grabbing;
        }

        .flow-minimap-hint {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255,255,255,0.68);
        }

        @media (max-width: 980px) {
            .plano-layout {
                grid-template-columns: 1fr;
            }

            .flow-inspector.plano-inspector {
                position: relative;
                top: auto;
                max-height: none;
            }
        }

.plano-item {
	    position: absolute;
	    width: 148px;
	    height: var(--plano-card-h, 176px);
	    padding: 10px 10px 10px 12px;
	    padding-right: 30px;
	    border-radius: 14px;
	    color: var(--texto);
	    font-size: 12px;
	    cursor: grab;
	    user-select: none;
	    box-shadow:
	      0 22px 54px rgba(6,2,10,0.36),
	      0 28px 92px var(--plano-card-glow, rgba(195,169,255,0.20));
	    transition: box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
	    display: flex;
	    flex-direction: column;
	    gap: 8px;
	    background: var(--plano-card-bg,
	      radial-gradient(circle at 22% 14%, rgba(243,120,156,0.06), transparent 55%),
	      radial-gradient(circle at 82% 78%, rgba(195,169,255,0.06), transparent 60%),
	      linear-gradient(180deg, rgba(255,255,255,0.94), rgba(255,255,255,0.86)));
	    border: 1px solid var(--plano-accent-soft);
	    border-top: 5px solid var(--plano-accent);
	    backdrop-filter: blur(10px) saturate(1.08);
	    align-items: stretch;
	    overflow: hidden;
	    --plano-accent: rgba(143,151,168,0.95);
	    --plano-accent-soft: rgba(143,151,168,0.22);
	    --plano-accent-wash: rgba(143,151,168,0.16);
	    --plano-material: rgba(143,151,168,0.95);
	    --plano-material-wash: rgba(143,151,168,0.16);
}

.plano-item.deposito,
.plano-item.mastelone,
.plano-item.barrica {
      border-top: 0;
      padding-right: 38px;
}

.plano-item.barrica {
      border-radius: 30px / 20px;
      background:
        radial-gradient(ellipse at 50% 44%, rgba(255,255,255,0.80) 0%, rgba(255,255,255,0.80) 58%, rgba(255,255,255,0) 60%),
        linear-gradient(
          180deg,
          transparent 0%,
          transparent 18%,
          rgba(70,42,18,0.18) 18%,
          rgba(70,42,18,0.18) 21%,
          transparent 21%,
          transparent 64%,
          rgba(70,42,18,0.18) 64%,
          rgba(70,42,18,0.18) 67%,
          transparent 67%,
          transparent 100%
        ),
        repeating-linear-gradient(90deg, rgba(88,54,24,0.14) 0 2px, rgba(255,255,255,0.10) 2px 7px),
        linear-gradient(90deg, #f0d79b 0%, #c4913f 18%, #f6e2b5 48%, #b47820 78%, #f0d79b 100%);
}

.plano-item.deposito {
      border-radius: 24px;
      background:
        radial-gradient(ellipse at 50% 44%, rgba(255,255,255,0.88) 0%, rgba(255,255,255,0.88) 60%, rgba(255,255,255,0) 62%),
        radial-gradient(
          ellipse at 50% 7%,
          rgba(255,255,255,0.92) 0%,
          rgba(255,255,255,0.92) 22%,
          rgba(0,0,0,0.10) 23%,
          rgba(0,0,0,0.10) 28%,
          rgba(255,255,255,0) 29%
        ),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.03) 0 1px, rgba(255,255,255,0.06) 1px 3px),
        linear-gradient(
          90deg,
          rgba(255,255,255,0.92) 0%,
          var(--plano-material-wash) 18%,
          rgba(255,255,255,0.97) 50%,
          rgba(0,0,0,0.10) 84%,
          rgba(255,255,255,0.88) 100%
        ),
        linear-gradient(180deg, rgba(255,255,255,0.22), rgba(0,0,0,0.06));
}

.plano-item.mastelone {
      border-radius: 24px 24px 18px 18px;
      background:
        radial-gradient(ellipse at 50% 44%, rgba(255,255,255,0.86) 0%, rgba(255,255,255,0.86) 58%, rgba(255,255,255,0) 60%),
        radial-gradient(ellipse at 50% 11%, rgba(20,8,24,0.38) 0%, rgba(20,8,24,0.38) 18%, rgba(20,8,24,0.0) 19%),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.04) 0 1px, rgba(255,255,255,0.06) 1px 4px),
        linear-gradient(180deg, rgba(255,255,255,0.22), rgba(0,0,0,0.08)),
        linear-gradient(180deg, var(--plano-accent-wash), rgba(0,0,0,0.05));
}

.plano-item.barrica::before,
.plano-item.deposito::before,
.plano-item.mastelone::before {
      opacity: 0.16;
}

.plano-item::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    background:
      radial-gradient(circle at 18% 12%, var(--plano-accent) 0%, transparent 56%),
      radial-gradient(circle at 92% 86%, var(--plano-accent) 0%, transparent 60%),
      radial-gradient(circle at 10% 92%, var(--plano-material) 0%, transparent 56%),
      linear-gradient(180deg, var(--plano-accent-wash) 0%, rgba(255,255,255,0) 52%);
    opacity: 0.28;
    filter: saturate(1.28);
}

.plano-item::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,0.55),
      inset 0 1px 0 rgba(255,255,255,0.55),
      inset 0 0 0 1px rgba(0,0,0,0.08),
      inset 0 0 0 1px var(--plano-accent-soft),
      inset 0 -26px 44px rgba(0,0,0,0.04),
      inset 0 -24px 46px var(--plano-accent-wash);
    opacity: 0.9;
}

.plano-item:not(.arrastrando):hover {
    transform: translateY(-2px);
    box-shadow:
      0 30px 82px rgba(0,0,0,0.42),
      0 30px 110px var(--plano-card-glow, rgba(195,169,255,0.26));
    border-color: var(--plano-accent-soft);
}

.plano-item.arrastrando {
    opacity: 0.9;
    cursor: grabbing;
    box-shadow: 0 35px 70px rgba(0,0,0,0.45);
}

.plano-card-header {
	    display: flex;
	    flex-direction: column;
	    align-items: flex-start;
	    font-size: 12px;
	    text-transform: none;
	    letter-spacing: 0.02em;
	    font-weight: 850;
	    color: var(--vino-oscuro);
	    text-align: left;
	    gap: 6px;
	    width: 100%;
	    word-break: break-word;
	    position: relative;
	    padding-top: 0;
	    padding-right: 40px;
}

.plano-card-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
}

.plano-card-pct {
      margin-left: auto;
      padding: 2px 8px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.86), rgba(255,255,255,0.60)),
        radial-gradient(circle at 28% 22%, var(--plano-accent-wash), rgba(255,255,255,0));
      border: 1px solid var(--plano-accent-soft);
      box-shadow:
        0 10px 18px rgba(0,0,0,0.10),
        inset 0 1px 0 rgba(255,255,255,0.82);
      color: rgba(18, 12, 28, 0.88);
      font-size: 10px;
      font-weight: 950;
      letter-spacing: 0.02em;
      line-height: 1.2;
      white-space: nowrap;
}

.plano-card-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--plano-wine-dot, var(--plano-accent));
      box-shadow:
        0 10px 20px rgba(0,0,0,0.22),
        0 0 0 3px rgba(255,255,255,0.62);
      flex: 0 0 auto;
}

.plano-card-code {
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.02em;
      color: rgba(18, 12, 28, 0.96);
}

.plano-card-header small {
	    font-size: 9px;
	    color: rgba(47,31,59,0.72);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.82), rgba(255,255,255,0.56)),
        radial-gradient(circle at 18% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      border: 1px solid var(--plano-accent-soft);
      white-space: nowrap;
}

.plano-card-material-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--plano-material);
      box-shadow:
        0 8px 14px rgba(0,0,0,0.16),
        0 0 0 2px rgba(255,255,255,0.62);
      flex: 0 0 auto;
}

.plano-card-body {
	    display: flex;
	    flex-direction: column;
	    gap: 10px;
	    width: 100%;
	    flex: 1;
}

.plano-card-visual {
      display: grid;
      grid-template-columns: 44px 1fr;
      align-items: start;
      gap: 8px;
      width: 100%;
}

.plano-card-icon {
      width: 44px;
      height: 60px;
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.75),
        inset 0 -14px 18px rgba(0,0,0,0.08);
      background:
        radial-gradient(circle at 30% 22%, rgba(255,255,255,0.85), transparent 48%),
        linear-gradient(180deg, rgba(255,255,255,0.82), rgba(255,255,255,0.32));
}

.plano-item.barrica .plano-card-icon {
      border-radius: 26px / 18px;
      border: 2px solid rgba(120,74,29,0.55);
      background:
        radial-gradient(circle at 30% 18%, rgba(255,255,255,0.55), transparent 48%),
        repeating-linear-gradient(90deg,
          rgba(88,54,24,0.18) 0 2px,
          rgba(255,255,255,0.10) 2px 4px),
        linear-gradient(90deg, #f0d79b 0%, #c4913f 18%, #f6e2b5 48%, #b47820 78%, #f0d79b 100%);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.16),
        inset 0 10px 14px rgba(255,255,255,0.22),
        inset 0 -16px 20px rgba(0,0,0,0.14);
}

.plano-item.barrica .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 6px;
      right: 6px;
      top: 14px;
      height: 3px;
      border-radius: 999px;
      background: rgba(70,42,18,0.40);
      box-shadow:
        0 14px 0 rgba(70,42,18,0.34),
        0 28px 0 rgba(70,42,18,0.34);
      opacity: 0.95;
}

.plano-item.barrica .plano-card-icon::after {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 78% 18%, rgba(255,255,255,0.55), transparent 44%),
        radial-gradient(circle at 40% 88%, rgba(0,0,0,0.20), transparent 56%);
      opacity: 0.8;
}

.plano-item.deposito .plano-card-icon {
      border-radius: 18px;
      border: 2px solid rgba(86,96,114,0.35);
      background:
        radial-gradient(circle at 52% 60%, rgba(0,0,0,0.14) 0 2px, transparent 3px),
        radial-gradient(circle at 28% 16%, rgba(255,255,255,0.92), transparent 44%),
        linear-gradient(90deg,
          rgba(255,255,255,0.90) 0%,
          var(--plano-material-wash) 18%,
          rgba(255,255,255,0.96) 50%,
          rgba(0,0,0,0.10) 84%,
          rgba(255,255,255,0.86) 100%),
        linear-gradient(180deg, rgba(255,255,255,0.34), rgba(0,0,0,0.06));
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.85),
        inset 0 -16px 20px rgba(0,0,0,0.10);
}

.plano-item.deposito .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 5px;
      right: 5px;
      top: 6px;
      height: 12px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.90), rgba(255,255,255,0.18)),
        radial-gradient(circle at 35% 35%, var(--plano-material-wash), transparent 58%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.95),
        inset 0 -1px 0 rgba(0,0,0,0.12);
      opacity: 0.96;
}

.plano-item.deposito .plano-card-icon::after {
      content: "";
      position: absolute;
      left: 7px;
      right: 7px;
      bottom: 4px;
      height: 16px;
      border-radius: 0 0 18px 18px;
      clip-path: polygon(0 0, 100% 0, 66% 100%, 34% 100%);
      background:
        linear-gradient(90deg,
          rgba(255,255,255,0.90) 0%,
          var(--plano-material-wash) 22%,
          rgba(255,255,255,0.94) 52%,
          rgba(0,0,0,0.12) 86%,
          rgba(255,255,255,0.84) 100%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.85),
        0 10px 18px rgba(0,0,0,0.10);
      opacity: 0.95;
}

.plano-item.mastelone .plano-card-icon {
      border-radius: 18px 18px 16px 16px;
      border: 2px solid rgba(123,27,71,0.38);
      background:
        radial-gradient(circle at 50% 28%, rgba(0,0,0,0.18) 0 8px, transparent 9px),
        radial-gradient(circle at 30% 18%, rgba(255,255,255,0.68), transparent 48%),
        linear-gradient(180deg, var(--plano-accent-wash), rgba(0,0,0,0.04) 54%),
        linear-gradient(180deg, rgba(255,255,255,0.18), rgba(0,0,0,0.10));
      box-shadow:
        0 14px 28px rgba(0,0,0,0.14),
        inset 0 1px 0 rgba(255,255,255,0.70),
        inset 0 -16px 20px rgba(0,0,0,0.14);
}

.plano-item.mastelone .plano-card-icon::before {
      content: "";
      position: absolute;
      left: 5px;
      right: 5px;
      top: 6px;
      height: 12px;
      border-radius: 999px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,255,255,0.12)),
        radial-gradient(circle at 40% 45%, var(--plano-accent-wash), transparent 62%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.78),
        inset 0 -1px 0 rgba(0,0,0,0.16);
      opacity: 0.96;
}

.plano-item.mastelone .plano-card-icon::after {
      content: "";
      position: absolute;
      left: 7px;
      right: 7px;
      top: 11px;
      height: 10px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 50% 50%, rgba(20, 8, 24, 0.75), rgba(20,8,24,0.35));
      opacity: 0.9;
}

.plano-card-barrel {
	    width: 40px;
	    height: 52px;
	    border-radius: 26px / 18px;
	    border: 2px solid rgba(139,92,64,0.4);
	    position: relative;
	    display: flex;
	    align-items: center;
	    justify-content: center;
	    font-weight: 700;
	    flex-shrink: 0;
	    box-shadow: inset 0 -4px 0 rgba(0,0,0,0.08);
}

.plano-card-barrel span {
	    font-size: 11px;
	    letter-spacing: 0.06em;
}

.plano-card-barrel.deposito {
    background: linear-gradient(180deg, #e5e8ee, #b6bdc9);
    color: #3f4653;
    border-color: rgba(111,121,138,0.5);
}

.plano-card-barrel.mastelone {
    background: linear-gradient(180deg, #e9b2c0, #a3223c);
    color: #5a0f1f;
    border-color: rgba(163,34,60,0.55);
}

.plano-card-barrel.barrica {
    background: linear-gradient(180deg, #f3d48b, #c08c32);
    color: #5d3a0f;
    border-color: rgba(184,128,34,0.6);
}

.plano-card-barrel::before,
.plano-card-barrel::after {
    content: "";
    position: absolute;
    left: 7px;
    right: 7px;
    height: 2px;
    background: rgba(0,0,0,0.15);
    border-radius: 999px;
}

.plano-card-barrel::before {
    top: 10px;
}

.plano-card-barrel::after {
    bottom: 10px;
}

.plano-card-info {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    flex: 1;
    text-align: left;
    width: 100%;
}

.plano-card-info small {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: rgba(47,31,59,0.6);
}

.plano-card-info strong {
	    font-size: 11px;
	    font-variant-numeric: tabular-nums;
	    display: block;
	    color: var(--vino-oscuro);
}

.plano-card-extra {
	    font-size: 9px;
	    color: rgba(47,31,59,0.78);
	    text-align: left;
	    width: 100%;
      display: grid;
      gap: 2px;
      margin-top: auto;
}

.plano-card-extra-line {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
}

.plano-card-extra-line.primary {
      white-space: normal;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
}

.plano-card-anada {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--plano-accent-soft);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.86), rgba(255,255,255,0.66)),
        radial-gradient(circle at 22% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      font-size: 9px;
      font-weight: 850;
      letter-spacing: 0.02em;
      color: rgba(47,31,59,0.82);
      width: fit-content;
}

.plano-card-vacio {
      border: 1px solid rgba(0,0,0,0.10);
      box-shadow:
        0 10px 22px rgba(6,2,10,0.14),
        inset 0 1px 0 rgba(255,255,255,0.28);
      margin-top: 2px;
      width: fit-content;
      cursor: default;
}

.plano-card-vacio.estado-vacio {
      background: linear-gradient(180deg, #a9b1bf, #8f97a8);
}

.plano-card-uvas {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: stretch;
      line-height: 1.15;
      margin-top: 2px;
}

.plano-card-uva-chip {
      display: inline-flex;
      align-items: flex-start;
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid var(--plano-accent-soft);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.92), rgba(255,255,255,0.70)),
        radial-gradient(circle at 22% 40%, var(--plano-accent-wash), rgba(255,255,255,0));
      color: rgba(18, 12, 28, 0.94);
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.01em;
      width: 100%;
      max-width: 100%;
      white-space: normal;
      overflow: visible;
      text-overflow: initial;
      word-break: break-word;
      line-height: 1.15;
}

.plano-card-progress {
	    position: absolute;
	    top: 10px;
	    right: 8px;
	    width: 18px;
	    height: calc(100% - 20px);
	    background:
	      linear-gradient(180deg, rgba(255,255,255,0.66), rgba(255,255,255,0.34)),
	      radial-gradient(circle at 30% 18%, var(--plano-accent-wash), rgba(255,255,255,0));
	    border-radius: 999px;
	    overflow: hidden;
	    display: flex;
	    align-items: flex-end;
	    justify-content: center;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.70),
        inset 0 0 0 1px var(--plano-accent-soft);
}

.plano-card-progress-bar {
    width: 100%;
    border-radius: 999px;
    transition: height 0.3s ease;
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,0.22),
      inset 0 -10px 18px rgba(0,0,0,0.10);
}

.plano-card-progress span {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%) rotate(-90deg);
      transform-origin: center;
      font-size: 9px;
      font-weight: 950;
      letter-spacing: 0.02em;
      color: rgba(18, 12, 28, 0.80);
      text-shadow: 0 1px 0 rgba(255,255,255,0.70);
      pointer-events: none;
      user-select: none;
}

        #planoMensaje {
            margin-top: 14px;
            color: rgba(255,255,255,0.85);
            font-size: 14px;
        }

	        .plano-placeholder {
	            position: absolute;
	            top: 50%;
	            left: 50%;
	            transform: translate(-50%, -50%);
	            color: rgba(255,255,255,0.7);
	            font-size: 14px;
	        }

	        /* =====================
	           UI Refresh (especial: mapa de nodos)
	        ===================== */
	        :root {
	            --ui-focus: rgba(243,120,156,0.55);
	            --flow-surface: rgba(12, 7, 20, 0.72);
	            --flow-surface-2: rgba(26, 16, 38, 0.78);
	            --flow-border: rgba(255,255,255,0.14);
	            --flow-border-2: rgba(255,255,255,0.22);
	            --flow-text: rgba(255,255,255,0.92);
	            --flow-muted: rgba(255,255,255,0.68);
	            --flow-grid-dot: rgba(255,255,255,0.08);
	            --flow-grid-dot-strong: rgba(255,255,255,0.14);
	            --flow-accent-entrada: #ff8ec7;
	            --flow-accent-estilo: #b07bff;
	            --flow-accent-deposito: #f3c77b;
	            --flow-accent-barrica: #c2a9ff;
	            --flow-accent-coupage: #90f2c9;
	            --flow-accent-embotellado: #7ee2ff;
	            --flow-accent-almacen: #c2c9ff;
	            --flow-accent-salida: #ff7aa8;
	        }

	        :focus-visible {
	            outline: 2px solid var(--ui-focus);
	            outline-offset: 3px;
	        }

	        #flujo .flow-toolbar {
	            position: sticky;
	            top: 86px;
	            z-index: 6;
	            padding: 14px;
	            border-radius: 22px;
	            background: rgba(255,255,255,0.78);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 18px 45px rgba(0,0,0,0.22);
	            backdrop-filter: blur(14px);
	        }

	        #flujo .flow-toolbar-group {
	            padding: 6px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.40);
	            border: 1px solid rgba(0,0,0,0.06);
	        }

	        #flujo .flow-toolbar-group button {
	            margin-top: 0;
	        }

	        #flujo .flow-toolbar .btnPrimario,
	        #flujo .flow-toolbar .btnSecundario {
	            border-radius: 999px;
	            padding: 10px 14px;
	            min-height: 40px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            gap: 8px;
	        }

	        #flujo .flow-toolbar .btnSecundario {
	            background: rgba(255,255,255,0.55);
	            border-color: rgba(0,0,0,0.10);
	        }

	        #flujo .flow-toolbar .btnSecundario:hover {
	            border-color: rgba(0,0,0,0.18);
	        }

	        .flow-layout {
	            display: grid;
	            grid-template-columns: minmax(0, 1fr) 360px;
	            gap: 18px;
	            margin-top: 14px;
	            align-items: start;
	        }

	        #flujo .flow-helper {
	            margin-top: 16px;
	            padding: 12px 14px;
	            border-radius: 18px;
	            background: rgba(255,255,255,0.60);
	            border: 1px solid rgba(255,255,255,0.55);
	            box-shadow: 0 14px 35px rgba(0,0,0,0.14);
	        }

	        #flujo .flow-helper p {
	            margin: 0;
	            color: rgba(47,31,59,0.78);
	        }

	        .flow-inspector {
	            position: sticky;
	            top: 126px;
	            max-height: calc(100vh - 156px);
	            overflow: auto;
	            margin-top: 0;
	            border-radius: 24px;
	            padding: 16px;
	            background: rgba(255,255,255,0.88);
	            border: 1px solid rgba(255,255,255,0.65);
	            box-shadow: 0 22px 60px rgba(11, 5, 21, 0.22);
	        }

	        .flow-inspector .flow-inspector-header {
	            display: flex;
	            gap: 12px;
	            align-items: center;
	            margin-bottom: 14px;
	        }

	        .flow-inspector .flow-inspector-icon {
	            width: 44px;
	            height: 44px;
	            border-radius: 16px;
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            background: radial-gradient(circle at 25% 20%, rgba(255, 230, 180, 0.6), transparent 45%),
	                        linear-gradient(135deg, rgba(243,199,123,0.85), rgba(243,120,156,0.75), rgba(155,93,229,0.75));
	            box-shadow: 0 18px 40px rgba(0,0,0,0.2);
	            color: #140818;
	            font-weight: 900;
	        }

	        .flow-inspector .flow-inspector-title {
	            font-weight: 800;
	            font-size: 14px;
	            color: var(--vino-oscuro);
	            letter-spacing: 0.02em;
	        }

	        .flow-inspector .flow-inspector-sub {
	            margin-top: 2px;
	            font-size: 12px;
	            color: rgba(47,31,59,0.68);
	        }

	        .flow-inspector .flow-inspector-tags {
	            display: flex;
	            flex-wrap: wrap;
	            gap: 8px;
	            margin: 10px 0 14px;
	        }

	        .flow-inspector .flow-tag {
	            display: inline-flex;
	            align-items: center;
	            padding: 6px 10px;
	            border-radius: 999px;
	            border: 1px solid rgba(0,0,0,0.08);
	            background: rgba(255,255,255,0.65);
	            font-size: 11px;
	            font-weight: 700;
	            letter-spacing: 0.02em;
	            color: rgba(47,31,59,0.82);
	        }

	        .flow-inspector .flow-inspector-fields {
	            display: grid;
	            gap: 10px;
	            margin: 0;
	        }

	        .flow-inspector .flow-field {
	            display: grid;
	            grid-template-columns: 1fr 1fr;
	            gap: 10px;
	            padding: 10px 12px;
	            border-radius: 16px;
	            background: rgba(255,255,255,0.68);
	            border: 1px solid rgba(0,0,0,0.06);
	        }

	        .flow-inspector .flow-field dt {
	            margin: 0;
	            font-size: 11px;
	            font-weight: 800;
	            text-transform: uppercase;
	            letter-spacing: 0.09em;
	            color: rgba(47,31,59,0.55);
	        }

		        .flow-inspector .flow-field dd {
		            margin: 0;
		            font-size: 12px;
		            font-weight: 650;
		            color: rgba(47,31,59,0.88);
		            text-align: right;
		            display: -webkit-box;
		            -webkit-box-orient: vertical;
		            -webkit-line-clamp: 6;
		            overflow: hidden;
		            white-space: pre-line;
		            word-break: break-word;
		        }

	        #flujo .flow-editor {
	            border: 1px solid rgba(255,255,255,0.16);
	            border-radius: 28px;
	            background: linear-gradient(180deg, rgba(8,4,15,0.62), rgba(8,4,15,0.48));
	            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06),
	                        inset 0 0 50px rgba(0,0,0,0.35);
	            overflow: auto;
	        }

	        #flujo .flow-stage {
	            min-width: 1400px;
	        }

	        #flujo .flow-canvas {
	            background-image:
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot) 1.25px, transparent 0),
	                radial-gradient(circle at 1px 1px, var(--flow-grid-dot-strong) 1.35px, transparent 0),
	                radial-gradient(circle at 18% 18%, rgba(243,120,156,0.10), transparent 50%),
	                radial-gradient(circle at 70% 10%, rgba(195,169,255,0.10), transparent 55%),
	                radial-gradient(circle at 82% 72%, rgba(243,199,123,0.08), transparent 55%);
	            background-size: 28px 28px, 112px 112px, auto, auto, auto;
	            background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
	        }

	        #flowCanvas[data-mode="connecting"] {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node {
	            cursor: crosshair;
	        }

	        #flowCanvas[data-mode="connecting"] .flow-node:not(.is-connect-source):hover {
	            border-color: rgba(116,245,162,0.55);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45), 0 0 0 6px rgba(116,245,162,0.10);
	        }

	        #flujo .flow-connector-line {
	            stroke: rgba(255,255,255,0.55);
	            stroke-width: 2.4;
	            filter: drop-shadow(0 10px 18px rgba(0,0,0,0.35));
	        }

	        #flujo .flow-connector-line.type-entrada { stroke: rgba(255,142,199,0.78); }
	        #flujo .flow-connector-line.type-estilo { stroke: rgba(176,123,255,0.78); }
	        #flujo .flow-connector-line.type-deposito { stroke: rgba(243,199,123,0.78); }
	        #flujo .flow-connector-line.type-barrica { stroke: rgba(255,215,156,0.78); }
	        #flujo .flow-connector-line.type-coupage { stroke: rgba(144,242,201,0.78); }
	        #flujo .flow-connector-line.type-embotellado { stroke: rgba(126,226,255,0.78); }
	        #flujo .flow-connector-line.type-almacen { stroke: rgba(194,201,255,0.78); }
	        #flujo .flow-connector-line.type-salida { stroke: rgba(255,122,168,0.78); }

	        #flujo .flow-connector-line.is-highlight {
	            stroke-width: 3.2;
	            opacity: 0.95;
	            filter: drop-shadow(0 12px 22px rgba(0,0,0,0.45));
	        }

	        #flujo .flow-connector-label {
	            font-weight: 750;
	            letter-spacing: 0.02em;
	            paint-order: stroke fill;
	            stroke: rgba(0,0,0,0.60);
	            stroke-width: 4px;
	        }

        #flujo .flow-node {
            min-width: 120px;
            padding: 6px 6px 30px;
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(34, 20, 52, 0.92), rgba(19, 10, 30, 0.82));
            border: 1px solid var(--flow-border);
            box-shadow: 0 16px 36px rgba(0,0,0,0.36);
            backdrop-filter: blur(10px);
            color: var(--flow-text);
            text-transform: none;
            letter-spacing: 0.2px;
        }

	        #flujo .flow-node::after {
	            content: "";
	            position: absolute;
	            left: 8px;
	            right: 8px;
	            top: 6px;
	            height: 2px;
	            border-radius: 999px;
	            background: var(--flow-accent, rgba(255,255,255,0.25));
	            opacity: 0.95;
	        }

	        #flujo .flow-node[data-tipo="entrada"] { --flow-accent: var(--flow-accent-entrada); }
	        #flujo .flow-node[data-tipo="estilo"] { --flow-accent: var(--flow-accent-estilo); }
	        #flujo .flow-node[data-tipo="deposito"] { --flow-accent: var(--flow-accent-deposito); }
	        #flujo .flow-node[data-tipo="barrica"] { --flow-accent: var(--flow-accent-barrica); }
	        #flujo .flow-node[data-tipo="coupage"] { --flow-accent: var(--flow-accent-coupage); }
	        #flujo .flow-node[data-tipo="embotellado"] { --flow-accent: var(--flow-accent-embotellado); }
	        #flujo .flow-node[data-tipo="almacen"] { --flow-accent: var(--flow-accent-almacen); }
	        #flujo .flow-node[data-tipo="salida"] { --flow-accent: var(--flow-accent-salida); }

	        /* Depósitos: matizar el acento según el color real del vino */
	        #flujo .flow-node[data-tipo="deposito"][data-vino="red"] { --flow-accent: #d43c68; }
	        #flujo .flow-node[data-tipo="deposito"][data-vino="rosado"] { --flow-accent: #f58bb5; }

	        #flujo .flow-node:hover {
	            border-color: var(--flow-border-2);
	            box-shadow: 0 26px 70px rgba(0,0,0,0.45);
	        }

	        #flujo .flow-node.is-selected {
	            border-color: rgba(243,120,156,0.55);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(243,120,156,0.12);
	        }

	        #flujo .flow-node.is-connect-source {
	            border-color: rgba(195,169,255,0.65);
	            box-shadow: 0 30px 90px rgba(0,0,0,0.55), 0 0 0 6px rgba(195,169,255,0.12);
	        }

	        #flujo .flow-node-header {
	            display: flex;
	            align-items: center;
	            gap: 6px;
	            margin: 3px 0 6px;
	        }

	        #flujo .flow-node-icon {
	            width: 20px;
	            height: 20px;
	            border-radius: 10px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            background: rgba(255,255,255,0.10);
	            border: 1px solid rgba(255,255,255,0.12);
	            box-shadow: 0 10px 20px rgba(0,0,0,0.22);
	            font-size: 13px;
	        }

        #flujo .flow-node h4 {
            font-size: 9px;
            margin: 0;
            font-weight: 850;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            text-align: left;
        }

        #flujo .flow-node-body {
            padding-right: 0;
            align-items: flex-start;
            text-align: left;
            gap: 3px;
        }

        #flujo .flow-node-subtitle {
            font-size: 10px;
            color: rgba(255,255,255,0.78);
            text-align: left;
            line-height: 1.2;
            max-width: 100%;
        }
        #flujo .flow-node-subtitle.flow-node-metodo {
            font-weight: 700;
            font-size: 12px;
        }

        #flujo .flow-node-subtitle.flow-subtitle-variedad {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 4;
            overflow: hidden;
            white-space: pre-line;
        }

        #flujo .flow-node .flow-unit {
            padding: 1px 4px;
            border-radius: 999px;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(255,255,255,0.14);
            color: rgba(255,255,255,0.92);
            font-size: 8px;
            letter-spacing: 0.04em;
        }

        #flujo .flow-node .flow-node-controls {
            bottom: 8px;
            right: 8px;
            gap: 5px;
        }

        #flujo .flow-node .flow-node-controls button {
            width: 20px;
            height: 20px;
            border-radius: 9px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.10);
            margin: 0;
            padding: 0;
            box-shadow: 0 10px 18px rgba(0,0,0,0.24);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        #flujo .flow-node .flow-node-controls button:hover {
            transform: translateY(-1px);
            border-color: rgba(255,255,255,0.22);
            box-shadow: 0 18px 34px rgba(0,0,0,0.32);
        }

        #flujo .flow-node .flow-node-controls button::before {
            display: none;
        }

        #flujo .flow-node .flow-node-controls button.blue {
            background: linear-gradient(180deg, rgba(109,168,255,0.30), rgba(109,168,255,0.10));
        }

        #flujo .flow-node .flow-node-controls button.green {
            background: linear-gradient(180deg, rgba(116,245,162,0.26), rgba(116,245,162,0.10));
        }

        #flujo .flow-node .flow-node-controls button.red {
            background: linear-gradient(180deg, rgba(255,122,122,0.28), rgba(255,122,122,0.10));
        }

        #flujo .flow-node .flow-node-controls button.blue::after {
            content: "✎";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.green::after {
            content: "⟶";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.red::after {
            content: "✕";
            font-size: 12px;
            color: rgba(255,255,255,0.95);
        }

        #flujo .flow-node .flow-node-controls button.menu {
            background: linear-gradient(180deg, rgba(154,165,185,0.28), rgba(154,165,185,0.12));
        }

        #flujo .flow-node .flow-node-controls button.menu::after {
            content: "⋯";
            font-size: 14px;
            color: rgba(255,255,255,0.95);
            line-height: 1;
        }

        #flujo .flow-node .flow-node-controls button.conectando {
            outline: 2px solid rgba(243,120,156,0.55);
            outline-offset: 2px;
        }

        #flujo .flow-node.menu-open {
            overflow: visible;
        }

        #flujo .flow-node .flow-node-menu {
            right: 8px;
            bottom: 36px;
            min-width: 170px;
        }

        #flowModal.flow-modal {
            background: rgba(4, 2, 8, 0.62);
            backdrop-filter: blur(10px);
            padding: 110px 20px 40px;
        }

	        #flowModal .flow-modal-content {
	            border-radius: 24px;
	            border: 1px solid rgba(255,255,255,0.65);
	            background: rgba(255,255,255,0.94);
	            box-shadow: 0 40px 90px rgba(0,0,0,0.55);
	            max-height: calc(100vh - 160px);
	            overflow: auto;
	        }

	        #flowModalTitulo {
	            margin: 4px 0 14px;
	            font-size: 18px;
	            letter-spacing: 0.02em;
	        }

	        #flowModal .flow-modal-content form label {
	            margin-top: 12px;
	            display: block;
	            font-weight: 800;
	            font-size: 12px;
	            letter-spacing: 0.08em;
	            text-transform: uppercase;
	            color: rgba(47,31,59,0.65);
	        }

	        #flowModal .flow-modal-content form input,
	        #flowModal .flow-modal-content form textarea,
	        #flowModal .flow-modal-content form select {
	            border-radius: 14px;
	            border: 1px solid rgba(95,44,130,0.18);
	            background: rgba(255,255,255,0.88);
	            transition: border-color 0.2s, box-shadow 0.2s;
	        }

	        #flowModal .flow-modal-content form input:focus,
	        #flowModal .flow-modal-content form textarea:focus,
	        #flowModal .flow-modal-content form select:focus {
	            outline: none;
	            border-color: rgba(243,120,156,0.75);
	            box-shadow: 0 0 0 4px rgba(243,120,156,0.18);
	        }

	        #flowModal .flow-modal-actions {
	            position: sticky;
	            bottom: -10px;
	            background: rgba(255,255,255,0.94);
	            padding: 14px 0 2px;
	            margin-top: 18px;
	            border-top: 1px solid rgba(0,0,0,0.06);
	        }

	        @media (max-width: 1100px) {
	            #flujo .flow-toolbar {
	                position: static;
	                top: auto;
	            }
	            .flow-layout {
	                grid-template-columns: 1fr;
	            }
	            .flow-inspector {
	                position: relative;
	                top: auto;
	                max-height: none;
	            }
	        }

	        @media (prefers-reduced-motion: reduce) {
	            *, *::before, *::after {
	                animation-duration: 0.01ms !important;
	                animation-iteration-count: 1 !important;
	                transition-duration: 0.01ms !important;
	                scroll-behavior: auto !important;
	            }
	        }
	    </style>
	    <style id="modernUiTheme">
	        :root {
	            --vino-oscuro: #120612;
	            --vino: #6b1036;
	            --magenta: #ff4d97;
	            --rose: #fff3f8;
	            --arena: #f8f2ff;
	            --oro: #f3c77b;
	            --texto: #1c1024;
	            --accent: #c2a9ff;
	            --linea: rgba(255, 255, 255, 0.34);
	            --gris-ligero: rgba(255,255,255,0.62);

	            --ui-bg0: #07030b;
	            --ui-bg1: #1a0f26;
	            --ui-surface: rgba(255,255,255,0.92);
	            --ui-surface-2: rgba(255,255,255,0.72);
	            --ui-surface-3: rgba(255,255,255,0.58);
	            --ui-border: rgba(255,255,255,0.42);
	            --ui-border-strong: rgba(255,255,255,0.62);
	            --ui-border-dark: rgba(255,255,255,0.14);
	            --ui-shadow-lg: 0 32px 90px rgba(0,0,0,0.45);
	            --ui-shadow-md: 0 20px 60px rgba(0,0,0,0.30);
	            --ui-shadow-sm: 0 12px 30px rgba(0,0,0,0.18);
	            --ui-radius-xl: 30px;
	            --ui-radius-lg: 24px;
	            --ui-radius-md: 16px;
	            --ui-radius-sm: 12px;
	            --ui-focus: rgba(255, 77, 151, 0.45);
	        }

	        body {
	            background:
	                radial-gradient(circle at 16% 18%, rgba(255, 142, 199, 0.14), transparent 48%),
	                radial-gradient(circle at 82% 10%, rgba(195, 169, 255, 0.16), transparent 52%),
	                radial-gradient(circle at 70% 85%, rgba(243, 199, 123, 0.10), transparent 55%),
	                linear-gradient(180deg, var(--ui-bg1), var(--ui-bg0) 60%);
	            color: var(--texto);
	        }

	        body::before,
	        body::after {
	            opacity: 0.7;
	            filter: blur(22px);
	        }

	        :focus-visible {
	            outline: 2px solid var(--ui-focus);
	            outline-offset: 3px;
	        }

	        .topbar {
	            padding: 10px 18px;
	            background: rgba(8, 4, 15, 0.22);
	            border-bottom: 1px solid rgba(255,255,255,0.10);
	            backdrop-filter: blur(16px);
	        }

	        .topbar-title button {
	            border-radius: 26px;
	            padding: 14px 22px;
	            box-shadow:
	                0 18px 48px rgba(0,0,0,0.45),
	                0 0 0 1px rgba(255,255,255,0.14) inset,
	                0 0 0 7px rgba(255,255,255,0.05);
	        }

	        .topbar-title .marca {
	            font-size: 34px;
	        }

	        .topbar-title .submarca {
	            letter-spacing: 5px;
	            font-size: 18px;
	        }

	        .user-chip {
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            width: 46px;
	            height: 46px;
	            border-radius: 999px;
	            border: 1px solid rgba(255,255,255,0.16);
	            background: rgba(255,255,255,0.06);
	            color: rgba(255,255,255,0.92);
	            font-weight: 900;
	            box-shadow: 0 18px 45px rgba(0,0,0,0.35);
	            backdrop-filter: blur(16px);
	            cursor: default;
	        }

	        .nav-dropdown-menu {
	            border-radius: 22px;
	            border: 1px solid rgba(255,255,255,0.14);
	            box-shadow: var(--ui-shadow-lg);
	        }

	        .nav-item-hidden {
	            display: none !important;
	        }

	        .card {
	            background: var(--ui-surface);
	            border-radius: var(--ui-radius-xl);
	            border: 1px solid var(--ui-border);
	            box-shadow: var(--ui-shadow-md);
	        }

	        .card::before {
	            opacity: 0.55;
	        }

	        .card .card {
	            background: var(--ui-surface-2);
	            border-radius: var(--ui-radius-lg);
	            border: 1px solid rgba(255,255,255,0.38);
	            box-shadow: var(--ui-shadow-sm);
	        }

	        .chart-card {
	            background: var(--ui-surface-3);
	            border-radius: var(--ui-radius-lg);
	            border: 1px solid rgba(255,255,255,0.30);
	        }

	        .indicador-card {
	            background: var(--ui-surface-2);
	            border-radius: var(--ui-radius-lg);
	            box-shadow: 0 14px 40px rgba(20,8,32,0.16);
	        }

	        table {
	            border-radius: 22px;
	            border: 1px solid rgba(255,255,255,0.32);
	            box-shadow: 0 12px 34px rgba(16,6,28,0.12);
	        }

	        th {
	            background: linear-gradient(90deg, rgba(95,44,130,0.10), rgba(241,92,146,0.10));
	        }

	        input,
	        select,
	        textarea {
	            border-radius: 14px;
	            border: 1px solid rgba(95,44,130,0.16);
	            background: rgba(255,255,255,0.86);
	            box-shadow: inset 0 1px 0 rgba(255,255,255,0.65);
	        }

	        input:focus,
	        select:focus,
	        textarea:focus {
	            border-color: rgba(255, 77, 151, 0.70);
	            box-shadow: 0 0 0 4px rgba(255, 77, 151, 0.16);
	            transform: translateY(-1px);
	        }

	        button {
	            border-radius: 14px;
	            background: linear-gradient(120deg, rgba(255, 77, 151, 0.95), rgba(95, 44, 130, 0.95));
	            box-shadow: 0 16px 42px rgba(95, 44, 130, 0.28);
	        }

	        button:hover {
	            box-shadow: 0 22px 60px rgba(95, 44, 130, 0.33);
	        }

	        .btnSecundario {
	            --btn-sec-bg: rgba(15, 7, 20, 0.06);
	            --btn-sec-border: rgba(18, 12, 28, 0.14);
	            --btn-sec-text: rgba(18, 12, 28, 0.92);
	            --btn-sec-bg-hover: rgba(15, 7, 20, 0.08);
	            --btn-sec-border-hover: rgba(18, 12, 28, 0.20);
	            background: var(--btn-sec-bg);
	            color: var(--btn-sec-text);
	            border: 1px solid var(--btn-sec-border);
	            box-shadow: none;
	        }

	        .btnSecundario:hover {
	            background: var(--btn-sec-bg-hover);
	            border-color: var(--btn-sec-border-hover);
	            transform: translateY(-1px);
	        }

	        .flow-replay-bar,
	        .nav-dropdown-menu {
	            --btn-sec-bg: rgba(255,255,255,0.08);
	            --btn-sec-border: rgba(255,255,255,0.18);
	            --btn-sec-text: rgba(255,255,255,0.92);
	            --btn-sec-bg-hover: rgba(255,255,255,0.12);
	            --btn-sec-border-hover: rgba(255,255,255,0.26);
	        }

	        .small-btn {
	            background: rgba(15, 7, 20, 0.08);
	            border: 1px solid rgba(18, 12, 28, 0.10);
	            border-radius: 999px;
	            padding: 8px 14px;
	        }

	        .metric-card {
	            display: flex;
	            flex-direction: column;
	            gap: 8px;
	            padding: 22px;
	            border-radius: 24px;
	            background: rgba(255,255,255,0.70);
	            border: 1px solid rgba(255,255,255,0.34);
	            box-shadow: 0 18px 52px rgba(11, 5, 21, 0.18);
	        }

	        .metric-value {
	            font-size: 34px;
	            font-weight: 900;
	            letter-spacing: 0.2px;
	            margin: 0;
	            color: rgba(18, 12, 28, 0.92);
	            font-variant-numeric: tabular-nums;
	        }

	        .toast {
	            border: 1px solid rgba(255,255,255,0.14);
	            backdrop-filter: blur(16px);
	        }

	        .toast-icon {
	            font-size: 16px;
	            filter: drop-shadow(0 6px 14px rgba(0,0,0,0.25));
	        }

	        .toast-text {
	            flex: 1;
	        }
	    </style>
    <!-- Librerías para exportar PDF de la tabla de control -->
    <!-- Integridad eliminada por fallo SRI; pendiente fijar hash correcto o self-host -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js" referrerpolicy="no-referrer"></script>
</head>
<script type="module" src="/js/app.js"></script>


<body>
    <div id="appAlerts" class="app-alerts"></div>
    <!-- Top navigation -->
    <div class="topbar">
        <div class="topbar-title">
            <button type="button" id="navToggle">
                <span class="microbrand">MicroCellerStudio</span>
                <span class="marca" id="marcaTexto">Bodega VegaLuna</span>
                <span class="submarca" id="submarcaTexto"></span>
                <span class="caret">▼</span>
            </button>
            <div class="nav-dropdown-menu" id="navMenu">
                <a href="#" data-section="bodega" data-keywords="inicio home dashboard bodega resumen" onclick="cerrarNavMenu(); mostrarSeccion('bodega')">🏠 Resumen</a>
                <a href="#" data-section="entradas" data-keywords="uva entrada vendimia kilos" onclick="cerrarNavMenu(); mostrarSeccion('entradas')">🍇 Entradas de uva</a>
                <a href="#" data-section="depositos" data-keywords="deposito depositos tanque mastelone mastelones" onclick="cerrarNavMenu(); mostrarSeccion('depositos')">🛢 Depósitos</a>
	                <a href="#" data-section="barricas" data-keywords="barrica barricas crianza madera maderas roble" onclick="cerrarNavMenu(); mostrarSeccion('barricas')" class="nav-barricas-link">
	                    <img src="/barricas.png" alt="Maderas" class="nav-barricas-icon" />
	                    Maderas
	                </a>
                <a href="#" data-section="plano" data-keywords="plano mapa bodega ubicacion" onclick="cerrarNavMenu(); mostrarSeccion('plano')">🗺 Plano bodega</a>
                <a href="#" data-section="flujo" data-keywords="flujo nodos mapa nodos replay" onclick="cerrarNavMenu(); mostrarSeccion('flujo')">🔗 Mapa de nodos</a>
                <a href="#" data-section="bitacora" data-keywords="bitacora cuaderno notas diario vino" onclick="cerrarNavMenu(); mostrarSeccion('bitacora')">📕 Bitácora</a>
                <a href="#" data-section="embotellado" data-keywords="embotellado botellas botella lote" onclick="cerrarNavMenu(); mostrarSeccion('embotellado')">🍾 Embotellado</a>
                <a href="#" data-section="enologicos" data-keywords="enologicos aditivos productos sulfuroso" onclick="cerrarNavMenu(); mostrarSeccion('enologicos')">🧪 Productos enológicos</a>
                <a href="#" data-section="analiticos" data-keywords="analiticos analitica registros" onclick="cerrarNavMenu(); mostrarSeccion('analiticos')">📊 Registros analíticos</a>
                <a href="#" data-section="analisisLab" data-keywords="analisis laboratorio lab pdf" onclick="cerrarNavMenu(); mostrarSeccion('analisisLab')">📄 Análisis laboratorio</a>
                <a href="#" data-section="limpieza" data-keywords="limpieza almacen productos limpieza" onclick="cerrarNavMenu(); mostrarSeccion('limpieza')">🧽 Almacén limpieza</a>
                <a href="#" id="navLogout" data-keywords="logout salir cerrar sesion">🚪 Cerrar sesión</a>
            </div>
        </div>
        <button type="button" class="user-chip" id="userBadge" title="Usuario activo">—</button>
    </div>

    <div id="flowTooltip" class="flow-tooltip" role="tooltip"></div>

    <!-- Contenido principal -->
    <div class="content">

        <!-- SECCIÓN BODEGA (RESUMEN GENERAL) -->
        <section id="bodega" class="card visible">
            <h1><span class="h1-emoji">🏠</span>Resumen de la bodega</h1>
            <p>Visión rápida de cómo va todo.</p>

            <div class="copiloto-shell">
                <div class="copiloto-header">
                    <div class="copiloto-header-main">
                        <div class="copiloto-title-row">
                            <h2 class="copiloto-title">🧭 Copiloto de bodega</h2>
                            <div class="copiloto-date">
                                <span id="copilotoFecha">—</span>
                                <span class="copiloto-campania" id="copilotoCampania">Campaña —</span>
                            </div>
                        </div>
                        <p class="copiloto-subtitle">Cabina de mando diaria para saber qué está vivo y qué pide atención.</p>
                        <div class="copiloto-chips">
                            <span class="copiloto-chip" id="copilotoFermentaciones">Fermentaciones activas: —</span>
                            <span class="copiloto-chip" id="copilotoCrianza">Contenedores en crianza: —</span>
                            <span class="copiloto-chip" id="copilotoPendientes">0 alertas activas</span>
                            <span class="copiloto-chip" id="copilotoEstado">Estado: calibrando</span>
                            <span class="copiloto-chip" id="copilotoActualizado">Última lectura: —</span>
                        </div>
                    </div>
                    <div class="copiloto-actions">
                        <button type="button" class="btnSecundario" id="copilotoToggleExpert">Modo experto: OFF</button>
                        <button type="button" class="btnSecundario" id="copilotoToggleNotif">Notificaciones: OFF</button>
                        <button type="button" class="btnPrimario" id="copilotoRefresh">Actualizar ahora</button>
                    </div>
                </div>
                <div class="copiloto-grid">
                    <div class="copiloto-grid-superior">
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Lo que está vivo</h3>
                                    <p class="copiloto-panel-sub">Depósitos en fermentación y crianzas activas.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoVivo" class="copiloto-live">
                                    <div class="copiloto-empty">Sin contenedores activos todavía.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Atención / Alertas</h3>
                                    <p class="copiloto-panel-sub">Prioriza lo urgente sin ruido.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoAlertas" class="copiloto-alerts">
                                    <div class="copiloto-empty">Sin alertas todavía.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Acción inmediata</h3>
                                    <p class="copiloto-panel-sub">Lo siguiente que toca hacer ahora.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoTareas" class="copiloto-tareas">
                                    <div class="copiloto-empty">Sin tareas pendientes.</div>
                                </div>
                            </div>
                        </div>
                        <div class="copiloto-panel">
                            <div class="copiloto-panel-head">
                                <div>
                                    <h3>Última actividad</h3>
                                    <p class="copiloto-panel-sub">Últimos eventos de Express, Control y notas.</p>
                                </div>
                            </div>
                            <div class="copiloto-panel-body">
                                <div id="copilotoActividad" class="copiloto-activity">
                                    <div class="copiloto-empty">Sin actividad reciente.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="copiloto-panel wide">
                        <div class="copiloto-panel-head">
                            <div>
                                <h3>Acciones directas</h3>
                                <p class="copiloto-panel-sub">Entrar, revisar y decidir en un toque.</p>
                            </div>
                        </div>
                        <div class="copiloto-actions-grid">
                            <button type="button" class="btnPrimario" id="copilotoAccionExpress">Nuevo registro Express</button>
                            <button type="button" class="btnSecundario" id="copilotoAccionDepositos">Ver depósitos</button>
                            <button type="button" class="btnSecundario" id="copilotoAccionBarricas">Ver maderas</button>
                            <button type="button" class="btnSecundario" id="copilotoAccionMovimientos">Bitácora</button>
                        </div>
                        <details class="copiloto-config-wrap">
                            <summary>Reglas del copiloto</summary>
                            <form id="copilotoConfig" class="copiloto-config">
                                <div class="copiloto-config-row">
                                    <div>
                                        <label>Horas sin bajar densidad</label>
                                        <input type="number" id="copilotoParadaHoras" min="1" step="1">
                                    </div>
                                    <div>
                                        <label>Delta densidad mínimo</label>
                                        <input type="number" id="copilotoParadaDelta" min="0" step="0.1">
                                    </div>
                                </div>
                                <div class="copiloto-config-row">
                                    <div>
                                        <label>Temp max tinto (°C)</label>
                                        <input type="number" id="copilotoTempTinto" min="0" step="0.1">
                                    </div>
                                    <div>
                                        <label>Temp max blanco (°C)</label>
                                        <input type="number" id="copilotoTempBlanco" min="0" step="0.1">
                                    </div>
                                    <div>
                                        <label>Temp max rosado (°C)</label>
                                        <input type="number" id="copilotoTempRosado" min="0" step="0.1">
                                    </div>
                                </div>
                                <div class="copiloto-config-row">
                                    <div>
                                        <label>Horas sin movimiento</label>
                                        <input type="number" id="copilotoOxidacionHoras" min="1" step="1">
                                    </div>
                                    <div>
                                        <label>Llenado mínimo (%)</label>
                                        <input type="number" id="copilotoOxidacionLlenado" min="10" max="100" step="1">
                                    </div>
                                </div>
                                <div class="copiloto-config-row">
                                    <div>
                                        <label>Horas sin analítica</label>
                                        <input type="number" id="copilotoAnaliticaHoras" min="1" step="1">
                                    </div>
                                    <div>
                                        <label>Auto refresco (min)</label>
                                        <input type="number" id="copilotoRefreshMin" min="1" step="1">
                                    </div>
                                </div>
                                <button type="button" class="btnSecundario" id="copilotoGuardar">Guardar reglas</button>
                            </form>
                        </details>
                    </div>
                    <div class="copiloto-panel wide">
                        <div class="copiloto-panel-head">
                            <div>
                                <h3>Notas y actividad</h3>
                                <p class="copiloto-panel-sub">Aquí no hay postureo: queda lo que pasó.</p>
                            </div>
                        </div>
                        <div class="copiloto-timeline-wrap">
                            <div class="copiloto-timeline-side">
                                <div class="copiloto-subpanel">
                                    <h4>Quick Note</h4>
                                    <div class="copiloto-quicknote">
                                        <label>Contenedor</label>
                                        <select id="copilotoNotaContenedor">
                                            <option value="">(Selecciona contenedor)</option>
                                        </select>
                                        <label>Estado del vino (opcional)</label>
                                        <select id="copilotoNotaEstado">
                                            <option value="">Sin estado</option>
                                        </select>
                                        <label>Nota rápida</label>
                                        <textarea id="copilotoNotaTexto" rows="4" placeholder="Escribe lo que el vino te está diciendo. Sin adornos."></textarea>
                                        <div class="copiloto-note-chips" id="copilotoNotaChips">
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Nariz cerrada">Nariz cerrada</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Reducción">Reducción</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Volátil">Volátil</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Tenso">Tenso</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Fluido">Fluido</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Duda">Duda</button>
                                            <button type="button" class="copiloto-chip copiloto-note-chip" data-tag="Acción mañana">Acción mañana</button>
                                        </div>
                                        <button type="button" class="btnPrimario" id="copilotoNotaGuardar">Guardar nota</button>
                                        <div class="copiloto-note-status" id="copilotoNotaStatus"></div>
                                    </div>
                                </div>
                                <div class="copiloto-subpanel">
                                    <h4>Actividad reciente</h4>
                                    <div class="copiloto-heatmap-head">
                                        <span id="copilotoHeatmapLabel">Últimos 56 días</span>
                                        <button type="button" class="btnSecundario" id="copilotoHeatmapClear">Quitar filtro</button>
                                    </div>
                                    <div id="copilotoHeatmap" class="copiloto-heatmap"></div>
                                </div>
                            </div>
                            <div>
                                <div class="copiloto-timeline-head">
                                    <div>
                                        <h4>La vida del vino</h4>
                                        <p class="copiloto-timeline-sub">Diario técnico, sin filtros.</p>
                                    </div>
                                    <span id="copilotoTimelineInfo">Últimos eventos</span>
                                </div>
                                <div class="copiloto-timeline-filters">
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineContenedor">Contenedor</label>
                                        <select id="copilotoTimelineContenedor">
                                            <option value="">Todos</option>
                                        </select>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <span>Origen</span>
                                        <div class="copiloto-filter-chips" id="copilotoTimelineOrigen">
                                            <button type="button" class="copiloto-chip is-active" data-origen="todos">Todos</button>
                                            <button type="button" class="copiloto-chip" data-origen="express">Express</button>
                                            <button type="button" class="copiloto-chip" data-origen="control">Control</button>
                                            <button type="button" class="copiloto-chip" data-origen="manual">Manual</button>
                                        </div>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineAccion">Acción</label>
                                        <select id="copilotoTimelineAccion">
                                            <option value="">Todas</option>
                                        </select>
                                    </div>
                                    <div class="copiloto-filter-group">
                                        <label for="copilotoTimelineBuscar">Buscar</label>
                                        <input type="text" id="copilotoTimelineBuscar" placeholder="Buscar en notas, acción o contenedor">
                                    </div>
                                </div>
                                <div id="copilotoTimeline" class="copiloto-timeline">
                                    <div class="copiloto-empty">Sin eventos todavía.</div>
                                </div>
                                <div class="copiloto-card-actions" id="copilotoTimelineFooter" style="display:none;">
                                    <span id="copilotoTimelineCount"></span>
                                    <button type="button" class="btnSecundario" id="copilotoTimelineMas">Cargar más</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div class="metric-card" style="flex:1;">
                    <h3>🍇 Kilos de uva entrados</h3>
                    <p id="resumenKilos" class="metric-value">0 kg</p>
                </div>

                <div class="metric-card" style="flex:1;">
                    <h3>🛢 Depósitos registrados</h3>
                    <p id="resumenDepositos" class="metric-value">0</p>
                </div>

                <div class="metric-card" style="flex:1;">
                    <h3 style="display:flex; align-items:center; gap:8px;">
                        <img src="/barricas.png" alt="Barricas" style="width:22px; height:22px; object-fit:contain; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas registradas
                    </h3>
                    <p id="resumenBarricas" class="metric-value">0</p>
                </div>

            </div>
            <div class="chart-card">
                <h2>Gráficos rápidos</h2>
                <div class="chart-grid">
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Kilos de uva</span>
                            <span id="chartKilosValue">0 kg</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartKilosBar"></div>
                        </div>
                        <small>Total registrado en entradas</small>
                    </div>
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Litros en bodega</span>
                            <span id="chartLitrosValue">0 L</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartLitrosBar"></div>
                        </div>
                        <small id="chartLitrosDetalle">Depósitos, mastelones y barricas</small>
                    </div>
                </div>
            </div>

            <div class="indicadores-grid">
                <div class="indicador-card">
                    <h4>🛢 Depósitos</h4>
                    <p id="indicadorDepositosPrincipal">--</p>
                    <small id="indicadorDepositosDetalle">Calculando ocupación...</small>
                    <small id="indicadorDepositosExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4><span style="color:#c94458;">🪣</span> Mastelones</h4>
                    <p id="indicadorMastelonesPrincipal">--</p>
                    <small id="indicadorMastelonesDetalle">Calculando ocupación...</small>
                    <small id="indicadorMastelonesExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 style="display:flex; align-items:center; gap:6px;">
                        <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas
                    </h4>
                    <p id="indicadorBarricasPrincipal">--</p>
                    <small id="indicadorBarricasDetalle">Calculando ocupación...</small>
                    <small id="indicadorBarricasExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4>🍾 Embotellado</h4>
                    <p id="indicadorEmbotelladosPrincipal">--</p>
                    <small id="indicadorEmbotelladosDetalle">Sin registros</small>
                </div>
            </div>

            <div class="card" style="margin-top:24px;">
                <h2>Aprovechamiento por añada</h2>
                <p>Relación entre los kilos de uva registrados y los litros actuales por cada añada.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Añada</th>
                            <th>Kilos de uva</th>
                            <th>Litros actuales</th>
                            <th>Aprovechamiento</th>
                        </tr>
                    </thead>
                    <tbody id="tablaAprovechamiento">
                        <tr><td colspan="4">Cargando...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
        <!-- SECCIÓN FLUJO -->
        <section id="flujo" class="card" style="display:none;">
	            <h1><span class="h1-emoji">🗺</span>Mapa de nodos de vinificación</h1>
	            <p>Diseña visualmente el recorrido de cada partida: arrastra nodos, conéctalos y edita la información con doble clic.</p>
		            <div class="flow-toolbar">
		                <div class="flow-toolbar-group">
		                    <button class="btnSecundario" type="button" onclick="sembrarNodosDesdeDatos()">Sembrar nodos desde datos</button>
		                </div>
	                <div class="flow-toolbar-group">
	                    <button class="btnPrimario" type="button" onclick="crearNodoManual('entrada')">🍇 Entrada de uva</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('estilo')">⚗️ Elaboración</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('deposito')">🛢 Depósito</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('coupage')">🧪 Coupage / Blend</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('barrica')">
                        <span style="display:inline-flex; align-items:center; gap:6px;">
                          <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                          Crianza
                        </span>
                    </button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('embotellado')">🍾 Embotellado</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('almacen')">📦 Almacén</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('salida')">🚛 Salida</button>
                </div>
	                <div class="flow-toolbar-group">
	                    <button class="btnSecundario" type="button" onclick="resetMapaFlujoLocal()">Limpiar mapa</button>
	                </div>
		                <div class="flow-toolbar-group">
		                    <button class="btnSecundario" type="button" onclick="exportarNodosComoImagen()">Exportar imagen</button>
		                </div>
		                <div class="flow-toolbar-group">
		                    <button id="flowReplayToggleBtn" class="btnSecundario" type="button" onclick="toggleReplayFlujo()">🎞 Replay</button>
		                </div>
		                <div class="flow-toolbar-group flow-zoom-controls">
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(-1)" title="Alejar" aria-label="Alejar">−</button>
		                    <button class="btnSecundario flow-zoom-label" id="flowZoomLabel" type="button" onclick="resetZoomMapaFlujo()" title="Reset zoom" aria-label="Reset zoom">100%</button>
		                    <button class="btnSecundario flow-zoom-btn" type="button" onclick="zoomMapaFlujo(1)" title="Acercar" aria-label="Acercar">+</button>
		                </div>
		            </div>
		            <div id="flowReplayBar" class="flow-replay-bar" aria-label="Replay de movimientos" role="region">
		                <div class="flow-replay-top">
		                    <div>
		                        <div class="flow-replay-title">🎞 Replay</div>
		                        <div class="flow-replay-sub" id="flowReplaySub">Selecciona una entrada (o cualquier nodo de su recorrido) y pulsa “Replay” para recorrer el historial por fechas.</div>
		                    </div>
		                    <div class="flow-replay-top-actions">
		                        <button class="btnSecundario" type="button" onclick="salirReplayFlujo()">Salir</button>
		                    </div>
		                </div>
		                <div class="flow-replay-controls">
		                    <button class="btnSecundario" type="button" onclick="replayPasoFlujo(-1)" title="Anterior">⏮</button>
		                    <button id="flowReplayPlayBtn" class="btnPrimario" type="button" onclick="togglePlayReplayFlujo()" title="Reproducir / Pausar">⏵</button>
		                    <button class="btnSecundario" type="button" onclick="replayPasoFlujo(1)" title="Siguiente">⏭</button>
		                    <input id="flowReplayRange" class="flow-replay-range" type="range" min="0" max="0" step="1" value="0" oninput="onReplayRangeInput(this.value)" aria-label="Línea de tiempo" />
		                    <div class="flow-replay-date" id="flowReplayDate">—</div>
		                </div>
		                <div class="flow-replay-hint" id="flowReplayHint">Hover en una conexión para ver volumen y fecha. Las conexiones futuras se muestran punteadas.</div>
		            </div>
		            <div class="flow-layout">
		                <div class="flow-editor" id="flowEditor">
		                    <div class="flow-stage" id="flowStage">
		                        <div class="flow-world" id="flowWorld">
		                            <svg id="flowConnections" class="flow-connections">
	                                <defs>
	                                    <marker id="arrowHead" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
	                                        <path d="M0,0 L0,6 L6,3 z" fill="rgba(255,255,255,0.7)" />
	                                    </marker>
	                                </defs>
	                                <g id="flowConnectionsLayer"></g>
	                            </svg>
	                            <div id="flowCanvas" class="flow-canvas"></div>
	                        </div>
	                    </div>
	                </div>
	                <aside id="flowNodeInfo" class="flow-node-info flow-inspector">Selecciona un nodo para ver los detalles.</aside>
	            </div>
	            <div class="flow-helper">
	                <p>Doble clic en un nodo para editarlo. Pulsa “Conectar” en un nodo y luego haz clic sobre el destino para crear el hilo. Puedes arrastrar los nodos a cualquier punto del lienzo.</p>
	            </div>

            <div class="chart-card" style="margin-top:18px;">
                <h3 style="margin-top:0;">Demo rápida: arrastra tanques y barricas</h3>
                <p style="margin:6px 0 12px;">Usa el array <code>tanques</code> y esta zona sandbox para probar drag & drop ligero sin tocar el mapa principal.</p>
	                <div id="demoFlowStage" class="demo-flow-stage"></div>
	            </div>
	        </section>
        <div id="flowModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowModalTitulo">Editar nodo</h3>
                <form id="flowModalForm"></form>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarFlowModal()">Cancelar</button>
                    <button type="button" class="btnSecundario" id="flowCleanBtn" onclick="abrirLimpiezaNodoDesdeModal()">Limpieza</button>
                    <button type="button" class="btnSecundario" onclick="eliminarNodoActivo()">Eliminar</button>
                    <button type="button" class="btnPrimario" onclick="guardarNodoDesdeModal()">Guardar</button>
                </div>
            </div>
        </div>
        <div id="flowCleanModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowCleanTitulo">Limpieza de nodo</h3>
                <p id="flowCleanDetalle" style="margin:10px 0 0; font-size:13px; opacity:0.85;"></p>
                <label style="display:flex; align-items:center; gap:8px; margin-top:12px; font-size:13px;">
                    <input type="checkbox" id="flowCleanCheck" />
                    Entiendo que esto deja el contenedor vacío pero mantiene toda la historia en Bitácora.
                </label>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarLimpiezaNodo()">Cancelar</button>
                    <button type="button" class="btnPrimario" id="flowCleanConfirm" onclick="confirmarLimpiezaNodo()" disabled>Confirmar</button>
                </div>
            </div>
        </div>
        <!-- SECCIÓN ENTRADAS DE UVA -->
        <section id="entradas" class="card entrada-page" style="display:none;">
            <form id="formEntradaUva" class="entrada-form" onsubmit="crearEntradaUva(event)">
                <div class="entrada-block entrada-block--hero">
                    <div class="entrada-block-header">
                        <div>
                            <div class="entrada-block-eyebrow">Cabecera técnica</div>
                            <h1 class="entrada-title"><span class="h1-emoji">🍇</span>Entrada de uva</h1>
                            <div class="entrada-block-subtitle" id="entradaFechaLectura">Fecha —</div>
                        </div>
                        <span class="entrada-chip" id="entradaChipAnada">Vendimia —</span>
                    </div>
                    <div class="entrada-grid entrada-grid-2">
                        <div class="entrada-field">
                            <label>Fecha y hora</label>
                            <input type="datetime-local" id="entradaFecha" required>
                            <input type="hidden" id="entradaAnada">
                        </div>
                        <div id="entradaVariedadWrap" class="entrada-field">
                            <label>Variedad</label>
                            <input type="text" id="entradaVariedad" required>
                        </div>
                    </div>

                    <label class="entrada-check">
                        <input type="checkbox" id="entradaMixto">
                        Remolque mixto
                    </label>

                    <div id="entradaModoKilosWrap" class="entrada-field" style="display:none;">
                        <label>Modo de kilos</label>
                        <select id="entradaModoKilos">
                            <option value="total">Kilos totales</option>
                            <option value="por_variedad">Kilos por variedad</option>
                        </select>
                    </div>

                    <div id="entradaLineasWrap" class="entrada-lineas" style="display:none;">
                        <div id="entradaLineas" style="display:grid; gap:8px;"></div>
                        <button type="button" class="btnSecundario" id="btnEntradaAgregarLinea" style="margin-top:8px;">
                            + Añadir variedad
                        </button>
                        <div id="entradaResumenLineas" style="font-size:12px; opacity:0.7; margin-top:6px;"></div>
                    </div>
                </div>

                <div id="entradaProcedenciaAdmin" class="entrada-block entrada-block--admin">
                    <div class="entrada-block-title">Procedencia · Datos oficiales</div>
                    <div class="entrada-block-subtitle">Información para trazabilidad y administración</div>
                    <div class="entrada-procedencia-grid">
                        <div class="entrada-procedencia-field entrada-procedencia-field--wide">
                            <label>Referencia Catastral <span class="entrada-chip-oficial">OFICIAL</span></label>
                            <input type="text" id="entradaRc" placeholder="20 caracteres" autocomplete="off">
                            <div class="entrada-hint" id="entradaRcAviso"></div>
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Provincia</label>
                            <input type="text" id="entradaProvincia" placeholder="Provincia">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Municipio</label>
                            <input type="text" id="entradaMunicipio" placeholder="Municipio">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Polígono</label>
                            <input type="text" id="entradaPoligono" placeholder="Polígono">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Parcela</label>
                            <input type="text" id="entradaParcelaCat" placeholder="Parcela">
                        </div>
                        <div class="entrada-procedencia-field">
                            <label>Recinto (opcional)</label>
                            <input type="text" id="entradaRecinto" placeholder="Recinto">
                        </div>
                    </div>

                    <div class="entrada-catastro-actions">
                        <button type="button" class="btnPrimario" id="btnCatastroRc" disabled>Ver en Catastro (RC)</button>
                        <button type="button" class="btnSecundario" id="btnCatastroParcela" disabled>Ver en Catastro (Parcela)</button>
                        <div class="entrada-hint" id="entradaCatastroHint">Faltan datos para abrir Catastro.</div>
                    </div>
                    <div class="entrada-catastro-links">
                        <a id="entradaCatastroLinkRc" href="#" target="_blank" rel="noopener" aria-disabled="true">Abrir enlace RC</a>
                        <a id="entradaCatastroLinkParcela" href="#" target="_blank" rel="noopener" aria-disabled="true">Abrir enlace Parcela</a>
                    </div>

                    <div class="entrada-plantillas">
                        <div class="entrada-plantillas-title">Acciones rápidas</div>
                        <label>Cargar procedencia</label>
                        <select id="entradaPlantillaSelect">
                            <option value="">(Sin plantilla)</option>
                        </select>
                        <div class="entrada-plantillas-actions">
                            <button type="button" class="btnSecundario" id="btnAplicarPlantilla">Cargar procedencia</button>
                            <button type="button" class="btnSecundario" id="btnGuardarPlantilla">Guardar como plantilla</button>
                        </div>
                    </div>
                </div>

                <div class="entrada-block entrada-block--identidad">
                    <div class="entrada-block-title">Identidad del viñedo</div>
                    <div class="entrada-block-subtitle">Información humana y agronómica</div>
                    <div class="entrada-grid entrada-grid-2">
                        <div class="entrada-field">
                            <label>Nombre de parcela (interno)</label>
                            <input type="text" id="entradaParcela" placeholder="Ej: La Ladera, Barranco Norte">
                        </div>
                        <div class="entrada-field">
                            <label>Viticultor / Proveedor</label>
                            <input type="text" id="entradaViticultor" placeholder="Nombre del viticultor o proveedor">
                        </div>
                        <div class="entrada-field">
                            <label>Tipo de suelo</label>
                            <input type="text" id="entradaSuelo" placeholder="Arcilloso, calizo...">
                        </div>
                        <div class="entrada-field">
                            <label>Años de la vid</label>
                            <input type="number" id="entradaAnosVid" min="0" placeholder="Edad aproximada">
                        </div>
                    </div>

                    <details class="entrada-procedencia-extra">
                        <summary>Datos extra de proveedor (opcional)</summary>
                        <label>NIF/CIF</label>
                        <input type="text" id="entradaViticultorNif" placeholder="NIF/CIF">
                        <label>Contacto</label>
                        <input type="text" id="entradaViticultorContacto" placeholder="Teléfono o email">
                    </details>
                </div>

                <div class="entrada-block entrada-block--fisica">
                    <div class="entrada-block-title">Entrada física de uva</div>
                    <div class="entrada-block-subtitle">Lecturas y cantidades de recepción</div>
                    <div class="entrada-grid entrada-grid-3">
                        <div id="entradaKilosWrap" class="entrada-field">
                            <label>Kilos</label>
                            <input type="number" id="entradaKilos" required>
                        </div>
                        <div class="entrada-field">
                            <label>Cajas</label>
                            <input type="number" id="entradaCajas" min="1" step="1" required>
                        </div>
                        <div class="entrada-field">
                            <label>Tipo de caja</label>
                            <select id="entradaTipoCaja">
                                <option value="">(Opcional)</option>
                                <option value="10">10</option>
                                <option value="12">12</option>
                                <option value="15">15</option>
                                <option value="18">18</option>
                                <option value="Otro">Otro</option>
                            </select>
                        </div>
                    </div>
                    <div class="entrada-grid entrada-grid-2">
                        <div class="entrada-field entrada-lectura">
                            <label>Densidad</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaDensidad" step="0.001" placeholder="1.050">
                                <span class="entrada-unidad">g/mL</span>
                            </div>
                        </div>
                        <div class="entrada-field entrada-lectura">
                            <label>Temperatura</label>
                            <div class="entrada-lectura-row">
                                <input type="number" id="entradaTemperatura" step="0.1" placeholder="18.5">
                                <span class="entrada-unidad">°C</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="entrada-block entrada-block--observaciones">
                    <div class="entrada-block-title">Observaciones y resumen</div>
                    <div class="entrada-block-subtitle">Notas y copia para administración</div>
                    <label>Observaciones</label>
                    <textarea id="entradaObservaciones" placeholder="Notas para administración, incidencias, detalles..."></textarea>

                    <details id="entradaResumenAdmin" class="entrada-resumen-admin">
                        <summary>Resumen para Administración</summary>
                        <div class="entrada-resumen-body">
                            <button type="button" class="btnPrimario" id="btnCopiarResumenEntrada">Copiar</button>
                            <textarea id="entradaResumenAdminTexto" readonly></textarea>
                        </div>
                    </details>
                </div>

                <div class="entrada-actions">
                    <button type="submit" class="btnPrimario" id="btnGuardarEntrada">Registrar entrada</button>
                    <button type="button" class="btnSecundario" id="btnCancelarEdicionEntrada" style="display:none;" onclick="cancelarEdicionEntrada()">Cancelar edición</button>
                </div>
                <div class="form-feedback" id="feedbackEntradaUva"></div>
            </form>

            <div class="entrada-historial">
                <h2>Historial</h2>
                <table>
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Fecha</th>
                            <th>Añada</th>
                            <th>Variedad</th>
                            <th>Viticultor</th>
                            <th>Tipo de suelo</th>
                            <th>Parcela (interno)</th>
                            <th>Años de la vid</th>
                            <th>Kilos</th>
                            <th>Cajas</th>
                            <th>Densidad</th>
                            <th>Temp (°C)</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody id="tablaEntradas"></tbody>
                </table>
                <h2 style="margin-top:24px;">Resumen por parcela (interno)</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Parcela</th>
                            <th>Viajes</th>
                            <th>Kilos</th>
                            <th>Última fecha</th>
                            <th>Hora de entrada</th>
                        </tr>
                    </thead>
                    <tbody id="tablaResumenParcelas"></tbody>
                </table>
            </div>
        </section>

        <!-- SECCIÓN DEPÓSITOS -->
        <section id="depositos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🛢</span>Depósitos</h1>
            <p>Registro de depósitos con su capacidad, tipo y material. La variedad y los litros asignados se actualizan automáticamente cuando un nodo se conecta al depósito.</p>

<table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Nombre de depósito</th>
        <th>Capacidad (L)</th>
        <th>Tipo</th>
        <th>Material</th>
        <th>Variedad asignada</th>
        <th>Volumen transferido</th>
        <th>Acciones</th>
        <th>Bitácora</th>
        <th>Borrar</th>
      </tr>
    </thead>
    <tbody id="tablaDepositos"></tbody>
</table>

<h2 style="margin-top:40px;">Nuevo depósito</h2>

<form id="formDeposito" onsubmit="crearDeposito(event)">
  <div style="display:flex; gap:20px; flex-wrap:wrap;">
    <div style="flex:1;">
      <label>Nombre de depósito</label>
      <input type="text" id="depCodigo" required>
    </div>
    <div style="flex:1;">
      <label>Capacidad (L)</label>
      <input type="number" id="depCapacidad" min="0" step="0.1" required>
    </div>
    <div style="flex:1;">
      <label>Tipo</label>
      <select id="depTipo" required>
        <option value="">Selecciona tipo</option>
        <option value="Siempre lleno">Siempre lleno</option>
        <option value="Cerrado">Cerrado</option>
        <option value="Mastelone">Mastelone</option>
        <option value="Ánfora">Ánfora</option>
        <option value="Foudre">Foudre</option>
        <option value="Barrica">Barrica</option>
        <option value="Damajuana">Damajuana</option>
      </select>
    </div>
    <div style="flex:1;">
      <label>Material</label>
      <select id="depMaterial" required>
        <option value="">Selecciona material</option>
        <option value="Inox">Inox</option>
        <option value="Fibra de vidrio">Fibra de vidrio</option>
        <option value="Cemento">Cemento</option>
        <option value="Barro">Barro</option>
        <option value="Madera">Madera</option>
        <option value="Cristal">Cristal</option>
        <option value="Plástico alimentario">Plástico alimentario</option>
      </select>
    </div>
  </div>
  <button type="submit" class="btnPrimario">Crear depósito</button>
  <div class="form-feedback" id="feedbackDepositos"></div>
</form>

            <div class="cata-section">
                <h2>Hoja de cata sensorial</h2>
                <p>Registra la evolución sensorial de cada depósito y deja huella para decidir el próximo paso.</p>
                <div id="cataGrid" class="cata-grid"></div>
            </div>
        </section>

        <div id="modalDeposito" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar depósito</h3>
                <form id="formEditarDeposito" onsubmit="guardarEdicionDeposito(event)">
                    <label>Nombre de depósito</label>
                    <input type="text" id="depCodigoEdit" required>

                    <label>Capacidad (L)</label>
                    <input type="number" id="depCapacidadEdit" min="0" step="0.1" required>

                    <label>Volumen actual (L)</label>
                    <input type="number" id="depVolumenEdit" min="0" step="0.1" required>

                    <label>Tipo</label>
                    <select id="depTipoEdit" required></select>

                    <label>Material</label>
                    <select id="depMaterialEdit" required></select>

                    <label>Estado</label>
                    <select id="depEstadoEdit" required></select>

                    <p style="margin-top:10px; font-size:13px; opacity:0.7;">
                        Variedad asignada: <strong id="depVariedadInfo">—</strong>
                    </p>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalDeposito()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cambios</button>
                    </div>
                    <div class="form-feedback" id="feedbackEditarDeposito"></div>
                </form>
                <div id="bitacoraSlotDeposito" style="margin-top:12px;"></div>
            </div>
        </div>

        <div id="modalCata" class="flow-modal">
            <div class="flow-modal-content cata-modal-content">
                <h3>Hoja de cata sensorial</h3>
                <p id="cataContenedorInfo" style="margin-top:6px; font-size:13px; opacity:0.7;"></p>
                <form id="formCata" onsubmit="guardarCata(event)">
                    <input type="hidden" id="cataTipo">
                    <input type="hidden" id="cataId">

                    <label>Fecha y hora</label>
                    <input type="datetime-local" id="cataFecha" required>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Vista</label>
                            <textarea id="cataVista" rows="2" placeholder="Color, limpidez, brillo..."></textarea>
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Nariz</label>
                            <textarea id="cataNariz" rows="2" placeholder="Aromas, intensidad, evolución..."></textarea>
                        </div>
                    </div>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Boca</label>
                            <textarea id="cataBoca" rows="2" placeholder="Ataque, volumen, tanino, acidez..."></textarea>
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Equilibrio</label>
                            <textarea id="cataEquilibrio" rows="2" placeholder="Equilibrio global, persistencia..."></textarea>
                        </div>
                    </div>

                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <label>Defectos / alertas</label>
                            <input type="text" id="cataDefectos" placeholder="Oxidación, VA, reducción...">
                        </div>
                        <div style="flex:1; min-width:200px;">
                            <label>Intensidad</label>
                            <select id="cataIntensidad">
                                <option value="">Selecciona intensidad</option>
                                <option value="baja">Baja</option>
                                <option value="media">Media</option>
                                <option value="alta">Alta</option>
                            </select>
                        </div>
                    </div>

                    <label>Nota general</label>
                    <textarea id="cataNota" rows="3" placeholder="Conclusión, próximos pasos, decisiones..."></textarea>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalCata()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cata</button>
                    </div>
                    <div class="form-feedback" id="feedbackCata"></div>
                </form>
            </div>
        </div>

        <!-- SECCIÓN ALMACÉN LIMPIEZA -->
        <section id="limpieza" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧽</span>Almacén de limpieza</h1>
            <p>Control de stock y consumo de productos de limpieza con trazabilidad por lote.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaLimpieza"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formLimpieza" onsubmit="crearProductoLimpieza(event)">
                        <label>Producto</label>
                        <input type="text" id="limNombre" required>

                        <label>Lote</label>
                        <input type="text" id="limLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="limCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="limUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="limNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN PRODUCTOS ENOLÓGICOS -->
        <section id="enologicos" class="card" style="display:none;">
            <h1><span class="h1-emoji">🧪</span>Productos enológicos</h1>
            <p>Registro de aditivos y productos empleados en la elaboración del vino.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEnologicos"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formEnologicos" onsubmit="crearProductoEnologico(event)">
                        <label>Producto</label>
                        <input type="text" id="enoNombre" required>

                        <label>Lote</label>
                        <input type="text" id="enoLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="enoCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="enoUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="enoNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN EMBOTELLADO -->
        <section id="embotellado" class="card" style="display:none;">
            <h1><span class="h1-emoji">🍾</span>Registro de embotellado</h1>
            <p>Documenta cada lote embotellado con trazabilidad completa.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Historial</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Origen</th>
                                <th>Botellas</th>
                                <th>Formatos</th>
                                <th>Lote</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEmbotellados"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar embotellado</h2>
                    <form id="formEmbotellado" onsubmit="crearEmbotellado(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="embFecha">

                        <label>Tipo contenedor</label>
                        <select id="embTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor (ID o código)</label>
                        <input type="text" id="embContenedor" placeholder="Ej. A1 o 3" required>

                        <label>Formato botella (si es único)</label>
                        <select id="embFormato">
                            <option value="Split 0,187 L">Split 0,187 L</option>
                            <option value="Demi 0,375 L">Demi 0,375 L</option>
                            <option value="Borgoña 0,75 L" selected>Borgoña 0,75 L</option>
                            <option value="Bordelesa 0,75 L">Bordelesa 0,75 L</option>
                            <option value="Magnum 1,5 L">Magnum 1,5 L</option>
                            <option value="Doble Magnum 3 L">Doble Magnum 3 L</option>
                            <option value="Jeroboam 3 L">Jeroboam 3 L</option>
                            <option value="Rehoboam 4,5 L">Rehoboam 4,5 L</option>
                            <option value="Methuselah 6 L">Methuselah 6 L</option>
                            <option value="Salmanazar 9 L">Salmanazar 9 L</option>
                            <option value="Balthazar 12 L">Balthazar 12 L</option>
                            <option value="Nebuchadnezzar 15 L">Nebuchadnezzar 15 L</option>
                        </select>

                        <label>Botellas (total)</label>
                        <input type="number" id="embBotellas" min="0" step="1" required>

                        <label>Formatos mixtos (opcional)</label>
                        <div id="embFormatosWrapper" class="tabla-formatos-embotellado"></div>
                        <small id="embFormatosHint" style="display:block; margin-top:6px; color:#666;">Si añades formatos mixtos, el total se calcula solo.</small>

                        <label>Lote embotellado</label>
                        <input type="text" id="embLote" placeholder="Referencia de lote">

                        <label>Nota</label>
                        <input type="text" id="embNota">

                        <button class="btnPrimario">Registrar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCIÓN PLANO BODEGA -->
        <section id="plano" class="card" style="display:none;">
            <h1><span class="h1-emoji">🗺</span>Plano de la bodega</h1>
            <p>Arrastra para colocar, haz clic para ver el desglose, y usa el zoom para navegar por toda la bodega.</p>

            <div class="plano-layout">
                <div class="plano-editor" id="planoEditor" aria-label="Plano de la bodega (lienzo)">
                    <div class="plano-stage" id="planoStage">
                        <div class="plano-canvas" id="planoCanvas">
                            <div class="plano-placeholder">Añade depósitos, mastelones o barricas para empezar</div>
                        </div>
                    </div>
                </div>
                <aside id="planoInfo" class="flow-inspector plano-inspector">Cargando inspector…</aside>
            </div>
            <p id="planoMensaje">Añade depósitos, mastelones o barricas para empezar.</p>
        </section>
        <!-- SECCIÓN BARRICAS -->
        <section id="barricas" class="card" style="display:none;">
            <h1 style="display:flex; align-items:center; gap:10px;">
                <img src="/barricas.png" alt="Maderas" style="width:30px; height:30px; object-fit:contain; filter: drop-shadow(0 3px 6px rgba(0,0,0,0.35)); mix-blend-mode:multiply; background:transparent;">
                Maderas
            </h1>
            <p>Control de maderas y litros dentro.</p>

            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Código</th>
                        <th>Capacidad&nbsp;(L)</th>
                        <th>Roble / tostado</th>
                        <th>Marca</th>
                        <th>Año barrica</th>
                        <th>Añada</th>
                        <th>Tipo de vino</th>
                        <th>Volumen actual (L)</th>
                        <th>Acciones</th>
                        <th>Bitácora</th>
                        <th>Borrar</th>
                    </tr>
                </thead>
                <tbody id="tablaBarricas"></tbody>
            </table>

            <h2 style="margin-top:40px;">Nueva madera</h2>

            <form id="formBarrica" onsubmit="crearBarrica(event)">
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <div style="flex:1;">
                        <label>Código</label>
                        <input type="text" id="barCodigo" required>
                    </div>
                    <div style="flex:1;">
                        <label>Capacidad&nbsp;(L)</label>
                        <input type="number" id="barCapacidad" required>
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de roble</label>
                        <input type="text" id="barTipo" placeholder="Francés, americano…">
                    </div>
                    <div style="flex:1;">
                        <label>Tostado</label>
                        <input type="text" id="barTostado" placeholder="Ligero, medio, fuerte…">
                    </div>
                    <div style="flex:1;">
                        <label>Marca</label>
                        <input type="text" id="barMarca" placeholder="Coperage, proveedor…">
                    </div>
                    <div style="flex:1;">
                        <label>Año</label>
                        <input type="number" id="barAnio" min="1900" max="2100" placeholder="2020">
                    </div>
                    <div style="flex:1;">
                        <label>Añada</label>
                        <input type="number" id="barVinoAnio" min="1900" max="2100" placeholder="2023">
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de vino</label>
                        <select id="barVinoTipo">
                            <option value="">Selecciona</option>
                            <option value="Vino tinto">Vino tinto</option>
                            <option value="Vino blanco">Vino blanco</option>
                            <option value="Vino rosado">Vino rosado / Clarete</option>
                        </select>
                    </div>
                </div>

                <button>Crear barrica</button>
            </form>

            <div class="cata-section">
                <h2>Hoja de cata sensorial</h2>
                <p>Seguimiento sensorial por barrica para anticipar decisiones de crianza.</p>
                <div id="cataGridBarricas" class="cata-grid"></div>
            </div>
        </section>

        <!-- SECCIÓN REGISTROS ANALÍTICOS -->
        <section id="analiticos" class="card" style="display:none;">
            <h1><span class="h1-emoji">📊</span>Registros analíticos</h1>
            <p>Densidad, temperatura, etc. por depósito, mastelone o barrica.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo registro</h2>

                    <form id="formAnalitico" onsubmit="crearRegistroAnalitico(event)">
                        <label>Tipo contenedor</label>
                        <select id="regTipo">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor</label>
                        <input type="text" id="regId" placeholder="Ej. 3 o A1" required>

                        <label>Fecha y hora</label>
                        <input type="datetime-local" id="regFecha" required>

                        <label>Densidad</label>
                        <input type="number" id="regDensidad" step="0.1">

                        <label>Temperatura (°C)</label>
                        <input type="number" id="regTemperatura" step="0.1">

                        <label>Nota sensorial</label>
                        <input type="text" id="regNotaSensorial" placeholder="Ej. frutos rojos, especias">

                        <label>Nota</label>
                        <input type="text" id="regNota">

                        <button>Guardar registro</button>
                        <div id="regMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.2; min-width:260px;">
                    <h2>Historial por contenedor</h2>

                    <div style="display:flex; gap:10px; align-items:flex-end;">
                        <div style="flex:1;">
                            <label>Tipo</label>
                            <select id="histTipo">
                                <option value="deposito">Depósito</option>
                                <option value="mastelone">Mastelone</option>
                                <option value="barrica">Barrica</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label>Contenedor</label>
                            <input type="text" id="histId" placeholder="Ej. 5 o B1">
                        </div>
                        <div>
                            <button class="small-btn" onclick="cargarHistorialAnalitico()">Ver</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Evento</th>
                                <th>Detalle</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaRegistros"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCIÓN BITÁCORA -->
        <section id="bitacora" class="card" style="display:none;">
            <h1 style="margin-top:0;"><span class="h1-emoji">📕</span>Bitácora</h1>
            <div style="margin-bottom:10px;">
                <label for="bitacoraBuscar">Buscar</label>
                <input type="search" id="bitacoraBuscar" placeholder="Buscar en el texto">
            </div>
            <div id="bitacoraEstado" style="opacity:0.7; font-size:13px; margin-top:6px;"></div>
            <div id="bitacoraTexto" class="bitacora-plain" style="margin-top:12px;"></div>
        </section>

        <!-- SECCIÓN ANÁLISIS LABORATORIO -->
        <section id="analisisLab" class="card" style="display:none;">
            <h1><span class="h1-emoji">📄</span>Análisis de laboratorio externos</h1>
            <p>Sube PDFs de laboratorios externos y asócialos a un depósito o mastelone.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo análisis</h2>
                    <form id="formAnalisisLab" onsubmit="crearAnalisisLab(event)">
                        <label>Tipo de contenedor</label>
                        <select id="labTipoContenedor">
                            <option value="deposito">Depósito</option>
                            <option value="mastelone">Mastelone</option>
                        </select>

                        <label>Contenedor (ID o código)</label>
                        <input type="text" id="labDeposito" placeholder="Ej. 2 o D3" required>

                        <label>Fecha del análisis</label>
                        <input type="date" id="labFecha">

                        <label>Laboratorio</label>
                        <input type="text" id="labLaboratorio" placeholder="Nombre del laboratorio">

                        <label>Descripción / tipo de análisis</label>
                        <input type="text" id="labDescripcion" placeholder="Ej. Microbiológico, físico-químico">

                        <label>Archivo PDF</label>
                        <input type="file" id="labArchivo" accept="application/pdf" required>

                        <button>Subir análisis</button>
                        <div id="labMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.3; min-width:280px;">
                    <h2>Historial de PDFs</h2>
                    <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
                        <div style="flex:1; min-width:160px;">
                            <label>Filtrar por contenedor</label>
                            <input type="text" id="labFiltroDeposito" placeholder="Ej. 2 o D3">
                        </div>
                        <div>
                            <label>Tipo</label>
                            <select id="labFiltroTipo">
                                <option value="">Todos</option>
                                <option value="deposito">Depósito</option>
                                <option value="mastelone">Mastelone</option>
                            </select>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="aplicarFiltroAnalisisLab()">Filtrar</button>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="limpiarFiltroAnalisisLab()">Limpiar</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Contenedor</th>
                                <th>Laboratorio</th>
                                <th>Descripción</th>
                                <th>Archivo</th>
                            </tr>
                        </thead>
                        <tbody id="tablaAnalisisLab"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div> <!-- fin .content -->

  <script>
// ---- Mostrar secciones del menú lateral ---
function mostrarSeccion(id) {
  if (id !== "flujo" && flowReplay?.playing) {
    togglePlayReplayFlujo(false);
  }
  const secciones = document.querySelectorAll("section.card, section#bitacora");
  secciones.forEach(sec => {
    const esObjetivo = sec.id === id;
    if (esObjetivo) {
      sec.style.display = "block";
      requestAnimationFrame(() => sec.classList.add("visible"));
      if (id === "plano") {
        requestAnimationFrame(() => {
          inicializarPlanoBodegaUI();
          renderPlano();
        });
      }
      if (id === "flujo") {
        requestAnimationFrame(() => {
          aplicarLayoutFlow({ mantenerCentro: true });
          renderFlowConnections();
          programarActualizacionMinimapFlow();
        });
      }
    } else if (sec.classList.contains("visible")) {
      sec.classList.remove("visible");
      setTimeout(() => {
        sec.style.display = "none";
      }, 250);
    } else {
      sec.style.display = "none";
    }
  });
  const links = document.querySelectorAll("[data-section]");
  links.forEach(link => {
    link.classList.toggle("activo", link.dataset.section === id);
  });
}
let cacheEntradas = [];
let cacheDepositos = [];
let cacheBarricas  = [];
let cacheMastelones = [];
let cacheMovimientos = [];
let cacheLimpieza = [];
let cacheEnologicos = [];
let cacheEmbotellados = [];
let cacheAnalisisLab = [];
let cacheCatas = [];
let depositoEditando = null;
let temporizadorGuardadoFlujo = null;
const RETARDO_GUARDADO_FLUJO = 600;
const TITULOS_DINAMICOS = {
  estilo: nodo => {
    if (!Array.isArray(flujoNodos)) return null;
    const estilos = flujoNodos.filter(n => n?.tipo === "estilo");
    const id = normalizarIdNodo(nodo);
    const idx = estilos.findIndex(n => normalizarIdNodo(n) === id);
    if (idx >= 0) return `Elaboración ${idx + 1}`;
    return "Elaboración";
  },
  deposito: nodo => {
    const nombre = nodo?.datos?.codigo || "Depósito";
    const fase = nodo?.datos?.fase;
    // Mostramos la fase en el badge coloreado, no en el título, para evitar duplicados.
    return nombre;
  },
  barrica: nodo => {
    const datos = nodo?.datos || {};
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const id = datos.contenedor_id || datos.id_ref;
    const info = id ? obtenerInfoContenedor(tipoCont, id) : null;
    const codigo = (info?.codigo || datos.codigo || "").toString().trim();
    if (!codigo) return null;
    return `${codigo} CRIANZA`;
  },
};
const COPILOTO_DEFAULT_CONFIG = {
  paradaHoras: 24,
  paradaDelta: 1,
  tempMax: { tinto: 28, blanco: 20, rosado: 22, default: 26 },
  oxidacionHoras: 36,
  oxidacionMinLlenado: 85,
  proteccionHoras: 12,
  analiticaHoras: 48,
  refreshMin: 5,
  modoExperto: false,
  notificaciones: false,
};
const COPILOTO_STORAGE_KEY = "copiloto_config_v1";
const COPILOTO_STATE_KEY = "copiloto_state_v1";
const COPILOTO_ANALITICOS_TTL_MS = 5 * 60 * 1000;
const COPILOTO_EVENTOS_TTL_MS = 90 * 1000;
const COPILOTO_EVENTOS_LIMIT = 200;
const COPILOTO_SEMAFORO_HORAS = 48;
const COPILOTO_TIMELINE_LIMIT = 200;
const COPILOTO_TIMELINE_STEP = 40;
const COPILOTO_TIMELINE_INIT = 60;
const COPILOTO_HEATMAP_DIAS = 56;
const COPILOTO_SNOOZE_HOURS = 12;
const COPILOTO_DONE_DAYS = 7;
let copilotoConfig = null;
let copilotoState = null;
const copilotoAnaliticosCache = new Map();
const copilotoAnaliticosTs = new Map();
let copilotoEventosCache = [];
let copilotoEventosTs = 0;
let copilotoAutoTimer = null;
let copilotoUpdateTimer = null;
let copilotoEnProgreso = false;
let copilotoFiltroDia = null;
let copilotoTimelineVisible = COPILOTO_TIMELINE_INIT;
let copilotoTimelineBusquedaTimer = null;
const copilotoTimelineFiltros = {
  contenedor: "",
  origen: "todos",
  accion: "",
  buscar: "",
};
const CAMPOS_PRIORITARIOS_MODAL = ["fecha", "fecha_operacion"];
const CAMPOS_CARGA_NUMERICOS = ["kilos", "litros", "litros_directos", "volumen"];
const CAMPOS_CARGA_TEXTO = ["variedad", "anada"];
const CAMPOS_CARGA_METRICAS = ["densidad", "temperatura"];
const TIPOS_CONTENEDOR_FLUJO = new Set(["deposito", "barrica", "coupage"]);
const VARIEDADES_BLANCAS = [
  "blanco",
  "malvar",
  "airen",
  "airén",
  "verdejo",
  "albariño",
  "albarino",
  "macabeo",
  "viura",
  "godello",
  "palomino",
  "parellada",
  "xarel·lo",
  "xarello",
  "moscatel",
  "moscat",
  "gewurztraminer",
  "gewürztraminer",
  "riesling",
  "viognier",
  "chardonnay",
  "sauvignon",
  "treixadura",
  "garnacha blanca",
  "albillo",
  "colombard",
  "gruner",
  "gruener",
  "grüner",
  "viosinho",
  "pedro ximenez",
  "pedro ximénez",
  "trebbiano",
  "pinot blanc",
  "pinot bianco",
  "marsanne",
  "roussanne",
  "chenin",
  "palomino",
  "godello",
  "loureira",
  "doña blanca",
  "dona blanca",
  "malvasia",
  "malvasía",
];
let VARIEDADES_BLANCAS_SET = null;
function obtenerNodoPorId(idBuscado) {
  const idNorm = normalizarIdNodo(idBuscado);
  return flujoNodos.find(n => normalizarIdNodo(n.id) === idNorm) || null;
}
function actualizarTituloNodo(nodo) {
  if (!nodo) return;
  const config = FLOW_NODE_TYPES[nodo.tipo];
  const generador = TITULOS_DINAMICOS[nodo.tipo];
  if (generador) {
    const titulo = generador(nodo);
    if (titulo) {
      nodo.titulo = titulo;
      return;
    }
  }
  nodo.titulo = config ? config.label : nodo.titulo || "Nodo";
}

function ordenarCamposParaModal(campos) {
  const originales = [...(campos || [])];
  const prioridad = CAMPOS_PRIORITARIOS_MODAL.map(id =>
    originales.find(campo => campo.id === id)
  ).filter(Boolean);
  const resto = originales.filter(campo => !CAMPOS_PRIORITARIOS_MODAL.includes(campo.id));
  return [...prioridad, ...resto];
}

function obtenerValorCampoVisual(nodo, campo) {
  if (!nodo || !campo) return "";

  if (campo.id === "capacidad" && nodo.tipo === "deposito") {
    const capacidadBase =
      nodo.datos?.capacidad ??
      nodo.datos?.capacidad_l ??
      (nodo.datos?.capacidad_hl != null ? nodo.datos.capacidad_hl * 100 : null);
    const volumenBase = obtenerVolumenActualNodo(nodo);
    const capNum = capacidadBase != null ? Number(capacidadBase) : NaN;
    const volNum = volumenBase != null ? Number(volumenBase) : NaN;
    const capTxt = Number.isFinite(capNum) ? formatearVolumenPlano(capNum) : "";
    const volTxt = Number.isFinite(volNum) && volNum > 0 ? formatearVolumenPlano(volNum) : "";
    const partes = [];
    if (capTxt) partes.push(capTxt);
    if (volTxt) partes.push(`Volumen: ${volTxt}`);
    const combinado = partes.join(" | ");
    if (combinado) return combinado;
  }

  if (campo.id === "variedad") {
    const texto = obtenerVariedadVisibleNodo(nodo);
    if (texto) return texto;
  }

  const valor = nodo.datos ? nodo.datos[campo.id] : "";
  if (valor === undefined || valor === null || valor === "") return "";
  if (campo.id === "fecha" || campo.id === "fecha_operacion") {
    return formatearFechaCorta(valor);
  }
  if (campo.id === "densidad") {
    return formatearDensidad(valor);
  }
  if (campo.id === "temperatura") {
    const num = normalizarNumero(valor);
    return num != null ? `${num.toFixed(1)} °C` : "";
  }
  if (campo.id === "litros_resultantes" || campo.id === "merma_abs") {
    const num = normalizarNumero(valor);
    return num != null ? formatearVolumenPlano(num) : "";
  }
  if (campo.id === "estado_vino") {
    if (String(valor).toLowerCase() === ESTADO_PERSONALIZADO) {
      const texto = nodo.datos?.estado_vino_texto || "";
      return texto || "Personalizado";
    }
    const encontrado = ESTADOS_VINO.find(item => item.value === String(valor).toLowerCase());
    return encontrado ? encontrado.label : valor;
  }
  return valor;
}

function esMetodoPrensado(metodo) {
  return (metodo || "").toLowerCase() === "prensado";
}

function esMetodoSangrado(metodo) {
  return (metodo || "").toLowerCase() === "sangrado";
}

function esNodoSangrado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "estilo") {
    return esMetodoSangrado(nodo.datos?.metodo);
  }
  return false;
}

function esNodoPrensado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "prensado") return true;
  if (nodo.tipo === "estilo") {
    const metodo = (nodo.datos?.metodo || "").toLowerCase();
    return metodo === "prensado" || metodo === "sangrado";
  }
  return false;
}

function esNodoConversor(nodo) {
  return esNodoPrensado(nodo) || esNodoSangrado(nodo);
}

	function obtenerPredecesores(id) {
	  const idNorm = normalizarIdNodo(id);
	  return flujoNodos.filter(n =>
	    (n.targets || []).some(targetId => normalizarIdNodo(targetId) === idNorm)
	  );
	}

	function obtenerUnidadNodo(nodo, memo = new Map()) {
	  if (!nodo) return "kilos";
	  // Los contenedores se gestionan siempre en volumen (capacidad/volumen) aunque reciban kilos.
	  if (
	    nodo.tipo === "deposito" ||
	    nodo.tipo === "barrica" ||
	    nodo.tipo === "almacen" ||
	    nodo.tipo === "coupage"
	  ) {
	    return "litros";
	  }
	  const clave = nodo.id || nodo;
	  // Evitar recursión infinita si hay ciclos
	  if (memo.get("visitando")?.has(clave)) return "kilos";
	  if (memo.has(clave)) return memo.get(clave);
  const visitando = memo.get("visitando") || new Set();
  visitando.add(clave);
  memo.set("visitando", visitando);
  let unidad = esNodoConversor(nodo) ? "litros" : "kilos";
  if (unidad === "kilos") {
    const padres = obtenerPredecesores(nodo.id);
    if (padres.some(pre => obtenerUnidadNodo(pre, memo) === "litros")) {
      unidad = "litros";
    }
  }
  memo.set(clave, unidad);
  visitando.delete(clave);
  return unidad;
}

function obtenerUnidadEntrante(nodo) {
  if (!nodo) return "kilos";
  const padres = obtenerPredecesores(nodo.id);
  if (!padres.length) return "kilos";
  return padres.some(pre => obtenerUnidadNodo(pre) === "litros") ? "litros" : "kilos";
}

function obtenerUnidadDisponible(origen) {
  return obtenerUnidadNodo(origen);
}

function obtenerUnidadVisual(nodo) {
  return nodo?.tipo === "entrada" ? "Kg" : "Volumen";
}

function getVolumenFromDatos(datos) {
  if (!datos || typeof datos !== "object") return null;
  const volumen = normalizarNumero(datos.volumen);
  if (volumen != null) return volumen;
  const kilos = normalizarNumero(datos.kilos);
  const litros = normalizarNumero(
    datos.litros_directos != null ? datos.litros_directos : datos.litros
  );
  if (kilos != null) return kilos;
  if (litros != null) return litros;
  return null;
}

function getVolumenFromNodo(nodo) {
  if (!nodo) return null;
  return getVolumenFromDatos(nodo.datos || {});
}

function obtenerCantidadEnUnidad(fuente, _unidad) {
  const volumen = getVolumenFromDatos(fuente);
  return Number.isFinite(volumen) ? volumen : 0;
}

function normalizarCargaSegunUnidad(carga, _unidad) {
  if (!carga) return null;
  const base = getVolumenFromDatos(carga);
  carga.volumen = base != null ? Number(base.toFixed(4)) : null;
  return carga;
}

function setVolumenRegistro(registro, valor) {
  if (!registro) return;
  const num = normalizarNumero(valor);
  if (num == null) {
    registro.volumen = null;
    registro.litros = null;
    registro.kilos = null;
    return;
  }
  const final = Number(num.toFixed(2));
  registro.volumen = final;
  registro.litros = final;
  registro.kilos = null;
}

function asegurarAsignacionRegistro(destino, origenId, volumenPorDefecto = null) {
  destino.datos = destino.datos || {};
  destino.datos.asignaciones = destino.datos.asignaciones || {};
  const key = origenId.toString();
  const existente = destino.datos.asignaciones[key];
  if (!existente) {
    destino.datos.asignaciones[key] = {
      volumen: null,
      litros: null,
      kilos: null,
      __manual: false,
    };
  } else {
    if (existente.volumen == null && volumenPorDefecto != null) {
      setVolumenRegistro(existente, volumenPorDefecto);
    }
  }
  const registro = destino.datos.asignaciones[key];
  if (registro.volumen == null && volumenPorDefecto != null) {
    setVolumenRegistro(registro, volumenPorDefecto);
  }
  return registro;
}

function normalizarIdNodo(nodo) {
  if (!nodo) return "";
  if (typeof nodo === "string" || typeof nodo === "number") return String(nodo);
  return nodo.id != null ? String(nodo.id) : "";
}

function buscarNodoPorId(id) {
  const idNorm = normalizarIdNodo(id);
  if (!idNorm) return null;
  return flujoNodos.find(n => normalizarIdNodo(n) === idNorm) || null;
}

function normalizarFlujoNodos() {
  if (!Array.isArray(flujoNodos)) {
    flujoNodos = [];
    return;
  }
  const idsValidos = new Set();
  flujoNodos.forEach(n => {
    if (!n) return;
    const idNorm = normalizarIdNodo(n);
    if (idNorm) {
      n.id = idNorm;
      idsValidos.add(idNorm);
    }
    const x = Number(n.x);
    const y = Number(n.y);
    if (Number.isFinite(x)) n.x = x;
    if (Number.isFinite(y)) n.y = y;
    if (!Number.isFinite(n.x)) n.x = 60;
    if (!Number.isFinite(n.y)) n.y = 60;
    if (!n.tipo) n.tipo = "entrada";
    if (!n.datos || typeof n.datos !== "object") n.datos = {};
    if (!Array.isArray(n.targets)) n.targets = [];
    n.targets = Array.from(
      new Set(n.targets.map(t => normalizarIdNodo(t)).filter(Boolean))
    );
    if (idNorm) {
      n.targets = n.targets.filter(t => t !== idNorm);
    }
  });
  flujoNodos.forEach(n => {
    if (!n || !Array.isArray(n.targets)) return;
    n.targets = n.targets.filter(t => idsValidos.has(t));
  });
}

	function esAncestro(posibleAncestroId, nodoId, visitados = new Set()) {
	  const ancestroId = normalizarIdNodo(posibleAncestroId);
	  const nodoNorm = normalizarIdNodo(nodoId);
	  if (!ancestroId || !nodoNorm) return false;
	  if (ancestroId === nodoNorm) return true;
	  if (visitados.has(nodoNorm)) return false;
	  visitados.add(nodoNorm);
	  const padres = obtenerPredecesores(nodoNorm);
	  return padres.some(pre => esAncestro(ancestroId, pre.id, visitados));
	}

function limpiarAsignacionesOrfanas(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo) || !nodo.datos?.asignaciones) return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.asignaciones).forEach(key => {
    if (!clavesPermitidas.has(key)) {
      delete nodo.datos.asignaciones[key];
    }
  });
  limpiarAportesOrfanos(nodo);
  actualizarVariedadDesdeAportes(nodo);
}

function limpiarAportesOrfanos(nodo) {
  if (!nodo || !nodo.datos?.aportes || typeof nodo.datos.aportes !== "object") return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.aportes).forEach(key => {
    if (!clavesPermitidas.has(String(key))) {
      delete nodo.datos.aportes[key];
    }
  });
}

function recalcularDatosDesdeAportes(nodo) {
  if (!nodo || !nodo.datos || !nodo.datos.aportes || typeof nodo.datos.aportes !== "object") return;

  // En depósitos/coupages el volumen lo llevan las asignaciones (tabla), no los aportes.
  if (["deposito", "coupage"].includes(nodo.tipo)) return;

  const aportes = Object.values(nodo.datos.aportes || {});
  if (!aportes.length) {
    setKilosLitrosNodo(nodo, 0, 0, "aportes_vacios");
    nodo.datos.densidad = "";
    nodo.datos.temperatura = "";
    if ("composicionVariedades" in nodo.datos) nodo.datos.composicionVariedades = [];
    if ("variedad" in nodo.datos) nodo.datos.variedad = "";
    if ("variedadBase" in nodo.datos) nodo.datos.variedadBase = "";
    if ("vino_tipo" in nodo.datos) nodo.datos.vino_tipo = "";
    if ("vino" in nodo.datos) nodo.datos.vino = "";
    return;
  }

  let sumVol = 0;
  let densidadSuma = 0;
  let densidadPeso = 0;
  let densidadPrimera = null;
  let tempSuma = 0;
  let tempPeso = 0;
  let tempPrimera = null;

  aportes.forEach(a => {
    const v = getVolumenFromDatos(a);
    const volumen = Number.isFinite(v) ? v : 0;
    if (volumen > 0) sumVol += volumen;
    const peso = volumen;

    const dens = normalizarNumero(a?.densidad);
    if (dens != null) {
      const pesoD = peso || 1;
      densidadSuma += dens * pesoD;
      densidadPeso += pesoD;
      if (densidadPrimera == null) densidadPrimera = dens;
    }

    const temp = normalizarNumero(a?.temperatura);
    if (temp != null) {
      const pesoT = peso || 1;
      tempSuma += temp * pesoT;
      tempPeso += pesoT;
      if (tempPrimera == null) tempPrimera = temp;
    }
  });

  // Barricas: guardamos el volumen para el relleno visual.
  if (nodo.tipo === "barrica") {
    setKilosLitrosNodo(
      nodo,
      null,
      Number(sumVol.toFixed(2)),
      "recalcular_barrica"
    );
  } else {
    // Nodos de proceso: consolidamos totales.
    setKilosLitrosNodo(
      nodo,
      null,
      Number(sumVol.toFixed(2)),
      "recalcular_proceso"
    );
  }

  const densidadMedia = densidadPeso > 0 ? densidadSuma / densidadPeso : densidadPrimera;
  const temperaturaMedia = tempPeso > 0 ? tempSuma / tempPeso : tempPrimera;
  nodo.datos.densidad =
    densidadMedia != null ? Number(densidadMedia.toFixed(4)) : "";
  nodo.datos.temperatura =
    temperaturaMedia != null ? Number(temperaturaMedia.toFixed(2)) : "";

  // Recalcular mezcla visible acorde a los aportes actuales.
  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix && comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    }
  } catch (e) {
    // noop
  }
}

function limpiarCargaNodo(nodo) {
  if (!nodo || !nodo.datos) return;
  CAMPOS_CARGA_NUMERICOS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = 0;
    }
  });
  CAMPOS_CARGA_METRICAS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  CAMPOS_CARGA_TEXTO.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
  if ("variedadBase" in nodo.datos) {
    nodo.datos.variedadBase = "";
  }
  if ("vino_tipo" in nodo.datos) {
    nodo.datos.vino_tipo = "";
  }
  if ("vino" in nodo.datos) {
    nodo.datos.vino = "";
  }
  if ("tipoColor" in nodo.datos) {
    nodo.datos.tipoColor = "";
  }
  if ("distribucion" in nodo.datos) {
    nodo.datos.distribucion = {};
  }
  if ("reparto_manual" in nodo.datos) {
    nodo.datos.reparto_manual = false;
  }
  Object.keys(nodo.datos).forEach(key => {
    if (key.startsWith("preview")) {
      delete nodo.datos[key];
    }
  });
  if ("aportes" in nodo.datos) {
    nodo.datos.aportes = {};
  }
  if ("asignaciones" in nodo.datos) {
    nodo.datos.asignaciones = {};
  }
  if ("composicionVariedades" in nodo.datos) {
    nodo.datos.composicionVariedades = [];
  }
}

function obtenerTextoVariedadColor(nodo) {
  const textos = [];
  if (!nodo) return textos;
  if (Array.isArray(nodo.datos?.composicionVariedades) && nodo.datos.composicionVariedades.length) {
    textos.push(...nodo.datos.composicionVariedades.map(c => c.nombre));
  }
  if (nodo.datos?.variedad) textos.push(nodo.datos.variedad);
  if (nodo.datos?.vino_tipo) textos.push(nodo.datos.vino_tipo);
  if (nodo.datos?.vino) textos.push(nodo.datos.vino);
  return textos;
}

function obtenerColorVino(nodo) {
  const textos = obtenerTextoVariedadColor(nodo).map(normalizarTextoUva).filter(Boolean);

  // Prioridad 1: tipoColor explícito
  const tipoColor = (nodo.datos?.tipoColor || "").toLowerCase();
  if (tipoColor === "blanca" || tipoColor === "blanco" || tipoColor === "white") return "white";
  if (tipoColor === "tinta" || tipoColor === "tinto" || tipoColor === "red") return "red";

  // Prioridad 2: si el nodo es de entrada y hay cache, usar la variedad de la entrada
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref && Array.isArray(cacheEntradas)) {
    const entrada = cacheEntradas.find(e => String(e.id) === String(nodo.datos.id_ref));
    if (entrada && entrada.variedad) {
      const txtEntrada = normalizarTextoUva(entrada.variedad);
      textos.unshift(txtEntrada);
    }
  }

  // Prioridad 3: si hay composición calculada, decidir por proporción (evita que 1% de blanca pinte todo de blanco)
  try {
    const comp = nodo?.datos?.composicionVariedades;
    if (Array.isArray(comp) && comp.length) {
      let pctBlancas = 0;
      let pctTintas = 0;
      comp.forEach(item => {
        const nombre = normalizarTextoUva(item?.nombre || item?.variedad || "");
        const pct = Number.isFinite(item?.porcentaje) ? item.porcentaje : Number(item?.pct);
        const pctVal = Number.isFinite(pct) ? pct : 0;
        if (!nombre || esVariedadGenerica(nombre)) return;
        if (esVariedadBlanca(nombre)) pctBlancas += pctVal;
        else pctTintas += pctVal;
      });
      const total = pctBlancas + pctTintas;
      if (total > 0) {
        if (pctBlancas > 0 && pctTintas > 0) {
          const ratioBlancas = pctBlancas / total;
          if (ratioBlancas > 0.55) return "white";
          if (ratioBlancas < 0.45) return "red";
          return "rosado";
        }
        return pctBlancas > 0 ? "white" : "red";
      }
    }
  } catch (err) {
    // noop
  }

  // Prioridad 4: heurística por texto
  if (textos.some(txt => txt.includes("ros") || txt.includes("rosad") || txt.includes("clarete"))) return "rosado";
  const hayBlancas = textos.some(txt => esVariedadBlanca(txt));
  if (hayBlancas) {
    const hayTintas = textos.some(txt => txt && !esVariedadBlanca(txt) && !esVariedadGenerica(txt));
    // Si hay mezcla y no tenemos % fiables, por defecto marcamos como tinto (evita amarillos falsos en depósitos).
    return hayTintas ? "red" : "white";
  }
  return "red";
}

function obtenerColorEmojiVino(colorVino) {
  if (colorVino === "white") return "#f7c859";
  if (colorVino === "rosado") return "#f58bb5";
  return "#d43c68";
}

function obtenerEstadoVisual(nodo) {
  if (!nodo || !nodo.datos) return null;
  const faseRaw = (nodo.datos.fase || "").toString().trim();
  const estadoRaw = (nodo.datos.estado || "").toString().trim();
  if (!faseRaw && !estadoRaw) return null;
  const colorVino = obtenerColorVino(nodo);
  const colorTexto = colorVino === "white" ? "#f7c859" : "#d43c68";

  if (faseRaw) {
    const faseNorm = faseRaw.toLowerCase();
    const infoFase = obtenerInfoEstadoDeposito ? obtenerInfoEstadoDeposito(faseNorm) : null;
    if (infoFase && (infoFase.id === faseNorm || faseNorm === "vacio")) {
      return { id: infoFase.id, label: infoFase.label, color: colorTexto };
    }
    return { id: faseNorm, label: faseRaw.toUpperCase(), color: colorTexto };
  }

  const estadoNorm = estadoRaw.toLowerCase();
  const info = obtenerInfoEstadoDeposito ? obtenerInfoEstadoDeposito(estadoNorm) : null;
  if (info) {
    return { id: info.id, label: info.label, color: colorTexto };
  }
  return { id: estadoNorm, label: estadoRaw.toUpperCase(), color: colorTexto };
}

function normalizarTextoUva(str) {
  if (!str) return "";
  return str
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
}

	function esVariedadBlanca(textoNormalizado) {
	  if (!textoNormalizado) return false;
	  if (textoNormalizado.includes("blanc") || textoNormalizado.includes("white") || textoNormalizado.includes("bianco")) {
	    return true;
	  }
  if (!VARIEDADES_BLANCAS_SET) {
    VARIEDADES_BLANCAS_SET = new Set(
      VARIEDADES_BLANCAS.map(nombre => normalizarTextoUva(nombre))
    );
  }
  const tokens = textoNormalizado.split(/[^a-z]+/).filter(Boolean);
  if (tokens.some(tok => VARIEDADES_BLANCAS_SET.has(tok))) return true;
  return Array.from(VARIEDADES_BLANCAS_SET).some(nombre => textoNormalizado.includes(nombre));
	}

	function calcularOcupacionNodo(nodo, volumenVisual = null) {
	  if (!nodo) return null;
	  const datos = nodo.datos || {};
	  const capacidad =
	    normalizarNumero(datos.capacidad) ??
	    normalizarNumero(datos.capacidad_l) ??
	    (datos.capacidad_hl != null ? normalizarNumero(datos.capacidad_hl * 100) : null);
	  if (capacidad == null || !(capacidad > 0)) return null;
	  const volumenBase =
	    volumenVisual != null ? volumenVisual : obtenerCantidadEnUnidad(datos, obtenerUnidadNodo(nodo));
	  if (volumenBase == null) return null;
	  return Math.max(0, Math.min(1, volumenBase / capacidad));
	}

function rellenarDatosEntradaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "entrada") return;
  const idRef = nodo.datos?.id_ref;
  if (!idRef || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => String(e.id) === String(idRef));
  if (!entrada) return;
  nodo.datos = nodo.datos || {};
  if (entrada.variedad) {
    nodo.datos.variedad = entrada.variedad;
    nodo.datos.vino_tipo = entrada.variedad;
    const varNorm = normalizarTextoUva(entrada.variedad);
    nodo.datos.tipoColor = esVariedadBlanca(varNorm) ? "blanca" : "tinta";
  }
  if (entrada.anada) nodo.datos.anada = entrada.anada;
}

function obtenerTemperaturaNodo(nodo) {
  if (!nodo) return null;
  if (normalizarNumero(nodo.datos?.temperatura) != null) {
    return normalizarNumero(nodo.datos.temperatura);
  }
  if (Array.isArray(nodo.datos?.control) && nodo.datos.control.length) {
    const ultimo = nodo.datos.control[nodo.datos.control.length - 1];
    if (normalizarNumero(ultimo?.temperatura) != null) {
      return normalizarNumero(ultimo.temperatura);
    }
  }
  return null;
}

function calcularProgresoBarrica(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  if (!inicioStr) return null;
  const inicio = parsearFechaValor(inicioStr);
  if (!inicio) return null;
  const ahora = new Date();

  const fin = finStr ? parsearFechaValor(finStr) : null;
  let msTotal = 0;
  if (fin) {
    msTotal = fin.getTime() - inicio.getTime();
  } else {
    const mesesObjetivo = normalizarNumero(finStr) || 12; // fallback si guardaron meses como número
    msTotal = mesesObjetivo * 30 * 24 * 60 * 60 * 1000;
  }
  if (!(msTotal > 0)) return null;

  const transcurrido = Math.max(0, ahora.getTime() - inicio.getTime());
  return Math.max(0, Math.min(1, transcurrido / msTotal));
}

function obtenerTooltipCrianza(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return "";
  const inicioStr = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const finStr = nodo.datos?.tiempo;
  const inicio = inicioStr ? parsearFechaValor(inicioStr) : null;
  if (!inicio) {
    return 'Crianza\nDefine "Fecha operación" (inicio).';
  }

  const formatearFechaTooltip = date => {
    if (!date) return "—";
    const d = new Date(date);
    if (isNaN(d.getTime())) return "—";
    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = d.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  };

  const finDate = finStr ? parsearFechaValor(finStr) : null;
  let fin = finDate;
  let finEsEstimado = false;
  if (!finDate) {
    const meses = normalizarNumero(finStr);
    if (meses != null && meses > 0) {
      fin = new Date(inicio.getTime() + meses * 30 * 24 * 60 * 60 * 1000);
      finEsEstimado = true;
    }
  }

  if (!fin) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      'Define "Fin previsto de la crianza" para ver el avance.',
    ].join("\n");
  }

  const ahora = new Date();
  const msTotal = fin.getTime() - inicio.getTime();
  if (!(msTotal > 0)) {
    return [
      "Crianza",
      `Inicio: ${formatearFechaTooltip(inicio)}`,
      `Fin: ${formatearFechaTooltip(fin)}`,
      "Revisa fechas: el fin debe ser posterior al inicio.",
    ].join("\n");
  }

  const msDia = 24 * 60 * 60 * 1000;
  const transcurridoMs = ahora.getTime() - inicio.getTime();
  const restanteMs = fin.getTime() - ahora.getTime();
  const pct = Math.max(0, Math.min(1, transcurridoMs / msTotal));
  const diasTotal = Math.max(1, Math.round(msTotal / msDia));
  const diasTrans = Math.max(0, Math.round(Math.max(0, transcurridoMs) / msDia));
  const diasRest = Math.max(0, Math.round(Math.max(0, restanteMs) / msDia));

  const lineas = [
    `Crianza: ${Math.round(pct * 100)}%`,
    `Inicio: ${formatearFechaTooltip(inicio)}`,
    `Fin: ${formatearFechaTooltip(fin)}${finEsEstimado ? " (estimado)" : ""}`,
    `Transcurrido: ${Math.min(diasTrans, diasTotal)}/${diasTotal} días`,
  ];
  if (restanteMs >= 0) {
    lineas.push(`Restan: ${diasRest} días`);
  } else {
    lineas.push(`Finalizada hace: ${Math.abs(Math.round(restanteMs / msDia))} días`);
  }
  return lineas.join("\n");
}

function obtenerTooltipEmbotellado(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return "";
  const formatos = nodo.datos?.formatos_botella;
  return construirDetalleFormatosBotella(formatos);
}

function getFlowTooltipEl() {
  return document.getElementById("flowTooltip");
}

function posicionarFlowTooltip(clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip || tip.style.display === "none") return;
  const padding = 12;
  const offset = 14;
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth || document.documentElement.clientWidth || 0;
  const vh = window.innerHeight || document.documentElement.clientHeight || 0;

  let x = clientX + offset;
  let y = clientY + offset;
  if (x + rect.width + padding > vw) x = Math.max(padding, clientX - rect.width - offset);
  if (y + rect.height + padding > vh) y = Math.max(padding, clientY - rect.height - offset);

  tip.style.left = `${Math.round(x)}px`;
  tip.style.top = `${Math.round(y)}px`;
}

function mostrarFlowTooltip(texto, clientX, clientY) {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  if (!texto) {
    tip.style.display = "none";
    return;
  }
  tip.textContent = texto;
  tip.style.display = "block";
  posicionarFlowTooltip(clientX, clientY);
}

function ocultarFlowTooltip() {
  const tip = getFlowTooltipEl();
  if (!tip) return;
  tip.style.display = "none";
}

function limpiarNodosSinEntradas() {
  flujoNodos.forEach(nodo => {
    if (nodo.tipo === "entrada") return;
    const predecesores = obtenerPredecesores(nodo.id);
    if (!predecesores.length) {
      const tieneSalidas = Array.isArray(nodo.targets) && nodo.targets.length > 0;
      if (tieneSalidas) return;
      limpiarCargaNodo(nodo);
      if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
        actualizarVariedadDesdeAportes(nodo);
      }
    }
  });
}

function construirCargaDesdeDatos(datos = {}) {
  const carga = {};
  if (datos.variedad) carga.variedad = datos.variedad;
  if (datos.anada) carga.anada = datos.anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  if (datos.fecha_operacion) carga.fecha_operacion = datos.fecha_operacion;
  const volumen = getVolumenFromDatos(datos);
  if (volumen != null) carga.volumen = volumen;
  const densidad = normalizarNumero(datos.densidad);
  if (densidad != null) carga.densidad = densidad;
  const temperatura = normalizarNumero(datos.temperatura);
  if (temperatura != null) carga.temperatura = temperatura;
  return Object.keys(carga).length ? carga : null;
}

function obtenerCargaParaSembrar(origen) {
  if (!origen) return null;
  const visitados = new Set();
  const cola = [origen];
  while (cola.length) {
    const actual = cola.shift();
    if (!actual || visitados.has(actual.id)) continue;
    visitados.add(actual.id);
	    if (actual.tipo === "entrada" && actual.datos?.id_ref) {
	      intentarPoblarNodoEntrada(actual, true);
	    }
	    if (actual.tipo === "deposito" && actual.datos?.id_ref) {
	      intentarPoblarNodoDeposito(actual, true);
	    }
    let carga = obtenerCargaDesdeNodo(actual);
    if (!carga) {
      carga = construirCargaDesdeDatos(actual.datos);
    }
    if (carga) return carga;
    const padres = obtenerPredecesores(actual.id);
    padres.forEach(pre => {
      if (pre && !visitados.has(pre.id)) {
        cola.push(pre);
      }
    });
  }
  return null;
}

function sembrarDatosIniciales(origen, destino) {
  if (!origen || !destino) return;
  if (destino.tipo === "deposito") return;
  const carga = obtenerCargaParaSembrar(origen);
  if (!carga) return;
  aplicarCargaProcesoSinDuplicar(destino, origen.id, carga);
  guardarEstadoNodos();
}

function obtenerVariedadVisibleNodo(nodo) {
  if (!nodo) return "";
  if (nodo.tipo === "deposito") {
    const volumen = getVolumenFromNodo(nodo);
    if (volumen != null && volumen <= 0) return "";
  }
  const compArray = nodo.datos?.composicionVariedades;
  if (Array.isArray(compArray) && compArray.length) {
    return compArray
      .filter(c => c?.nombre && !esVariedadGenerica(c.nombre))
      .map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`)
      .join("\n");
  }
  const comp = calcularComposicionVariedades(nodo);
  const calculada = guardarComposicionEnNodo(nodo, comp.mix, comp.total);
  if (calculada.length) {
    return calculada
      .filter(c => c?.nombre && !esVariedadGenerica(c.nombre))
      .map(c => `${formatearPctVariedad(c.porcentaje)} ${c.nombre}`)
      .join("\n");
  }
  const textoBase = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  if (!textoBase) return "";
  return textoBase
    .split(/[/·]/)
    .map(t => t.trim())
    .filter(Boolean)
    .filter(t => !esVariedadGenerica(t))
    .join("\n");
}

function limpiarTextoVariedad(variedad) {
  if (!variedad) return "";
  return variedad
    .split("·")
    .map(part => part.replace(/\s*\d+(\.\d+)?%/g, "").trim())
    .filter(Boolean)
    .join(" · ");
}

// Helper para sumar variedades ponderadas (admite listas con porcentajes)
function agregarVariedadAPeso(mix, texto, peso) {
  if (!mix || !texto) return;
  const pesoBase = Number.isFinite(Number(peso)) && Number(peso) > 0 ? Number(peso) : 1;
  const partes = texto
    .split(/[\/·,]/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) return;
  const items = partes.map(p => {
    const m = p.match(/^(.*?)(?:\s+(\d+(?:[.,]\d+)?)%?)?$/);
    return {
      nombre: m && m[1] ? m[1].trim() : p,
      pct: m && m[2] ? Number(String(m[2]).replace(",", ".")) : null,
    };
  });
  const conPct = items.filter(i => Number.isFinite(i.pct) && i.pct > 0);
  if (conPct.length) {
    conPct.forEach(i => {
      const nombre = limpiarTextoVariedad(i.nombre);
      if (!nombre || esVariedadGenerica(nombre)) return;
      const aporte = pesoBase * (i.pct / 100);
      mix.set(nombre, (mix.get(nombre) || 0) + aporte);
    });
    return;
  }
  const reparto = pesoBase / items.length;
  items.forEach(i => {
    const nombre = limpiarTextoVariedad(i.nombre);
    if (!nombre || esVariedadGenerica(nombre)) return;
    mix.set(nombre, (mix.get(nombre) || 0) + reparto);
  });
}

function mixToArray(mix, total) {
  if (!mix || !mix.size) return [];
  const entradas = Array.from(mix.entries());
  const sumatoria = total && total > 0 ? total : entradas.reduce((a, [, v]) => a + v, 0);
  const base = sumatoria > 0 ? sumatoria : entradas.length;
  const ordenadas = entradas.sort((a, b) => {
    if (sumatoria <= 0) return a[0].localeCompare(b[0]);
    return b[1] - a[1];
  });
  return ordenadas.map(([nombre, cantidad]) => {
    const peso = sumatoria > 0 ? cantidad : 1;
    const pct = base > 0 ? (peso / base) * 100 : 0;
    return { nombre, porcentaje: pct };
  });
}

function formatearPctVariedad(valor) {
  if (!Number.isFinite(valor)) return "0%";
  if (Math.abs(valor) < 1) return `${valor.toFixed(1)}%`;
  const redondeado = Math.round(valor);
  if (Math.abs(valor - redondeado) < 0.05) return `${redondeado}%`;
  return `${valor.toFixed(1)}%`;
}

function formatearResumenVariedades(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = item.nombre || item.variedad || "";
      const pct = formatearPctVariedad(
        Number.isFinite(item.porcentaje) ? item.porcentaje : Number(item.pct)
      );
      return nombre ? `${pct} ${nombre}` : "";
    })
    .filter(Boolean)
    .join(" / ");
}

function guardarComposicionEnNodo(nodo, mix, total) {
  if (!nodo) return [];
  nodo.datos = nodo.datos || {};
  const composicion = mixToArray(mix, total);
  // Mezcla dinámica calculada en el flujo
  nodo.datos.composicionVariedades = composicion;
  if (composicion.length) {
    nodo.datos.variedad = composicion
      .map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`)
      .join(" / ");
  } else if (!nodo.datos.variedad && nodo.datos.variedadBase) {
    // Fallback solo si no hay mezcla y tampoco texto
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
  return composicion;
}

function calcularComposicionVariedades(nodo, visitados = new Set()) {
  const mix = new Map();
  if (!nodo) return { total: 0, mix };
  const key = nodo.id || nodo;
  if (visitados.has(key)) return { total: 0, mix };
  visitados.add(key);
  const pesoNumerico = valor => {
    const num = Number(valor);
    return Number.isFinite(num) && num > 0 ? num : 0;
  };
  const sumar = (variedad, cantidad) => {
    const cant = pesoNumerico(cantidad);
    if (!cant) return;
    agregarVariedadAPeso(mix, variedad, cant);
  };
  const totalizar = () => Array.from(mix.values()).reduce((acc, v) => acc + v, 0);

  if (nodo.tipo === "entrada") {
    const entrada = nodo.datos?.id_ref ? buscarEntradaPorId(nodo.datos.id_ref) : null;
    const variedad = entrada?.variedad || nodo.datos?.variedad || nodo.datos?.vino || "";
    const pesoEntrada = getVolumenFromDatos(entrada);
    const pesoNodo = getVolumenFromNodo(nodo);
    const peso =
      (Number.isFinite(pesoEntrada) && pesoEntrada > 0
        ? pesoEntrada
        : Number.isFinite(pesoNodo) && pesoNodo > 0
        ? pesoNodo
        : 1);
    agregarVariedadAPeso(mix, variedad, peso);
    return { total: totalizar(), mix };
  }

  const tieneAsignaciones = nodo.datos?.asignaciones && Object.keys(nodo.datos.asignaciones).length;
  if (tieneAsignaciones) {
    const permitidos = new Set(obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre)));
    Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
      if (!permitidos.has(origenId)) return;
      const cantidad = getVolumenFromDatos(info);
      if (!(cantidad > 0)) return;
      const origen = obtenerNodoPorId(origenId);
      const comp = calcularComposicionVariedades(origen, visitados);
      if (!comp.mix.size) return;
      const factor = comp.total > 0 ? cantidad / comp.total : 1;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, valor * factor);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
    // Si hay asignaciones pero sin cantidades, no forzamos porcentajes: seguimos con aportes/padres.
    // Solo si no hay otra fuente de cantidad, haremos fallback al final.
    // Si no hay cantidades válidas, seguimos buscando en padres o dato propio.
  }

  // Si el nodo tiene aportes acumulados (nodos de proceso/trasiegos), usamos esa mezcla directa.
  // Filtramos por predecesores actuales para evitar aportes huérfanos o incompletos.
  if (nodo.datos?.aportes) {
    const predecesores = obtenerPredecesores(nodo.id);
    const idsPermitidos = new Set(predecesores.map(pre => normalizarIdNodo(pre)));
    if (idsPermitidos.size) {
      const entries = Object.entries(nodo.datos.aportes).filter(([origenId]) =>
        idsPermitidos.has(String(origenId))
      );
      // Si faltan aportes para algún predecesor, preferimos calcular desde los padres.
      if (!(idsPermitidos.size > 1 && entries.length < idsPermitidos.size)) {
        const aportes = entries.map(([, a]) => a);
        const pesos = aportes.map(a => getVolumenFromDatos(a) || 0);
        const hayPesos = pesos.some(p => p > 0);
        aportes.forEach((a, idx) => {
          if (!a?.variedad) return;
          const peso = pesos[idx] || 0;
          if (hayPesos) {
            if (!(peso > 0)) return;
            agregarVariedadAPeso(mix, a.variedad, peso);
            return;
          }
          // Si no hay cantidad válida en ningún aporte, mostramos mezcla visual a partes iguales.
          agregarVariedadAPeso(mix, a.variedad, 1);
        });
        const total = totalizar();
        if (total > 0 && mix.size) {
          return { total, mix };
        }
      }
    }
  }

  const padres = obtenerPredecesores(nodo.id);
  if (padres.length) {
    padres.forEach(pre => {
      const pesoBase = getVolumenFromNodo(pre) || 1;
      const comp = calcularComposicionVariedades(pre, visitados);
      if (!comp.mix.size) return;
      const factor = comp.total > 0 ? pesoBase / comp.total : pesoBase;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, valor * factor);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
  }

  // Fallback final: si hay asignaciones pero no cantidades, mezclamos a partes iguales por origen
  // (p.ej. recién conectado pero sin litros/kilos asignados todavía).
  if (tieneAsignaciones) {
    const permitidos = new Set(obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre)));
    Object.keys(nodo.datos.asignaciones).forEach(origenId => {
      if (!permitidos.has(origenId)) return;
      const origen = obtenerNodoPorId(origenId);
      const comp = calcularComposicionVariedades(origen, visitados);
      if (!comp.mix.size) return;
      comp.mix.forEach((valor, nombre) => {
        agregarVariedadAPeso(mix, nombre, 1);
      });
    });
    if (mix.size) {
      return { total: totalizar(), mix };
    }
  }

  const propia = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  const pesoPropio = getVolumenFromNodo(nodo) || 1;
  sumar(propia, pesoPropio);
  return { total: totalizar(), mix };
}

function formatearComposicionVariedades(mix, total) {
  const composicion = mixToArray(mix, total);
  if (!composicion.length) return "";
  return composicion.map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`).join(" / ");
}

function normalizarFormatosBotellaLista(formatos) {
  if (!Array.isArray(formatos)) return [];
  return formatos
    .map(item => {
      if (!item) return null;
      const formato = (item.formato || item.tipo || item.botella || "").toString().trim();
      const botellasRaw = normalizarNumero(item.botellas);
      const botellas = Number.isFinite(botellasRaw)
        ? Math.max(0, Math.floor(botellasRaw))
        : 0;
      if (!formato || !(botellas > 0)) return null;
      const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
      const litros = volBotella > 0 ? botellas * volBotella : 0;
      return { formato, botellas, litros };
    })
    .filter(Boolean);
}

function calcularResumenFormatosBotellaDesdeLista(formatos) {
  const lista = normalizarFormatosBotellaLista(formatos);
  let totalBotellas = 0;
  let totalLitros = 0;
  lista.forEach(item => {
    totalBotellas += item.botellas;
    totalLitros += item.litros;
  });
  return {
    totalBotellas,
    totalLitros,
    formatosActivos: lista.length,
    lista,
  };
}

function construirDetalleFormatosBotella(formatos) {
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  if (!resumen.lista.length) return "";
  const lineas = ["Formatos:"];
  resumen.lista.forEach(item => {
    const etiqueta = item.botellas === 1 ? "botella" : "botellas";
    const litrosTxt = item.litros > 0 ? ` (${item.litros.toFixed(2)} L)` : "";
    lineas.push(
      `${item.formato}: ${item.botellas.toLocaleString("es-ES")} ${etiqueta}${litrosTxt}`
    );
  });
  if (resumen.totalBotellas > 0) {
    const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
    const litrosTotal = resumen.totalLitros > 0 ? ` · ${resumen.totalLitros.toFixed(2)} L` : "";
    lineas.push(`Total: ${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${litrosTotal}`);
  }
  return lineas.join("\n");
}

function formatearResumenFormatosEmbotellado(formatos) {
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  if (!resumen.lista.length) return "";
  return resumen.lista
    .map(item => `${item.botellas.toLocaleString("es-ES")}×${item.formato}`)
    .join(" · ");
}

function calcularResumenFormatosBotella(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") {
    return { totalBotellas: 0, totalLitros: 0, formatosActivos: 0 };
  }
  const formatos = Array.isArray(nodo.datos?.formatos_botella)
    ? nodo.datos.formatos_botella
    : [];
  const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
  return {
    totalBotellas: resumen.totalBotellas,
    totalLitros: resumen.totalLitros,
    formatosActivos: resumen.formatosActivos,
  };
}

function obtenerVolumenNumericoNodo(nodo) {
  if (!nodo) return null;
  const valorVisual = obtenerVolumenVisualNodo(nodo);
  const volumen = valorVisual != null ? valorVisual : obtenerVolumenActualNodo(nodo);
  return Number.isFinite(volumen) ? Number(volumen) : null;
}

function esNodoProcesoHistorico(nodo) {
  if (!nodo) return false;
  return nodo.tipo === "estilo" || nodo.tipo === "prensado" || nodo.tipo === "fermentacion";
}

function obtenerHistoricoNodo(nodo) {
  if (!nodo) return 0;
  if (nodo.tipo === "entrada") {
    const base = obtenerVolumenBaseNodoParaUI(nodo);
    return Number.isFinite(base) ? Number(base) : 0;
  }
  const padres = obtenerPredecesores(nodo.id);
  if (!padres.length) return 0;
  const vistos = new Set();
  return padres.reduce((total, pre) => {
    const preId = normalizarIdNodo(pre);
    if (!preId || vistos.has(preId)) return total;
    vistos.add(preId);
    const volumen = obtenerVolumenTransferenciaEntreNodos(pre, nodo);
    return total + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
}

function obtenerTextoVolumenNodo(nodo) {
  if (!nodo) return "";
  const valor = obtenerVolumenNumericoNodo(nodo);

  if (nodo.tipo === "embotellado") {
    const resumen = calcularResumenFormatosBotella(nodo);
    if (resumen.totalBotellas > 0) {
      const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
      const sufijo = resumen.formatosActivos > 1 ? " (mixto)" : "";
      return `${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${sufijo}`;
    }
    const litros = normalizarNumero(valor);
    const volBotella = VOLUMEN_BOTELLA_L[nodo.datos?.botella] || 0;
    if (volBotella > 0 && litros != null) {
      const botellas = Math.floor(litros / volBotella);
      const etiqueta = botellas === 1 ? "botella" : "botellas";
      return `${botellas.toLocaleString("es-ES")} ${etiqueta}`;
    }
    return "Botellas —";
  }

  const capBase =
    normalizarNumero(nodo.datos?.capacidad) ??
    normalizarNumero(nodo.datos?.capacidad_l) ??
    (nodo.datos?.capacidad_hl != null
      ? normalizarNumero(nodo.datos.capacidad_hl * 100)
      : null);

  const redondear = v => (Number.isFinite(v) ? Number(v.toFixed(0)) : null);
  const cap = redondear(capBase);
  let cont = redondear(valor);

  if (nodo.tipo === "entrada") {
    if (cont != null) return `Kg ${cont}`;
    return "Pendiente de Kg";
  }

  if (cont == null && (nodo.tipo === "deposito" || nodo.tipo === "barrica")) {
    const info = nodo.tipo === "deposito"
      ? resolverInfoDepositoDesdeNodo(nodo)
      : resolverInfoBarricaDesdeNodo(nodo);
    const estado = normalizarNumero(
      info?.cantidad ??
        info?.litros_actuales ??
        nodo.datos?.cantidad ??
        nodo.datos?.litros_actuales
    );
    cont = redondear(estado);
  }

  if (nodo.tipo === "deposito" || nodo.tipo === "barrica") {
    if (cont == null) return "Pendiente de volumen";
    if (cap != null) return `Volumen ${cont}/${cap}`;
    return `Volumen ${cont}`;
  }
  if (cont != null) {
    return `Volumen ${cont}`;
  }
  return "Pendiente de volumen";
}

function describirNodoOrigen(origen) {
  if (!origen) return "Nodo";
  const base = origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
  const variedad = obtenerVariedadVisibleNodo(origen);
  if (origen.tipo === "estilo") {
    const metodo = origen.datos?.metodo ? ` · ${origen.datos.metodo}` : "";
    const variedadTexto = variedad ? ` (${variedad})` : "";
    return `${base}${metodo}${variedadTexto}`;
  }
  if (origen.tipo === "entrada") {
    if (origen.datos?.id_ref) {
      return obtenerEtiquetaEntrada(origen.datos.id_ref);
    }
    return variedad ? `${base} (${variedad})` : base;
  }
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    const info =
      origen.tipo === "deposito"
        ? buscarDepositoPorId(origen.datos?.id_ref)
        : (() => {
            const datos = origen.datos || {};
            const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
            const id = datos.contenedor_id || datos.id_ref;
            if (!id) return null;
            return tipoCont === "barrica" ? buscarBarricaPorId(id) : buscarDepositoPorId(id);
          })();
    const nombre = info?.codigo || origen.datos?.codigo || origen.titulo || base;
    const varTexto =
      info?.vino_tipo ||
      origen.datos?.vino_tipo ||
      origen.datos?.variedad ||
      variedad ||
      "";
    const varLabel = varTexto ? ` (${varTexto})` : "";
    return `${nombre}${varLabel}`;
  }
  return variedad ? `${base} (${variedad})` : base;
}

function describirNodoDestino(dest) {
  if (!dest) return "Nodo";
  const contenedor = obtenerContenedorPorIdRef(dest.datos?.id_ref);
  if (contenedor) {
    const nombre =
      contenedor.codigo ||
      dest.datos?.codigo ||
      dest.titulo ||
      (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad =
      contenedor.variedad ||
      dest.datos?.vino_tipo ||
      dest.datos?.variedad ||
      "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  if (dest.tipo === "deposito") {
    const info = dest.datos?.id_ref ? buscarDepositoPorId(dest.datos.id_ref) : null;
    const nodosMap = getNodosPorId();
    const mapaDep = crearMapaDeposPorRef(nodosMap);
    const refKey = dest.datos?.id_ref != null ? String(dest.datos.id_ref) : null;
    const nombreMapa = refKey && mapaDep[refKey] ? mapaDep[refKey].codigo : null;
    const nombre =
      info?.codigo ||
      nombreMapa ||
      dest.datos?.codigo ||
      dest.titulo ||
      (dest.datos?.id_ref ? `Depósito #${dest.datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || dest.datos?.vino_tipo || dest.datos?.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  return etiquetarDestinoFlow(dest);
}

function obtenerContenedorPrevio(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return null;
  visitados.add(origen.id);
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    return origen;
  }
  const padres = obtenerPredecesores(origen.id);
  for (const pre of padres) {
    const encontrado = obtenerContenedorPrevio(pre, visitados);
    if (encontrado) return encontrado;
  }
  return null;
}

function nombreOrigenBlend(origen) {
  if (!origen) return "Origen";
  const datos = origen.datos || {};
  const contenedorPrevio = obtenerContenedorPrevio(origen);
  if (contenedorPrevio && contenedorPrevio !== origen) {
    return nombreOrigenBlend(contenedorPrevio);
  }
  if (origen.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      (datos.id_ref ? `Depósito ${datos.id_ref}` : "Depósito")
    );
  }
  if (origen.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback = datos.contenedor_id
      ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
      : "";
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza"
    );
  }
  if (origen.tipo === "entrada") {
    return datos.id_ref ? obtenerEtiquetaEntrada(datos.id_ref) : origen.titulo || "Entrada";
  }
  return origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
}

function obtenerEtiquetaEntrada(id) {
  if (!id) return "";
  const entrada = cacheEntradas.find(e => String(e.id) === String(id));
  if (!entrada) return `Entrada #${id}`;
  const variedad = entrada.variedad ? ` (${entrada.variedad})` : "";
  return `Entrada #${id}${variedad}`;
}

function buscarEntradaPorId(id) {
  if (!id || !Array.isArray(cacheEntradas)) return null;
  return cacheEntradas.find(e => String(e.id) === String(id)) || null;
}

function buscarDepositoPorId(id) {
  if (!id || !Array.isArray(cacheDepositos)) return null;
  const dep = cacheDepositos.find(d => String(d.id) === String(id));
  if (dep) return dep;
  if (Array.isArray(cacheMastelones)) {
    const mas = cacheMastelones.find(m => String(m.id) === String(id));
    if (mas) return mas;
  }
  return null;
}

function buscarDepositoPorCodigo(codigo) {
  if (!codigo) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  const dep =
    (cacheDepositos || []).find(d => (d.codigo || "").toLowerCase() === codNorm) ||
    (cacheMastelones || []).find(d => (d.codigo || "").toLowerCase() === codNorm);
  return dep || null;
}

function resolverInfoDepositoDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "deposito") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.id_ref) {
    info = buscarDepositoPorId(datos.id_ref);
  }
  if (!info && datos.codigo) {
    info = buscarDepositoPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarDepositoPorCodigo(nodo.titulo);
  }
  return info;
}

function buscarBarricaPorId(id) {
  if (!id || !Array.isArray(cacheBarricas)) return null;
  return cacheBarricas.find(b => String(b.id) === String(id)) || null;
}

function buscarBarricaPorCodigo(codigo) {
  if (!codigo || !Array.isArray(cacheBarricas)) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  return cacheBarricas.find(b => (b.codigo || "").toLowerCase() === codNorm) || null;
}

function resolverInfoBarricaDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.contenedor_id) {
    info = buscarBarricaPorId(datos.contenedor_id);
  }
  if (!info && datos.codigo) {
    info = buscarBarricaPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarBarricaPorCodigo(nodo.titulo);
  }
  return info;
}

function obtenerContenedorPorIdRef(idRef) {
  if (!idRef) return null;
  const dep = buscarDepositoPorId(idRef);
  if (dep) {
    return { tipo: "deposito", codigo: dep.codigo, variedad: dep.vino_tipo };
  }
  const bar = buscarBarricaPorId(idRef);
  if (bar) {
    return { tipo: "barrica", codigo: bar.codigo, variedad: bar.vino_tipo };
  }
  return null;
}

function rellenarDatosDepositoDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "deposito" || !nodo.datos?.id_ref) return;
  const info = buscarDepositoPorId(nodo.datos.id_ref);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    nodo.datos.capacidad ||
    info.capacidad_l ||
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.vino_tipo = nodo.datos.vino_tipo || info.vino_tipo;
  const tieneMezcla = Array.isArray(nodo.datos.composicionVariedades) && nodo.datos.composicionVariedades.length > 0;
  nodo.datos.variedadBase = nodo.datos.variedadBase || info.vino_tipo || nodo.datos.variedad || "";
  if (!tieneMezcla && !nodo.datos.variedad) {
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
}

function rellenarDatosCrianzaDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const tipoCont = claveContenedor(nodo.datos?.contenedor_tipo) || "barrica";
  const id = nodo.datos?.contenedor_id || nodo.datos?.id_ref;
  if (!id) return;
  const info =
    tipoCont === "barrica"
      ? buscarBarricaPorId(id) || buscarBarricaPorCodigo(nodo.datos?.codigo || nodo.titulo)
      : buscarDepositoPorId(id) || buscarDepositoPorCodigo(nodo.datos?.codigo || nodo.titulo);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  const capInfo =
    info.capacidad_l ??
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : null) ??
    nodo.datos.capacidad;
  if (capInfo != null) {
    nodo.datos.capacidad = capInfo;
    nodo.datos.capacidad_l = capInfo;
  }
  const volumenInfo = info.litros_actuales ?? info.volumen ?? null;
  if (volumenInfo != null) {
    aplicarVolumenAbsoluto(nodo, volumenInfo, "litros", "cache_crianza");
  }
  nodo.datos.vino_tipo = nodo.datos.vino_tipo || info.vino_tipo;
  const tieneMezcla = Array.isArray(nodo.datos.composicionVariedades) && nodo.datos.composicionVariedades.length > 0;
  nodo.datos.variedadBase = nodo.datos.variedadBase || info.vino_tipo || nodo.datos.variedad || "";
  if (!tieneMezcla && !nodo.datos.variedad) {
    nodo.datos.variedad = nodo.datos.variedadBase;
  }
  // Texto descriptivo del contenedor elegido para mostrar en modal/nodo.
  const tipoLabel = nodo.datos.contenedor_tipo || (tipoCont === "barrica" ? "Barrica" : "Depósito");
  const descripcion = describirContenedor(info, tipoLabel);
  if (descripcion) {
    nodo.datos.tipo = descripcion;
  } else if (tipoLabel) {
    nodo.datos.tipo = tipoLabel;
  }
}

// Cargar nodos (preferimos el estado en memoria) y mapear por id
function getNodosPorId() {
  const enMemoria = Array.isArray(flujoNodos) ? flujoNodos : [];
  const nodos =
    enMemoria.length > 0
      ? enMemoria
      : JSON.parse(localStorage.getItem("flowNodes") || "[]");
  return Object.fromEntries(nodos.map(n => [n.id, n]));
}

function crearMapaDeposPorRef(nodosPorId) {
  const mapa = {};
  Object.values(nodosPorId || {}).forEach(nodo => {
    if (nodo.tipo === "deposito" && nodo.datos?.id_ref != null) {
      const clave = String(nodo.datos.id_ref);
      rellenarDatosDepositoDesdeCache(nodo);
      if (!mapa[clave]) {
        mapa[clave] = {
          codigo: nodo.datos.codigo || nodo.titulo || `Depósito #${clave}`,
          nodoId: nodo.id,
        };
      }
    }
  });
  return mapa;
}

function getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef) {
  const nodo = nodosPorId[idNodoDestino];
  if (!nodo) return `Nodo ${idNodoDestino}`;

  const datos = nodo.datos || {};
  const mapa = mapaDepRef || crearMapaDeposPorRef(nodosPorId);

  switch (nodo.tipo) {
    case "deposito":
      // A1, A2, A3…
      if (datos.id_ref != null) {
        const depMap = mapa[String(datos.id_ref)];
        if (depMap?.codigo) return depMap.codigo;
        const info = buscarDepositoPorId(datos.id_ref);
        if (info?.codigo) return info.codigo;
      }
      return `${datos.codigo || nodo.titulo || "Depósito"}`;

    case "barrica":
      // Crianza / Barrica 500L Francés, etc.
      return nodo.titulo || datos.tipo || "Crianza";

    case "entrada":
      // Solo por si algún día enlazas a otra entrada
      return `Entrada #${datos.id_ref || "?"}${
        datos.variedad ? ` (${datos.variedad})` : ""
      }`;

    default:
      return nodo.titulo || nodo.tipo || `Nodo ${idNodoDestino}`;
  }
}

function buildRepartoDestinos(nodoElaboracion) {
  if (!nodoElaboracion) return [];
  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const distribucion = nodoElaboracion.datos?.distribucion || {};
  return Object.entries(distribucion).map(([idNodoDestino, valores]) => {
    return {
      idNodoDestino,
      nombre: getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef),
      volumen: getVolumenFromDatos(valores) || 0,
    };
  });
}

function etiquetarDestinoFlow(dest) {
  if (!dest) return "Nodo";
  const datos = dest.datos || {};

  if (dest.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    const nombre =
      info?.codigo ||
      datos.codigo ||
      dest.titulo ||
      (datos.id_ref ? `Depósito #${datos.id_ref}` : "Depósito");
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "barrica") {
    const tipoCont = claveContenedor(datos.contenedor_tipo) || "barrica";
    const info = datos.contenedor_id
      ? tipoCont === "barrica"
        ? buscarBarricaPorId(datos.contenedor_id)
        : buscarDepositoPorId(datos.contenedor_id)
      : null;
    const etiquetaFallback =
      datos.contenedor_id
        ? `${tipoCont === "barrica" ? "Barrica" : "Depósito"} ${datos.contenedor_id}`
        : "";
    const nombre =
      info?.codigo ||
      dest.titulo ||
      datos.codigo ||
      datos.tipo ||
      etiquetaFallback ||
      "Crianza";
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "entrada" && datos.id_ref) {
    return obtenerEtiquetaEntrada(datos.id_ref);
  }

  // Si viene con id_ref de contenedor aunque el tipo no sea depósito/barrica, intentamos resolverlo
  const contenedor = obtenerContenedorPorIdRef(datos.id_ref);
  if (contenedor) {
    const nombre = contenedor.codigo || dest.titulo || (contenedor.tipo === "barrica" ? "Barrica" : "Depósito");
    const variedad = contenedor.variedad || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  return dest.titulo || dest.tipo || "Nodo";
}

function obtenerEtiquetaNodoLimite(nodo) {
  if (!nodo) return "Este nodo";
  if (nodo.tipo === "entrada") {
    return obtenerEtiquetaEntrada(nodo.datos?.id_ref) || "Esta entrada";
  }
  if (nodo.tipo === "deposito") {
    return nodo.datos?.codigo || nodo.titulo || "Depósito";
  }
  return nodo.titulo || "Este nodo";
}

	function sumarConsumoDesdeNodo(origen) {
	  if (!origen) return 0;
	  const origenKey = normalizarIdNodo(origen);
	  const vistos = new Set();
	  return (origen.targets || []).reduce((total, targetId) => {
	    const destinoId = normalizarIdNodo(targetId);
	    if (!destinoId || vistos.has(destinoId)) return total;
	    vistos.add(destinoId);
	    const destino = obtenerNodoPorId(destinoId);
	    if (!destino) return total;

	    const registroAsignacion =
	      destino.datos?.asignaciones?.[origenKey] ||
	      destino.datos?.asignaciones?.[String(origen.id)];
	    // En contenedores (depósito/coupage), la fuente de verdad para el consumo son las asignaciones (tabla).
	    if (registroAsignacion && (destino.tipo === "deposito" || destino.tipo === "coupage")) {
	      const valor = getVolumenFromDatos(registroAsignacion);
	      return total + (Number.isFinite(valor) ? valor : 0);
	    }

	    const aporte =
	      destino.datos?.aportes?.[origenKey] ||
	      destino.datos?.aportes?.[String(origen.id)];
	    if (aporte) {
	      const valor = getVolumenFromDatos(aporte);
	      return total + (Number.isFinite(valor) ? valor : 0);
	    }

	    if (registroAsignacion) {
	      const valor = getVolumenFromDatos(registroAsignacion);
	      return total + (Number.isFinite(valor) ? valor : 0);
	    }
	    return total;
	  }, 0);
	}

function obtenerLimiteNodo(nodo) {
  if (!nodo) return null;
  // Recalcular/normalizar la carga antes de validar para evitar inconsistencias visual vs. validación.
  const carga = obtenerCargaDesdeNodo(nodo);
  const total = carga ? getVolumenFromDatos(carga) : getVolumenFromNodo(nodo);
  const totalNum = Number.isFinite(total) ? Number(total.toFixed(2)) : 0;
  return totalNum;
}

function obtenerVolumenBaseNodoParaUI(nodo) {
  if (!nodo) return null;
  const carga = obtenerCargaDesdeNodo(nodo);
  const base = carga ? getVolumenFromDatos(carga) : getVolumenFromNodo(nodo);
  return Number.isFinite(base) ? Number(base.toFixed(2)) : null;
}

function obtenerVolumenRestanteNodo(nodo) {
  if (!nodo) return null;
  const limite = obtenerVolumenBaseNodoParaUI(nodo);
  if (limite == null) return null;
  // La entrada de uva es una referencia: sus kilos no se descuentan visualmente.
  if (nodo.tipo === "entrada") return limite;
  // En nodos de proceso mantenemos el volumen 1-1 (solo varía si hay merma).
  if (esNodoProcesoHistorico(nodo)) return limite;
  const consumo = sumarConsumoDesdeNodo(nodo);
  const consumoSeguro = Number.isFinite(consumo) ? consumo : 0;
  const restante = Number(limite) - consumoSeguro;
  if (!Number.isFinite(restante)) return null;
  return Math.max(0, restante);
}

	function repararNodoFuenteSinLimite(origen, consumo) {
	  if (!origen || !origen.id) return false;
	  if (origen.tipo === "entrada") return false;
	  const padres = obtenerPredecesores(origen.id);
	  if (padres.length) return false;
	  const valor = Number(consumo);
	  if (!Number.isFinite(valor) || valor <= 0) return false;
	  origen.datos = origen.datos || {};
	  const limite = Number(valor.toFixed(2));
	  setKilosLitrosNodo(origen, null, limite, "reparar_limite");
	  return true;
	}

	function ajustarRegistroAsignacionParaUnidad(registro, _unidad, nuevoValor) {
	  if (!registro) return;
	  const objetivo = Math.max(0, Number.isFinite(Number(nuevoValor)) ? Number(nuevoValor) : 0);
	  setVolumenRegistro(registro, objetivo);
	}

	function ajustarAporteParaUnidad(aporte, _unidad, nuevoValor) {
	  if (!aporte) return;
	  const objetivo = Math.max(0, Number.isFinite(Number(nuevoValor)) ? Number(nuevoValor) : 0);
	  setVolumenRegistro(aporte, objetivo);
	  aporte.litros_directos = aporte.volumen != null ? aporte.volumen : null;
	}

	function recortarConsumoDesdeNodo(origen, limite) {
	  if (!origen || !Array.isArray(origen.targets) || !origen.targets.length) return false;
	  const lim = Number(limite);
	  if (!Number.isFinite(lim)) return false;
	  const origenKey = normalizarIdNodo(origen);
	  const edges = (origen.targets || [])
	    .map(targetId => {
	      const destino = obtenerNodoPorId(targetId);
	      if (!destino) return null;
	      const datos = destino.datos || {};
	      const reg =
	        datos.asignaciones?.[origenKey] || datos.asignaciones?.[String(origen.id)];
	      const aporte =
	        datos.aportes?.[origenKey] || datos.aportes?.[String(origen.id)];
	      const consumoReg = r => getVolumenFromDatos(r);
	      const consumoAporte = a => getVolumenFromDatos(a);
	      let valor = 0;
	      let manual = false;
	      if (reg) {
	        valor = consumoReg(reg) || 0;
	        manual = reg?.__manual === true;
	      } else if (aporte) {
	        valor = consumoAporte(aporte) || 0;
	      }
	      return { destino, reg, aporte, valor, manual };
	    })
	    .filter(Boolean);

	  const total = edges.reduce((acc, e) => acc + (Number.isFinite(e.valor) ? e.valor : 0), 0);
	  if (!(total > lim + 0.0001)) return false;

	  let exceso = total - lim;
	  const orden = [...edges].sort((a, b) => {
	    if (a.manual === b.manual) return 0;
	    return a.manual ? 1 : -1; // primero no-manual
	  });

	  for (const edge of orden) {
	    if (!(exceso > 0.0001)) break;
	    const actual = Number(edge.valor) || 0;
	    if (!(actual > 0)) continue;
	    const delta = Math.min(actual, exceso);
	    const nuevo = Math.max(0, actual - delta);
	    if (edge.reg) {
	      ajustarRegistroAsignacionParaUnidad(edge.reg, null, nuevo);
	      if (edge.destino.tipo === "deposito" || edge.destino.tipo === "coupage") {
	        actualizarVolumenDesdeAsignaciones(edge.destino);
	        actualizarVariedadDesdeAportes(edge.destino);
	      }
	    } else if (edge.aporte) {
	      ajustarAporteParaUnidad(edge.aporte, null, nuevo);
	      try {
	        recalcularDatosDesdeAportes(edge.destino);
	      } catch (e) {
	        // noop
	      }
	    }
	    edge.valor = nuevo;
	    exceso -= delta;
	  }

	  return true;
	}

	function validarLimitesFlujo(intentarReparar = true) {
	  const MAX_PASADAS_REPARACION = 4;
	  const pasadas = intentarReparar ? MAX_PASADAS_REPARACION : 1;

  for (let pasada = 0; pasada < pasadas; pasada++) {
    let huboReparaciones = false;

    for (const nodo of flujoNodos) {
      const limite = obtenerLimiteNodo(nodo);
      if (limite == null) continue;
      const consumo = sumarConsumoDesdeNodo(nodo);
      if (!(consumo > limite + 0.0001)) continue;

      if (!intentarReparar) {
        return {
          ok: false,
          nodo,
          consumo,
          limite,
          unidad: obtenerUnidadVisual(nodo),
        };
      }

	      try {
	        const padres = obtenerPredecesores(nodo.id);
	        // Si el nodo tiene entradas, reconstruimos aportes desde sus padres antes de bloquear.
	        // Esto evita falsos "0 disponible" cuando aún no se han recalculado los aportes.
	        if (padres.length) {
	          padres.forEach(pre => redistribuirCargas(pre));
	        } else if (Number(limite) <= 0.0001) {
	          repararNodoFuenteSinLimite(nodo, consumo);
	        }
	        // Reparación suave: recalcula repartos automáticos para intentar cuadrar límites sin bloquear la UI.
	        redistribuirCargas(nodo);
	        // Último recurso: recortar consumos (auto primero) para que el flujo no bloquee conexiones.
	        const limiteRe = obtenerLimiteNodo(nodo);
	        const consumoRe = sumarConsumoDesdeNodo(nodo);
	        if (limiteRe != null && consumoRe > limiteRe + 0.0001) {
	          const recortado = recortarConsumoDesdeNodo(nodo, limiteRe);
	          if (recortado) {
	            redistribuirCargas(nodo);
	          }
	        }
	      } catch (err) {
	        // noop
	      }

      huboReparaciones = true;
    }

    if (!huboReparaciones) {
      return { ok: true };
    }
  }

  // Si tras varias pasadas sigue habiendo inconsistencias, devolvemos el primer error sin tocar nada.
  return intentarReparar ? validarLimitesFlujo(false) : { ok: true };
}

function obtenerFechaNodoParaReplay(nodo) {
  if (!nodo) return null;
  const datos = nodo.datos || {};
  const raw = datos.fecha_operacion || datos.fecha || datos.fecha_hora || "";
  const fecha = parsearFechaValor(String(raw || ""));
  return fecha ? fecha.getTime() : null;
}

function obtenerLitrosTransferenciaEntreNodos(origen, destino) {
  if (!origen || !destino) return 0;
  const key = normalizarIdNodo(origen);
  const datos = destino.datos || {};
  const regAsig = datos.asignaciones?.[key] || datos.asignaciones?.[String(origen.id)];
  if (regAsig) {
    const volumen = getVolumenFromDatos(regAsig);
    if (volumen != null) return volumen > 0 ? volumen : 0;
  }
  const aporte = datos.aportes?.[key] || datos.aportes?.[String(origen.id)];
  if (aporte) {
    const volumen = getVolumenFromDatos(aporte);
    if (volumen != null) return volumen > 0 ? volumen : 0;
  }
  return 0;
}

function obtenerKilosTransferenciaEntreNodos(origen, destino) {
  if (!origen || !destino) return 0;
  return 0;
}

function obtenerVolumenTransferenciaEntreNodos(origen, destino) {
  const volumen = obtenerLitrosTransferenciaEntreNodos(origen, destino);
  return Number.isFinite(volumen) && volumen > 0 ? volumen : 0;
}

function construirModeloReplayFlujo(rootId) {
  const root = obtenerNodoPorId(rootId);
  if (!root) return null;

  const rootNorm = normalizarIdNodo(root);
  const nodesSet = new Set();
  const stack = [rootNorm];
  while (stack.length) {
    const id = stack.pop();
    if (!id || nodesSet.has(id)) continue;
    nodesSet.add(id);
    const nodo = obtenerNodoPorId(id);
    if (!nodo) continue;
    (nodo.targets || []).forEach(t => {
      const tid = normalizarIdNodo(t);
      if (tid && !nodesSet.has(tid)) stack.push(tid);
    });
  }

  const nodes = new Map();
  nodesSet.forEach(id => {
    const nodo = obtenerNodoPorId(id);
    if (nodo) nodes.set(id, nodo);
  });

  const nodeTs = new Map();
  let sinFecha = 0;
  nodes.forEach((nodo, id) => {
    const ts = obtenerFechaNodoParaReplay(nodo);
    if (ts == null) sinFecha += 1;
    else nodeTs.set(id, ts);
  });

  const rootTs = nodeTs.get(rootNorm) ?? null;
  const pasosOrdenados = Array.from(new Set(Array.from(nodeTs.values()))).sort((a, b) => a - b);
  const pasos = rootTs != null ? pasosOrdenados.filter(ts => ts >= rootTs) : pasosOrdenados;

  const edges = [];
  const inCount = new Map();
  nodes.forEach((origen, origenId) => {
    (origen.targets || []).forEach(destIdRaw => {
      const destId = normalizarIdNodo(destIdRaw);
      if (!destId || !nodes.has(destId)) return;
      const destino = nodes.get(destId);
      const volumen = obtenerVolumenTransferenciaEntreNodos(origen, destino);
      const ts = nodeTs.get(destId) ?? null;
      edges.push({ origenId, destId, volumen, ts });
      inCount.set(destId, (inCount.get(destId) || 0) + 1);
    });
  });

  const baseVolumen = new Map();
  nodes.forEach((nodo, id) => {
    const tieneEntradas = (inCount.get(id) || 0) > 0;
    if (tieneEntradas) {
      baseVolumen.set(id, 0);
      return;
    }
    const datos = nodo.datos || {};
    const unidad = obtenerUnidadNodo(nodo);
    const baseRaw = obtenerCantidadEnUnidad(datos, unidad);
    const base = Number.isFinite(baseRaw) && baseRaw > 0 ? baseRaw : 0;
    baseVolumen.set(id, base);
  });

  return {
    rootId: rootNorm,
    nodesSet,
    nodes,
    nodeTs,
    pasos,
    edges,
    baseVolumen,
    sinFecha,
  };
}

function calcularEstadoReplayFlujo(model, timeMs) {
  const activeNodes = new Set();
  model.nodes.forEach((nodo, id) => {
    const ts = model.nodeTs.get(id);
    if (ts == null || ts <= timeMs) activeNodes.add(id);
  });

  const inflow = new Map();
  const outflow = new Map();
  const currentEdges = new Set();

  model.edges.forEach(edge => {
    if (!activeNodes.has(edge.destId) || !activeNodes.has(edge.origenId)) return;
    if (edge.ts != null && edge.ts === timeMs) {
      currentEdges.add(`${edge.origenId}→${edge.destId}`);
    }
    const volumen = normalizarNumero(edge.volumen) || 0;
    if (!(volumen > 0)) return;
    inflow.set(edge.destId, (inflow.get(edge.destId) || 0) + volumen);
    outflow.set(edge.origenId, (outflow.get(edge.origenId) || 0) + volumen);
  });

  const stockVolumen = new Map();
  model.nodes.forEach((nodo, id) => {
    if (!FLOW_REPLAY_TIPOS_VOLUMEN.has(nodo.tipo)) return;
    const base = model.baseVolumen.get(id) || 0;
    const inL = inflow.get(id) || 0;
    const outL = outflow.get(id) || 0;
    const v = base + inL - outL;
    stockVolumen.set(id, Math.max(0, Number(v.toFixed(4))));
  });

  return { activeNodes, inflow, outflow, stockVolumen, currentEdges };
}

function obtenerVolumenVisualNodo(nodo) {
  if (!nodo) return null;
  const nodoId = normalizarIdNodo(nodo);
  if (flowReplay?.activo && flowReplay.model && flowReplay.state && flowReplay.model.nodesSet?.has(nodoId)) {
    if (nodo.tipo === "entrada") {
      const limite = obtenerVolumenBaseNodoParaUI(nodo);
      return limite != null ? limite : null;
    }
    if (FLOW_REPLAY_TIPOS_VOLUMEN.has(nodo.tipo)) {
      const activo = flowReplay.state.activeNodes?.has(nodoId);
      if (!activo) return 0;
      const v = flowReplay.state.stockVolumen?.get(nodoId);
      return v != null ? v : 0;
    }
  }
  const restante = obtenerVolumenRestanteNodo(nodo);
  return restante != null ? restante : null;
}

function formatearFechaReplay(ms) {
  if (ms == null) return "—";
  const d = new Date(ms);
  if (Number.isNaN(d.getTime())) return "—";
  return d.toLocaleDateString("es-ES");
}

function actualizarUIReplayFlujo() {
  const section = document.getElementById("flujo");
  const bar = document.getElementById("flowReplayBar");
  const toggleBtn = document.getElementById("flowReplayToggleBtn");
  const range = document.getElementById("flowReplayRange");
  const dateEl = document.getElementById("flowReplayDate");
  const sub = document.getElementById("flowReplaySub");
  const hint = document.getElementById("flowReplayHint");
  const playBtn = document.getElementById("flowReplayPlayBtn");

  const activo = Boolean(flowReplay?.activo && flowReplay.model);
  if (section) section.classList.toggle("replay-mode", activo);
  if (bar) bar.classList.toggle("visible", activo);
  if (toggleBtn) toggleBtn.textContent = activo ? "Salir replay" : "🎞 Replay";

  if (!activo) {
    if (playBtn) playBtn.textContent = "⏵";
    return;
  }

  const pasos = flowReplay.model.pasos || [];
  const max = Math.max(0, pasos.length - 1);
  if (range) {
    range.min = "0";
    range.max = String(max);
    range.step = "1";
    range.value = String(Math.min(flowReplay.idx || 0, max));
    range.disabled = max <= 0;
  }

  if (dateEl) {
    dateEl.textContent = pasos.length ? formatearFechaReplay(flowReplay.timeMs) : "Sin fechas";
  }

  if (sub) {
    const root = obtenerNodoPorId(flowReplay.rootId);
    const rootLabel = root ? root.titulo || root.tipo || "Nodo" : "Nodo";
    const sinFecha = flowReplay.model.sinFecha || 0;
    const extra = sinFecha ? ` · ${sinFecha} nodo(s) sin fecha` : "";
    sub.textContent = `Replay de: ${rootLabel}${extra}`;
  }

  if (hint) {
    hint.textContent = pasos.length
      ? "Hover en una conexión para ver volumen y fecha. Las conexiones futuras se muestran punteadas."
      : "No hay fechas en este recorrido. Añade “Fecha operación” en los nodos para usar Replay.";
  }

  if (playBtn) {
    playBtn.textContent = flowReplay.playing ? "⏸" : "⏵";
  }
}

function obtenerEntradasAncestroParaReplay(nodoId) {
  const start = obtenerNodoPorId(nodoId);
  if (!start) return [];
  const visitados = new Set();
  const entradas = new Map();
  const stack = [normalizarIdNodo(start)];
  while (stack.length) {
    const actualId = stack.pop();
    if (!actualId || visitados.has(actualId)) continue;
    visitados.add(actualId);
    const nodo = obtenerNodoPorId(actualId);
    if (!nodo) continue;
    if (nodo.tipo === "entrada") {
      entradas.set(actualId, nodo);
      continue;
    }
    const padres = obtenerPredecesores(actualId);
    padres.forEach(pre => {
      const pid = normalizarIdNodo(pre);
      if (pid && !visitados.has(pid)) stack.push(pid);
    });
  }
  return Array.from(entradas.values());
}

function iniciarReplayFlujo() {
  if (!nodoSeleccionadoId) {
    mostrarAviso("Selecciona una entrada (o un nodo de su recorrido) para iniciar el replay.", "info");
    return;
  }
  const seleccionado = obtenerNodoPorId(nodoSeleccionadoId);
  if (!seleccionado) {
    mostrarAviso("No se encontró el nodo seleccionado.", "error");
    return;
  }
  let entradaRoot = null;
  if (seleccionado.tipo === "entrada") {
    entradaRoot = seleccionado;
  } else {
    const entradas = obtenerEntradasAncestroParaReplay(seleccionado.id);
    if (!entradas.length) {
      mostrarAviso("Este nodo no tiene una entrada de uva asociada aguas arriba.", "error");
      return;
    }
    if (entradas.length > 1) {
      const etiquetas = entradas
        .slice(0, 6)
        .map(e => (e.datos?.id_ref ? `Entrada #${e.datos.id_ref}` : e.titulo || "Entrada"))
        .join(", ");
      mostrarAviso(
        `Hay varias entradas posibles (${etiquetas}${entradas.length > 6 ? ", …" : ""}). Selecciona una entrada y vuelve a pulsar Replay.`,
        "info"
      );
      return;
    }
    entradaRoot = entradas[0];
    nodoSeleccionadoId = entradaRoot.id;
  }

  const model = construirModeloReplayFlujo(entradaRoot.id);
  if (!model) {
    mostrarAviso("No se pudo construir el replay para este nodo.", "error");
    return;
  }
  flowReplay.activo = true;
  flowReplay.playing = false;
  flowReplay.rootId = model.rootId;
  flowReplay.model = model;
  flowReplay.idx = 0;
  flowReplay.timeMs = model.pasos.length ? model.pasos[0] : Date.now();
  flowReplay.state = calcularEstadoReplayFlujo(model, flowReplay.timeMs);
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function salirReplayFlujo() {
  if (flowReplay.timer) {
    clearInterval(flowReplay.timer);
    flowReplay.timer = null;
  }
  flowReplay.playing = false;
  flowReplay.activo = false;
  flowReplay.rootId = null;
  flowReplay.model = null;
  flowReplay.state = null;
  flowReplay.idx = 0;
  flowReplay.timeMs = null;
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function toggleReplayFlujo() {
  if (flowReplay?.activo) {
    salirReplayFlujo();
    return;
  }
  iniciarReplayFlujo();
}

function onReplayRangeInput(valor) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  if (!pasos.length) return;
  const idx = Math.max(0, Math.min(Number(valor) || 0, pasos.length - 1));
  flowReplay.idx = idx;
  flowReplay.timeMs = pasos[idx];
  flowReplay.state = calcularEstadoReplayFlujo(flowReplay.model, flowReplay.timeMs);
  if (flowReplay.playing && idx >= pasos.length - 1) {
    togglePlayReplayFlujo(false);
  }
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function replayPasoFlujo(delta) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  if (!pasos.length) return;
  const max = pasos.length - 1;
  const next = Math.max(0, Math.min(max, (flowReplay.idx || 0) + (delta || 0)));
  const range = document.getElementById("flowReplayRange");
  flowReplay.idx = next;
  flowReplay.timeMs = pasos[next];
  flowReplay.state = calcularEstadoReplayFlujo(flowReplay.model, flowReplay.timeMs);
  if (range) range.value = String(next);
  actualizarUIReplayFlujo();
  renderFlowNodes();
}

function togglePlayReplayFlujo(force) {
  if (!flowReplay?.activo || !flowReplay.model) return;
  const pasos = flowReplay.model.pasos || [];
  const max = pasos.length - 1;
  const shouldPlay = force == null ? !flowReplay.playing : Boolean(force);

  if (!shouldPlay || max <= 0) {
    if (flowReplay.timer) clearInterval(flowReplay.timer);
    flowReplay.timer = null;
    flowReplay.playing = false;
    actualizarUIReplayFlujo();
    return;
  }

  if (flowReplay.timer) clearInterval(flowReplay.timer);
  flowReplay.playing = true;
  flowReplay.timer = setInterval(() => {
    const pasosLocal = flowReplay.model?.pasos || [];
    const maxLocal = pasosLocal.length - 1;
    if (!pasosLocal.length || flowReplay.idx >= maxLocal) {
      togglePlayReplayFlujo(false);
      return;
    }
    replayPasoFlujo(1);
  }, FLOW_REPLAY_INTERVAL_MS);

  actualizarUIReplayFlujo();
}

const ESTADOS_VINO = Array.isArray(window.BITACORA_ESTADOS_VINO)
  ? window.BITACORA_ESTADOS_VINO
  : [
      { value: "tranquilo", label: "Tranquilo" },
      { value: "activo", label: "Activo" },
      { value: "violento", label: "Violento" },
      { value: "lento", label: "Lento" },
      { value: "inestable", label: "Inestable" },
      { value: "reductivo", label: "Reductivo" },
      { value: "abierto", label: "Abierto" },
      { value: "cerrado", label: "Cerrado" },
      { value: "tenso", label: "Tenso" },
      { value: "equilibrado", label: "Equilibrado" },
      { value: "personalizado", label: "Personalizado" },
    ];
const ESTADO_PERSONALIZADO = window.BITACORA_ESTADO_PERSONALIZADO || "personalizado";

function crearTablaControlFermentacion(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.control)) {
    nodo.datos.control = [];
  }
  const contenedor = document.createElement("div");
  contenedor.className = "tabla-control-fermentacion";

  const toolbar = document.createElement("div");
  toolbar.style.display = "flex";
  toolbar.style.justifyContent = "flex-end";
  toolbar.style.marginBottom = "6px";
  const btnPdf = document.createElement("button");
  btnPdf.type = "button";
  btnPdf.className = "small-btn";
  btnPdf.textContent = "PDF";
  btnPdf.addEventListener("click", () => exportarTablaControlPDF(nodo));
  toolbar.appendChild(btnPdf);
  contenedor.appendChild(toolbar);

  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Fecha</th>
      <th>Densidad</th>
      <th>°C</th>
      <th>Estado</th>
      <th>Productos</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.control.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="6" style="text-align:center; color:#777;">Sin registros</td>`;
      tbody.appendChild(fila);
      return;
    }
    nodo.datos.control.forEach((registro, index) => {
      const tr = document.createElement("tr");
      const tdFecha = document.createElement("td");
      const inputFecha = document.createElement("input");
      inputFecha.type = "date";
      inputFecha.value = registro.fecha || "";
      inputFecha.dataset.index = index;
      inputFecha.dataset.campo = "fecha";
      tdFecha.appendChild(inputFecha);

      const tdDensidad = document.createElement("td");
      const inputDensidad = document.createElement("input");
      inputDensidad.type = "number";
      inputDensidad.step = "0.001";
      inputDensidad.value = registro.densidad || "";
      inputDensidad.dataset.index = index;
      inputDensidad.dataset.campo = "densidad";
      tdDensidad.appendChild(inputDensidad);

      const tdTemp = document.createElement("td");
      const inputTemp = document.createElement("input");
      inputTemp.type = "number";
      inputTemp.step = "0.1";
      inputTemp.value = registro.temperatura || "";
      inputTemp.dataset.index = index;
      inputTemp.dataset.campo = "temperatura";
      tdTemp.appendChild(inputTemp);

      const tdEstado = document.createElement("td");
      const estadoWrap = document.createElement("div");
      estadoWrap.style.display = "grid";
      estadoWrap.style.gap = "4px";
      const selectEstado = document.createElement("select");
      const optionEmpty = document.createElement("option");
      optionEmpty.value = "";
      optionEmpty.textContent = "Sin estado";
      selectEstado.appendChild(optionEmpty);
      ESTADOS_VINO.forEach(item => {
        const option = document.createElement("option");
        option.value = item.value;
        option.textContent = item.label;
        selectEstado.appendChild(option);
      });
      selectEstado.value = registro.estado_vino || "";
      selectEstado.dataset.index = index;
      selectEstado.dataset.campo = "estado_vino";

      const inputEstado = document.createElement("input");
      inputEstado.type = "text";
      inputEstado.placeholder = "Personalizado";
      inputEstado.maxLength = 40;
      inputEstado.value = registro.estado_vino_texto || "";
      inputEstado.dataset.index = index;
      inputEstado.dataset.campo = "estado_vino_texto";
      inputEstado.style.display = selectEstado.value === ESTADO_PERSONALIZADO ? "block" : "none";

      estadoWrap.appendChild(selectEstado);
      estadoWrap.appendChild(inputEstado);
      tdEstado.appendChild(estadoWrap);

      const tdProductos = document.createElement("td");
      const inputProductos = document.createElement("input");
      inputProductos.type = "text";
      inputProductos.value = registro.productos || "";
      inputProductos.dataset.index = index;
      inputProductos.dataset.campo = "productos";
      tdProductos.appendChild(inputProductos);

      const tdEliminar = document.createElement("td");
      const btnEliminar = document.createElement("button");
      btnEliminar.type = "button";
      btnEliminar.className = "small-btn";
      btnEliminar.dataset.index = index;
      btnEliminar.dataset.accion = "eliminar";
      btnEliminar.textContent = "✕";
      tdEliminar.appendChild(btnEliminar);

      tr.appendChild(tdFecha);
      tr.appendChild(tdDensidad);
      tr.appendChild(tdTemp);
      tr.appendChild(tdEstado);
      tr.appendChild(tdProductos);
      tr.appendChild(tdEliminar);
      tbody.appendChild(tr);
    });
  };
  renderFilas();
  tabla.appendChild(tbody);
  tabla.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    guardarEstadoNodos();
  });
  tabla.addEventListener("change", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    if (campo === "estado_vino") {
      const wrap = target.parentElement;
      const input = wrap?.querySelector("input[data-campo='estado_vino_texto']");
      if (input) {
        const mostrar = target.value === ESTADO_PERSONALIZADO;
        input.style.display = mostrar ? "block" : "none";
        if (!mostrar) {
          input.value = "";
          nodo.datos.control[index].estado_vino_texto = "";
        }
      }
    }
    guardarEstadoNodos();
  });
  tabla.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = btn.dataset.index;
    nodo.datos.control.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
  });
  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ Añadir control";
  btnAdd.addEventListener("click", () => {
    nodo.datos.control.push({
      fecha: nodo.datos.fecha_operacion || nodo.datos.fecha || "",
      densidad: "",
      temperatura: "",
      estado_vino: "",
      estado_vino_texto: "",
      productos: "",
    });
    guardarEstadoNodos();
    renderFilas();
  });
  contenedor.appendChild(tabla);
  contenedor.appendChild(btnAdd);
  return contenedor;
}

function crearTablaFormatosEmbotellado(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.formatos_botella)) {
    nodo.datos.formatos_botella = [];
  }
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-formatos-embotellado";
  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Formato</th>
      <th>Botellas</th>
      <th>L calc.</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  tabla.appendChild(tbody);
  const resumen = document.createElement("div");
  resumen.className = "tabla-formatos-resumen";
  const formatosDisponibles = Object.keys(VOLUMEN_BOTELLA_L);

  const calcularLitrosTexto = registro => {
    if (!registro) return "";
    const formato = registro.formato;
    const botellasRaw = normalizarNumero(registro.botellas);
    const botellas = Number.isFinite(botellasRaw) ? Math.max(0, Math.floor(botellasRaw)) : 0;
    const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
    if (volBotella > 0 && botellas > 0) {
      return (botellas * volBotella).toFixed(2);
    }
    return "";
  };

  const actualizarResumen = () => {
    const resumenDatos = calcularResumenFormatosBotella(nodo);
    const litrosDisponibles = obtenerLitrosDesdePredecesores(nodo);
    const botellasTxt = resumenDatos.totalBotellas
      ? `${resumenDatos.totalBotellas.toLocaleString("es-ES")} botellas`
      : "0 botellas";
    const litrosTxt = resumenDatos.totalLitros
      ? ` · ${resumenDatos.totalLitros.toFixed(2)} L`
      : "";
    const dispTxt = litrosDisponibles
      ? ` · ${litrosDisponibles.toFixed(2)} L disponibles`
      : "";
    resumen.textContent = `Total: ${botellasTxt}${litrosTxt}${dispTxt}`;
  };

  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.formatos_botella.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="4" style="text-align:center; color:#777;">Sin formatos mixtos</td>`;
      tbody.appendChild(fila);
      actualizarResumen();
      return;
    }
    nodo.datos.formatos_botella.forEach((registro, index) => {
      const tr = document.createElement("tr");
      const tdFormato = document.createElement("td");
      const select = document.createElement("select");
      select.dataset.index = index;
      select.dataset.campo = "formato";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Selecciona formato";
      if (!registro.formato) placeholder.selected = true;
      select.appendChild(placeholder);
      formatosDisponibles.forEach(op => {
        const option = document.createElement("option");
        option.value = op;
        option.textContent = op;
        select.appendChild(option);
      });
      if (registro.formato) select.value = registro.formato;
      tdFormato.appendChild(select);
      const tdBotellas = document.createElement("td");
      const input = document.createElement("input");
      input.type = "number";
      input.min = "0";
      input.step = "1";
      input.dataset.index = index;
      input.dataset.campo = "botellas";
      input.value = registro.botellas != null ? registro.botellas : "";
      tdBotellas.appendChild(input);
      const tdLitros = document.createElement("td");
      tdLitros.dataset.index = index;
      tdLitros.dataset.campo = "litros";
      tdLitros.textContent = calcularLitrosTexto(registro);
      const tdAccion = document.createElement("td");
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "small-btn";
      btn.textContent = "✕";
      btn.dataset.index = index;
      btn.dataset.accion = "eliminar";
      tdAccion.appendChild(btn);
      tr.appendChild(tdFormato);
      tr.appendChild(tdBotellas);
      tr.appendChild(tdLitros);
      tr.appendChild(tdAccion);
      tbody.appendChild(tr);
    });
    actualizarResumen();
  };

  tbody.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    if (!nodo.datos.formatos_botella[index]) return;
    nodo.datos.formatos_botella[index][campo] = target.value;
    const litrosCell = tbody.querySelector(
      `td[data-index="${index}"][data-campo="litros"]`
    );
    if (litrosCell) {
      litrosCell.textContent = calcularLitrosTexto(nodo.datos.formatos_botella[index]);
    }
    guardarEstadoNodos();
    actualizarResumen();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  tbody.addEventListener("change", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    if (!nodo.datos.formatos_botella[index]) return;
    nodo.datos.formatos_botella[index][campo] = target.value;
    const litrosCell = tbody.querySelector(
      `td[data-index="${index}"][data-campo="litros"]`
    );
    if (litrosCell) {
      litrosCell.textContent = calcularLitrosTexto(nodo.datos.formatos_botella[index]);
    }
    guardarEstadoNodos();
    actualizarResumen();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  tbody.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = Number(btn.dataset.index);
    if (!Number.isFinite(index)) return;
    nodo.datos.formatos_botella.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ Añadir formato";
  btnAdd.addEventListener("click", () => {
    const formatoBase =
      (nodo.datos.botella && VOLUMEN_BOTELLA_L[nodo.datos.botella] != null
        ? nodo.datos.botella
        : formatosDisponibles[0]) || "";
    nodo.datos.formatos_botella.push({ formato: formatoBase, botellas: "" });
    guardarEstadoNodos();
    renderFilas();
    actualizarBotellasResultantes(nodo);
    renderFlowNodes();
  });

  renderFilas();
  wrapper.appendChild(tabla);
  wrapper.appendChild(btnAdd);
  wrapper.appendChild(resumen);
  return wrapper;
}

function crearTablaAsignacionesDeposito(nodo, soloLectura = false) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  limpiarAsignacionesOrfanas(nodo);
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) {
    const mensaje =
      nodo.tipo === "coupage"
        ? "Conecta depósitos para seleccionar el volumen de cada uno."
        : "Conecta este depósito para repartir volumen.";
    wrapper.innerHTML = `<p style='font-size:13px; color:#666;'>${mensaje}</p>`;
    return wrapper;
  }
  nodo.datos = nodo.datos || {};
  nodo.datos.asignaciones = nodo.datos.asignaciones || {};
  const esCoupage = nodo.tipo === "coupage";
  if (esCoupage) {
    const infoDest = obtenerTotalesDestino(nodo);
    if (infoDest) {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#777";
      info.textContent = `Destino: capacidad ${formatearVolumenPlano(infoDest.capTotal)} · Libre ${formatearVolumenPlano(infoDest.libre)}`;
      wrapper.appendChild(info);
    } else {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#c06";
      info.textContent = "Conecta este blend a un destino (depósito o barrica) para ver la capacidad libre, o revisa que el destino tenga capacidad/volumen definidos.";
      wrapper.appendChild(info);
    }
  }
  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Origen</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  predecesores.forEach(origen => {
    const key = origen.id.toString();
    const cargaOrigen = obtenerCargaDesdeNodo(origen) || {};
    const volumenPorDefecto = Number(getVolumenFromDatos(cargaOrigen) || 0);
    const volumenNodoDisponibles = (() => {
	      if (!esCoupage) return volumenPorDefecto;
	      if (origen.tipo === "deposito") {
	        const idRef = origen.datos?.id_ref || origen.datos?.contenedor_id || origen.datos?.codigo || origen.id;
	        const vol = obtenerVolumenFinalNodoContenedor("deposito", idRef);
	        if (Number.isFinite(vol)) return vol;
	        const fallbackVol = getVolumenFromNodo(origen) ?? volumenPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
	      }
	      if (origen.tipo === "barrica") {
	        const idRef = origen.datos?.contenedor_id || origen.datos?.id_ref || origen.datos?.codigo || origen.id;
	        const vol = obtenerVolumenFinalNodoContenedor("barrica", idRef);
	        if (Number.isFinite(vol)) return vol;
	        const fallbackVol = getVolumenFromNodo(origen) ?? volumenPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      return volumenPorDefecto;
    })();
    const registro = asegurarAsignacionRegistro(
      nodo,
      origen.id,
      Number.isFinite(volumenPorDefecto) && volumenPorDefecto > 0 ? volumenPorDefecto : null
    );
    const tr = document.createElement("tr");
    const nombreBase = describirNodoOrigen(origen);
    const nombre = esCoupage
      ? nombreOrigenBlend(origen)
      : nombreBase;
    const disponibleTexto = esCoupage ? `Disponible: ${Number(volumenNodoDisponibles || 0).toFixed(2)}` : describirNodoOrigen(origen);
    const valorVolumen = getVolumenFromDatos(registro) || "";
    tr.innerHTML = `
      <td>${nombre}<br><small>${disponibleTexto}</small></td>
      <td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorVolumen}" data-origen="${key}" data-tipo="volumen"${esCoupage && Number.isFinite(volumenNodoDisponibles) ? ` data-max-volumen="${Number(volumenNodoDisponibles).toFixed(4)}"` : ""}></td>`;
    if (!soloLectura) {
	      const inputs = tr.querySelectorAll("input");
	      inputs.forEach(input => {
	        input.addEventListener("input", () => {
	          const snapshot = { ...registro };
	          const valor = Number(input.value);
	          const tipo = input.dataset.tipo;
	          setVolumenRegistro(registro, Number.isFinite(valor) ? valor : null);
	          registro.__manual = true;
	          if (esCoupage && tipo === "volumen") {
	            const maxAttr = input.dataset.maxVolumen;
	            const max = maxAttr != null ? Number(maxAttr) : null;
	            if (Number.isFinite(max) && max > 0 && valor > max) {
              setVolumenRegistro(registro, max);
              input.value = max.toFixed(2);
              mostrarAviso("No puedes usar más volumen del disponible en el depósito.", "error");
            }
	          }
	          actualizarVariedadDesdeAportes(nodo);
	          actualizarVolumenDesdeAsignaciones(nodo);
	          try {
	            redistribuirCargas(nodo);
	            const valid = validarLimitesFlujo(false);
	            if (!valid.ok) {
	              Object.assign(registro, snapshot);
	              actualizarVariedadDesdeAportes(nodo);
	              actualizarVolumenDesdeAsignaciones(nodo);
	              redistribuirCargas(nodo);
	              mostrarAviso("La asignación supera el disponible en algún nodo del flujo.", "error");
	              return;
	            }
	          } catch (e) {
	            Object.assign(registro, snapshot);
	            mostrarAviso("No se pudo aplicar la asignación.", "error");
	            return;
	          }
	          guardarEstadoNodos();
	          renderFlowNodes();
	          mostrarInfoNodo(nodo.id);
	        });
	      });
	    }
    tbody.appendChild(tr);
  });
  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function limpiarDistribucionEstilo(nodo) {
  if (!nodo || !nodo.datos?.distribucion) return;
  const permitidos = new Set((nodo.targets || []).map(id => String(id)));
  Object.keys(nodo.datos.distribucion).forEach(key => {
    if (!permitidos.has(key)) {
      delete nodo.datos.distribucion[key];
    }
  });
}

function ajustarDistribucionEstilo(nodo, cargaBase) {
  if (!nodo || nodo.tipo !== "estilo") return;
  const distribucion = nodo.datos?.distribucion;
  if (!distribucion) return;
  const targets = (nodo.targets || []).map(id => String(id));
  if (!targets.length) return;
  let totalAsignado = 0;
  targets.forEach(id => {
    const reg = distribucion[id];
    if (!reg) return;
    const valor = getVolumenFromDatos(reg) || 0;
    if (valor > 0) totalAsignado += valor;
  });
  if (!(totalAsignado > 0)) return;
  const disponibleRaw = getVolumenFromDatos(cargaBase);
  const disponible = Number.isFinite(disponibleRaw) ? Number(disponibleRaw.toFixed(4)) : 0;
  if (totalAsignado <= disponible + 0.0001) return;
  const factor = disponible / totalAsignado;
  targets.forEach(id => {
    const reg = distribucion[id];
    if (!reg) return;
    const actual = getVolumenFromDatos(reg);
    if (!(actual > 0)) return;
    const nuevo = Number((actual * factor).toFixed(2));
    reg.volumen = nuevo;
    reg.kilos = null;
    reg.litros = null;
  });
  if (flowDebugActivo()) {
    console.debug("[flow][estilo] Distribucion ajustada", {
      nodo: nodo.id,
      disponible,
      totalAsignado,
      factor: Number(factor.toFixed(4)),
    });
  }
}

function crearTablaDistribucionEstilo(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const distribucion = nodo.datos?.distribucion || {};
  const entradasDistrib = Object.entries(distribucion);
  if (!entradasDistrib.length) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta este nodo a otro para repartir el volumen.</p>";
    return wrapper;
  }
  const mapaNodos = getNodosPorId();
  const cargaDisponible = obtenerCargaDesdeNodo(nodo) || {};
  const dispVolumen = Number(getVolumenFromDatos(cargaDisponible) || 0);
  const totDestinos = nodo.tipo === "coupage" ? obtenerTotalesDestino(nodo) : null;
  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  const infoCap =
    totDestinos
      ? ` | Destino: ${Number.isFinite(totDestinos.capTotal) ? formatearVolumenPlano(totDestinos.capTotal) + " cap" : "capacidad n/d"} · Libre ${Number.isFinite(totDestinos.libre) ? formatearVolumenPlano(totDestinos.libre) : "—"}`
      : "";
  resumen.textContent = `Disponible: ${dispVolumen.toFixed(2)}${infoCap}`;
  wrapper.appendChild(resumen);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  const destinos = buildRepartoDestinos(nodo);

	  destinos.forEach(dest => {
	    const tr = document.createElement("tr");
	    tr.innerHTML = `
	      <td>${dest.nombre}</td>
	      <td><input type="number" step="0.01" min="0" value="${dest.volumen || ""}" data-destino="${dest.idNodoDestino}" data-tipo="volumen"></td>`;
	    tr.querySelectorAll("input").forEach(input => {
	      input.addEventListener("input", () => {
	        const snapshotDistrib = JSON.parse(JSON.stringify(nodo.datos?.distribucion || {}));
	        const valor = Number(input.value);
	        const tipo = input.dataset.tipo;
	        if (!nodo.datos.distribucion[dest.idNodoDestino]) {
	          nodo.datos.distribucion[dest.idNodoDestino] = { volumen: 0 };
	        }
	        nodo.datos.distribucion[dest.idNodoDestino][tipo] = Number.isFinite(valor) ? valor : "";
	        nodo.datos.distribucion[dest.idNodoDestino].kilos = null;
	        nodo.datos.distribucion[dest.idNodoDestino].litros = null;

	        // Limitar por la unidad activa del nodo para evitar sobreasignaciones al vuelo.
	        const limite = obtenerLimiteNodo(nodo);
	        if (limite != null) {
	          const total = destinos.reduce((acc, d) => {
	            const reg = nodo.datos?.distribucion?.[d.idNodoDestino] || {};
	            const v = getVolumenFromDatos(reg) ?? 0;
	            return acc + v;
	          }, 0);
	          if (total > limite + 0.0001) {
	            const actual = Math.max(0, normalizarNumero(nodo.datos.distribucion[dest.idNodoDestino][tipo]) ?? 0);
	            const exceso = total - limite;
	            const nuevo = Math.max(0, actual - exceso);
	            nodo.datos.distribucion[dest.idNodoDestino][tipo] = nuevo;
	            input.value = nuevo ? nuevo.toFixed(2) : "";
	            mostrarAviso(
	              `No puedes repartir más de ${Number(limite).toFixed(2)} de volumen total.`,
	              "error"
	            );
	          }
	        }

	        try {
	          redistribuirCargas(nodo);
	          const valid = validarLimitesFlujo(false);
	          if (!valid.ok) {
	            nodo.datos.distribucion = snapshotDistrib;
	            redistribuirCargas(nodo);
	            mostrarAviso("El reparto supera el disponible en el nodo de elaboración.", "error");
	            return;
	          }
	        } catch (e) {
	          nodo.datos.distribucion = snapshotDistrib;
	          mostrarAviso("No se pudo aplicar el reparto.", "error");
	          return;
	        }
	        guardarEstadoNodos();
	        renderFlowNodes();
	        mostrarInfoNodo(nodo.id);
	      });
	    });
	    tbody.appendChild(tr);
	  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function obtenerCargaDistribuida(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "estilo") return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  if (!registro) return null;
  const valor = getVolumenFromDatos(registro);
  // Si no hay valores positivos, tratamos la distribución como "no definida"
  // y dejamos que actúe el reparto automático (o el fallback a un único destino).
  if (!(valor > 0)) return null;
  const carga = { ...cargaBase };
  carga.volumen = valor;
  return carga;
}

function obtenerCargaDistribuidaEntrada(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "entrada" || origen.datos?.reparto_manual !== true) return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  const volumen = getVolumenFromDatos(registro);
  const carga = { ...cargaBase, __manual: true };
  carga.volumen = Math.max(0, volumen ?? 0);
  return carga;
}

function crearTablaDistribucionEntrada(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const targets = (nodo.targets || []).map(id => String(id));
  if (targets.length < 2) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta esta entrada a varios nodos para repartir el volumen.</p>";
    return wrapper;
  }

  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const cargaDisponible = obtenerCargaDesdeNodo(nodo) || {};
  const dispVolumen = Number(getVolumenFromDatos(cargaDisponible) || 0);
  const manual = nodo.datos?.reparto_manual === true;

  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  resumen.textContent = manual
    ? `Disponible: ${dispVolumen.toFixed(2)} · Reparto manual`
    : `Disponible: ${dispVolumen.toFixed(2)} · Reparto automático (a partes iguales)`;
  wrapper.appendChild(resumen);

  const hint = document.createElement("p");
  hint.style.fontSize = "12px";
  hint.style.color = "#777";
  hint.style.marginTop = "-6px";
  hint.textContent = manual
    ? "Edita el volumen por destino. Los cambios se aplican al flujo."
    : "Edita cualquier valor para activar el reparto manual.";
  wrapper.appendChild(hint);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Volumen</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");

  targets.forEach(destinoId => {
    const destino = nodosPorId[destinoId];
    if (!destino) return;
    const nombre = getNombreNodoDestino(destinoId, nodosPorId, mapaDepRef);
    const volumenActual = obtenerVolumenTransferenciaEntreNodos(nodo, destino);
    const valorManual = getVolumenFromDatos(nodo.datos?.distribucion?.[destinoId]) ?? 0;

    const tr = document.createElement("tr");
    const tdNombre = document.createElement("td");
    tdNombre.textContent = nombre;
    const tdKilos = document.createElement("td");
    const input = document.createElement("input");
    input.type = "number";
    input.step = "0.01";
    input.min = "0";
    if (manual) input.value = String(valorManual);
    input.placeholder = Number(volumenActual).toFixed(2);
    input.dataset.destino = destinoId;
    tdKilos.appendChild(input);
    tr.appendChild(tdNombre);
    tr.appendChild(tdKilos);
    input.addEventListener("input", () => {
      nodo.datos = nodo.datos || {};
      const eraManual = nodo.datos.reparto_manual === true;
      const snapshotDistrib = JSON.parse(JSON.stringify(nodo.datos.distribucion || {}));

      if (!eraManual) {
        nodo.datos.reparto_manual = true;
        nodo.datos.distribucion = {};
        // Sembrar el reparto actual (auto) para no "vaciar" otras ramas al activar el manual.
        targets.forEach(tid => {
          const dest = nodosPorId[tid];
          if (!dest) return;
          nodo.datos.distribucion[tid] = {
            volumen: obtenerVolumenTransferenciaEntreNodos(nodo, dest),
          };
        });
      } else {
        nodo.datos.distribucion = nodo.datos.distribucion || {};
      }

      if (!nodo.datos.distribucion[destinoId]) {
        nodo.datos.distribucion[destinoId] = { volumen: 0 };
      }

      const valorIngresado = normalizarNumero(input.value);
      const volumen = Math.max(0, valorIngresado ?? 0);
      nodo.datos.distribucion[destinoId].volumen = volumen;
      nodo.datos.distribucion[destinoId].kilos = null;
      nodo.datos.distribucion[destinoId].litros = null;

      const limite = obtenerLimiteNodo(nodo);
      if (limite != null) {
        const total = targets.reduce((acc, tid) => {
          const v = getVolumenFromDatos(nodo.datos?.distribucion?.[tid]) ?? 0;
          return acc + v;
        }, 0);
        if (total > limite + 0.0001) {
          const exceso = total - limite;
          const nuevo = Math.max(0, volumen - exceso);
          nodo.datos.distribucion[destinoId].volumen = nuevo;
          input.value = nuevo.toFixed(2);
          mostrarAviso(`No puedes repartir más de ${Number(limite).toFixed(2)} en total.`, "error");
        }
      }

      try {
        redistribuirCargas(nodo);
        const valid = validarLimitesFlujo(false);
        if (!valid.ok) {
          nodo.datos.distribucion = snapshotDistrib;
          if (!eraManual) nodo.datos.reparto_manual = false;
          redistribuirCargas(nodo);
          mostrarAviso("El reparto supera el disponible en la entrada.", "error");
          return;
        }
      } catch (e) {
        nodo.datos.distribucion = snapshotDistrib;
        if (!eraManual) nodo.datos.reparto_manual = false;
        mostrarAviso("No se pudo aplicar el reparto.", "error");
        return;
      }

      limpiarDistribucionEstilo(nodo);
      guardarEstadoNodos();
      renderFlowNodes();
      mostrarInfoNodo(nodo.id);
    });

    tbody.appendChild(tr);
  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}


function actualizarVariedadDesdeAportes(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  nodo.datos = nodo.datos || {};
  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    } else {
      nodo.datos.composicionVariedades = [];
      nodo.datos.variedad = obtenerVariedadDesdeAsignaciones(nodo);
    }
  } catch (e) {
    console.warn("No se pudo recalcular la composición del nodo:", e);
  }
  actualizarVolumenDesdeAsignaciones(nodo);
}

function obtenerVariedadDesdeAsignaciones(nodo) {
  if (!nodo) return "";
  const variedadExistente = nodo.datos?.variedad || nodo.datos?.variedadBase || nodo.datos?.vino || "";
  if (!nodo.datos?.asignaciones) return variedadExistente;
  const comp = calcularComposicionVariedades(nodo);
  const mezcla = formatearComposicionVariedades(comp.mix, comp.total);
  return mezcla || variedadExistente;
}

function capYVolDesdeInfo(info, fallbackCap, fallbackVol, extraCap = null) {
  if (!info && fallbackCap == null && fallbackVol == null && extraCap == null) return { cap: null, vol: null };
  const capRaw =
    (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
    fallbackCap ??
    extraCap;
  const volRaw =
    (info && (info.litros_actuales ?? info.volumen)) ??
    fallbackVol ??
    0;
  return { cap: Number(capRaw), vol: Number(volRaw) };
}

function capacidadDisponibleContenedorDesdeInfo(info, fallbackCap, fallbackVol) {
  const { cap, vol } = capYVolDesdeInfo(info, fallbackCap, fallbackVol);
  if (cap == null || Number.isNaN(cap)) return null;
  const capacidad = Number(cap);
  const volumen = Number(vol) || 0;
  if (!Number.isFinite(capacidad)) return null;
  return Math.max(0, capacidad - volumen);
}

function obtenerCapacidadDisponibleContenedor(nodoDestino) {
  if (!nodoDestino) return null;
  const datos = nodoDestino.datos || {};
  if (nodoDestino.tipo === "deposito") {
    const info = resolverInfoDepositoDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      getVolumenFromDatos(datos)
    );
  }
  if (nodoDestino.tipo === "barrica") {
    const info = resolverInfoBarricaDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      getVolumenFromDatos(datos)
    );
  }
  return null;
}

function obtenerTotalesDestino(nodo) {
  if (!nodo || !Array.isArray(nodo.targets) || !nodo.targets.length) return null;
  let capTotal = 0;
  let volTotal = 0;
  let tieneDestino = false;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const datos = dest.datos || {};
    tieneDestino = true;
	    if (dest.tipo === "deposito") {
	      if (datos.id_ref && (!datos.capacidad && !datos.capacidad_l)) {
	        intentarPoblarNodoDeposito(dest, true);
	      }
      const info = resolverInfoDepositoDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    } else if (dest.tipo === "barrica") {
      const info = resolverInfoBarricaDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    }
  });
  if (!tieneDestino) return null;
  const libreCalc = Number.isFinite(capTotal) ? Math.max(0, capTotal - volTotal) : null;
  return { capTotal, volTotal, libre: libreCalc };
}

function obtenerCapacidadDisponibleDesdeTargets(nodo) {
  if (!nodo || !Array.isArray(nodo.targets)) return null;
  let total = 0;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const cap = obtenerCapacidadDisponibleContenedor(dest);
    if (cap != null) total += cap;
  });
  return total > 0 ? total : null;
}

function sumarAsignacionesLitros(nodo) {
  if (!nodo?.datos?.asignaciones) return 0;
  return Object.values(nodo.datos.asignaciones).reduce((acc, reg) => {
    const val = getVolumenFromDatos(reg);
    return acc + (Number.isFinite(val) ? val : 0);
  }, 0);
}

function calcularTotalesAsignaciones(nodo) {
  if (!nodo?.datos?.asignaciones) return null;
  const permitidos = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  let totalVolumen = 0;
  Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
    if (!permitidos.has(origenId)) return;
    const volumen = getVolumenFromDatos(info);
    if (volumen != null && volumen > 0) totalVolumen += volumen;
  });
  if (totalVolumen <= 0) return null;
  return { totalVolumen, total: totalVolumen };
}

function actualizarVolumenDesdeAsignaciones(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  nodo.datos = nodo.datos || {};
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) return;

  const vistos = new Set();
  const total = predecesores.reduce((acc, pre) => {
    const key = normalizarIdNodo(pre);
    if (vistos.has(key)) return acc;
    vistos.add(key);
    const reg = nodo.datos?.asignaciones?.[key];
    const aporte = reg
      ? null
      : nodo.datos?.aportes?.[key] || nodo.datos?.aportes?.[String(pre.id)];
    const valor = getVolumenFromDatos(reg || aporte);
    return acc + (Number.isFinite(valor) ? valor : 0);
  }, 0);

  if (!(total > 0) && total !== 0) return;

  const final = Number(Number(total || 0).toFixed(2));
  setKilosLitrosNodo(nodo, null, final, "asignaciones");
  if (nodo.tipo === "coupage") {
    nodo.datos.litros_blend = nodo.datos.volumen;
  }
}

function obtenerEstadoDepositoDesdeNodo(idDeposito) {
  const estado = obtenerEstadoContenedorDesdeNodo("deposito", idDeposito);
  if (!estado) return null;
  return estado;
}


const ETAPAS_FLUJO = [
  { id: "entrada", titulo: "Entrada de uva", unidad: "kg" },
  { id: "despalillado", titulo: "Despalillado", unidad: "L" },
  { id: "deposito", titulo: "Depósitos", unidad: "L" },
  { id: "barrica", titulo: "Barricas", unidad: "L" },
  { id: "embotellado", titulo: "Embotellado", unidad: "L" },
  { id: "salida", titulo: "Salida de bodega", unidad: "L" },
];
const OPCIONES_TIPO_CONTENEDOR = [
  "Siempre lleno",
  "Cerrado",
  "Mastelone",
  "Ánfora",
  "Foudre",
  "Barrica",
  "Damajuana",
];
const OPCIONES_MATERIAL_CONTENEDOR = [
  "Inox",
  "Fibra de vidrio",
  "Cemento",
  "Barro",
  "Madera",
  "Cristal",
  "Plástico alimentario",
];

function poblarSelectOpciones(selectId, opciones, placeholder = "Selecciona") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    select.appendChild(placeholderOption);
  }
  opciones.forEach(op => {
    const option = document.createElement("option");
    option.value = op;
    option.textContent = op;
    select.appendChild(option);
  });
  if (valorActual && opciones.includes(valorActual)) {
    select.value = valorActual;
  }
}

const FLOW_NODE_TYPES = {
  entrada: {
    label: "Entrada de uva",
    icono: "🍇",
    campos: [
      { id: "id_ref", label: "ID existente", tipo: "number", placeholder: "ID en Entradas" },
      { id: "kilos", label: "Kilos", tipo: "number", placeholder: "1000" },
      { id: "variedad", label: "Variedad", tipo: "text", placeholder: "Tempranillo" },
      { id: "densidad", label: "Densidad", tipo: "info" },
      { id: "temperatura", label: "Temperatura", tipo: "info" },
    ],
  },
  fermentacion: {
    label: "Fermentación",
    icono: "⚗️",
    campos: [
      {
        id: "estilo",
        label: "Fermentación / Elaboración",
        tipo: "select",
        opciones: ["FA", "FML"],
        placeholder: "Selecciona tipo",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  estilo: {
    label: "Elaboración",
    icono: "⚗️",
    campos: [
      { id: "kilos", label: "Volumen asignado", tipo: "info" },
      {
        id: "metodo",
        label: "Método de elaboración",
        tipo: "select",
        opciones: ["Despalillado", "Pisado", "Prensado", "Uva entera", "Mixto", "Sangrado", "Trasvase"],
      },
      { id: "descripcion", label: "Descripción de elaboración", tipo: "textarea", placeholder: "Detalles adicionales" },
    ],
  },
  deposito: {
    label: "Depósito",
    icono: "🛢️",
    campos: [
      { id: "id_ref", label: "Depósito / mastelone", tipo: "number", placeholder: "Selecciona depósito" },
      { id: "capacidad", label: "Capacidad y volumen", tipo: "info" },
      { id: "tipo", label: "Tipo", tipo: "info" },
      { id: "material", label: "Material", tipo: "info" },
      {
        id: "fase",
        label: "Estado",
        tipo: "select",
        opciones: ["FA", "FML", "CRIANZA"],
        placeholder: "Selecciona estado",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  coupage: {
    label: "Coupage / Blend",
    icono: "🍷",
    campos: [
      { id: "nombre_blend", label: "Nombre del coupage/vino", tipo: "text", placeholder: "Coupage Tempranillo-Malvar" },
      { id: "litros_blend", label: "Volumen total del blend", tipo: "info" },
      { id: "descripcion", label: "Notas del blend", tipo: "textarea", placeholder: "Proporciones, estilo..." },
    ],
  },
  barrica: {
    label: "Crianza",
    icono: '<img src="/barricas.png" alt="Barrica" style="width:26px;height:26px;object-fit:contain;vertical-align:middle;">',
    campos: [
      { id: "nombre_vino", label: "Nombre vino", tipo: "text", placeholder: "Nombre del vino en crianza" },
      {
        id: "contenedor_id",
        label: "Contenedor asignado",
        tipo: "select",
        opciones: [],
        placeholder: "Selecciona contenedor",
      },
      { id: "tipo", label: "Tipo de contenedor", tipo: "info" },
      { id: "tiempo", label: "Fin previsto de la crianza", tipo: "date", placeholder: "" },
      { id: "tiempo_estimado", label: "Duración estimada", tipo: "info" },
      { id: "estado_vino", label: "Estado del vino", tipo: "estadoVino" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Batonnage mensual" },
    ],
  },
  embotellado: {
    label: "Embotellado",
    icono: "🍾",
    campos: [
      {
        id: "botella",
        label: "Tipo de botella",
        tipo: "select",
        opciones: [
          "Mixto (varios formatos)",
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgoña 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
      { id: "filtrado", label: "Filtrado", tipo: "text", placeholder: "Tierra blanca" },
      {
        id: "cierre",
        label: "Tipo de cierre",
        tipo: "select",
        opciones: [
          "Corcho natural",
          "Corcho técnico",
          "Corcho aglomerado",
          "Tapón sintético",
          "Stelvin / Screw-cap",
          "Corona",
          "Vidrio Vinolok",
          "Tapa de rosca",
        ],
        placeholder: "Selecciona cierre",
      },
      { id: "botellas_resultantes", label: "Botellas resultantes", tipo: "info" },
    ],
  },
  almacen: {
    label: "Almacén",
    icono: "📦",
    campos: [
      { id: "condicion", label: "Condición de guarda", tipo: "text", placeholder: "Horizontal, 15 ºC" },
      { id: "fecha", label: "Fecha de entrada", tipo: "date", placeholder: "" },
    ],
  },
  salida: {
    label: "Salida de bodega",
    icono: "🚛",
    campos: [
      { id: "destino", label: "Destino", tipo: "text", placeholder: "Cliente / País" },
      { id: "transporte", label: "Cantidad de salida (botellas)", tipo: "text", placeholder: "Palet / Caja / Botella" },
      {
        id: "formato_botella",
        label: "Formato de botella",
        tipo: "select",
        opciones: [
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgoña 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
    ],
  },
  prensado: {
    label: "Prensado",
    icono: "🌀",
    campos: [
      { id: "litros_resultantes", label: "Volumen resultante", tipo: "number", placeholder: "1275" },
      { id: "merma_abs", label: "Merma abs (volumen)", tipo: "number", placeholder: "425" },
      { id: "merma", label: "Merma (%)", tipo: "number", placeholder: "30" },
      { id: "presion", label: "Presión", tipo: "text", placeholder: "0.8 bar" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Observaciones" },
    ],
  },
};
Object.keys(FLOW_NODE_TYPES).forEach(key => {
  const tipo = FLOW_NODE_TYPES[key];
  tipo.campos = tipo.campos || [];
  const ids = new Set(tipo.campos.map(c => c.id));
  const esEntrada = key === "entrada";
  const asegurarCampo = (id, campo) => {
    if (!ids.has(id)) {
      tipo.campos.unshift({ id, ...campo });
      ids.add(id);
    }
  };
  asegurarCampo("fecha", {
    label: "Fecha de entrada",
    tipo: "info",
    soloLectura: true,
  });
  asegurarCampo("variedad", {
    label: "Variedad de uva",
    tipo: "text",
    placeholder: "Tempranillo",
    soloLectura: !esEntrada,
  });
  if (key !== "deposito" && key !== "entrada") {
    asegurarCampo("merma", {
      label: "Merma / pérdida (%)",
      tipo: "number",
      placeholder: "0",
    });
  }
  if (key !== "entrada") {
    asegurarCampo("fecha_operacion", {
      label: "Fecha operación",
      tipo: "date",
      placeholder: "",
    });
  }
});
	let datosEtapasFlujo = {};
		let flujoNodos = [];
		let nodoConectandoOrigen = null;
			let nodoSeleccionadoId = null;
			let nodoEnEdicion = null;
      let nodoEnEdicionPrevio = null;
      let nodoLimpiezaId = null;
			let dragEstado = null;
			let ultimoNodoManual = null;
			let flowZoom = 1;
      let flowMinimapDrag = null;
      let flowMinimapRaf = null;
	  let flowReplay = {
	    activo: false,
	    playing: false,
	    rootId: null,
	    model: null,
	    state: null,
	    idx: 0,
	    timeMs: null,
	    timer: null,
	  };
	  const FLOW_REPLAY_INTERVAL_MS = 900;
	  const FLOW_REPLAY_TIPOS_VOLUMEN = new Set(["deposito", "coupage", "barrica", "almacen", "embotellado", "salida"]);
			const FLOW_ZOOM_MIN = 0.3;
			const FLOW_ZOOM_MAX = 2;
			const FLOW_ZOOM_STEP = 0.1;
			const FLOW_WORLD_BASE = { width: 5000, height: 3000 };
	let filtrosMovimientos = {
  tipo: "",
  desde: "",
  hasta: "",
  contenedor: "",
  contenedor_tipo: "",
};
let filtroAnalisisDeposito = null;

function mostrarAviso(mensaje, tipo = "info") {
  const contenedor = document.getElementById("appAlerts");
  if (!contenedor) return;
  const toast = document.createElement("div");
  toast.className = `toast ${tipo}`;
  const icon = document.createElement("span");
  icon.className = "toast-icon";
  icon.textContent =
    tipo === "success" ? "🍷" : tipo === "error" ? "⚠️" : tipo === "info" ? "🍇" : "ℹ️";
  const text = document.createElement("span");
  text.className = "toast-text";
  text.textContent = mensaje;
  toast.appendChild(icon);
  toast.appendChild(text);
  contenedor.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateX(20px)";
  }, 3500);
  setTimeout(() => toast.remove(), 4200);
}

function mostrarSkeletonTabla(tbodyId, columnas, filas = 3) {
  const tbody = document.getElementById(tbodyId);
  if (!tbody) return;
  const celda = '<td><div class="skeleton-line"></div></td>';
  const fila = `<tr>${celda.repeat(columnas)}</tr>`;
  tbody.innerHTML = new Array(filas).fill(fila).join("");
}

function setFormFeedback(id, mensaje, tipo = "info") {
  const elemento = document.getElementById(id);
  if (!elemento) return;
  elemento.textContent = mensaje || "";
  elemento.className = `form-feedback ${tipo === "error" ? "error" : tipo === "success" ? "success" : ""}`;
}

// ---------- Copiloto ----------
function cargarConfigCopiloto() {
  let guardado = null;
  try {
    guardado = JSON.parse(localStorage.getItem(COPILOTO_STORAGE_KEY));
  } catch (e) {
    guardado = null;
  }
  const tempMaxGuardado = guardado && guardado.tempMax ? guardado.tempMax : {};
  copilotoConfig = {
    ...COPILOTO_DEFAULT_CONFIG,
    ...guardado,
    tempMax: {
      ...COPILOTO_DEFAULT_CONFIG.tempMax,
      ...tempMaxGuardado,
    },
  };
}

function guardarConfigCopiloto() {
  if (!copilotoConfig) return;
  try {
    localStorage.setItem(COPILOTO_STORAGE_KEY, JSON.stringify(copilotoConfig));
  } catch (e) {
    // noop
  }
}

function cargarEstadoCopiloto() {
  let guardado = null;
  try {
    guardado = JSON.parse(localStorage.getItem(COPILOTO_STATE_KEY));
  } catch (e) {
    guardado = null;
  }
  copilotoState = {
    snoozed: guardado && guardado.snoozed ? guardado.snoozed : {},
    done: guardado && guardado.done ? guardado.done : {},
    seen: guardado && guardado.seen ? guardado.seen : {},
  };
  limpiarEstadoCopiloto();
}

function guardarEstadoCopiloto() {
  if (!copilotoState) return;
  try {
    localStorage.setItem(COPILOTO_STATE_KEY, JSON.stringify(copilotoState));
  } catch (e) {
    // noop
  }
}

function limpiarEstadoCopiloto() {
  if (!copilotoState) return;
  const ahora = Date.now();
  const limpiar = (obj) => {
    if (!obj) return;
    Object.keys(obj).forEach(key => {
      const exp = Number(obj[key] || 0);
      if (!exp || exp < ahora) delete obj[key];
    });
  };
  limpiar(copilotoState.snoozed);
  limpiar(copilotoState.done);
  if (copilotoState.seen) {
    Object.keys(copilotoState.seen).forEach(key => {
      const ts = Number(copilotoState.seen[key] || 0);
      if (!ts || ahora - ts > 48 * 60 * 60 * 1000) delete copilotoState.seen[key];
    });
  }
}

function leerNumeroInput(id, fallback) {
  const input = document.getElementById(id);
  if (!input) return fallback;
  const raw = (input.value || "").toString().replace(",", ".");
  const num = Number(raw);
  return Number.isFinite(num) ? num : fallback;
}

function sincronizarCopilotoUI() {
  if (!copilotoConfig) cargarConfigCopiloto();
  const cfg = copilotoConfig || COPILOTO_DEFAULT_CONFIG;
  const setVal = (id, val) => {
    const input = document.getElementById(id);
    if (input) input.value = val;
  };
  setVal("copilotoParadaHoras", cfg.paradaHoras);
  setVal("copilotoParadaDelta", cfg.paradaDelta);
  setVal("copilotoTempTinto", cfg.tempMax.tinto);
  setVal("copilotoTempBlanco", cfg.tempMax.blanco);
  setVal("copilotoTempRosado", cfg.tempMax.rosado);
  setVal("copilotoOxidacionHoras", cfg.oxidacionHoras);
  setVal("copilotoOxidacionLlenado", cfg.oxidacionMinLlenado);
  setVal("copilotoAnaliticaHoras", cfg.analiticaHoras);
  setVal("copilotoRefreshMin", cfg.refreshMin);
  const toggle = document.getElementById("copilotoToggleExpert");
  if (toggle) {
    toggle.textContent = `Modo experto: ${cfg.modoExperto ? "ON" : "OFF"}`;
  }
  const notif = document.getElementById("copilotoToggleNotif");
  if (notif) {
    notif.textContent = `Notificaciones: ${cfg.notificaciones ? "ON" : "OFF"}`;
  }
}

function actualizarConfigCopilotoDesdeUI() {
  if (!copilotoConfig) cargarConfigCopiloto();
  copilotoConfig.paradaHoras = leerNumeroInput("copilotoParadaHoras", COPILOTO_DEFAULT_CONFIG.paradaHoras);
  copilotoConfig.paradaDelta = leerNumeroInput("copilotoParadaDelta", COPILOTO_DEFAULT_CONFIG.paradaDelta);
  copilotoConfig.tempMax = {
    ...copilotoConfig.tempMax,
    tinto: leerNumeroInput("copilotoTempTinto", COPILOTO_DEFAULT_CONFIG.tempMax.tinto),
    blanco: leerNumeroInput("copilotoTempBlanco", COPILOTO_DEFAULT_CONFIG.tempMax.blanco),
    rosado: leerNumeroInput("copilotoTempRosado", COPILOTO_DEFAULT_CONFIG.tempMax.rosado),
    default: COPILOTO_DEFAULT_CONFIG.tempMax.default,
  };
  copilotoConfig.oxidacionHoras = leerNumeroInput("copilotoOxidacionHoras", COPILOTO_DEFAULT_CONFIG.oxidacionHoras);
  const llenado = leerNumeroInput("copilotoOxidacionLlenado", COPILOTO_DEFAULT_CONFIG.oxidacionMinLlenado);
  copilotoConfig.oxidacionMinLlenado = Math.min(100, Math.max(10, llenado));
  copilotoConfig.analiticaHoras = leerNumeroInput("copilotoAnaliticaHoras", COPILOTO_DEFAULT_CONFIG.analiticaHoras);
  copilotoConfig.refreshMin = leerNumeroInput("copilotoRefreshMin", COPILOTO_DEFAULT_CONFIG.refreshMin);
  guardarConfigCopiloto();
}

function poblarSelectCopilotoNotaEstados() {
  const select = document.getElementById("copilotoNotaEstado");
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  const optionEmpty = document.createElement("option");
  optionEmpty.value = "";
  optionEmpty.textContent = "Sin estado";
  select.appendChild(optionEmpty);
  ESTADOS_VINO.forEach(item => {
    const option = document.createElement("option");
    option.value = item.value;
    option.textContent = item.label;
    select.appendChild(option);
  });
  if (valorActual) select.value = valorActual;
}

function obtenerOpcionesContenedoresCopiloto() {
  const opciones = [];
  const agregar = (tipo, items) => {
    (items || []).forEach(item => {
      if (!item || item.id == null) return;
      opciones.push({
        tipo,
        id: item.id,
        nombre: obtenerNombreContenedorCopiloto(tipo, item.id),
      });
    });
  };
  agregar("deposito", cacheDepositos);
  agregar("mastelone", cacheMastelones);
  agregar("barrica", cacheBarricas);
  const vistos = new Set();
  const lista = opciones.filter(opt => {
    const key = `${opt.tipo}:${opt.id}`;
    if (vistos.has(key)) return false;
    vistos.add(key);
    return true;
  });
  lista.sort((a, b) => a.nombre.localeCompare(b.nombre, "es", { sensitivity: "base" }));
  return lista;
}

function poblarSelectCopilotoContenedores(selectId, placeholderTexto) {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  const lista = obtenerOpcionesContenedoresCopiloto();
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = placeholderTexto;
  select.appendChild(placeholder);
  lista.forEach(opt => {
    const option = document.createElement("option");
    option.value = `${opt.tipo}:${opt.id}`;
    option.textContent = opt.nombre;
    select.appendChild(option);
  });
  if (valorActual) select.value = valorActual;
}

function poblarSelectCopilotoNotaContenedores() {
  poblarSelectCopilotoContenedores("copilotoNotaContenedor", "(Selecciona contenedor)");
}

function poblarSelectCopilotoTimelineContenedores() {
  poblarSelectCopilotoContenedores("copilotoTimelineContenedor", "Todos");
}

function setCopilotoNotaStatus(mensaje, tipo = "info") {
  const status = document.getElementById("copilotoNotaStatus");
  if (!status) return;
  status.textContent = mensaje || "";
  status.classList.remove("success", "error");
  if (tipo === "success") status.classList.add("success");
  if (tipo === "error") status.classList.add("error");
}

function normalizarOrigenCopiloto(valor) {
  const origen = (valor || "").toString().toLowerCase();
  if (origen === "express" || origen === "control" || origen === "manual") return origen;
  return "todos";
}

function obtenerAccionEventoCopiloto(evento) {
  const accionTexto = (evento?.meta?.accion_texto || "").toString().trim();
  const raw = (accionTexto || evento?.meta?.accion || evento?.tipo || "").toString().trim();
  const key = raw.toLowerCase();
  return {
    key,
    label: accionTexto || formatearAccionEvento(raw),
  };
}

function formatearHoraCorta(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
  } catch (_err) {
    return "—";
  }
}

function resolverEtiquetaDiaTimeline(ms) {
  if (!ms) return "Sin fecha";
  const hoy = new Date();
  const claveHoy = obtenerClaveDiaLocal(hoy.getTime());
  const ayer = new Date();
  ayer.setDate(hoy.getDate() - 1);
  const claveAyer = obtenerClaveDiaLocal(ayer.getTime());
  const clave = obtenerClaveDiaLocal(ms);
  if (clave && clave === claveHoy) return "Hoy";
  if (clave && clave === claveAyer) return "Ayer";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      weekday: "short",
      day: "2-digit",
      month: "short",
    });
  } catch (_err) {
    return "—";
  }
}

function obtenerFiltrosTimeline() {
  const selectCont = document.getElementById("copilotoTimelineContenedor");
  const selectAccion = document.getElementById("copilotoTimelineAccion");
  const inputBuscar = document.getElementById("copilotoTimelineBuscar");
  return {
    contenedor: selectCont ? selectCont.value : "",
    accion: selectAccion ? selectAccion.value : "",
    buscar: inputBuscar ? inputBuscar.value.trim().toLowerCase() : "",
    origen: normalizarOrigenCopiloto(copilotoTimelineFiltros.origen),
  };
}

function resetearVisibilidadTimeline() {
  copilotoTimelineVisible = COPILOTO_TIMELINE_INIT;
}

function actualizarOpcionesAccionTimeline(eventos) {
  const select = document.getElementById("copilotoTimelineAccion");
  if (!select) return;
  const valorActual = select.value;
  const mapa = new Map();
  (eventos || []).forEach(evento => {
    const { key, label } = obtenerAccionEventoCopiloto(evento);
    if (!key) return;
    if (!mapa.has(key)) mapa.set(key, label);
  });
  const opciones = Array.from(mapa.entries()).sort((a, b) =>
    a[1].localeCompare(b[1], "es", { sensitivity: "base" })
  );
  select.innerHTML = "";
  const base = document.createElement("option");
  base.value = "";
  base.textContent = "Todas";
  select.appendChild(base);
  opciones.forEach(([key, label]) => {
    const option = document.createElement("option");
    option.value = key;
    option.textContent = label;
    select.appendChild(option);
  });
  if (valorActual === "") {
    select.value = "";
  } else {
    const existe = Array.from(select.options).some(opt => opt.value === valorActual);
    if (existe) select.value = valorActual;
  }
}

function actualizarEventosCopilotoLocales(evento) {
  if (!evento) return;
  const actuales = Array.isArray(copilotoEventosCache) ? [...copilotoEventosCache] : [];
  const id = evento.id;
  const filtrados = id != null ? actuales.filter(ev => ev?.id !== id) : actuales;
  filtrados.unshift(evento);
  copilotoEventosCache = filtrados.slice(0, COPILOTO_EVENTOS_LIMIT);
  copilotoEventosTs = Date.now();
  actualizarOpcionesAccionTimeline(copilotoEventosCache);
  renderCopilotoActividad(copilotoEventosCache);
  renderCopilotoTimeline(copilotoEventosCache);
  renderCopilotoHeatmap(copilotoEventosCache);
}

async function guardarNotaCopiloto() {
  const selectCont = document.getElementById("copilotoNotaContenedor");
  const selectEstado = document.getElementById("copilotoNotaEstado");
  const textarea = document.getElementById("copilotoNotaTexto");
  const btn = document.getElementById("copilotoNotaGuardar");
  if (!selectCont || !textarea) return;
  const texto = textarea.value.trim();
  if (!texto) {
    setCopilotoNotaStatus("Escribe una nota antes de guardar.", "error");
    return;
  }
  if (!selectCont.value) {
    setCopilotoNotaStatus("Selecciona un contenedor para guardar la nota.", "info");
    return;
  }
  const [tipo, idRaw] = selectCont.value.split(":");
  const id = Number(idRaw);
  if (!tipo || !Number.isFinite(id)) {
    setCopilotoNotaStatus("Contenedor inválido.", "error");
    return;
  }
  const estadoValor = selectEstado ? selectEstado.value : "";
  const meta = { fuente: "copiloto", accion: "nota" };
  if (estadoValor) {
    meta.estado = estadoValor === ESTADO_PERSONALIZADO
      ? { valor: ESTADO_PERSONALIZADO, texto: "Personalizado" }
      : { valor: estadoValor };
  }
  const payload = {
    contenedor_tipo: tipo,
    contenedor_id: id,
    tipo: "nota",
    resumen: "Nota rápida",
    detalle: texto,
    origen: "manual",
    meta,
  };
  const textoBtn = btn ? btn.textContent : "";
  if (btn) {
    btn.disabled = true;
    btn.textContent = "Guardando...";
  }
  setCopilotoNotaStatus("Guardando nota...", "info");
  try {
    const res = await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      setCopilotoNotaStatus(data?.error || "No se pudo guardar la nota.", "error");
      return;
    }
    setCopilotoNotaStatus("Anotado en Bitácora.", "success");
    textarea.value = "";
    const evento = data?.evento || {
      ...payload,
      id: data?.id,
      fecha_hora: new Date().toISOString(),
    };
    actualizarEventosCopilotoLocales(evento);
  } catch (_err) {
    setCopilotoNotaStatus("No se pudo guardar la nota.", "error");
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.textContent = textoBtn || "Guardar nota";
    }
  }
}

function inicializarCopilotoUI() {
  cargarConfigCopiloto();
  cargarEstadoCopiloto();
  sincronizarCopilotoUI();
  const btnGuardar = document.getElementById("copilotoGuardar");
  if (btnGuardar) {
    btnGuardar.addEventListener("click", () => {
      actualizarConfigCopilotoDesdeUI();
      sincronizarCopilotoUI();
      programarAutoCopiloto();
      mostrarAviso("Reglas del copiloto guardadas.", "success");
      actualizarCopiloto(true);
    });
  }
  const formConfig = document.getElementById("copilotoConfig");
  if (formConfig) {
    formConfig.addEventListener("submit", ev => ev.preventDefault());
  }
  const btnRefresh = document.getElementById("copilotoRefresh");
  if (btnRefresh) {
    btnRefresh.addEventListener("click", () => actualizarCopiloto(true));
  }
  const btnExpert = document.getElementById("copilotoToggleExpert");
  if (btnExpert) {
    btnExpert.addEventListener("click", () => {
      copilotoConfig.modoExperto = !copilotoConfig.modoExperto;
      guardarConfigCopiloto();
      sincronizarCopilotoUI();
      actualizarCopiloto(true);
    });
  }
  const btnNotif = document.getElementById("copilotoToggleNotif");
  if (btnNotif) {
    btnNotif.addEventListener("click", async () => {
      if (copilotoConfig.notificaciones) {
        copilotoConfig.notificaciones = false;
        guardarConfigCopiloto();
        sincronizarCopilotoUI();
        mostrarAviso("Notificaciones silenciadas.", "info");
        return;
      }
      if (!("Notification" in window)) {
        mostrarAviso("Tu navegador no soporta notificaciones.", "error");
        return;
      }
      if (Notification.permission === "denied") {
        mostrarAviso("Las notificaciones están bloqueadas en el navegador.", "error");
        return;
      }
      if (Notification.permission === "default") {
        const permiso = await Notification.requestPermission();
        if (permiso !== "granted") {
          mostrarAviso("Necesito permiso para avisarte.", "error");
          return;
        }
      }
      copilotoConfig.notificaciones = true;
      guardarConfigCopiloto();
      sincronizarCopilotoUI();
      mostrarAviso("Notificaciones activadas.", "success");
    });
  }
  const btnExpress = document.getElementById("copilotoAccionExpress");
  if (btnExpress) {
    btnExpress.addEventListener("click", () => {
      const fab = document.getElementById("express-fab");
      if (fab) fab.click();
    });
  }
  const btnDepositos = document.getElementById("copilotoAccionDepositos");
  if (btnDepositos) {
    btnDepositos.addEventListener("click", () => {
      mostrarSeccion("depositos");
    });
  }
  const btnBarricas = document.getElementById("copilotoAccionBarricas");
  if (btnBarricas) {
    btnBarricas.addEventListener("click", () => {
      mostrarSeccion("barricas");
    });
  }
  const btnMovimientos = document.getElementById("copilotoAccionMovimientos");
  if (btnMovimientos) {
    btnMovimientos.addEventListener("click", () => {
      mostrarSeccion("bitacora");
    });
  }
  poblarSelectCopilotoNotaEstados();
  poblarSelectCopilotoNotaContenedores();
  poblarSelectCopilotoTimelineContenedores();
  const btnNota = document.getElementById("copilotoNotaGuardar");
  if (btnNota) {
    btnNota.addEventListener("click", guardarNotaCopiloto);
  }
  const chipsNota = document.querySelectorAll(".copiloto-note-chip");
  if (chipsNota.length) {
    const textarea = document.getElementById("copilotoNotaTexto");
    chipsNota.forEach(chip => {
      chip.addEventListener("click", () => {
        if (!textarea) return;
        const raw = (chip.dataset.tag || chip.textContent || "").toString().trim();
        if (!raw) return;
        const etiqueta = raw.replace(/\s+/g, "");
        const token = `#${etiqueta}`;
        const actual = textarea.value || "";
        const separador = actual && !/\s$/.test(actual) ? " " : "";
        textarea.value = `${actual}${separador}${token} `;
        textarea.focus();
      });
    });
  }
  const btnHeatmap = document.getElementById("copilotoHeatmapClear");
  if (btnHeatmap) {
    btnHeatmap.addEventListener("click", () => {
      setCopilotoFiltroDia(null, copilotoEventosCache);
    });
  }
  const selectFiltroCont = document.getElementById("copilotoTimelineContenedor");
  if (selectFiltroCont) {
    selectFiltroCont.addEventListener("change", () => {
      resetearVisibilidadTimeline();
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  const selectFiltroAccion = document.getElementById("copilotoTimelineAccion");
  if (selectFiltroAccion) {
    selectFiltroAccion.addEventListener("change", () => {
      resetearVisibilidadTimeline();
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  const inputBuscar = document.getElementById("copilotoTimelineBuscar");
  if (inputBuscar) {
    inputBuscar.addEventListener("input", () => {
      if (copilotoTimelineBusquedaTimer) clearTimeout(copilotoTimelineBusquedaTimer);
      copilotoTimelineBusquedaTimer = setTimeout(() => {
        resetearVisibilidadTimeline();
        renderCopilotoTimeline(copilotoEventosCache);
      }, 200);
    });
  }
  const chipsOrigen = document.querySelectorAll("#copilotoTimelineOrigen .copiloto-chip");
  if (chipsOrigen.length) {
    const activo = document.querySelector("#copilotoTimelineOrigen .copiloto-chip.is-active");
    if (activo) {
      copilotoTimelineFiltros.origen = normalizarOrigenCopiloto(activo.dataset.origen || "todos");
    }
    chipsOrigen.forEach(chip => {
      chip.addEventListener("click", () => {
        chipsOrigen.forEach(btn => btn.classList.remove("is-active"));
        chip.classList.add("is-active");
        copilotoTimelineFiltros.origen = normalizarOrigenCopiloto(chip.dataset.origen || "todos");
        resetearVisibilidadTimeline();
        renderCopilotoTimeline(copilotoEventosCache);
      });
    });
  }
  const btnMas = document.getElementById("copilotoTimelineMas");
  if (btnMas) {
    btnMas.addEventListener("click", () => {
      copilotoTimelineVisible += COPILOTO_TIMELINE_STEP;
      renderCopilotoTimeline(copilotoEventosCache);
    });
  }
  programarAutoCopiloto();
}

function programarAutoCopiloto() {
  if (copilotoAutoTimer) clearInterval(copilotoAutoTimer);
  if (!copilotoConfig) cargarConfigCopiloto();
  const minutos = Math.max(1, Number(copilotoConfig.refreshMin) || COPILOTO_DEFAULT_CONFIG.refreshMin);
  copilotoAutoTimer = setInterval(() => actualizarCopiloto(), minutos * 60 * 1000);
}

function programarActualizacionCopiloto(forzar = false) {
  if (copilotoUpdateTimer) clearTimeout(copilotoUpdateTimer);
  copilotoUpdateTimer = setTimeout(() => actualizarCopiloto(forzar), 350);
}

function parseFechaMs(valor) {
  if (!valor) return null;
  const ms = new Date(valor).getTime();
  return Number.isNaN(ms) ? null : ms;
}

function horasEntre(msInicio, msFin = Date.now()) {
  if (!msInicio || !msFin) return null;
  return Math.max(0, (msFin - msInicio) / 36e5);
}

function formatearTiempoRelativo(ms) {
  if (!ms) return "—";
  const diff = Date.now() - ms;
  if (!Number.isFinite(diff) || diff < 0) return "—";
  const minutos = Math.round(diff / 60000);
  if (minutos < 60) return `hace ${minutos} min`;
  const horas = Math.round(minutos / 60);
  if (horas < 24) return `hace ${horas} h`;
  const dias = Math.round(horas / 24);
  return `hace ${dias} d`;
}

function formatearAccionEvento(valor) {
  const texto = (valor || "").toString().trim().toLowerCase();
  if (!texto) return "Evento";
  return texto
    .replace(/_/g, " ")
    .replace(/\b\w/g, letra => letra.toUpperCase());
}

function extraerEstadoMetaCopiloto(meta) {
  if (!meta) return null;
  const raw = meta.estado || meta.estado_vino || meta.estadoVino || null;
  if (!raw) return null;
  if (typeof raw === "string") {
    const limpio = raw.trim();
    return limpio ? { valor: limpio.toLowerCase(), texto: "" } : null;
  }
  if (typeof raw === "object") {
    const valor = (raw.valor || raw.id || raw.codigo || "").toString().trim().toLowerCase();
    const texto = (raw.texto || raw.nombre || raw.custom || raw.etiqueta || "").toString().trim();
    return valor || texto ? { valor, texto } : null;
  }
  return null;
}

function resolverEtiquetaEstado(estado) {
  if (!estado) return "";
  const valor = (estado.valor || "").toString().trim().toLowerCase();
  const texto = (estado.texto || "").toString().trim();
  if (valor === ESTADO_PERSONALIZADO) return texto || "Personalizado";
  const encontrado = ESTADOS_VINO.find(item => item.value === valor);
  if (encontrado) return encontrado.label;
  return texto || estado.valor || "";
}

async function obtenerEventosBitacoraRecientes(forzar = false) {
  const ahora = Date.now();
  if (!forzar && copilotoEventosTs && ahora - copilotoEventosTs < COPILOTO_EVENTOS_TTL_MS) {
    return Array.isArray(copilotoEventosCache) ? copilotoEventosCache : [];
  }
  try {
    const res = await fetch(`/api/eventos?scope=contenedor&limit=${COPILOTO_EVENTOS_LIMIT}`);
    if (!res.ok) return [];
    const data = await res.json().catch(() => ({}));
    const eventos = Array.isArray(data.eventos) ? data.eventos : [];
    copilotoEventosCache = eventos;
    copilotoEventosTs = ahora;
    actualizarOpcionesAccionTimeline(eventos);
    return eventos;
  } catch (_err) {
    return [];
  }
}

function mapearEventosPorContenedor(eventos) {
  const mapa = new Map();
  (eventos || []).forEach(evento => {
    const tipo = (evento.contenedor_tipo || "").toString().toLowerCase();
    const id = Number(evento.contenedor_id);
    if (!tipo || !Number.isFinite(id)) return;
    const key = `${tipo}:${id}`;
    if (!mapa.has(key)) {
      mapa.set(key, evento);
    }
  });
  return mapa;
}

function obtenerFaseContenedor(cont) {
  if (!cont) return "";
  if (cont.tipo === "barrica") return "Crianza";
  const nodo = obtenerNodoFinalContenedor("deposito", cont.id);
  const fase = (nodo?.datos?.fase || "").toString().trim().toUpperCase();
  if (fase === "FA") return "Fermentación";
  if (fase === "FML") return "Maloláctica";
  if (fase === "CRIANZA") return "Crianza";
  return "Activo";
}

function obtenerEtiquetaContenedor(contenedor) {
  if (!contenedor) return "";
  const tipoLabel =
    contenedor.tipo === "mastelone"
      ? "Mastelone"
      : contenedor.tipo === "barrica"
      ? "Barrica"
      : "Depósito";
  const codigo = (contenedor.codigo || "").toString().trim();
  return `${tipoLabel} ${codigo || "#" + contenedor.id}`;
}

function obtenerNombreContenedorCopiloto(tipo, id) {
  if (!tipo || id == null) return "Contenedor";
  const idNum = Number(id);
  if (tipo === "deposito") return obtenerNombreDeposito(idNum);
  if (tipo === "mastelone") return obtenerNombreMastelone(idNum);
  if (tipo === "barrica") return obtenerNombreBarrica(idNum);
  return `${tipo} ${id}`;
}

function obtenerContenedoresCopiloto() {
  const contenedores = [];
  const agregar = (tipo, item) => {
    if (!item) return;
    const estadoNodo =
      tipo === "barrica"
        ? obtenerEstadoBarricaDesdeNodo(item.id)
        : obtenerEstadoDepositoDesdeNodo(item.id);
    const capacidad =
      item.capacidad_l != null
        ? Number(item.capacidad_l)
        : item.capacidad_hl != null
        ? Number(item.capacidad_hl * 100)
        : null;
    const volumenNodo = estadoNodo?.volumen;
    const volumen = Number.isFinite(volumenNodo)
      ? Number(volumenNodo)
      : Number(item.litros_actuales ?? 0);
    const variedad = estadoNodo?.variedad || item.vino_tipo || "";
    const estado = item.estado || "";
    const activo = (Number(volumen) > 0) || (estado && estado !== "vacio");
    if (!activo) return;
    contenedores.push({
      tipo,
      id: item.id,
      codigo: item.codigo || "",
      capacidad: Number.isFinite(capacidad) ? capacidad : null,
      volumen: Number.isFinite(volumen) ? volumen : 0,
      variedad,
      vino_tipo: item.vino_tipo || "",
      estado,
    });
  };
  (cacheDepositos || []).forEach(item => agregar("deposito", item));
  (cacheMastelones || []).forEach(item => agregar("mastelone", item));
  (cacheBarricas || []).forEach(item => agregar("barrica", item));
  return contenedores;
}

function obtenerMovimientosContenedor(tipo, id) {
  if (!Array.isArray(cacheMovimientos)) return [];
  return cacheMovimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .sort((a, b) => {
      const aMs = parseFechaMs(a.fecha || a.fecha_hora) || 0;
      const bMs = parseFechaMs(b.fecha || b.fecha_hora) || 0;
      return bMs - aMs;
    });
}

async function obtenerAnaliticosCopiloto(tipo, id, forzar = false) {
  const key = `${tipo}:${id}`;
  const ahora = Date.now();
  const ultimo = copilotoAnaliticosTs.get(key);
  if (!forzar && ultimo && ahora - ultimo < COPILOTO_ANALITICOS_TTL_MS) {
    return copilotoAnaliticosCache.get(key) || [];
  }
  try {
    const res = await fetch(`/api/registros/${tipo}/${id}`);
    if (!res.ok) return [];
    const datos = await res.json();
    datos.sort((a, b) => {
      const aMs = parseFechaMs(a.fecha_hora || a.fecha) || 0;
      const bMs = parseFechaMs(b.fecha_hora || b.fecha) || 0;
      return bMs - aMs;
    });
    copilotoAnaliticosCache.set(key, datos);
    copilotoAnaliticosTs.set(key, ahora);
    return datos;
  } catch (err) {
    console.warn("No se pudieron cargar registros analíticos:", err);
    return [];
  }
}

function inferirEstiloContenedor(contenedor) {
  const base = (contenedor.vino_tipo || contenedor.variedad || "").toString().trim();
  if (!base) return "default";
  const limpio = base
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (limpio.includes("rosado") || limpio.includes("clarete")) return "rosado";
  if (limpio.includes("tinto")) return "tinto";
  if (limpio.includes("blanco")) return "blanco";
  const norm = normalizarTextoUva(limpio);
  if (esVariedadBlanca(norm)) return "blanco";
  return "tinto";
}

function contieneProteccion(nota) {
  if (!nota) return false;
  const limpio = nota
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  const claves = ["so2", "sulf", "sulfuroso", "co2", "n2", "nitrogeno", "inert"];
  return claves.some(clave => limpio.includes(clave));
}

function reglaFermentacionEstancada(contenedor, analiticos, config) {
  const conDensidad = (analiticos || []).filter(r => r.densidad != null).slice(0, 2);
  if (conDensidad.length < 2) return null;
  const [ultima, anterior] = conDensidad;
  const densUlt = normalizarNumero(ultima.densidad);
  const densAnt = normalizarNumero(anterior.densidad);
  if (densUlt == null || densAnt == null) return null;
  const msUlt = parseFechaMs(ultima.fecha_hora || ultima.fecha);
  const msAnt = parseFechaMs(anterior.fecha_hora || anterior.fecha);
  if (!msUlt || !msAnt) return null;
  const horas = Math.abs(msUlt - msAnt) / 36e5;
  const bajada = densAnt - densUlt;
  if (horas < config.paradaHoras) return null;
  if (bajada > config.paradaDelta) return null;
  const temp = normalizarNumero(ultima.temperatura_c);
  const tempTxt = temp != null ? `${temp.toFixed(1)} °C` : "—";
  const horasTxt = Math.round(horas);
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `fermentacion:${contenedor.tipo}:${contenedor.id}`,
    level: "alta",
    titulo: "Riesgo de parada de fermentación",
    mensaje: `La densidad no ha bajado en ${horasTxt} h y la temperatura está en ${tempTxt}. Revisa nutrición/temperatura y mueve lías si aplica.`,
    acciones: ["Revisar nutrientes", "Ajustar temperatura", "Mover lías"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `Ojo: ${etiqueta} lleva ${horasTxt} h sin bajar densidad (temp ${tempTxt}).`,
  };
}

function reglaOxidacion(contenedor, movimientos, config) {
  if (!contenedor.capacidad || !Number.isFinite(contenedor.capacidad)) return null;
  if (!movimientos || !movimientos.length) return null;
  const llenado = contenedor.capacidad > 0 ? contenedor.volumen / contenedor.capacidad : 0;
  const llenadoPct = Math.round(llenado * 100);
  if (llenadoPct >= config.oxidacionMinLlenado) return null;
  const ultimo = movimientos[0];
  const msUlt = parseFechaMs(ultimo.fecha || ultimo.fecha_hora);
  const horas = horasEntre(msUlt);
  if (horas == null || horas < config.oxidacionHoras) return null;
  const proteccion = movimientos.some(mov => {
    const msMov = parseFechaMs(mov.fecha || mov.fecha_hora);
    const horasMov = horasEntre(msMov);
    if (horasMov == null || horasMov > config.proteccionHoras) return false;
    return contieneProteccion(mov.nota);
  });
  if (proteccion) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `oxidacion:${contenedor.tipo}:${contenedor.id}`,
    level: "media",
    titulo: "Riesgo de oxidación",
    mensaje: `Movimiento largo sin protección registrada (${Math.round(horas)} h). Si puedes, satura con CO2 y minimiza exposición.`,
    acciones: ["Proteger con CO2", "Minimizar exposición", "Revisar SO2"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} lleva ${Math.round(horas)} h sin movimiento y está al ${llenadoPct}%.`,
  };
}

function reglaTemperaturaAlta(contenedor, analiticos, config) {
  const registro = (analiticos || []).find(r => r.temperatura_c != null);
  if (!registro) return null;
  const temp = normalizarNumero(registro.temperatura_c);
  if (temp == null) return null;
  const estilo = inferirEstiloContenedor(contenedor);
  const maxTemp =
    Number(config.tempMax?.[estilo]) ||
    Number(config.tempMax?.default) ||
    COPILOTO_DEFAULT_CONFIG.tempMax.default;
  if (!(temp > maxTemp)) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  const estiloTexto = estilo === "default" ? "este estilo" : estilo;
  return {
    id: `temperatura:${contenedor.tipo}:${contenedor.id}`,
    level: "media",
    titulo: "Control de temperatura",
    mensaje: `Temperatura alta (${temp.toFixed(1)} °C) para ${estiloTexto}. Puede subir VA o extraer de más.`,
    acciones: ["Bajar temperatura", "Revisar extracción", "Controlar VA"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} va caliente (${temp.toFixed(1)} °C) para ${estiloTexto}.`,
  };
}

function reglaAnaliticaPendiente(contenedor, analiticos, config) {
  const registro = (analiticos || [])[0];
  if (!registro) {
    const etiqueta = obtenerEtiquetaContenedor(contenedor);
    return {
      id: `analitica:${contenedor.tipo}:${contenedor.id}`,
      level: "baja",
      basica: true,
      titulo: "Faltan datos críticos",
      mensaje: "No hay registros analíticos recientes. Sin datos no hay copiloto.",
      acciones: ["Medir densidad", "Medir temperatura", "Añadir nota sensorial"],
      contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
      feed: `${etiqueta} no tiene registros analíticos aún.`,
    };
  }
  const ms = parseFechaMs(registro.fecha_hora || registro.fecha);
  const horas = horasEntre(ms);
  if (horas == null || horas < config.analiticaHoras) return null;
  const etiqueta = obtenerEtiquetaContenedor(contenedor);
  return {
    id: `analitica:${contenedor.tipo}:${contenedor.id}`,
    level: "baja",
    basica: true,
    titulo: "Analítica pendiente",
    mensaje: `Hace ${Math.round(horas)} h que no registras datos. Necesito densidad y temperatura.`,
    acciones: ["Medir densidad", "Medir temperatura", "Actualizar nota"],
    contenedor: { tipo: contenedor.tipo, id: contenedor.id, codigo: contenedor.codigo, etiqueta },
    feed: `${etiqueta} lleva ${Math.round(horas)} h sin analítica.`,
  };
}

function ordenarAlertasCopiloto(alertas) {
  const prioridad = { alta: 3, media: 2, baja: 1 };
  return [...alertas].sort((a, b) => {
    const score = (prioridad[b.level] || 0) - (prioridad[a.level] || 0);
    if (score !== 0) return score;
    return (a.titulo || "").localeCompare(b.titulo || "");
  });
}

function filtrarAlertasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  limpiarEstadoCopiloto();
  const ahora = Date.now();
  return alertas.filter(alerta => {
    const snooze = copilotoState.snoozed?.[alerta.id];
    const done = copilotoState.done?.[alerta.id];
    if (snooze && snooze > ahora) return false;
    if (done && done > ahora) return false;
    return true;
  });
}

function generarTareasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  const tareas = [];
  const vistos = new Set();
  alertas.forEach(alerta => {
    (alerta.acciones || []).forEach((accion, idx) => {
      const id = `${alerta.id}:accion:${idx}`;
      if (vistos.has(id)) return;
      if (copilotoState.done?.[id]) return;
      vistos.add(id);
      tareas.push({
        id,
        texto: accion,
        contenedor: alerta.contenedor,
        basica: alerta.basica || false,
      });
    });
  });
  return tareas;
}

function crearElementoCopilotoEmpty(texto) {
  const empty = document.createElement("div");
  empty.className = "copiloto-empty";
  empty.textContent = texto;
  return empty;
}

function obtenerEstadoNodoCopiloto(contenedor) {
  if (!contenedor) return null;
  if (contenedor.tipo === "barrica") {
    const nodo = obtenerNodoFinalContenedor("barrica", contenedor.id);
    const valor = (nodo?.datos?.estado_vino || "").toString().trim();
    const texto = (nodo?.datos?.estado_vino_texto || "").toString().trim();
    return valor ? { valor, texto } : null;
  }
  if (contenedor.tipo === "deposito" || contenedor.tipo === "mastelone") {
    const nodo = obtenerNodoFinalContenedor("deposito", contenedor.id);
    const control = Array.isArray(nodo?.datos?.control) ? nodo.datos.control : [];
    const ultimo = control.length ? control[control.length - 1] : null;
    const valor = (ultimo?.estado_vino || "").toString().trim();
    const texto = (ultimo?.estado_vino_texto || "").toString().trim();
    return valor ? { valor, texto } : null;
  }
  return null;
}

function construirLineaVariablesCopiloto(meta) {
  if (!meta) return "";
  const partes = [];
  if (meta.densidad !== undefined && meta.densidad !== null && meta.densidad !== "") {
    const densidad = Number(meta.densidad);
    if (Number.isFinite(densidad)) partes.push(`Densidad ${densidad}`);
  }
  let temperatura = null;
  if (meta.temperatura_c !== undefined && meta.temperatura_c !== null && meta.temperatura_c !== "") {
    temperatura = Number(meta.temperatura_c);
  } else if (meta.temperatura !== undefined && meta.temperatura !== null && meta.temperatura !== "") {
    temperatura = Number(meta.temperatura);
  }
  if (Number.isFinite(temperatura)) partes.push(`Temperatura ${temperatura}°C`);
  if (meta.so2 !== undefined && meta.so2 !== null && meta.so2 !== "") {
    const so2 = Number(meta.so2);
    if (Number.isFinite(so2)) partes.push(`SO2 ${so2}`);
  }
  if (meta.nivel_llenado !== undefined && meta.nivel_llenado !== null && meta.nivel_llenado !== "") {
    const nivel = Number(meta.nivel_llenado);
    if (Number.isFinite(nivel)) partes.push(`Nivel ${nivel}%`);
  }
  if (meta.litros !== undefined && meta.litros !== null && meta.litros !== "") {
    const litros = Number(meta.litros);
    if (Number.isFinite(litros)) partes.push(`Litros ${litros}`);
  }
  if (meta.volumen !== undefined && meta.volumen !== null && meta.volumen !== "") {
    const volumen = Number(meta.volumen);
    if (Number.isFinite(volumen)) partes.push(`Volumen ${volumen}`);
  }
  const producto = (meta.productos || meta.producto || "").toString().trim();
  if (producto) partes.push(`Producto ${producto}`);
  let dosisTexto = "";
  if (meta.dosis && typeof meta.dosis === "object") {
    const cantidad = meta.dosis.cantidad != null ? String(meta.dosis.cantidad).trim() : "";
    const unidad = meta.dosis.unidad != null ? String(meta.dosis.unidad).trim() : "";
    dosisTexto = [cantidad, unidad].filter(Boolean).join(" ");
  } else if (meta.dosis != null && meta.dosis !== "") {
    dosisTexto = String(meta.dosis).trim();
  }
  if (dosisTexto) partes.push(`Dosis ${dosisTexto}`);
  if (meta.bazuqueo) partes.push("Bazuqueo");
  if (meta.remontado) partes.push("Remontado");
  if (meta.trasiego) partes.push("Trasiego");
  return partes.join(" · ");
}

function obtenerClaveDiaLocal(ms) {
  if (!ms) return "";
  const fecha = new Date(ms);
  if (Number.isNaN(fecha.getTime())) return "";
  const y = fecha.getFullYear();
  const m = String(fecha.getMonth() + 1).padStart(2, "0");
  const d = String(fecha.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function formatearDiaCorto(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      day: "2-digit",
      month: "short",
    });
  } catch (_err) {
    return "—";
  }
}

function formatearDiaLargo(ms) {
  if (!ms) return "—";
  try {
    return new Date(ms).toLocaleDateString("es-ES", {
      weekday: "long",
      day: "2-digit",
      month: "long",
    });
  } catch (_err) {
    return "—";
  }
}

function formatearFechaHoraCopiloto(ms) {
  if (!ms) return "—";
  try {
    const fecha = new Date(ms);
    const dia = fecha.toLocaleDateString("es-ES", {
      weekday: "short",
      day: "2-digit",
      month: "short",
    });
    const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
    return `${dia} · ${hora}`;
  } catch (_err) {
    return "—";
  }
}

function parseClaveDiaLocal(clave) {
  if (!clave) return null;
  const partes = clave.split("-").map(n => Number(n));
  if (partes.length !== 3) return null;
  const [anio, mes, dia] = partes;
  if (!anio || !mes || !dia) return null;
  return new Date(anio, mes - 1, dia).getTime();
}

function detectarInconsistenciaCopiloto(contenedor) {
  if (!contenedor) return false;
  const volumen = Number(contenedor.volumen) || 0;
  const variedad = (contenedor.variedad || contenedor.vino_tipo || "").toString().trim();
  const estado = (contenedor.estado || "").toString().trim().toLowerCase();
  const tieneVolumen = volumen > 0;
  const tieneVariedad = Boolean(variedad);
  if (tieneVariedad && !tieneVolumen) return true;
  if (tieneVolumen && !tieneVariedad) return true;
  if (estado === "vacio" && tieneVolumen) return true;
  return false;
}

function calcularSemaforoCopiloto(contenedor, evento, analiticos) {
  if (detectarInconsistenciaCopiloto(contenedor)) {
    return { nivel: "actua", emoji: "🔴", texto: "Actúa" };
  }
  const msEvento = parseFechaMs(evento?.fecha_hora || evento?.fecha);
  const horasEvento = horasEntre(msEvento);
  if (horasEvento == null || horasEvento > COPILOTO_SEMAFORO_HORAS) {
    return { nivel: "preparate", emoji: "🟠", texto: "Prepárate" };
  }
  const activo = esFermentacionActiva(contenedor, analiticos) || esCrianzaActiva(contenedor);
  if (activo) {
    return { nivel: "observa", emoji: "🔵", texto: "Observa" };
  }
  return { nivel: "mantener", emoji: "🟢", texto: "Mantén" };
}

function renderCopilotoVivo(contenedores, analiticosMap, eventosMap) {
  const contenedor = document.getElementById("copilotoVivo");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const lista = Array.isArray(contenedores) ? contenedores : [];
  if (!lista.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin contenedores activos todavía."));
    return;
  }

  const items = lista.map(cont => {
    const key = `${cont.tipo}:${cont.id}`;
    const evento = eventosMap?.get(key) || null;
    const estadoEvento = extraerEstadoMetaCopiloto(evento?.meta);
    const estadoNodo = obtenerEstadoNodoCopiloto(cont);
    const estadoFinal = estadoEvento || estadoNodo;
    const analiticos = analiticosMap?.get(key) || [];
    const densidadReg = analiticos.find(r => r.densidad != null);
    const tempReg = analiticos.find(r => r.temperatura_c != null || r.temperatura != null);
    const densidadValor = densidadReg ? Number(densidadReg.densidad) : Number(evento?.meta?.densidad);
    const temperaturaValor = tempReg
      ? Number(tempReg.temperatura_c ?? tempReg.temperatura)
      : Number(evento?.meta?.temperatura_c ?? evento?.meta?.temperatura);

    const msEvento = parseFechaMs(evento?.fecha_hora || evento?.fecha);
    const msAnalitico = parseFechaMs(analiticos?.[0]?.fecha_hora || analiticos?.[0]?.fecha);
    const mov = obtenerMovimientosContenedor(cont.tipo, cont.id)[0];
    const msMov = parseFechaMs(mov?.fecha || mov?.fecha_hora);
    const ultimoMs = [msEvento, msAnalitico, msMov].filter(Boolean).sort((a, b) => b - a)[0] || null;
    const semaforo = calcularSemaforoCopiloto(cont, evento, analiticos);

    return {
      cont,
      evento,
      estadoFinal,
      densidadValor: Number.isFinite(densidadValor) ? densidadValor : null,
      temperaturaValor: Number.isFinite(temperaturaValor) ? temperaturaValor : null,
      ultimoMs,
      fase: obtenerFaseContenedor(cont),
      semaforo,
    };
  });

  items.sort((a, b) => {
    const aMs = a.ultimoMs || 0;
    const bMs = b.ultimoMs || 0;
    return aMs - bMs;
  });

  items.slice(0, 12).forEach(item => {
    const card = document.createElement("div");
    card.className = "copiloto-live-item";

    const top = document.createElement("div");
    top.className = "copiloto-live-top";
    const titulo = document.createElement("div");
    titulo.className = "copiloto-live-title";
    titulo.textContent = obtenerEtiquetaContenedor(item.cont);

    const badges = document.createElement("div");
    badges.className = "copiloto-live-badges";
    const badgeFase = document.createElement("span");
    badgeFase.className = "copiloto-badge";
    badgeFase.textContent = item.fase;
    badges.appendChild(badgeFase);

    if (item.semaforo) {
      const badgeSemaforo = document.createElement("span");
      badgeSemaforo.className = "copiloto-semaforo";
      badgeSemaforo.dataset.level = item.semaforo.nivel;
      badgeSemaforo.textContent = `${item.semaforo.emoji} ${item.semaforo.texto}`;
      badges.appendChild(badgeSemaforo);
    }

    const estadoTxt = resolverEtiquetaEstado(item.estadoFinal);
    if (estadoTxt) {
      const badgeEstado = document.createElement("span");
      badgeEstado.className = "copiloto-badge";
      badgeEstado.dataset.estado = (item.estadoFinal?.valor || "").toString().toLowerCase();
      badgeEstado.textContent = estadoTxt;
      badges.appendChild(badgeEstado);
    }

    top.appendChild(titulo);
    top.appendChild(badges);

    const meta = document.createElement("div");
    meta.className = "copiloto-live-meta";
    const densTxt = item.densidadValor != null && typeof formatearDensidad === "function"
      ? (formatearDensidad(item.densidadValor) || item.densidadValor)
      : (item.densidadValor != null ? item.densidadValor : "—");
    const tempTxt = item.temperaturaValor != null
      ? `${item.temperaturaValor.toFixed(1)}°C`
      : "—";
    meta.innerHTML = `
      <span>Última densidad: <strong>${densTxt}</strong></span>
      <span>Última temp: <strong>${tempTxt}</strong></span>
      <span>Última acción: <strong>${formatearTiempoRelativo(item.ultimoMs)}</strong></span>
    `;

    const acciones = document.createElement("div");
    acciones.className = "copiloto-live-actions";

    const btnExpress = document.createElement("button");
    btnExpress.type = "button";
    btnExpress.className = "small-btn copiloto-action-express";
    btnExpress.textContent = "Express";
    btnExpress.addEventListener("click", () => {
      const fab = document.getElementById("express-fab");
      if (fab) fab.click();
    });

    const btnBitacora = document.createElement("button");
    btnBitacora.type = "button";
    btnBitacora.className = "small-btn";
    btnBitacora.textContent = "Bitácora";
    btnBitacora.addEventListener("click", () => {
      if (typeof window.abrirModalBitacora === "function") {
        window.abrirModalBitacora({
          contenedorTipo: item.cont.tipo,
          contenedorId: item.cont.id,
          nombre: obtenerEtiquetaContenedor(item.cont),
        });
      }
    });

    const btnEditar = document.createElement("button");
    btnEditar.type = "button";
    btnEditar.className = "small-btn";
    btnEditar.textContent = "Editar";
    btnEditar.addEventListener("click", () => {
      if (item.cont.tipo === "barrica") {
        if (typeof editarBarricaDatos === "function") editarBarricaDatos(item.cont.id);
      } else if (typeof editarDepositoDatos === "function") {
        editarDepositoDatos(item.cont.id);
      }
    });

    acciones.appendChild(btnExpress);
    acciones.appendChild(btnBitacora);
    acciones.appendChild(btnEditar);

    card.appendChild(top);
    card.appendChild(meta);
    card.appendChild(acciones);
    contenedor.appendChild(card);
  });
}

function renderCopilotoActividad(eventos) {
  const contenedor = document.getElementById("copilotoActividad");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const lista = Array.isArray(eventos) ? eventos.slice(0, 15) : [];
  if (!lista.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin actividad reciente."));
    return;
  }
  lista.forEach(evento => {
    const item = document.createElement("div");
    item.className = "copiloto-activity-item";
    const contTipo = (evento.contenedor_tipo || "").toString().toLowerCase();
    const contId = Number(evento.contenedor_id);
    const nombre = contTipo && Number.isFinite(contId)
      ? obtenerNombreContenedorCopiloto(contTipo, contId)
      : "Contenedor";
    const accionTexto = (evento?.meta?.accion_texto || "").toString().trim();
    const accion = accionTexto || formatearAccionEvento(evento?.meta?.accion || evento?.tipo);
    const estadoMeta = extraerEstadoMetaCopiloto(evento?.meta);
    const estadoTxt = resolverEtiquetaEstado(estadoMeta);
    const origenRaw = (evento.origen || "manual").toString().toLowerCase();
    const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
    const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);

    const meta = document.createElement("div");
    meta.className = "copiloto-activity-meta";
    meta.innerHTML = `
      <span>${formatearTiempoRelativo(fechaMs)}</span>
      <span>${nombre}</span>
    `;

    const badgeOrigen = document.createElement("span");
    badgeOrigen.className = "copiloto-badge";
    badgeOrigen.dataset.origen = origen;
    badgeOrigen.textContent = origen === "express" ? "Express" : origen === "control" ? "Control" : "Manual";
    meta.appendChild(badgeOrigen);

    if (estadoTxt) {
      const badgeEstado = document.createElement("span");
      badgeEstado.className = "copiloto-badge";
      badgeEstado.dataset.estado = (estadoMeta?.valor || "").toString().toLowerCase();
      badgeEstado.textContent = estadoTxt;
      meta.appendChild(badgeEstado);
    }

    const titulo = document.createElement("div");
    titulo.className = "copiloto-activity-title";
    titulo.textContent = `${accion} · ${evento.resumen || "Evento"}`;

    item.appendChild(meta);
    item.appendChild(titulo);

    if (evento.detalle) {
      const desc = document.createElement("div");
      desc.style.fontSize = "12px";
      desc.style.opacity = "0.78";
      desc.textContent = evento.detalle;
      item.appendChild(desc);
    }
    const variables = construirLineaVariablesCopiloto(evento?.meta);
    if (variables) {
      const vars = document.createElement("div");
      vars.style.fontSize = "12px";
      vars.style.opacity = "0.7";
      vars.textContent = variables;
      item.appendChild(vars);
    }

    item.addEventListener("click", () => {
      if (typeof window.abrirModalBitacora === "function" && contTipo && Number.isFinite(contId)) {
        window.abrirModalBitacora({
          contenedorTipo: contTipo,
          contenedorId: contId,
          nombre,
        });
      }
    });

    contenedor.appendChild(item);
  });
}

function obtenerEventosOrdenadosCopiloto(eventos) {
  const lista = Array.isArray(eventos) ? [...eventos] : [];
  return lista.sort((a, b) => {
    const aMs = parseFechaMs(a?.fecha_hora || a?.fecha) || 0;
    const bMs = parseFechaMs(b?.fecha_hora || b?.fecha) || 0;
    return bMs - aMs;
  });
}

function setCopilotoFiltroDia(clave, eventos) {
  copilotoFiltroDia = clave || null;
  resetearVisibilidadTimeline();
  const lista = Array.isArray(eventos) ? eventos : (Array.isArray(copilotoEventosCache) ? copilotoEventosCache : []);
  renderCopilotoHeatmap(lista);
  renderCopilotoTimeline(lista);
}

function renderCopilotoHeatmap(eventos) {
  const contenedor = document.getElementById("copilotoHeatmap");
  if (!contenedor) return;
  contenedor.innerHTML = "";

  const label = document.getElementById("copilotoHeatmapLabel");
  const btnClear = document.getElementById("copilotoHeatmapClear");
  const lista = Array.isArray(eventos) ? eventos : [];
  const conteos = {};
  lista.forEach(evento => {
    const ms = parseFechaMs(evento?.fecha_hora || evento?.fecha);
    const clave = obtenerClaveDiaLocal(ms);
    if (!clave) return;
    conteos[clave] = (conteos[clave] || 0) + 1;
  });

  const hoy = new Date();
  const dias = [];
  for (let i = COPILOTO_HEATMAP_DIAS - 1; i >= 0; i -= 1) {
    const fecha = new Date(hoy);
    fecha.setDate(hoy.getDate() - i);
    const ms = fecha.getTime();
    const clave = obtenerClaveDiaLocal(ms);
    dias.push({ clave, ms, count: conteos[clave] || 0 });
  }
  const max = dias.reduce((acc, dia) => Math.max(acc, dia.count), 0);

  dias.forEach(dia => {
    const cell = document.createElement("button");
    cell.type = "button";
    cell.className = "copiloto-heatmap-cell";
    if (dia.count > 0) {
      let nivel = max <= 1 ? 1 : Math.ceil((dia.count / max) * 4);
      nivel = Math.min(4, Math.max(1, nivel));
      cell.classList.add(`heat-${nivel}`);
    }
    if (copilotoFiltroDia && dia.clave === copilotoFiltroDia) {
      cell.classList.add("is-selected");
    }
    cell.title = `${formatearDiaLargo(dia.ms)} · ${dia.count} eventos`;
    cell.addEventListener("click", () => setCopilotoFiltroDia(dia.clave, eventos));
    contenedor.appendChild(cell);
  });

  if (label) {
    if (copilotoFiltroDia) {
      const msFiltro = parseClaveDiaLocal(copilotoFiltroDia);
      label.textContent = msFiltro ? `Filtrando: ${formatearDiaCorto(msFiltro)}` : "Filtrando";
    } else {
      label.textContent = `Últimos ${COPILOTO_HEATMAP_DIAS} días`;
    }
  }
  if (btnClear) {
    btnClear.disabled = !copilotoFiltroDia;
  }
}

function renderCopilotoTimeline(eventos) {
  const contenedor = document.getElementById("copilotoTimeline");
  if (!contenedor) return;
  contenedor.innerHTML = "";

  const info = document.getElementById("copilotoTimelineInfo");
  const footer = document.getElementById("copilotoTimelineFooter");
  const countEl = document.getElementById("copilotoTimelineCount");
  const btnMas = document.getElementById("copilotoTimelineMas");
  const ordenados = obtenerEventosOrdenadosCopiloto(eventos);
  const filtros = obtenerFiltrosTimeline();
  let filtrados = ordenados;

  if (filtros.contenedor) {
    const [tipo, idRaw] = filtros.contenedor.split(":");
    const id = Number(idRaw);
    filtrados = filtrados.filter(ev => {
      const evTipo = (ev.contenedor_tipo || "").toString().toLowerCase();
      const evId = Number(ev.contenedor_id);
      return evTipo === tipo && Number.isFinite(evId) && evId === id;
    });
  }

  if (filtros.origen !== "todos") {
    filtrados = filtrados.filter(ev => {
      const origenRaw = (ev.origen || "manual").toString().toLowerCase();
      const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
      return origen === filtros.origen;
    });
  }

  if (filtros.accion) {
    filtrados = filtrados.filter(ev => obtenerAccionEventoCopiloto(ev).key === filtros.accion);
  }

  if (filtros.buscar) {
    filtrados = filtrados.filter(ev => {
      const contTipo = (ev.contenedor_tipo || "").toString().toLowerCase();
      const contId = Number(ev.contenedor_id);
      const nombre = contTipo && Number.isFinite(contId)
        ? obtenerNombreContenedorCopiloto(contTipo, contId)
        : "Contenedor";
      const { label } = obtenerAccionEventoCopiloto(ev);
      const resumen = (ev.resumen || "").toString().trim();
      const detalle = (ev.detalle || "").toString().trim();
      const variables = construirLineaVariablesCopiloto(ev?.meta);
      const texto = [label, resumen, detalle, variables, nombre, contTipo]
        .filter(Boolean)
        .join(" ")
        .toLowerCase();
      return texto.includes(filtros.buscar);
    });
  }

  if (copilotoFiltroDia) {
    filtrados = filtrados.filter(ev =>
      obtenerClaveDiaLocal(parseFechaMs(ev?.fecha_hora || ev?.fecha)) === copilotoFiltroDia
    );
  }

  const maximo = Math.min(COPILOTO_TIMELINE_LIMIT, filtrados.length);
  const visible = Math.min(copilotoTimelineVisible, maximo);
  const lista = filtrados.slice(0, visible);

  if (info) {
    if (copilotoFiltroDia) {
      const msFiltro = parseClaveDiaLocal(copilotoFiltroDia);
      const label = msFiltro ? resolverEtiquetaDiaTimeline(msFiltro) : "este día";
      info.textContent = `Eventos de ${label} · ${filtrados.length}`;
    } else {
      info.textContent = `Mostrando ${lista.length} de ${filtrados.length}`;
    }
  }

  if (footer && countEl) {
    const hayMas = filtrados.length > lista.length;
    footer.style.display = hayMas ? "flex" : "none";
    countEl.textContent = `Mostrando ${lista.length} de ${filtrados.length}`;
    if (btnMas) btnMas.disabled = !hayMas;
  }

  if (!lista.length) {
    const mensaje = copilotoFiltroDia ? "Sin eventos en este día." : "Sin eventos todavía.";
    contenedor.appendChild(crearElementoCopilotoEmpty(mensaje));
    return;
  }

  const grupos = [];
  let actual = null;
  lista.forEach(evento => {
    const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);
    const clave = obtenerClaveDiaLocal(fechaMs) || "sin-fecha";
    if (!actual || actual.clave !== clave) {
      actual = { clave, ms: fechaMs, eventos: [] };
      grupos.push(actual);
    }
    actual.eventos.push(evento);
  });

  grupos.forEach(grupo => {
    const bloque = document.createElement("div");
    bloque.className = "copiloto-timeline-day";
    const tituloDia = document.createElement("div");
    tituloDia.className = "copiloto-timeline-day-title";
    tituloDia.textContent = resolverEtiquetaDiaTimeline(grupo.ms);
    bloque.appendChild(tituloDia);

    grupo.eventos.forEach(evento => {
      const contTipo = (evento.contenedor_tipo || "").toString().toLowerCase();
      const contId = Number(evento.contenedor_id);
      const nombre = contTipo && Number.isFinite(contId)
        ? obtenerNombreContenedorCopiloto(contTipo, contId)
        : "Contenedor";
      const tipoLabel =
        contTipo === "barrica"
          ? "Barrica"
          : contTipo === "mastelone"
          ? "Mastelone"
          : contTipo
          ? "Depósito"
          : "Contenedor";
      const { label: accionLabel } = obtenerAccionEventoCopiloto(evento);
      const accion = accionLabel || "Evento";
      const resumen = (evento.resumen || "").toString().trim();
      const detalle = (evento.detalle || "").toString().trim();
      const fechaMs = parseFechaMs(evento.fecha_hora || evento.fecha);
      const estadoMeta = extraerEstadoMetaCopiloto(evento?.meta);
      const estadoTxt = resolverEtiquetaEstado(estadoMeta);
      const origenRaw = (evento.origen || "manual").toString().toLowerCase();
      const origen = origenRaw === "express" ? "express" : origenRaw === "control" ? "control" : "manual";
      const variables = construirLineaVariablesCopiloto(evento?.meta);

      const card = document.createElement("div");
      card.className = "copiloto-timeline-card";

      const top = document.createElement("div");
      top.className = "copiloto-card-top";

      const hora = document.createElement("div");
      hora.className = "copiloto-card-time";
      hora.textContent = formatearHoraCorta(fechaMs);

      const main = document.createElement("div");
      main.className = "copiloto-card-main";

      const meta = document.createElement("div");
      meta.className = "copiloto-card-meta";
      const nombreEl = document.createElement("span");
      nombreEl.textContent = nombre;
      meta.appendChild(nombreEl);

      const badgeTipo = document.createElement("span");
      badgeTipo.className = "copiloto-badge";
      badgeTipo.textContent = tipoLabel;
      meta.appendChild(badgeTipo);

      const badgeOrigen = document.createElement("span");
      badgeOrigen.className = "copiloto-badge";
      badgeOrigen.dataset.origen = origen;
      badgeOrigen.textContent = origen === "express" ? "Express" : origen === "control" ? "Control" : "Manual";
      meta.appendChild(badgeOrigen);

      if (estadoTxt) {
        const badgeEstado = document.createElement("span");
        badgeEstado.className = "copiloto-badge";
        badgeEstado.dataset.estado = (estadoMeta?.valor || "").toString().toLowerCase();
        badgeEstado.textContent = estadoTxt;
        meta.appendChild(badgeEstado);
      }

      const titulo = document.createElement("div");
      titulo.className = "copiloto-card-title";
      titulo.textContent = accion;

      main.appendChild(meta);
      main.appendChild(titulo);

      const subline = variables || (resumen && resumen !== accion ? resumen : "");
      if (subline) {
        const sub = document.createElement("div");
        sub.className = "copiloto-card-sub";
        sub.textContent = subline;
        main.appendChild(sub);
      }

      let notaTexto = detalle;
      if (!notaTexto && resumen && resumen !== accion && subline !== resumen) {
        notaTexto = resumen;
      }

      let notaEl = null;
      let btnExpandir = null;
      if (notaTexto) {
        notaEl = document.createElement("div");
        notaEl.className = "copiloto-card-note";
        notaEl.textContent = notaTexto;
        main.appendChild(notaEl);
        if (notaTexto.length > 140) {
          btnExpandir = document.createElement("button");
          btnExpandir.type = "button";
          btnExpandir.className = "small-btn";
          btnExpandir.textContent = "Ver más";
          btnExpandir.addEventListener("click", ev => {
            ev.stopPropagation();
            notaEl.classList.toggle("is-expanded");
            btnExpandir.textContent = notaEl.classList.contains("is-expanded") ? "Ver menos" : "Ver más";
          });
        }
      }

      top.appendChild(hora);
      top.appendChild(main);
      card.appendChild(top);

      const acciones = document.createElement("div");
      acciones.className = "copiloto-card-actions";
      const enlace = document.createElement("button");
      enlace.type = "button";
      enlace.className = "small-btn";
      enlace.textContent = "Ver en bitácora";
      const abrirBitacora = () => {
        if (typeof window.abrirModalBitacora === "function" && contTipo && Number.isFinite(contId)) {
          window.abrirModalBitacora({
            contenedorTipo: contTipo,
            contenedorId: contId,
            nombre,
          });
        }
      };
      enlace.addEventListener("click", ev => {
        ev.stopPropagation();
        abrirBitacora();
      });

      if (btnExpandir) acciones.appendChild(btnExpandir);
      acciones.appendChild(enlace);
      card.appendChild(acciones);

      card.addEventListener("click", abrirBitacora);
      bloque.appendChild(card);
    });

    contenedor.appendChild(bloque);
  });
}

function renderCopilotoAlertas(alertas) {
  const contenedor = document.getElementById("copilotoAlertas");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  if (!alertas.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin alertas activas."));
    return;
  }
  alertas.forEach(alerta => {
    const card = document.createElement("div");
    card.className = "copiloto-alert";
    card.dataset.level = alerta.level || "baja";

    const title = document.createElement("div");
    title.className = "copiloto-alert-title";
    const titulo = document.createElement("span");
    titulo.textContent = alerta.titulo || "Alerta";
    const meta = document.createElement("span");
    meta.className = "copiloto-alert-meta";
    meta.textContent = alerta.contenedor?.etiqueta || "";
    title.appendChild(titulo);
    title.appendChild(meta);

    const mensaje = document.createElement("div");
    mensaje.className = "copiloto-alert-meta";
    mensaje.textContent = alerta.mensaje || "";

    card.appendChild(title);
    card.appendChild(mensaje);

    if (alerta.acciones && alerta.acciones.length) {
      const acciones = document.createElement("div");
      acciones.className = "copiloto-alert-actions";
      alerta.acciones.forEach(accion => {
        const chip = document.createElement("span");
        chip.className = "copiloto-chip";
        chip.textContent = accion;
        acciones.appendChild(chip);
      });
      card.appendChild(acciones);
    }

    const botones = document.createElement("div");
    botones.className = "copiloto-alert-actions";

    if (alerta.contenedor) {
      const verBtn = document.createElement("button");
      verBtn.className = "small-btn";
      verBtn.type = "button";
      verBtn.textContent = "Ver contenedor";
      verBtn.addEventListener("click", () => irAlContenedor(alerta.contenedor));
      botones.appendChild(verBtn);
    }

    const ignoreBtn = document.createElement("button");
    ignoreBtn.className = "small-btn";
    ignoreBtn.type = "button";
    ignoreBtn.textContent = `Ignorar ${COPILOTO_SNOOZE_HOURS}h`;
    ignoreBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.snoozed[alerta.id] = Date.now() + COPILOTO_SNOOZE_HOURS * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    botones.appendChild(ignoreBtn);

    const doneBtn = document.createElement("button");
    doneBtn.className = "small-btn";
    doneBtn.type = "button";
    doneBtn.textContent = "Hecho";
    doneBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.done[alerta.id] = Date.now() + COPILOTO_DONE_DAYS * 24 * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    botones.appendChild(doneBtn);

    card.appendChild(botones);
    contenedor.appendChild(card);
  });
}

function renderCopilotoTareas(tareas) {
  const contenedor = document.getElementById("copilotoTareas");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const filtradas = (tareas || []).filter(t => !(copilotoConfig?.modoExperto && t.basica));
  if (!filtradas.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin tareas pendientes."));
    return;
  }
  filtradas.forEach(tarea => {
    const row = document.createElement("div");
    row.className = "copiloto-task";
    const info = document.createElement("div");
    const titulo = document.createElement("div");
    titulo.textContent = tarea.texto;
    info.appendChild(titulo);
    if (tarea.contenedor?.etiqueta) {
      const small = document.createElement("small");
      small.textContent = tarea.contenedor.etiqueta;
      info.appendChild(small);
    }
    const doneBtn = document.createElement("button");
    doneBtn.className = "small-btn";
    doneBtn.type = "button";
    doneBtn.textContent = "Hecho";
    doneBtn.addEventListener("click", () => {
      if (!copilotoState) cargarEstadoCopiloto();
      copilotoState.done[tarea.id] = Date.now() + COPILOTO_DONE_DAYS * 24 * 60 * 60 * 1000;
      guardarEstadoCopiloto();
      actualizarCopiloto();
    });
    row.appendChild(info);
    row.appendChild(doneBtn);
    contenedor.appendChild(row);
  });
}

function renderCopilotoFeed(alertas) {
  const contenedor = document.getElementById("copilotoFeed");
  if (!contenedor) return;
  contenedor.innerHTML = "";
  const items = (alertas || [])
    .filter(a => !(copilotoConfig?.modoExperto && a.basica))
    .slice(0, 4);
  if (!items.length) {
    contenedor.appendChild(crearElementoCopilotoEmpty("Sin novedades críticas."));
    return;
  }
  items.forEach(alerta => {
    const item = document.createElement("div");
    item.className = "copiloto-feed-item";
    item.textContent = alerta.feed || alerta.mensaje || "Actualización del copiloto.";
    contenedor.appendChild(item);
  });
}

function esFermentacionActiva(contenedor, analiticos = []) {
  if (!contenedor || contenedor.tipo === "barrica") return false;
  const fase = obtenerFaseContenedor(contenedor);
  if (fase === "Fermentación" || fase === "Maloláctica") return true;
  const registro = analiticos.find(r => r.densidad != null);
  const ms = parseFechaMs(registro?.fecha_hora || registro?.fecha);
  const horas = horasEntre(ms);
  return horas != null && horas <= 120;
}

function esCrianzaActiva(contenedor) {
  if (!contenedor) return false;
  if (contenedor.tipo === "barrica") return true;
  return obtenerFaseContenedor(contenedor) === "Crianza";
}

function renderCopiloto(alertas, tareas, data = {}) {
  renderCopilotoAlertas(alertas);
  renderCopilotoTareas(tareas);
  renderCopilotoVivo(data.contenedores || [], data.analiticosMap || new Map(), data.eventosMap || new Map());
  const eventos = Array.isArray(data.eventos)
    ? data.eventos
    : (Array.isArray(copilotoEventosCache) ? copilotoEventosCache : []);
  actualizarOpcionesAccionTimeline(eventos);
  renderCopilotoActividad(eventos);
  renderCopilotoTimeline(eventos);
  renderCopilotoHeatmap(eventos);
  poblarSelectCopilotoNotaContenedores();
  poblarSelectCopilotoTimelineContenedores();
  const estado = document.getElementById("copilotoEstado");
  const actualizado = document.getElementById("copilotoActualizado");
  const pendientes = document.getElementById("copilotoPendientes");
  const fechaEl = document.getElementById("copilotoFecha");
  const campaniaEl = document.getElementById("copilotoCampania");
  const fermentacionesEl = document.getElementById("copilotoFermentaciones");
  const crianzaEl = document.getElementById("copilotoCrianza");
  const niveles = alertas.map(a => a.level);
  const nivelMax = niveles.includes("alta")
    ? "En guardia"
    : niveles.includes("media")
    ? "En vigilancia"
    : niveles.includes("baja")
    ? "En calma"
    : "Sin riesgos";
  if (estado) estado.textContent = `Estado: ${nivelMax}`;
  if (pendientes) pendientes.textContent = `${alertas.length} alertas activas`;
  if (actualizado) {
    const ahora = new Date();
    actualizado.textContent = `Última lectura: ${ahora.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })}`;
  }
  if (fechaEl) {
    fechaEl.textContent = new Date().toLocaleDateString("es-ES", {
      weekday: "long",
      day: "2-digit",
      month: "short",
    });
  }
  if (campaniaEl) {
    const anio = new Date().getFullYear();
    campaniaEl.textContent = `Campaña ${anio}`;
  }
  const contenedores = Array.isArray(data.contenedores) ? data.contenedores : [];
  const analiticosMap = data.analiticosMap || new Map();
  const fermentaciones = contenedores.filter(cont => esFermentacionActiva(cont, analiticosMap.get(`${cont.tipo}:${cont.id}`) || []));
  const crianzas = contenedores.filter(cont => esCrianzaActiva(cont));
  if (fermentacionesEl) fermentacionesEl.textContent = `Fermentaciones activas: ${fermentaciones.length}`;
  if (crianzaEl) crianzaEl.textContent = `Contenedores en crianza: ${crianzas.length}`;
}

function notificarAlertasCopiloto(alertas) {
  if (!copilotoState) cargarEstadoCopiloto();
  const ahora = Date.now();
  alertas.forEach(alerta => {
    if (alerta.level !== "alta") return;
    if (copilotoState.seen?.[alerta.id]) return;
    mostrarAviso(alerta.mensaje, "error");
    if (
      copilotoConfig?.notificaciones &&
      "Notification" in window &&
      Notification.permission === "granted"
    ) {
      try {
        new Notification(`Copiloto: ${alerta.titulo}`, {
          body: alerta.mensaje,
          tag: alerta.id,
        });
      } catch (e) {
        // noop
      }
    }
    copilotoState.seen[alerta.id] = ahora;
  });
  guardarEstadoCopiloto();
}

async function actualizarCopiloto(forzar = false) {
  const contenedorAlertas = document.getElementById("copilotoAlertas");
  if (!contenedorAlertas) return;
  if (copilotoEnProgreso) return;
  copilotoEnProgreso = true;
  if (!copilotoConfig) cargarConfigCopiloto();
  if (!copilotoState) cargarEstadoCopiloto();
  const contenedores = obtenerContenedoresCopiloto();
  try {
    const analiticosMap = new Map();
    if (contenedores.length) {
      await Promise.all(
        contenedores.map(async cont => {
          const registros = await obtenerAnaliticosCopiloto(cont.tipo, cont.id, forzar);
          analiticosMap.set(`${cont.tipo}:${cont.id}`, registros);
        })
      );
    }
    const alertas = [];
    contenedores.forEach(cont => {
      const analiticos = analiticosMap.get(`${cont.tipo}:${cont.id}`) || [];
      const movimientos = obtenerMovimientosContenedor(cont.tipo, cont.id);
      [
        reglaFermentacionEstancada(cont, analiticos, copilotoConfig),
        reglaOxidacion(cont, movimientos, copilotoConfig),
        reglaTemperaturaAlta(cont, analiticos, copilotoConfig),
        reglaAnaliticaPendiente(cont, analiticos, copilotoConfig),
      ]
        .filter(Boolean)
        .forEach(alerta => alertas.push(alerta));
    });
    const ordenadas = ordenarAlertasCopiloto(alertas);
    const filtradas = filtrarAlertasCopiloto(ordenadas);
    const tareas = generarTareasCopiloto(filtradas);
    const eventos = await obtenerEventosBitacoraRecientes(forzar);
    const eventosMap = mapearEventosPorContenedor(eventos);
    renderCopiloto(filtradas, tareas, {
      contenedores,
      analiticosMap,
      eventos,
      eventosMap,
    });
    notificarAlertasCopiloto(filtradas);
  } finally {
    copilotoEnProgreso = false;
  }
}

function obtenerAnadaDesdeFecha(fechaStr) {
  if (!fechaStr) return "";
  const match = fechaStr.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function obtenerValorAnada(valor) {
  if (!valor) return "Sin añada";
  return valor.toString();
}

function coincideConFiltros(anadaVal, vinoVal, filtros) {
  const anadaComparar = obtenerValorAnada(anadaVal);
  const vinoComparar = (vinoVal || "").trim() || "Sin clasificar";
  const okAnada = filtros.anada === "todos" || filtros.anada === anadaComparar;
  const okVino = filtros.vino === "todos" || vinoComparar === filtros.vino;
  return okAnada && okVino;
}

function obtenerInfoContenedor(tipo, id) {
  if (tipo === "deposito") {
    return mapaDepositosPorId && mapaDepositosPorId.get(id);
  }
  if (tipo === "mastelone") {
    return mapaMastelonesPorId && mapaMastelonesPorId.get(id);
  }
  if (tipo === "barrica") {
    return mapaBarricasPorId && mapaBarricasPorId.get(id);
  }
  return null;
}

function obtenerCapacidadFormateada(info) {
  if (!info) return "";
  const capacidad =
    info.capacidad_l != null
      ? Number(info.capacidad_l)
      : info.capacidad_hl != null
      ? Number(info.capacidad_hl) * 100
      : null;
  if (!Number.isFinite(capacidad) || capacidad <= 0) return "";
  return capacidad % 1 === 0 ? capacidad.toFixed(0) : capacidad.toFixed(2);
}

function describirContenedor(info, tipoLabel) {
  const partes = [];
  if (tipoLabel) partes.push(tipoLabel);
  if (info) {
    const cap = obtenerCapacidadFormateada(info);
    if (cap) partes.push(cap);
    const material =
      info.material ||
      info.tipo_roble ||
      info.tipo ||
      info.marca ||
      info.clase ||
      "";
    if (material) partes.push(material);
  }
  return partes.join(" ").trim();
}

function parsearFechaValor(valor) {
  if (!valor) return null;
  let base = valor.trim();
  if (!base) return null;
  if (base.includes("/")) {
    const partes = base.split("/");
    if (partes.length === 3) {
      // dd/mm/yyyy -> yyyy-mm-dd
      base = `${partes[2]}-${partes[1].padStart(2, "0")}-${partes[0].padStart(2, "0")}`;
    }
  }
  const fecha = new Date(base);
  return isNaN(fecha.getTime()) ? null : fecha;
}

function calcularMesesEntre(fechaInicio, fechaFin) {
  const inicio = parsearFechaValor(fechaInicio);
  const fin = parsearFechaValor(fechaFin);
  if (!inicio || !fin) return null;
  let meses = (fin.getFullYear() - inicio.getFullYear()) * 12 + (fin.getMonth() - inicio.getMonth());
  if (fin.getDate() < inicio.getDate()) {
    meses -= 1;
  }
  if (meses < 0) meses = 0;
  return meses;
}

function actualizarDuracionPrevista(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const inicio = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const fin = nodo.datos?.tiempo;
  if (!inicio || !fin) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  const meses = calcularMesesEntre(inicio, fin);
  if (meses == null) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  nodo.datos.tiempo_estimado = meses === 1 ? "1 mes" : `${meses} meses`;
}

function refrescarDuracionModal(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  actualizarDuracionPrevista(nodo);
  const display = document.getElementById("flowField-tiempo_estimado-display");
  if (display) {
    display.textContent = nodo.datos?.tiempo_estimado || "—";
  }
  const hidden = document.getElementById("flowField-tiempo_estimado");
  if (hidden) {
    hidden.value = nodo.datos?.tiempo_estimado || "";
  }
}

function obtenerVinosEntrada(entrada) {
  const vinos = new Set();
  if (Array.isArray(entrada.destinos)) {
    entrada.destinos.forEach(dest => {
      const info = obtenerInfoContenedor(dest.contenedor_tipo, dest.contenedor_id);
      if (info && info.vino_tipo) {
        vinos.add(info.vino_tipo);
      }
    });
  }
  if (!vinos.size && entrada.variedad) {
    vinos.add(entrada.variedad);
  }
  return vinos;
}

function calcularDatosMapaFlujo() {
  const resultado = {
    entrada: { valor: 0, detalle: "" },
    despalillado: { valor: 0, detalle: "" },
    deposito: { valor: 0, detalle: "" },
    barrica: { valor: 0, detalle: "" },
    embotellado: { valor: 0, detalle: "" },
    salida: { valor: 0, detalle: "" },
  };

  const entradas = cacheEntradas || [];
  resultado.entrada.valor = entradas.reduce((acc, e) => {
    const volumen = getVolumenFromDatos(e);
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.entrada.detalle = `${entradas.length} entradas registradas`;

  let volumenDesp = 0;
  entradas.forEach(entrada => {
    if (Array.isArray(entrada.destinos) && entrada.destinos.length) {
      entrada.destinos.forEach(dest => {
        const volumen = getVolumenFromDatos(dest);
        if (Number.isFinite(volumen)) volumenDesp += volumen;
      });
    } else {
      const volumen = getVolumenFromDatos(entrada);
      if (Number.isFinite(volumen)) volumenDesp += volumen;
    }
  });
  resultado.despalillado.valor = volumenDesp;
  resultado.despalillado.detalle = "Estimación tras despalillado / prensado";

  const depositos = (cacheDepositos || []).concat(cacheMastelones || []);
  resultado.deposito.valor = depositos.reduce((acc, d) => {
    const volumen = getVolumenFromDatos({
      volumen: d.volumen,
      litros: d.litros_actuales,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.deposito.detalle = `${depositos.length} depósitos / mastelones`;

  const barricas = cacheBarricas || [];
  resultado.barrica.valor = barricas.reduce((acc, b) => {
    const volumen = getVolumenFromDatos({
      volumen: b.volumen,
      litros: b.litros_actuales,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.barrica.detalle = `${barricas.length} barricas activas`;

  const embotellados = cacheEmbotellados || [];
  resultado.embotellado.valor = embotellados.reduce((acc, e) => {
    const volumen = getVolumenFromDatos({
      volumen: e.volumen,
      litros: e.litros,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.embotellado.detalle = `${embotellados.length} lotes embotellados`;

  const salidas = (cacheMovimientos || []).filter(m => {
    const tipo = (m.tipo || "").toLowerCase();
    return tipo === "venta" || tipo === "salida" || tipo === "expedicion" || m.destino_tipo === "venta";
  });
  resultado.salida.valor = salidas.reduce((acc, m) => {
    const volumen = getVolumenFromDatos({
      volumen: m.volumen,
      litros: m.litros,
    });
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
  resultado.salida.detalle = `${salidas.length} movimientos de salida`;

  return resultado;
}

function actualizarMapaFlujo() {
  datosEtapasFlujo = calcularDatosMapaFlujo();
}

function limitarZoomFlow(valor) {
  const num = Number(valor);
  if (!Number.isFinite(num)) return 1;
  return Math.min(Math.max(num, FLOW_ZOOM_MIN), FLOW_ZOOM_MAX);
}

function actualizarEtiquetaZoomFlow() {
  const label = document.getElementById("flowZoomLabel");
  if (!label) return;
  label.textContent = `${Math.round(flowZoom * 100)}%`;
}

function aplicarLayoutFlow({ mantenerCentro = false } = {}) {
  const editor = document.getElementById("flowEditor");
  const stage = document.getElementById("flowStage");
  const world = document.getElementById("flowWorld");
  if (!editor || !stage || !world) return;

  const prevZoom = flowZoom || 1;
  let centroWorld = null;
  if (mantenerCentro) {
    const cx = editor.scrollLeft + editor.clientWidth / 2;
    const cy = editor.scrollTop + editor.clientHeight / 2;
    centroWorld = { x: cx / prevZoom, y: cy / prevZoom };
  }

  flowZoom = limitarZoomFlow(flowZoom);
  world.style.width = `${FLOW_WORLD_BASE.width}px`;
  world.style.height = `${FLOW_WORLD_BASE.height}px`;
  world.style.transform = `scale(${flowZoom})`;
  stage.style.width = `${FLOW_WORLD_BASE.width * flowZoom}px`;
  stage.style.height = `${FLOW_WORLD_BASE.height * flowZoom}px`;

  if (centroWorld) {
    editor.scrollLeft = Math.max(0, centroWorld.x * flowZoom - editor.clientWidth / 2);
    editor.scrollTop = Math.max(0, centroWorld.y * flowZoom - editor.clientHeight / 2);
  }

  actualizarEtiquetaZoomFlow();
  programarActualizacionMinimapFlow();
}

function aplicarZoomMapaFlujo(nuevoZoom, { mantenerCentro = true } = {}) {
  flowZoom = limitarZoomFlow(nuevoZoom);
  aplicarLayoutFlow({ mantenerCentro });
  try {
    localStorage.setItem("flowZoom", String(flowZoom));
  } catch (err) {
    // noop
  }
  renderFlowConnections();
}

function zoomMapaFlujo(direccion) {
  const delta = Number(direccion) || 0;
  if (!delta) return;
  aplicarZoomMapaFlujo(flowZoom + delta * FLOW_ZOOM_STEP);
}

function resetZoomMapaFlujo() {
  aplicarZoomMapaFlujo(1);
}

function programarActualizacionMinimapFlow() {
  if (flowMinimapRaf) return;
  flowMinimapRaf = requestAnimationFrame(() => {
    flowMinimapRaf = null;
    actualizarMinimapFlow();
  });
}

function inicializarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const viewport = document.getElementById("flowMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("flowEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    flowMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapFlow(ev);
    world.addEventListener("pointermove", moverDesdeMinimapFlow);
    world.addEventListener("pointerup", finalizarMinimapFlow);
    world.addEventListener("pointercancel", finalizarMinimapFlow);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, editor } = flowMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / (rect.width || 1)) * (FLOW_WORLD_BASE.width || 1);
  const worldY = (relY / (rect.height || 1)) * (FLOW_WORLD_BASE.height || 1);
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, worldX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function finalizarMinimapFlow(ev) {
  if (!flowMinimapDrag || ev.pointerId !== flowMinimapDrag.pointerId) return;
  const { world, pointerId } = flowMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapFlow);
  world.removeEventListener("pointerup", finalizarMinimapFlow);
  world.removeEventListener("pointercancel", finalizarMinimapFlow);
  flowMinimapDrag = null;
}

function centrarNodoFlowEnVista(nodo) {
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!editor || !canvas) return;
  const el = Array.from(canvas.querySelectorAll(".flow-node")).find(n => n.dataset.id === nodo.id);
  const w = el ? el.offsetWidth : 160;
  const h = el ? el.offsetHeight : 110;
  const centerX = (Number(nodo.x) || 0) + w / 2;
  const centerY = (Number(nodo.y) || 0) + h / 2;
  const zoom = flowZoom || 1;
  editor.scrollLeft = Math.max(0, centerX * zoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * zoom - editor.clientHeight / 2);
  programarActualizacionMinimapFlow();
}

function actualizarMinimapFlow() {
  const world = document.getElementById("flowMinimapWorld");
  const dotsHost = document.getElementById("flowMinimapDots");
  const viewport = document.getElementById("flowMinimapViewport");
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const baseW = FLOW_WORLD_BASE.width || 1;
  const baseH = FLOW_WORLD_BASE.height || 1;
  const aspect = baseH / baseW;
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = flowZoom || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / baseW) * mmW}px`;
  viewport.style.top = `${(viewY / baseH) * mmH}px`;
  viewport.style.width = `${(viewW / baseW) * mmW}px`;
  viewport.style.height = `${(viewH / baseH) * mmH}px`;

  const nodeEls = Array.from(canvas.querySelectorAll(".flow-node"));
  dotsHost.innerHTML = "";
  nodeEls.forEach(nodeEl => {
    const id = nodeEl.dataset.id || "";
    const tipo = nodeEl.dataset.tipo || "";
    const x = parseFloat(nodeEl.style.left || "") || 0;
    const y = parseFloat(nodeEl.style.top || "") || 0;
    const cx = x + nodeEl.offsetWidth / 2;
    const cy = y + nodeEl.offsetHeight / 2;
    const px = (cx / baseW) * mmW;
    const py = (cy / baseH) * mmH;
    const dot = document.createElement("div");
    dot.className = `flow-minimap-dot ${tipo || ""}`;
    if (id && nodoSeleccionadoId && String(nodoSeleccionadoId) === String(id)) {
      dot.classList.add("seleccionado");
    }
    dot.style.left = `${px}px`;
    dot.style.top = `${py}px`;
    const nodo = id ? obtenerNodoPorId(id) : null;
    dot.title = nodo?.titulo ? nodo.titulo : tipo ? tipo : "Nodo";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!id) return;
      const nodoClick = obtenerNodoPorId(id);
      if (!nodoClick) return;
      nodoSeleccionadoId = nodoClick.id;
      renderFlowNodes();
      mostrarInfoNodo(nodoClick.id);
      requestAnimationFrame(() => centrarNodoFlowEnVista(nodoClick));
    });
    dotsHost.appendChild(dot);
  });
}

function exportarNodosComoImagen() {
  const editor = document.querySelector(".flow-editor");
  if (!editor) return;

  const descargarCanvas = canvas => {
    const data = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = data;
    link.download = "mapa-nodos.png";
    document.body.appendChild(link);
    link.click();
    link.remove();
  };

  const hacerCaptura = () => {
    if (window.html2canvas) {
      window.html2canvas(editor, {
        backgroundColor: "#0b0515",
        scale: 2,
        useCORS: true,
        logging: false,
      }).then(descargarCanvas);
      return true;
    }
    return false;
  };

  if (hacerCaptura()) return;

  // Cargar html2canvas al vuelo si no está disponible
  const script = document.createElement("script");
  script.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
  script.onload = () => hacerCaptura();
  script.onerror = () => mostrarAviso("No se pudo exportar la imagen. Intenta con otra captura.", "error");
  document.body.appendChild(script);
}

	async function inicializarFlowEditor() {
	  await cargarNodosGuardados();
	  // Recalcular el flujo tras cargar (rellena asignaciones implícitas, mezcla y volúmenes)
	  // para evitar estados inconsistentes al abrir el editor.
	  try {
	    const raices = flujoNodos.filter(n => obtenerPredecesores(n.id).length === 0);
	    raices.forEach(n => redistribuirCargas(n));
	  } catch (err) {
	    console.warn("No se pudo recalcular el flujo al iniciar:", err);
	  }
	  try {
	    const savedZoom = Number(localStorage.getItem("flowZoom"));
	    if (Number.isFinite(savedZoom)) {
	      flowZoom = savedZoom;
	    }
	  } catch (err) {
	    // noop
	  }
	  flowZoom = limitarZoomFlow(flowZoom);
	  aplicarLayoutFlow();
	  renderFlowNodes();
	  const editor = document.getElementById("flowEditor");
	  if (editor) {
	    editor.addEventListener("scroll", programarActualizacionMinimapFlow, { passive: true });
	  }
	  const canvas = document.getElementById("flowCanvas");
		  if (canvas) {
		    canvas.addEventListener("click", e => {
		      if (!e.target.closest(".flow-node")) {
		        ocultarFlowTooltip();
		        nodoSeleccionadoId = null;
	        try {
	          mostrarInfoNodo(null);
	        } catch (err) {
	          // noop
	        }
	        canvas
	          .querySelectorAll(".flow-node.is-selected")
	          .forEach(el => el.classList.remove("is-selected"));
	      }
		      cancelarConexionEnCurso();
		    });
		  }
		  window.addEventListener("resize", renderFlowConnections);
		  window.addEventListener("resize", programarActualizacionMinimapFlow);
		  try {
		    mostrarInfoNodo(null);
		  } catch (err) {
		    // noop
		  }
		  programarActualizacionMinimapFlow();
		  actualizarUIReplayFlujo();
		}

function generarIdNodo() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `nodo-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
}

function crearNodoManual(tipo) {
  try {
    console.log("Crear nodo manual", tipo, "flujoNodos len:", Array.isArray(flujoNodos) ? flujoNodos.length : flujoNodos);
    const config = FLOW_NODE_TYPES[tipo];
    if (!config) {
      console.error("Tipo de nodo desconocido", tipo);
      mostrarAviso("No se reconoce este tipo de nodo.", "error");
      return;
    }
    const nodo = {
      id: generarIdNodo(),
      tipo,
      titulo: config.label,
      x: 60 + flujoNodos.length * 40,
      y: 60 + flujoNodos.length * 20,
      datos: {},
      targets: [],
    };
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    flujoNodos.push(nodo);
    registrarAccionNodoMapa("Nodo creado", nodo, { noteType: "accion" });
    ultimoNodoManual = nodo.id;
    guardarEstadoNodos();
    console.log("Nodo creado", nodo.id, "total nodos", flujoNodos.length);
    renderFlowNodes();
    abrirFlowModal(nodo.id);
  } catch (err) {
    console.error("Error creando nodo", err);
    const msg = err && err.message ? err.message : "Error desconocido";
    mostrarAviso(`No se pudo crear el nodo: ${msg}`, "error");
  }
}

async function sembrarNodosDesdeDatos() {
  // Refrescar datos antes de sembrar
  await Promise.all([cargarResumen(), cargarDepositos(), cargarBarricas(), cargarEntradas(), cargarMovimientos()]);
  actualizarMapaFlujo();
  flujoNodos = ETAPAS_FLUJO.map((etapa, idx) => {
    const nodo = {
      id: generarIdNodo(),
      tipo:
        etapa.id === "despalillado"
          ? "estilo"
          : etapa.id === "barrica"
          ? "barrica"
          : etapa.id === "embotellado"
          ? "embotellado"
          : etapa.id === "salida"
          ? "salida"
          : etapa.id === "entrada"
          ? "entrada"
          : "deposito",
      titulo: etapa.titulo,
      x: 80 + idx * 180,
      y: 120 + (idx % 2) * 120,
      datos: {
        resumen: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].detalle
          : "",
        valor: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].valor.toLocaleString("es-ES", { maximumFractionDigits: 1 })
          : "0",
      },
      targets: [],
    };
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    return nodo;
  });
  for (let i = 0; i < flujoNodos.length - 1; i++) {
    flujoNodos[i].targets.push(flujoNodos[i + 1].id);
  }
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  guardarEstadoNodos();
  renderFlowNodes();
  registrarBitacoraMapaNodosGeneral("Mapa de nodos sembrado desde datos · mapa de nodos", "accion");
}

function cerrarMenusNodo() {
  document.querySelectorAll(".flow-node-menu.visible").forEach(menu => {
    menu.classList.remove("visible");
    const host = menu.closest(".flow-node");
    if (host) host.classList.remove("menu-open");
  });
}

// Override renderFlowNodes with a clean version (prev block had duplicated closures)

		function renderFlowNodes() {
		  const canvas = document.getElementById("flowCanvas");
		  if (!canvas) return;
		  normalizarFlujoNodos();
		  aplicarLayoutFlow();
		  canvas.innerHTML = "";
		  canvas.dataset.mode = nodoConectandoOrigen ? "connecting" : "default";
		  if (flowDebugActivo()) {
		    console.debug("[flow][render]", { nodos: flujoNodos.length });
		  }
	
	  flujoNodos.forEach(nodo => {
	    if (nodo.tipo === "entrada") {
	      rellenarDatosEntradaDesdeCache(nodo);
    } else if (nodo.tipo === "deposito") {
      rellenarDatosDepositoDesdeCache(nodo);
      actualizarTituloNodo(nodo);
    } else if (nodo.tipo === "barrica") {
      rellenarDatosCrianzaDesdeCache(nodo);
      actualizarTituloNodo(nodo);
    }
	    // Recalcular mezcla visible por si el nodo recibe varias variedades
	    const compRender = calcularComposicionVariedades(nodo);
	    if (compRender.mix.size) {
	      guardarComposicionEnNodo(nodo, compRender.mix, compRender.total);
	    }
	    if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
	      actualizarVolumenDesdeAsignaciones(nodo);
	    }

		    const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo" };
		    const div = document.createElement("div");
		    div.className = "flow-node";
		    div.dataset.tipo = nodo.tipo;
		    if (flowReplay?.activo && flowReplay.model) {
		      const nodoId = normalizarIdNodo(nodo);
		      if (!flowReplay.model.nodesSet?.has(nodoId)) {
		        div.classList.add("replay-outside");
		      } else if (!flowReplay.state?.activeNodes?.has(nodoId)) {
		        div.classList.add("replay-inactive");
		      } else {
		        const ts = flowReplay.model.nodeTs?.get(nodoId);
		        if (ts != null && flowReplay.timeMs != null && ts === flowReplay.timeMs) {
		          div.classList.add("replay-current");
		        }
		      }
		    }
	    const tooltipFlow =
	      nodo.tipo === "barrica"
	        ? obtenerTooltipCrianza(nodo)
	        : nodo.tipo === "embotellado"
	        ? obtenerTooltipEmbotellado(nodo)
	        : "";
	    if (tooltipFlow) {
	      div.title = tooltipFlow;
	      div.addEventListener("pointerenter", e => {
	        if (e.pointerType !== "mouse") return;
	        ocultarFlowTooltip();
	        mostrarFlowTooltip(tooltipFlow, e.clientX, e.clientY);
	      });
	      div.addEventListener("pointermove", e => {
	        if (e.pointerType !== "mouse") return;
	        posicionarFlowTooltip(e.clientX, e.clientY);
	      });
	      div.addEventListener("pointerleave", () => ocultarFlowTooltip());
	      div.addEventListener("pointerdown", () => ocultarFlowTooltip());
	    }
	    const nodoIdNorm = normalizarIdNodo(nodo);
	    const conectandoNorm = nodoConectandoOrigen ? normalizarIdNodo(nodoConectandoOrigen) : "";
	    const seleccionadoNorm = nodoSeleccionadoId ? normalizarIdNodo(nodoSeleccionadoId) : "";
	    if (conectandoNorm && conectandoNorm === nodoIdNorm) {
	      div.classList.add("is-connect-source");
	    }
	    if (seleccionadoNorm && seleccionadoNorm === nodoIdNorm) {
	      div.classList.add("is-selected");
	    }
	
	    const fill = document.createElement("div");
	    fill.className = "fill-level";
	    const volumenVisual = obtenerVolumenVisualNodo(nodo);
	    const barricaVacia =
	      nodo.tipo === "barrica" && volumenVisual != null && volumenVisual <= 0;
	    const colorVino = barricaVacia ? "" : obtenerColorVino(nodo);
	    if (colorVino) {
	      div.dataset.vino = colorVino;
	      fill.classList.add(
	        colorVino === "white" ? "white" : colorVino === "rosado" ? "rosado" : "red"
	      );
	    } else {
	      div.dataset.vino = "";
	    }
    const ocupacion = calcularOcupacionNodo(nodo, volumenVisual);
    if (ocupacion != null) {
      fill.style.height = `${(ocupacion * 100).toFixed(1)}%`;
    } else if (barricaVacia) {
      fill.style.height = "0%";
    }
    div.appendChild(fill);

	    const progresoBarrica = calcularProgresoBarrica(nodo);
	    if (progresoBarrica != null) {
	      const ring = document.createElement("div");
	      const pct = Math.max(0, Math.min(1, progresoBarrica));
	      const ang = pct * 360;
	      ring.className = "flow-progress-ring";
	      ring.style.background = `conic-gradient(from -90deg, var(--flow-accent, rgba(255,255,255,0.75)) 0deg ${ang}deg, rgba(255,255,255,0.08) ${ang}deg 360deg)`;
	      div.appendChild(ring);
	    }

	    div.style.left = `${nodo.x}px`;
	    div.style.top = `${nodo.y}px`;
	    div.dataset.id = nodoIdNorm;
	
	    const headerWrap = document.createElement("div");
	    headerWrap.className = "flow-node-header";
	    const icon = document.createElement("span");
	    icon.className = "flow-node-icon";
	    if (config.icono && config.icono.trim().startsWith("<")) {
	      icon.innerHTML = config.icono;
    } else {
      let iconChar = config.icono || "●";
      if (config.icono === "🍇") iconChar = "🍇";
      icon.textContent = iconChar;
    }
    headerWrap.appendChild(icon);
    if (config.icono === "🍇") {
      const badge = document.createElement("span");
      const tono = colorVino === "white" ? "white" : "red";
      badge.className = `grape-badge ${tono}`;
      badge.title = tono === "white" ? "Uva blanca" : "Uva tinta";
      headerWrap.appendChild(badge);
    }
    const header = document.createElement("h4");
    const estadoInline = obtenerEstadoVisual(nodo);
    header.textContent = nodo.titulo || config.label;
    if (estadoInline) {
      const estadoSpan = document.createElement("span");
      estadoSpan.className = "flow-state-inline";
      const separador = header.textContent ? " - " : "";
      estadoSpan.textContent = `${separador}${estadoInline.label}`;
      if (estadoInline.color) {
        estadoSpan.style.color = estadoInline.color;
      }
      header.appendChild(estadoSpan);
    }
    headerWrap.appendChild(header);
    div.appendChild(headerWrap);

    const body = document.createElement("div");
    body.className = "flow-node-body";
    const densidadNodo = nodo.tipo === "entrada" ? normalizarNumero(nodo.datos?.densidad) : null;
    const temperaturaNodo = nodo.tipo === "entrada" ? normalizarNumero(nodo.datos?.temperatura) : null;
    if (nodo.tipo === "entrada" && (densidadNodo != null || temperaturaNodo != null)) {
      const metrics = document.createElement("div");
      metrics.className = "flow-node-metrics";
      if (densidadNodo != null) {
        const chip = document.createElement("span");
        chip.className = "flow-chip";
        chip.textContent = `${formatearDensidad(densidadNodo)} dens`;
        metrics.appendChild(chip);
      }
      if (temperaturaNodo != null) {
        const chip = document.createElement("span");
        chip.className = "flow-chip";
        chip.textContent = `${temperaturaNodo.toFixed(1)}°C`;
        metrics.appendChild(chip);
      }
      body.appendChild(metrics);
    }

	    const variedadVisible = obtenerVariedadVisibleNodo(nodo);
	    if (variedadVisible) {
	      const subtitleVar = document.createElement("div");
	      subtitleVar.className = "flow-node-subtitle flow-subtitle-variedad";
	      subtitleVar.textContent = variedadVisible;
	      subtitleVar.title = variedadVisible;
	      body.appendChild(subtitleVar);
	    }

    const textoVolumen = obtenerTextoVolumenNodo(nodo);
    if (textoVolumen) {
      const volEl = document.createElement("div");
      volEl.className = "flow-node-subtitle";
      volEl.textContent = textoVolumen;
      body.appendChild(volEl);
    } else {
      const unidadBadge = document.createElement("div");
      unidadBadge.className = "flow-unit";
      unidadBadge.textContent = obtenerUnidadVisual(nodo);
      body.appendChild(unidadBadge);
    }
    if (nodo.tipo !== "entrada") {
      const historico = obtenerHistoricoNodo(nodo);
      const historicoNum = Number.isFinite(historico) ? Number(historico.toFixed(0)) : 0;
      const histEl = document.createElement("div");
      histEl.className = "flow-node-subtitle";
      histEl.textContent = `Histórico ${historicoNum}`;
      body.appendChild(histEl);
    }

    div.appendChild(body);

    if (nodo.tipo === "estilo" && nodo.datos?.metodo) {
      const metodoSubtitle = document.createElement("div");
      metodoSubtitle.className = "flow-node-subtitle flow-node-metodo";
      metodoSubtitle.textContent = nodo.datos.metodo;
      div.appendChild(metodoSubtitle);
    }

    const controls = document.createElement("div");
    controls.className = "flow-node-controls";
    const btnEditar = document.createElement("button");
    btnEditar.className = "blue";
    btnEditar.title = "Editar";
    btnEditar.addEventListener("pointerdown", e => e.stopPropagation());
    btnEditar.addEventListener("click", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });
    const btnConectar = document.createElement("button");
    btnConectar.className = `green ${conectandoNorm === nodoIdNorm ? "conectando" : ""}`;
    btnConectar.title = "Conectar";
    if (conectandoNorm === nodoIdNorm) btnConectar.classList.add("conectando");
    btnConectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnConectar.addEventListener("click", e => {
      e.stopPropagation();
      prepararConexion(nodo.id);
    });
    const btnDesconectar = document.createElement("button");
    btnDesconectar.className = "red";
    btnDesconectar.title = "Desconectar";
    btnDesconectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnDesconectar.addEventListener("click", e => {
      e.stopPropagation();
      if (!nodo._clickDesconectar) {
        desconectarNodo(nodo.id);
        nodo._clickDesconectar = Date.now();
        mostrarAviso("Pulsa de nuevo rápidamente para eliminar el nodo.", "info");
        setTimeout(() => {
          if (nodo._clickDesconectar && Date.now() - nodo._clickDesconectar > 800) delete nodo._clickDesconectar;
        }, 900);
      } else if (Date.now() - nodo._clickDesconectar < 800) {
        delete nodo._clickDesconectar;
        eliminarNodoPorId(nodo.id);
      } else {
        nodo._clickDesconectar = Date.now();
      }
    });
    controls.appendChild(btnEditar);
    controls.appendChild(btnConectar);
    controls.appendChild(btnDesconectar);

    const esContenedorAccion = nodo.tipo === "deposito" || nodo.tipo === "barrica";
    if (esContenedorAccion) {
      const menu = document.createElement("div");
      menu.className = "flow-node-menu";
      menu.addEventListener("pointerdown", e => e.stopPropagation());
      menu.addEventListener("click", e => e.stopPropagation());

      const btnControl = document.createElement("button");
      btnControl.type = "button";
      btnControl.textContent = "Control";
      btnControl.addEventListener("click", e => {
        e.stopPropagation();
        cerrarMenusNodo();
        abrirFlowModal(nodo.id);
      });

      const btnBitacora = document.createElement("button");
      btnBitacora.type = "button";
      btnBitacora.textContent = "Bitácora";
      btnBitacora.addEventListener("click", e => {
        e.stopPropagation();
        cerrarMenusNodo();
        abrirBitacoraDesdeNodo(nodo);
      });

      const btnCuaderno = document.createElement("button");
      btnCuaderno.type = "button";
      btnCuaderno.textContent = "Cuaderno";
      btnCuaderno.addEventListener("click", e => {
        e.stopPropagation();
        cerrarMenusNodo();
        abrirCuadernoDesdeNodo(nodo);
      });

      const btnLimpieza = document.createElement("button");
      btnLimpieza.type = "button";
      btnLimpieza.textContent = "🧹 Limpieza";
      btnLimpieza.addEventListener("click", e => {
        e.stopPropagation();
        cerrarMenusNodo();
        abrirLimpiezaNodo(nodo.id);
      });

      menu.appendChild(btnControl);
      menu.appendChild(btnBitacora);
      menu.appendChild(btnCuaderno);
      menu.appendChild(btnLimpieza);
      console.debug("[flow] menu acciones nodo", nodo.id, ["Control", "Bitácora", "Cuaderno", "Limpieza"]);

      const btnMenu = document.createElement("button");
      btnMenu.className = "menu";
      btnMenu.title = "Acciones";
      btnMenu.addEventListener("pointerdown", e => e.stopPropagation());
      btnMenu.addEventListener("click", e => {
        e.stopPropagation();
        const abierto = menu.classList.contains("visible");
        cerrarMenusNodo();
        if (!abierto) {
          menu.classList.add("visible");
          div.classList.add("menu-open");
        }
      });
      controls.appendChild(btnMenu);
      div.appendChild(menu);
    }
    div.appendChild(controls);

    const tempNodo = obtenerTemperaturaNodo(nodo);
    const estado = (nodo.datos?.estado || "").toLowerCase();
    const enFermentacion = estado.includes("ferment");
    if (enFermentacion && tempNodo != null && tempNodo >= 28) {
      div.classList.add("temp-alert");
    }

	    div.addEventListener("pointerdown", e => iniciarArrastreNodo(e, nodo.id));
	    div.addEventListener("click", () => {
	      if (dragEstado && dragEstado.activo) return;
	      if (conectandoNorm && conectandoNorm !== nodoIdNorm) {
	        conectarNodos(conectandoNorm, nodoIdNorm);
	        nodoConectandoOrigen = null;
	        renderFlowNodes();
	      } else {
	        nodoSeleccionadoId = nodoIdNorm;
	        const canvasEl = document.getElementById("flowCanvas");
	        if (canvasEl) {
	          canvasEl
	            .querySelectorAll(".flow-node.is-selected")
	            .forEach(el => el.classList.remove("is-selected"));
	          div.classList.add("is-selected");
	        }
	        mostrarInfoNodo(nodoIdNorm);
	      }
	    });
    div.addEventListener("dblclick", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });

    canvas.appendChild(div);
  });

  renderFlowConnections();
  programarActualizacionMinimapFlow();
}

function resumenNodo(nodo) {
  const datos = nodo.datos || {};
  if (datos.resumen) return datos.resumen;
  const keys = Object.keys(datos).filter(k => datos[k]);
  if (!keys.length) return "Doble clic para detallar";
  return keys
    .slice(0, 2)
    .map(k => `${k}: ${datos[k]}`)
    .join(" · ");
}

	function renderFlowConnections() {
	  const svg = document.getElementById("flowConnections");
	  const canvas = document.getElementById("flowCanvas");
	  const layer = document.getElementById("flowConnectionsLayer");
	  if (!svg || !canvas) return;
	  normalizarFlujoNodos();
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  const targetLayer = layer || svg;
  if (layer) {
    layer.innerHTML = "";
  } else {
    svg.innerHTML = "";
  }
  const nodosDom = new Map();
  canvas.querySelectorAll(".flow-node").forEach(nodeEl => {
    nodosDom.set(nodeEl.dataset.id, nodeEl);
  });

	  flujoNodos.forEach(nodo => {
	    try {
	      const origenId = normalizarIdNodo(nodo);
	      const origenEl = nodosDom.get(origenId);
	      if (!origenEl) return;
      const x1 = nodo.x + origenEl.offsetWidth / 2;
      const y1 = nodo.y + origenEl.offsetHeight / 2;
      (nodo.targets || []).forEach(targetId => {
        const destinoId = normalizarIdNodo(targetId);
        const destinoEl = nodosDom.get(destinoId);
        if (!destinoEl) return;
        const destinoNodo = buscarNodoPorId(destinoId);
        if (!destinoNodo) return;
	        const x2 = destinoNodo.x + destinoEl.offsetWidth / 2;
	        const y2 = destinoNodo.y + destinoEl.offsetHeight / 2;
	        const curva = document.createElementNS("http://www.w3.org/2000/svg", "path");
	        const delta = Math.max(Math.abs(x2 - x1) / 2, 60);
	        const d = `M${x1} ${y1} C ${x1 + delta} ${y1}, ${x2 - delta} ${y2}, ${x2} ${y2}`;
	        curva.setAttribute("d", d);
	        const tipoLinea = String(nodo.tipo || "").toLowerCase();
	        const seleccionadoNorm = nodoSeleccionadoId ? normalizarIdNodo(nodoSeleccionadoId) : "";
	        const seleccion =
	          seleccionadoNorm &&
	          (seleccionadoNorm === origenId || seleccionadoNorm === destinoId);
	        const replayActivo = Boolean(flowReplay?.activo && flowReplay.model && flowReplay.state);
	        const origenIdNorm = normalizarIdNodo(nodo);
	        const destinoIdNorm = normalizarIdNodo(destinoNodo);
	        const enReplay =
	          replayActivo &&
	          flowReplay.model.nodesSet?.has(origenIdNorm) &&
	          flowReplay.model.nodesSet?.has(destinoIdNorm);
	        const edgeKey = `${origenIdNorm}→${destinoIdNorm}`;
	        const futuro = enReplay && !flowReplay.state.activeNodes?.has(destinoIdNorm);
	        const current = enReplay && flowReplay.state.currentEdges?.has(edgeKey);
	        curva.setAttribute(
	          "class",
	          `flow-connector-line${tipoLinea ? " type-" + tipoLinea : ""}${seleccion ? " is-highlight" : ""}${
	            replayActivo
	              ? enReplay
	                ? current
	                  ? " replay-now"
	                  : futuro
	                  ? " replay-future"
	                  : " replay-done"
	                : " replay-outside"
	              : ""
	          }`
	        );
	        (layer || svg).appendChild(curva);

	        if (replayActivo && enReplay) {
	          const volumen = obtenerVolumenTransferenciaEntreNodos(nodo, destinoNodo);
	          const ts = flowReplay.model.nodeTs?.get(destinoIdNorm) ?? null;
	          const fechaTxt = ts != null ? formatearFechaReplay(ts) : "Sin fecha";
	          const volumenTxt = volumen > 0 ? formatearVolumenPlano(volumen) : "—";
	          const estadoTxt = futuro ? "Pendiente" : "Hecho";
	          const tooltip = `${nodo.titulo || nodo.tipo || "Origen"} → ${destinoNodo.titulo || destinoNodo.tipo || "Destino"}\nFecha: ${fechaTxt}\nVolumen: ${volumenTxt}\nEstado: ${estadoTxt}`;
	          curva.addEventListener("pointerenter", e => {
	            if (e.pointerType !== "mouse") return;
	            mostrarFlowTooltip(tooltip, e.clientX, e.clientY);
	          });
	          curva.addEventListener("pointermove", e => {
	            if (e.pointerType !== "mouse") return;
	            posicionarFlowTooltip(e.clientX, e.clientY);
	          });
	          curva.addEventListener("pointerleave", () => ocultarFlowTooltip());
	          curva.addEventListener("pointerdown", () => ocultarFlowTooltip());
	        }

	        // Etiqueta de composición de variedades en la mitad del conector
	        try {
	          const comp = calcularComposicionVariedades(nodo);
	          const textoComp = formatearComposicionVariedades(comp.mix, comp.total);
          if (textoComp) {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2 - 6;
            label.setAttribute("x", midX);
            label.setAttribute("y", midY);
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("class", "flow-connector-label");
            label.textContent = textoComp;
            (layer || svg).appendChild(label);
          }
        } catch (err) {
          console.warn("No se pudo calcular la composición del conector:", err);
        }
      });
    } catch (err) {
      console.error("Error renderizando conexiones", err);
    }
  });
}

function iniciarArrastreNodo(ev, nodoId) {
  if (flowReplay?.activo) return;
  const nodo = flujoNodos.find(n => n.id === nodoId);
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  const editorRect = editor.getBoundingClientRect();
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  dragEstado = {
    id: nodoId,
    offsetX: posX - nodo.x,
    offsetY: posY - nodo.y,
    startX: ev.clientX,
    startY: ev.clientY,
    activo: false,
    elemento: ev.currentTarget,
    editor,
    pointerId: ev.pointerId,
  };
  ev.currentTarget.classList.add("dragging");
  try {
    ev.currentTarget.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  ev.currentTarget.addEventListener("pointermove", moverNodoArrastre);
  ev.currentTarget.addEventListener("pointerup", finalizarArrastreNodo);
  ev.currentTarget.addEventListener("pointercancel", finalizarArrastreNodo);
}

function moverNodoArrastre(ev) {
  if (!dragEstado) return;
  const nodo = flujoNodos.find(n => n.id === dragEstado.id);
  if (!nodo) return;
  const canvas = document.getElementById("flowCanvas");
  const editor = dragEstado.editor || document.getElementById("flowEditor");
  const editorRect = editor.getBoundingClientRect();
  const dx = ev.clientX - dragEstado.startX;
  const dy = ev.clientY - dragEstado.startY;
  if (!dragEstado.activo) {
    if (Math.abs(dx) + Math.abs(dy) < 4) {
      return;
    }
    dragEstado.activo = true;
  }
  const nodoWidth = dragEstado.elemento ? dragEstado.elemento.offsetWidth : 120;
  const nodoHeight = dragEstado.elemento ? dragEstado.elemento.offsetHeight : 70;
  const zoom = flowZoom || 1;
  const posX = (ev.clientX - editorRect.left + editor.scrollLeft) / zoom;
  const posY = (ev.clientY - editorRect.top + editor.scrollTop) / zoom;
  const maxX = Math.max(0, canvas.offsetWidth - nodoWidth - 10);
  const maxY = Math.max(0, canvas.offsetHeight - nodoHeight - 10);
  nodo.x = Math.min(Math.max(posX - dragEstado.offsetX, 10), maxX);
  nodo.y = Math.min(Math.max(posY - dragEstado.offsetY, 10), maxY);
  if (dragEstado.elemento) {
    dragEstado.elemento.style.left = `${nodo.x}px`;
    dragEstado.elemento.style.top = `${nodo.y}px`;
  }
  renderFlowConnections();
  programarActualizacionMinimapFlow();
}

function finalizarArrastreNodo(ev) {
  if (ev.currentTarget) {
    try {
      if (dragEstado && dragEstado.pointerId != null) {
        ev.currentTarget.releasePointerCapture(dragEstado.pointerId);
      }
    } catch (e) {
      // noop
    }
    ev.currentTarget.classList.remove("dragging");
    ev.currentTarget.removeEventListener("pointermove", moverNodoArrastre);
    ev.currentTarget.removeEventListener("pointerup", finalizarArrastreNodo);
    ev.currentTarget.removeEventListener("pointercancel", finalizarArrastreNodo);
  }
  if (dragEstado && dragEstado.activo) {
    guardarEstadoNodos();
  }
  dragEstado = null;
}

function prepararConexion(id) {
  const idNorm = normalizarIdNodo(id);
  if (!idNorm) return;
  const conectandoNorm = nodoConectandoOrigen ? normalizarIdNodo(nodoConectandoOrigen) : "";
	  if (flowReplay?.activo) {
	    mostrarAviso("Sal del replay para conectar nodos.", "info");
	    return;
	  }
	  if (conectandoNorm && conectandoNorm === idNorm) {
	    nodoConectandoOrigen = null;
	  } else if (!conectandoNorm) {
	    nodoConectandoOrigen = idNorm;
  } else {
    conectarNodos(conectandoNorm, idNorm);
    nodoConectandoOrigen = null;
  }
  renderFlowNodes();
}

function cancelarConexionEnCurso() {
  if (nodoConectandoOrigen) {
    nodoConectandoOrigen = null;
    renderFlowNodes();
    mostrarAviso("Conexión cancelada.", "info");
  }
}

function conectarNodos(origenId, destinoId, silencioso = false) {
  const origenNorm = normalizarIdNodo(origenId);
  const destinoNorm = normalizarIdNodo(destinoId);
  if (!origenNorm || !destinoNorm) return;
  normalizarFlujoNodos();
  const origen = buscarNodoPorId(origenNorm);
  const destino = buscarNodoPorId(destinoNorm);
  if (!origen) return;
	  if (esAncestro(destinoNorm, origenNorm)) {
	    const predecesores = obtenerPredecesores(origen.id);
	    const esPredecesorDirecto = predecesores.some(pre => normalizarIdNodo(pre) === destinoNorm);
	    const permitirPrensado = esNodoPrensado(origen) && esPredecesorDirecto;
	    if (!permitirPrensado) {
	      mostrarAviso("No puedes crear ciclos en el flujo.", "error");
	      return;
	    }
	  }
	  origen.targets = origen.targets || [];
	  if (!origen.targets.includes(destinoNorm)) {
	    const snapshot = JSON.parse(JSON.stringify(flujoNodos));
	    origen.targets.push(destinoNorm);
    if (origen.tipo === "estilo") {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoNorm.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { volumen: 0 };
      }
    }
    if (origen.tipo === "entrada" && origen.datos?.reparto_manual === true) {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoNorm.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { volumen: 0 };
      }
    }
    if (destino) {
      sembrarDatosIniciales(origen, destino);
    }
    redistribuirCargas(origen);
    const validacion = validarLimitesFlujo();
    if (!validacion.ok) {
      flujoNodos = snapshot;
      renderFlowNodes();
      const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
      const unidad = validacion.unidad || "u.";
      mostrarAviso(
        `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}.`,
        "error"
      );
      return;
    }
    guardarEstadoNodos();
    renderFlowNodes();
    registrarConexionMapaNodos(origen, destino || buscarNodoPorId(destinoNorm));
    if (!silencioso) {
      mostrarAviso("Nodos conectados.", "success");
    }
  }
}

function completarCargaVisual(carga) {
  if (!carga) return null;
  const volumen = getVolumenFromDatos(carga);
  carga.volumen = volumen != null ? Number(volumen.toFixed(4)) : null;
  return carga;
}

function obtenerLitrosDesdePredecesores(nodo) {
  if (!nodo) return 0;
  const padres = obtenerPredecesores(nodo.id);
  return padres.reduce((acc, pre) => {
    const carga = obtenerCargaDesdeNodo(pre);
    const volumen = getVolumenFromDatos(carga);
    return acc + (Number.isFinite(volumen) ? volumen : 0);
  }, 0);
}

function actualizarBotellasResultantes(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return;
  const selectBotella = document.getElementById("flowField-botella");
  const display = document.getElementById("flowField-botellas_resultantes-display");
  const hidden = document.getElementById("flowField-botellas_resultantes");
  if (!selectBotella || !display || !hidden) return;
  const litrosDisponibles = obtenerLitrosDesdePredecesores(nodo);
  const resumen = calcularResumenFormatosBotella(nodo);
  if (resumen.totalBotellas > 0) {
    const etiqueta = resumen.totalBotellas === 1 ? "botella" : "botellas";
    const formatosTxt = resumen.formatosActivos > 1 ? ` · ${resumen.formatosActivos} formatos` : "";
    const volumenTxt = resumen.totalLitros > 0
      ? ` (${formatearVolumenPlano(resumen.totalLitros)} volumen calculado)`
      : "";
    display.textContent = `${resumen.totalBotellas.toLocaleString("es-ES")} ${etiqueta}${formatosTxt}${volumenTxt}`;
    hidden.value = resumen.totalBotellas;
    nodo.datos = nodo.datos || {};
    nodo.datos.botellas = resumen.totalBotellas;
    return;
  }
  const volBotella = VOLUMEN_BOTELLA_L[selectBotella.value] || 0;
  const botellas = volBotella > 0 ? Math.floor(litrosDisponibles / volBotella) : 0;
  display.textContent = botellas
    ? `${botellas} uds (${formatearVolumenPlano(litrosDisponibles)} volumen disponible)`
    : "—";
  hidden.value = botellas;
  nodo.datos = nodo.datos || {};
  nodo.datos.botellas = botellas;
}

async function asegurarJsPDF() {
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  const cargar = src =>
    new Promise(resolve => {
      const script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.onload = resolve;
      script.onerror = resolve;
      document.head.appendChild(script);
    });
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js");
  return window.jspdf && window.jspdf.jsPDF ? window.jspdf.jsPDF : null;
}

async function exportarTablaControlPDF(nodo) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se cargó). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const anada =
      nodo.datos?.anada ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha) ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha_operacion) ||
      "";
    const titulo = `Control analítico de ${nodo.titulo || "Depósito"}${anada ? " · añada " + anada : ""}`;
    doc.setFontSize(14);
    doc.text(titulo, 14, 18);
    doc.setFontSize(11);

    const depInfo = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const variedad = depInfo?.vino_tipo || nodo.datos?.variedad || nodo.datos?.vino || "";
    const tipoDep = depInfo?.tipo || nodo.datos?.tipo || "Depósito";
    const capacidadRaw =
      depInfo?.capacidad_l ??
      (depInfo?.capacidad_hl != null ? depInfo.capacidad_hl * 100 : nodo.datos?.capacidad);
    const capacidad = Number.isFinite(capacidadRaw) ? `${Number(capacidadRaw).toFixed(2)} L` : "—";
    const volumenRaw =
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos ??
      depInfo?.litros_actuales;
    const volumen = Number.isFinite(Number(volumenRaw))
      ? `${Number(volumenRaw).toFixed(2)} L`
      : "—";

    const infoLines = [
      `Variedad de uva: ${variedad || "—"}`,
      `Tipo de depósito: ${tipoDep || "—"}`,
      `Capacidad depósito: ${capacidad}`,
      `Volumen uva/vino: ${volumen}`,
    ];
    doc.setFontSize(10);
    infoLines.forEach((linea, idx) => {
      doc.text(linea, 14, 24 + idx * 6);
    });

    const startYTable = 24 + infoLines.length * 6 + 6;

    const formatearFechaCorta = fechaStr => {
      if (!fechaStr) return "";
      const d = new Date(fechaStr);
      if (isNaN(d.getTime())) return fechaStr;
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    };

    const filas = (nodo.datos?.control || []).map(reg => [
      formatearFechaCorta(reg.fecha),
      reg.densidad || "",
      reg.temperatura || "",
      reg.productos || "",
    ]);
    const body = filas.length ? filas : [["", "", "", ""]];
    const headers = [["Fecha", "Densidad", "°C", "Productos"]];
    const autoTable = (window.jspdf && window.jspdf.autoTable) || (doc && doc.autoTable);
    if (autoTable) {
      (window.jspdf && window.jspdf.autoTable ? window.jspdf.autoTable : doc.autoTable).call(doc, {
        head: headers,
        body,
        startY: startYTable,
        styles: { fontSize: 11, cellPadding: 4 },
        headStyles: { fillColor: [60, 0, 90], textColor: 255 },
        alternateRowStyles: { fillColor: [245, 240, 248] },
      });
    } else {
      let y = startYTable;
      doc.text(headers[0].join(" | "), 14, y);
      y += 8;
      body.forEach(row => {
        doc.text(row.join(" | "), 14, y);
        y += 8;
      });
    }
    const nombreArchivo = `control-${(nodo.titulo || "deposito").toString().replace(/\s+/g, "-")}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de control:", err);
    alert("No se pudo generar el PDF.");
  }
}

function escalarCarga(cargaBase, factor) {
  if (!cargaBase || !Number.isFinite(factor)) return null;
  const carga = { ...cargaBase };
  const volumen = getVolumenFromDatos(cargaBase);
  if (volumen != null) {
    carga.volumen = Number((volumen * factor).toFixed(4));
  }
  return completarCargaVisual(carga);
}

	function prepararCargaParaDestino(origen, destino, cargaBase, totalDestinos, hayAsignacionesManuales = false) {
	  if (!origen || !destino || !cargaBase) return null;
	  const origenKey = normalizarIdNodo(origen);
	  let carga = null;
	  if (origen.tipo === "estilo") {
	    carga = obtenerCargaDistribuida(origen, destino.id, cargaBase);
	  }
	  if (!carga && origen.tipo === "entrada" && origen.datos?.reparto_manual === true) {
	    carga = obtenerCargaDistribuidaEntrada(origen, destino.id, cargaBase);
	  }
	  if (carga) {
	    return completarCargaVisual(carga);
	  }
	  if (destino.tipo === "deposito") {
	    const volumenBase = getVolumenFromDatos(cargaBase);
	    const origenTargets = Array.isArray(origen.targets) ? origen.targets : [];
	    const destinoIdNorm = normalizarIdNodo(destino);
	    const origenTieneUnSoloDestino =
	      origenTargets.length === 1 && normalizarIdNodo(origenTargets[0]) === destinoIdNorm;
	    const registro = asegurarAsignacionRegistro(
	      destino,
	      origen.id,
	      totalDestinos <= 1 && volumenBase > 0 ? volumenBase : null
	    );
	    // Si la asignación NO es manual y el origen solo tiene un destino, esta debe reflejar
	    // siempre la carga base actual (para corregir snapshots con asignaciones erróneas).
	    if (registro.__manual !== true && origenTieneUnSoloDestino) {
	      if (volumenBase != null) setVolumenRegistro(registro, volumenBase);
	    } else if (registro.__manual !== true && totalDestinos <= 1) {
	      // Último destino: si estaba vacío/incorrecto, rellenamos con lo que queda.
	      const regVol = getVolumenFromDatos(registro) || 0;
	      const necesitaVol = volumenBase > 0 && !(regVol > 0);
	      if (necesitaVol) {
	        setVolumenRegistro(registro, volumenBase);
	      }
	    }
	    const volumenAsignado = getVolumenFromDatos(registro);
	    const tieneCarga = volumenAsignado != null && volumenAsignado > 0;
	    const carga = { ...cargaBase };
	    if (!tieneCarga) {
	      carga.volumen = 0;
	      return completarCargaVisual(carga);
	    }
	    carga.volumen = volumenAsignado;
	    return completarCargaVisual(carga);
	  }
	  const registro = destino.datos?.asignaciones?.[origenKey];
	  if (registro) {
	    const volumen = getVolumenFromDatos(registro);
	    const carga = { ...cargaBase };
	    if (volumen != null) carga.volumen = Number(volumen.toFixed(4));
	    return completarCargaVisual(carga);
	  }

	  // Reparto automático: dividir entre destinos si el origen tiene varias salidas
	  // Si hay asignaciones manuales en algún destino contenedor, no repartimos automáticamente a otros destinos
	  // para evitar sobreasignaciones al conectar un nuevo nodo.
	  if (hayAsignacionesManuales && totalDestinos > 1) {
	    const carga = { ...cargaBase };
	    carga.volumen = 0;
	    return completarCargaVisual(carga);
	  }
	  if (totalDestinos <= 1) {
	    return { ...cargaBase };
	  }
	  const cargaDividida = escalarCarga(cargaBase, 1 / totalDestinos);
	  return cargaDividida;
	}

	function redistribuirCargas(origen, visitados = new Set()) {
	  if (!origen || visitados.has(origen.id)) return;
	  visitados.add(origen.id);
  if (origen.tipo === "estilo") {
    limpiarDistribucionEstilo(origen);
  }
	  const targets = (origen.targets || [])
	    .map(id => flujoNodos.find(n => n.id === id))
	    .filter(Boolean);
  if (!targets.length) {
    visitados.delete(origen.id);
    return;
  }
  const cargaBase = obtenerCargaDesdeNodo(origen);
	  if (!cargaBase) {
	    visitados.delete(origen.id);
	    return;
	  }
	  if (origen.tipo === "estilo") {
	    ajustarDistribucionEstilo(origen, cargaBase);
	  }
	  // Reparto automático solo si no hay asignaciones manuales en destinos contenedor
	  const origenKey = normalizarIdNodo(origen);
	  const hayAsignacionesManuales = targets.some(dest => {
	    const reg = dest?.datos?.asignaciones?.[origenKey];
	    return reg?.__manual === true;
	  });
	  if (targets.length > 1 && !hayAsignacionesManuales) {
	    const baseVolumen = getVolumenFromDatos(cargaBase) || 0;
	    const shareVolumen = Number((baseVolumen / targets.length).toFixed(4));
    targets.forEach(dest => {
      if (TIPOS_CONTENEDOR_FLUJO.has(dest.tipo)) {
        const registro = asegurarAsignacionRegistro(dest, origen.id);
        registro.__manual = false;
        setVolumenRegistro(registro, shareVolumen);
      }
    });
  }
  let cargaLibre = { ...cargaBase };
	  const totalDestinos = targets.length;
	  targets.forEach((dest, idx) => {
    // En nodos de elaboración restamos lo ya asignado; para mantener el reparto automático correcto,
    // dividimos por los destinos restantes (no por el total original) cuando usamos `cargaLibre`.
	    const destinosRestantes =
	      origen.tipo === "estilo" ? Math.max(1, totalDestinos - idx) : totalDestinos;
	    const cargaDestino = prepararCargaParaDestino(origen, dest, cargaLibre, destinosRestantes, hayAsignacionesManuales);
	    if (cargaDestino) {
	      const aplicado = manejarTransferenciaNodo(origen, dest, cargaDestino);
	      if (origen.tipo === "estilo" && aplicado) {
	        const volumenUsado = getVolumenFromDatos(aplicado) || 0;
        if (cargaLibre.volumen != null) {
          cargaLibre.volumen = Math.max(0, cargaLibre.volumen - volumenUsado);
        }
      }
    } else if (dest.tipo === "deposito") {
      actualizarVariedadDesdeAportes(dest);
    }
    redistribuirCargas(dest, visitados);
  });
  visitados.delete(origen.id);
}

	function manejarTransferenciaNodo(origen, destino, cargaPersonalizada = null) {
	  if (!origen || !destino) return null;
	  origen.datos = origen.datos || {};
	  destino.datos = destino.datos || {};
	  asegurarMermaPorDefecto(origen);
	  asegurarMermaPorDefecto(destino);
	  const cargaBase = obtenerCargaDesdeNodo(origen);
	  if (!cargaBase) return null;
	  const esCargaManual = cargaPersonalizada?.__manual === true;
	  let carga = completarCargaVisual(cargaPersonalizada ? { ...cargaPersonalizada } : { ...cargaBase });

	  if (!carga) return null;

		  if (esNodoPrensado(destino)) {
		    const volumenAsignado = getVolumenFromDatos(carga) || 0;
		    if (!(volumenAsignado > 0)) {
		      // Aún sin carga, aplicamos 0 para limpiar aportes previos y mantener el flujo consistente.
		      carga.volumen = 0;
		    } else {
		      const params = obtenerParametrosPrensadoNodo(destino);
		      const salida = calcularSalidaPrensado({
		        kilos: volumenAsignado,
		        litros: null,
		        litrosResultantes: params.litrosResultantes,
		        mermaAbs: params.mermaAbs,
		        mermaPct: params.mermaPct,
		      });
		      if (!salida.ok) {
		        carga.volumen = 0;
		        mostrarAviso(salida.error || "Prensado sin datos de merma.", "error");
		      } else {
		        carga.volumen = salida.volumenFinal;
		        carga.merma_abs = salida.mermaAbs;
		        carga.merma_pct = salida.mermaPct;
		        registrarPrensadoMapaNodos(origen, destino, salida);
		      }
		    }
		  }

	  

  carga = completarCargaVisual(carga);

  aplicarCargaProcesoSinDuplicar(destino, origen.id, carga);

		  if (destino.tipo === "deposito" || destino.tipo === "coupage") {
		    const registro = asegurarAsignacionRegistro(destino, origen.id);
		    const volumenFinal = getVolumenFromDatos(carga) ?? 0;
	    if (esCargaManual) {
	      registro.__manual = true;
	      setVolumenRegistro(registro, Math.max(0, volumenFinal));
	    } else {
	      // Si el usuario fijó manualmente esta asignación, no la sobreescribimos al redistribuir automáticamente.
	      if (registro.__manual !== true) {
	        setVolumenRegistro(registro, Math.max(0, volumenFinal));
	      }
	    }
		    actualizarVariedadDesdeAportes(destino);
		    actualizarVolumenDesdeAsignaciones(destino);
		    guardarEstadoNodos();
		  }
		  return carga;
		}

function normalizarNumero(valor) {
  if (valor === undefined || valor === null || valor === "") return null;
  if (typeof valor === "number") return Number.isFinite(valor) ? valor : null;
  let limpio = typeof valor === "string" ? valor.trim() : String(valor);
  if (!limpio) return null;
  limpio = limpio.replace(/\s+/g, "");
  const tieneComa = limpio.includes(",");
  const tienePunto = limpio.includes(".");
  if (tieneComa && tienePunto) {
    limpio = limpio.replace(/\./g, "").replace(",", ".");
  } else if (tieneComa) {
    limpio = limpio.replace(",", ".");
  } else if (tienePunto) {
    const partes = limpio.split(".");
    if (partes.length > 2) {
      const dec = partes.pop();
      limpio = partes.join("") + "." + dec;
    }
  }
  const numero = Number(limpio);
  return Number.isFinite(numero) ? numero : null;
}

function normalizarKilosLitrosDesdeDatos(datos) {
  const volumen = getVolumenFromDatos(datos);
  return {
    volumen: volumen != null ? Number(volumen.toFixed(2)) : null,
  };
}

function recalcularVolumenNodo(nodo, motivo = "") {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const normalizado = normalizarKilosLitrosDesdeDatos(nodo.datos);
  const volumen = normalizado.volumen;
  nodo.datos.volumen = volumen != null ? Number(volumen.toFixed(2)) : null;
  if (flowDebugActivo()) {
    console.debug("[flow][volumen]", {
      motivo,
      volumen,
      nodo: nodo.id,
      tipo: nodo.tipo,
    });
  }
  return nodo.datos.volumen;
}

function formatearDensidad(valor) {
  const num = normalizarNumero(valor);
  if (num == null) return "";
  const entero = Math.round(num);
  return entero.toString().padStart(4, "0");
}

function obtenerVariedadNodo(nodo, visitados = new Set()) {
  const comp = calcularComposicionVariedades(nodo, visitados);
  if (comp.mix.size) {
    const composicion = guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    return composicion.map(c => `${c.nombre} ${formatearPctVariedad(c.porcentaje)}`).join(" / ");
  }
  return nodo?.datos?.variedad || nodo?.datos?.variedadBase || "";
}

	function obtenerCargaDesdeNodo(nodo, visitados = new Set()) {
	  if (!nodo) return null;
	  const clave = nodo.id || nodo;
	  if (visitados.has(clave)) return null;
	  visitados.add(clave);
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref && nodo.datos?.kilos == null) {
    intentarPoblarNodoEntrada(nodo, true);
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref) {
    const esRaiz = nodo.id != null && obtenerPredecesores(nodo.id).length === 0;
    const volActual = getVolumenFromDatos(nodo.datos);
	    if (nodo.datos?.codigo == null || (esRaiz && !(volActual > 0))) {
	      intentarPoblarNodoDeposito(nodo, true);
	    }
	  }
  if ((nodo.tipo === "deposito" || nodo.tipo === "coupage") && nodo.datos?.asignaciones) {
    actualizarVolumenDesdeAsignaciones(nodo);
  }
  const datos = { ...(nodo.datos || {}) };
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref) {
    const entrada = buscarEntradaPorId(nodo.datos.id_ref);
    if (entrada) {
      if (datos.kilos == null && entrada.kilos != null) datos.kilos = entrada.kilos;
      if (!datos.variedad && entrada.variedad) datos.variedad = entrada.variedad;
      if (!datos.anada && entrada.anada) datos.anada = entrada.anada;
      if (!datos.fecha && entrada.fecha) datos.fecha = entrada.fecha.slice(0, 10);
      if (datos.densidad == null && entrada.densidad != null) datos.densidad = entrada.densidad;
      if (datos.temperatura == null && entrada.temperatura != null) datos.temperatura = entrada.temperatura;
    }
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref) {
    const deposito = buscarDepositoPorId(nodo.datos.id_ref);
    if (deposito) {
      if (datos.volumen == null && deposito.litros_actuales != null) datos.volumen = deposito.litros_actuales;
      if (!datos.variedad && deposito.vino_tipo) datos.variedad = deposito.vino_tipo;
      if (!datos.anada && deposito.vino_anio) datos.anada = deposito.vino_anio;
      if (!datos.fecha && deposito.fecha_uso) datos.fecha = deposito.fecha_uso.slice(0, 10);
    }
  }
  const variedad = obtenerVariedadNodo(nodo);
  const volumenRaw = getVolumenFromDatos(datos);
  const volumen = volumenRaw != null ? Number(volumenRaw.toFixed(4)) : null;
	  const carga = {};
	  if (variedad) carga.variedad = variedad;
  if (volumen != null) {
    carga.volumen = volumen;
  }
  if (datos.parcela) carga.parcela = datos.parcela;
  const anada = datos.anada || obtenerAnadaDesdeFecha(datos.fecha);
  if (anada) carga.anada = anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  const densidad = normalizarNumero(datos.densidad);
  if (densidad != null) {
    carga.densidad = densidad;
  }
  const temperatura = normalizarNumero(datos.temperatura);
  if (temperatura != null) {
    carga.temperatura = temperatura;
  }

  const sinVolumen = carga.volumen == null;
	  if (sinVolumen && nodo.id != null) {
	    let sumVol = 0;
	    const vistos = new Set();
	    obtenerPredecesores(nodo.id).forEach(pre => {
	      const key = normalizarIdNodo(pre);
	      if (vistos.has(key)) return;
	      vistos.add(key);
	      const cargaPre = obtenerCargaDesdeNodo(pre, visitados);
	      if (!cargaPre) return;
	      const v = getVolumenFromDatos(cargaPre) || 0;
	      if (v > 0) sumVol += v;
	    });
	    if (sumVol > 0) {
	      carga.volumen = Number(sumVol.toFixed(2));
	    }
	  }

	  if (nodo.id != null && esNodoConversor(nodo)) {
	    let volumenEntrante = 0;

	    const aportesObj = nodo.datos?.aportes;
	    const aportes = aportesObj && typeof aportesObj === "object" ? Object.values(aportesObj) : [];

	    // Preferimos los aportes reales del nodo (cantidad asignada a ESTE nodo) para evitar
	    // sobrecontar cuando un padre reparte su carga entre varios destinos.
	    if (aportes.length) {
	      aportes.forEach(a => {
	        const v = getVolumenFromDatos(a) || 0;
	        if (v > 0) volumenEntrante += v;
	      });
	    } else {
	      // Fallback: si aún no hay aportes (recién conectado), usamos los padres.
	      const padres = obtenerPredecesores(nodo.id);
	      padres.forEach(pre => {
	        const cargaPre = obtenerCargaDesdeNodo(pre, visitados);
	        if (!cargaPre) return;
	        const v = getVolumenFromDatos(cargaPre) || 0;
	        if (v > 0) volumenEntrante += v;
	      });
	    }

	    const params = obtenerParametrosPrensadoNodo(nodo);
	    const salida = calcularSalidaPrensado({
	      kilos: volumenEntrante,
	      litros: null,
	      litrosResultantes: params.litrosResultantes,
	      mermaAbs: params.mermaAbs,
	      mermaPct: params.mermaPct,
	    });
	    if (salida.ok && salida.volumenFinal > 0) {
	      const totalRed = Number(salida.volumenFinal.toFixed(2));
	      carga.volumen = totalRed;
	      setKilosLitrosNodo(nodo, null, totalRed, "conversor");
	    }
		  }

	  const unidad = obtenerUnidadNodo(nodo);
	  normalizarCargaSegunUnidad(carga, unidad);

	  visitados.delete(clave);
	  return Object.keys(carga).length ? carga : null;
	}

function obtenerMermaDefault(nodo) {
  // Por defecto no aplicamos merma; solo se usa la que indique el usuario.
  return MERMA_DEFAULT_GENERAL;
}

function asegurarMermaPorDefecto(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  if (esNodoPrensado(nodo)) return;
  const mermaActual = normalizarNumero(nodo.datos.merma);
  if (mermaActual == null) {
    nodo.datos.merma = 0;
  }
}

function obtenerFactorMermaNodo(nodo) {
  const mermaDatos = nodo?.datos ? normalizarNumero(nodo.datos.merma) : null;
  const base = mermaDatos != null ? mermaDatos : obtenerMermaDefault(nodo);
  const factor = Number.isFinite(base) ? base / 100 : 0;
  return Math.min(Math.max(factor, 0), 0.95);
}

function aplicarMerma(base, factor) {
  const resultado = base * (1 - factor);
  return Number.isFinite(resultado) ? Number(resultado.toFixed(2)) : 0;
}

function flowDebugActivo() {
  if (typeof window === "undefined") return false;
  try {
    return window.__FLOW_DEBUG === true || localStorage.getItem("flowDebug") === "1";
  } catch (_err) {
    return window.__FLOW_DEBUG === true;
  }
}

function obtenerMermaLitrosNodo(nodo) {
  const valor = normalizarNumero(
    nodo?.datos?.merma_abs ?? nodo?.datos?.merma_litros ?? nodo?.datos?.merma_l
  );
  return valor != null && valor >= 0 ? valor : null;
}

function obtenerLitrosResultantesNodo(nodo) {
  const valor = normalizarNumero(
    nodo?.datos?.litros_resultantes ?? nodo?.datos?.litros_result
  );
  return valor != null && valor >= 0 ? valor : null;
}

function obtenerParametrosPrensadoNodo(nodo) {
  return {
    litrosResultantes: obtenerLitrosResultantesNodo(nodo),
    mermaAbs: obtenerMermaLitrosNodo(nodo),
    mermaPct: normalizarNumero(nodo?.datos?.merma),
  };
}

function calcularSalidaPrensado({ kilos, litros, litrosResultantes, mermaAbs, mermaPct }) {
  const kilosEntrada = normalizarNumero(kilos);
  const litrosEntrada = normalizarNumero(litros);
  const volumenEntradaRaw = getVolumenFromDatos({ kilos, litros });
  const volumenEntrada = volumenEntradaRaw != null ? Number(volumenEntradaRaw.toFixed(2)) : 0;
  if (!(volumenEntrada > 0)) {
    return { ok: false, error: "Sin volumen de entrada.", volumenEntrada, volumenFinal: 0 };
  }

  const litrosRes = normalizarNumero(litrosResultantes);
  const mermaAbsVal = normalizarNumero(mermaAbs);
  const mermaPctVal = normalizarNumero(mermaPct);
  const tieneMermaConfig =
    litrosRes != null ||
    (mermaAbsVal != null && mermaAbsVal > 0) ||
    (mermaPctVal != null && mermaPctVal > 0);
  let volumenFinal = null;
  let mermaAbsFinal = null;
  let mermaPctFinal = null;

  if (!tieneMermaConfig) {
    return {
      ok: true,
      kilosEntrada,
      litrosEntrada,
      volumenEntrada,
      volumenFinal: volumenEntrada,
      mermaAbs: 0,
      mermaPct: 0,
    };
  }

  if (litrosRes != null) {
    volumenFinal = Number(litrosRes.toFixed(2));
    mermaAbsFinal = Number((volumenEntrada - volumenFinal).toFixed(2));
    mermaPctFinal = Number(((mermaAbsFinal / volumenEntrada) * 100).toFixed(2));
  } else if (mermaAbsVal != null && mermaAbsVal > 0) {
    mermaAbsFinal = Number(mermaAbsVal.toFixed(2));
    volumenFinal = Number((volumenEntrada - mermaAbsFinal).toFixed(2));
    mermaPctFinal = Number(((mermaAbsFinal / volumenEntrada) * 100).toFixed(2));
  } else if (mermaPctVal != null && mermaPctVal > 0) {
    mermaPctFinal = Number(mermaPctVal.toFixed(2));
    mermaAbsFinal = Number(((volumenEntrada * mermaPctFinal) / 100).toFixed(2));
    volumenFinal = Number((volumenEntrada - mermaAbsFinal).toFixed(2));
  } else {
    return {
      ok: true,
      kilosEntrada,
      litrosEntrada,
      volumenEntrada,
      volumenFinal: volumenEntrada,
      mermaAbs: 0,
      mermaPct: 0,
    };
  }

  if (volumenFinal > volumenEntrada) {
    return {
      ok: false,
      error: "El volumen resultante no puede superar el de entrada.",
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    };
  }
  if (volumenFinal < 0) {
    return {
      ok: false,
      error: "La merma supera el volumen de entrada.",
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    };
  }

  if (flowDebugActivo()) {
    console.debug("[flow][prensado]", {
      volumenEntrada,
      volumenFinal,
      mermaAbs: mermaAbsFinal,
      mermaPct: mermaPctFinal,
    });
  }

  return {
    ok: true,
    kilosEntrada,
    litrosEntrada,
    volumenEntrada,
    volumenFinal,
    mermaAbs: mermaAbsFinal,
    mermaPct: mermaPctFinal,
  };
}

function obtenerValorUnidadNodo(nodo, _unidad) {
  if (!nodo) return 0;
  const volumen = getVolumenFromNodo(nodo);
  return Number.isFinite(volumen) ? volumen : 0;
}

function obtenerVolumenActualNodo(nodo) {
  if (!nodo) return null;
  const volumen = recalcularVolumenNodo(nodo, "obtener_volumen");
  return volumen != null ? volumen : null;
}

function setKilosLitrosNodo(nodo, kilos, litros, motivo = "") {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const volumen = getVolumenFromDatos({ volumen: null, kilos, litros });
  nodo.datos.volumen = volumen != null ? Number(volumen.toFixed(2)) : null;
  const kilosNum = normalizarNumero(kilos);
  const litrosNum = normalizarNumero(litros);
  if (kilosNum != null && kilosNum > 0) {
    nodo.datos.kilos = Number(kilosNum.toFixed(2));
    nodo.datos.litros = null;
    nodo.datos.litros_directos = null;
  } else if (litrosNum != null && litrosNum > 0) {
    nodo.datos.litros = Number(litrosNum.toFixed(2));
    nodo.datos.litros_directos = nodo.datos.litros;
    nodo.datos.kilos = null;
  } else {
    if (kilosNum != null) nodo.datos.kilos = Number(kilosNum.toFixed(2));
    if (litrosNum != null) {
      nodo.datos.litros = Number(litrosNum.toFixed(2));
      nodo.datos.litros_directos = nodo.datos.litros;
    }
  }
  return recalcularVolumenNodo(nodo, motivo);
}

function applyVolumeOperation(nodo, { litrosDelta = 0, kilosDelta = 0, motivo = "" } = {}) {
  if (!nodo) return null;
  nodo.datos = nodo.datos || {};
  const actual = getVolumenFromNodo(nodo) || 0;
  const delta = getVolumenFromDatos({ volumen: null, kilos: kilosDelta, litros: litrosDelta }) || 0;
  nodo.datos.volumen = Math.max(0, Number((actual + delta).toFixed(2)));
  return recalcularVolumenNodo(nodo, motivo);
}

function aplicarVolumenAbsoluto(nodo, valor, unidad, motivo = "") {
  const objetivo = normalizarNumero(valor);
  if (objetivo == null) return null;
  const actual = obtenerValorUnidadNodo(nodo, unidad);
  const delta = Number((objetivo - actual).toFixed(2));
  return applyVolumeOperation(nodo, { litrosDelta: delta, motivo });
}

function esConexionTrasiego(origen, destino) {
  return (
    TIPOS_NODO_CONTENEDOR.has(origen.tipo) &&
    TIPOS_NODO_CONTENEDOR.has(destino.tipo) &&
    origen.id !== destino.id
  );
}

function aplicarCargaANodo(nodo, carga) {
  nodo.datos = nodo.datos || {};
  const acumular = false; // evitar acumulados duplicados // en nodos de proceso sumamos aportes múltiples
  const prevVol = getVolumenFromNodo(nodo) || 0;
  if (carga.variedad) {
    nodo.datos.variedad = carga.variedad;
  }
  if (carga.parcela) {
    nodo.datos.parcela = carga.parcela;
  }
  if (carga.anada) {
    nodo.datos.anada = carga.anada;
  }
  const volumenCarga = getVolumenFromDatos(carga);
  if (volumenCarga != null) {
    const nuevos = Number(volumenCarga.toFixed(2));
    nodo.datos.volumen = acumular ? Number((prevVol + nuevos).toFixed(2)) : nuevos;
    recalcularVolumenNodo(nodo, "aplicarCargaANodo");
  }
  if (carga.fecha) {
    nodo.datos.fecha = carga.fecha;
    if (!nodo.datos.fecha_operacion) {
      nodo.datos.fecha_operacion = carga.fecha;
    }
  }
  const densidadCarga = normalizarNumero(carga.densidad);
  if (densidadCarga != null) {
    nodo.datos.densidad = Number(densidadCarga.toFixed(4));
  }
  const tempCarga = normalizarNumero(carga.temperatura);
  if (tempCarga != null) {
    nodo.datos.temperatura = Number(tempCarga.toFixed(2));
  }
}
function aplicarCargaProcesoSinDuplicar(destino, origenId, carga) {
  if (!destino) return;
  destino.datos = destino.datos || {};
  destino.datos.aportes = destino.datos.aportes || {};
  const aporteVolumen = getVolumenFromDatos(carga);
  const aporte = {
    volumen: aporteVolumen != null ? Number(aporteVolumen.toFixed(2)) : null,
    variedad: carga.variedad,
    anada: carga.anada,
    parcela: carga.parcela,
    fecha: carga.fecha,
    densidad: normalizarNumero(carga.densidad),
    temperatura: normalizarNumero(carga.temperatura),
  };
  destino.datos.aportes[normalizarIdNodo(origenId)] = aporte;
  limpiarAportesOrfanos(destino);
  let sumVol = 0;
  const mixVariedades = new Map();
  let densidadSuma = 0;
  let densidadPeso = 0;
  let densidadPrimera = null;
  let tempSuma = 0;
  let tempPeso = 0;
  let tempPrimera = null;

  const pesoParaAporte = a => {
    const volumen = getVolumenFromDatos(a);
    return Number.isFinite(volumen) ? volumen : 0;
  };

  Object.values(destino.datos.aportes).forEach(a => {
    const volumen = getVolumenFromDatos(a);
    const volumenSeguro = Number.isFinite(volumen) ? volumen : 0;
    if (volumenSeguro > 0) sumVol += volumenSeguro;
    const peso = pesoParaAporte(a);
    if (a.variedad && peso > 0) {
      agregarVariedadAPeso(mixVariedades, a.variedad, peso);
    }
    const dens = normalizarNumero(a.densidad);
    if (dens != null) {
      const pesoD = peso || 1;
      densidadSuma += dens * pesoD;
      densidadPeso += pesoD;
      if (densidadPrimera == null) densidadPrimera = dens;
    }
    const temp = normalizarNumero(a.temperatura);
    if (temp != null) {
      const pesoT = peso || 1;
      tempSuma += temp * pesoT;
      tempPeso += pesoT;
      if (tempPrimera == null) tempPrimera = temp;
    }
  });
  const totalMix = Array.from(mixVariedades.values()).reduce((acc, v) => acc + v, 0);
  if (mixVariedades.size) {
    guardarComposicionEnNodo(destino, mixVariedades, totalMix);
  } else if (aporte.variedad) {
    destino.datos.composicionVariedades = [];
    destino.datos.variedad = aporte.variedad;
  }
  if (aporte.anada) destino.datos.anada = aporte.anada;
  if (aporte.parcela) destino.datos.parcela = aporte.parcela;
  if (aporte.fecha) destino.datos.fecha = aporte.fecha;
  const densidadMedia =
    densidadPeso > 0 ? densidadSuma / densidadPeso : densidadPrimera;
  const temperaturaMedia = tempPeso > 0 ? tempSuma / tempPeso : tempPrimera;
  destino.datos.densidad =
    densidadMedia != null ? Number(densidadMedia.toFixed(4)) : "";
  destino.datos.temperatura =
    temperaturaMedia != null ? Number(temperaturaMedia.toFixed(2)) : "";

  // Para contenedores dejamos que el volumen lo gestionen asignaciones; solo propagamos mezcla.
  if (TIPOS_NODO_CONTENEDOR.has(destino.tipo)) {
    // Aseguramos que el mix se refleje aunque las asignaciones estén vacías
    if (mixVariedades.size) {
      guardarComposicionEnNodo(destino, mixVariedades, totalMix);
    }
    // En barricas no tenemos tabla de asignaciones, así que guardamos volumen para el relleno visual.
    if (destino.tipo === "barrica") {
      setKilosLitrosNodo(
        destino,
        null,
        Number(sumVol.toFixed(2)),
        "aportes_barrica"
      );
    }
    return;
  }

  // En nodos de proceso sí consolidamos los volúmenes para mostrar totales.
  setKilosLitrosNodo(
    destino,
    null,
    Number(sumVol.toFixed(2)),
    "aportes_proceso"
  );
}

function desconectarNodo(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  if (!nodo) return;
  const conexionesPrevias = construirConexionesNodoMapa(nodo);
  const afectados = new Set();
  nodo.targets = [];
  flujoNodos.forEach(other => {
    if (other.targets) {
      const longitudInicial = other.targets.length;
      other.targets = other.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== other.targets.length) {
        afectados.add(other.id);
        if (other.datos?.distribucion) {
          limpiarDistribucionEstilo(other);
        }
      }
    }
  });
  if (nodo.datos?.distribucion) {
    limpiarDistribucionEstilo(nodo);
  }
  if (nodoConectandoOrigen === id) {
    nodoConectandoOrigen = null;
  }
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => recalcularDatosDesdeAportes(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  limpiarVariedadDepositosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  registrarDesconexionMapaNodos(nodo, conexionesPrevias);
  mostrarAviso("Conexiones eliminadas para este nodo.", "info");
}

function limpiarVariedadDepositosSinEntradas() {
  flujoNodos
    .filter(n => n.tipo === "deposito")
    .forEach(dep => {
      const padres = obtenerPredecesores(dep.id);
      const sinEntradas = !padres || padres.length === 0;
      const tieneSalidas = Array.isArray(dep.targets) && dep.targets.length > 0;
      if (sinEntradas && !tieneSalidas) {
        dep.datos = dep.datos || {};
        dep.datos.variedad = "";
        dep.datos.variedadBase = "";
        dep.datos.vino_tipo = "";
        dep.datos.vino = "";
        dep.datos.tipoColor = "";
        dep.datos.composicionVariedades = [];
        dep.datos.aportes = {};
      }
    });
}

function limpiarEstadoEnologicoNodo(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  limpiarCargaNodo(nodo);
  const datos = nodo.datos;
  const camposTexto = [
    "variedad",
    "variedadBase",
    "tipoColor",
    "vino_tipo",
    "vino",
    "vino_anio",
    "anada",
    "nombre_vino",
    "nombre_blend",
    "descripcion",
    "notas",
  ];
  const camposFecha = ["tiempo", "tiempo_estimado", "fecha", "fecha_operacion", "fecha_uso"];
  camposTexto.forEach(campo => {
    if (campo in datos) datos[campo] = "";
  });
  camposFecha.forEach(campo => {
    if (campo in datos) datos[campo] = "";
  });
  if ("litros_blend" in datos) datos.litros_blend = 0;
  if ("control" in datos) datos.control = [];
  if ("estado_vino" in datos) datos.estado_vino = "";
  if ("estado_vino_texto" in datos) datos.estado_vino_texto = "";
  if ("fase" in datos) datos.fase = "";
  datos.estado = "vacio";
}

function obtenerNombreContenedorNodo(nodo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return nodo?.titulo || "Nodo";
  if (contenedor.tipo === "barrica") return obtenerNombreBarrica(contenedor.id);
  if (contenedor.tipo === "mastelone") return obtenerNombreMastelone(contenedor.id);
  return obtenerNombreDeposito(contenedor.id);
}

function formatearKilosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} kg`;
}

function formatearVolumenPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })}`;
}

function normalizarTextoMapa(valor) {
  if (valor == null) return "";
  const texto = valor.toString().trim();
  return texto;
}

function obtenerEtiquetaNodoMapa(nodo) {
  if (!nodo) return "Nodo";
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (contenedor) return obtenerNombreContenedorNodo(nodo);
  if (nodo.tipo === "entrada") {
    return nodo.datos?.id_ref ? obtenerEtiquetaEntrada(nodo.datos.id_ref) : (nodo.titulo || "Entrada");
  }
  return nodo.titulo || FLOW_NODE_TYPES[nodo.tipo]?.label || "Nodo";
}

function obtenerOperacionNodoMapa(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  if (nodo.tipo === "estilo" && datos.metodo) return datos.metodo;
  if (nodo.tipo === "fermentacion" && datos.estilo) return datos.estilo;
  if (nodo.tipo === "deposito" && datos.fase) return datos.fase;
  if (nodo.tipo === "barrica") {
    const estado = normalizarTextoMapa(datos.estado_vino_texto || datos.estado_vino);
    return estado ? estado : "Crianza";
  }
  return "";
}

function obtenerFechaEventoNodo(nodo) {
  if (!nodo) return "";
  const datos = nodo.datos || {};
  return normalizarTextoMapa(datos.fecha_operacion || datos.fecha);
}

function agregarLineaMapa(lineas, etiqueta, valor) {
  const texto = normalizarTextoMapa(valor);
  if (!texto) return;
  lineas.push(`${etiqueta}: ${texto}`);
}

function construirDetalleNodoMapa(nodo) {
  const lineas = [];
  if (!nodo) return lineas;
  const datos = nodo.datos || {};
  const tipoLabel = FLOW_NODE_TYPES[nodo.tipo]?.label || nodo.tipo || "Nodo";
  const nombre = obtenerEtiquetaNodoMapa(nodo);
  agregarLineaMapa(lineas, "Tipo", tipoLabel);
  if (nombre && nombre !== tipoLabel) {
    agregarLineaMapa(lineas, "Nodo", nombre);
  }
  const fecha = obtenerFechaEventoNodo(nodo);
  agregarLineaMapa(lineas, "Fecha", fecha);
  const operacion = obtenerOperacionNodoMapa(nodo);
  agregarLineaMapa(lineas, "Operación", operacion);
  const variedad = obtenerVariedadVisibleNodo(nodo);
  agregarLineaMapa(lineas, "Variedad", variedad);
  const volumen = obtenerTextoVolumenNodo(nodo);
  if (volumen) lineas.push(volumen);

  if (nodo.tipo === "entrada") {
    const densidad = normalizarNumero(datos.densidad);
    if (densidad != null) agregarLineaMapa(lineas, "Densidad", densidad);
    const temp = normalizarNumero(datos.temperatura);
    if (temp != null) agregarLineaMapa(lineas, "Temperatura", `${temp} ºC`);
    agregarLineaMapa(lineas, "Parcela", datos.parcela);
  } else if (nodo.tipo === "fermentacion") {
    agregarLineaMapa(lineas, "Fermentación", datos.estilo);
    const registros = Array.isArray(datos.control) ? datos.control : [];
    const ultimo = registros.length ? registros[registros.length - 1] : null;
    if (ultimo) {
      const densidad = normalizarNumero(ultimo.densidad);
      if (densidad != null) agregarLineaMapa(lineas, "Densidad", densidad);
      const temp = normalizarNumero(ultimo.temperatura);
      if (temp != null) agregarLineaMapa(lineas, "Temperatura", `${temp} ºC`);
    }
  } else if (nodo.tipo === "estilo") {
    agregarLineaMapa(lineas, "Método", datos.metodo);
    agregarLineaMapa(lineas, "Descripción", datos.descripcion);
  } else if (nodo.tipo === "deposito") {
    agregarLineaMapa(lineas, "Fase", datos.fase);
    agregarLineaMapa(lineas, "Estado", datos.estado);
  } else if (nodo.tipo === "barrica") {
    agregarLineaMapa(lineas, "Vino", datos.nombre_vino);
    agregarLineaMapa(lineas, "Fin crianza", datos.tiempo);
    agregarLineaMapa(lineas, "Notas", datos.notas);
  } else if (nodo.tipo === "prensado") {
    const merma = normalizarNumero(datos.merma);
    if (merma != null) agregarLineaMapa(lineas, "Merma", `${merma}%`);
    agregarLineaMapa(lineas, "Presión", datos.presion);
    agregarLineaMapa(lineas, "Notas", datos.notas);
  } else if (nodo.tipo === "embotellado") {
    agregarLineaMapa(lineas, "Botella", datos.botella);
    agregarLineaMapa(lineas, "Cierre", datos.cierre);
    agregarLineaMapa(lineas, "Filtrado", datos.filtrado);
    const botellas = normalizarNumero(datos.botellas || datos.botellas_resultantes);
    if (botellas != null) agregarLineaMapa(lineas, "Botellas", botellas);
  } else if (nodo.tipo === "coupage") {
    agregarLineaMapa(lineas, "Nombre", datos.nombre_blend);
    const volumenBlend = normalizarNumero(datos.litros_blend);
    if (volumenBlend != null) agregarLineaMapa(lineas, "Volumen", formatearVolumenPlano(volumenBlend));
    agregarLineaMapa(lineas, "Notas", datos.descripcion);
  } else if (nodo.tipo === "almacen") {
    agregarLineaMapa(lineas, "Condición", datos.condicion);
    agregarLineaMapa(lineas, "Fecha", datos.fecha);
  } else if (nodo.tipo === "salida") {
    agregarLineaMapa(lineas, "Destino", datos.destino);
    agregarLineaMapa(lineas, "Transporte", datos.transporte);
    agregarLineaMapa(lineas, "Formato", datos.formato_botella);
  }
  return lineas;
}

function registrarBitacoraMapaNodosGeneral(texto, noteType = "accion") {
  const limpio = normalizarTextoMapa(texto);
  if (!limpio) return;
  fetch("/api/bitacora", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: limpio,
      scope: "general",
      origin: "mapa_nodos",
      note_type: noteType,
    }),
  }).catch(() => {});
}

function registrarEventoContenedorMapaNodos(contenedor, resumen, detalle, meta, fechaEvento, tipoEvento = "nota") {
  if (!contenedor) return;
  const resumenFinal = resumen || "Mapa de nodos";
  const detalleFinal = detalle
    ? [resumenFinal, detalle].filter(Boolean).join("\n")
    : resumenFinal;
  const payload = {
    contenedor_tipo: contenedor.tipo,
    contenedor_id: contenedor.id,
    tipo: tipoEvento,
    resumen: resumenFinal,
    detalle: detalleFinal,
    origen: "control",
    meta: meta || { accion: "mapa_nodos" },
  };
  if (fechaEvento) payload.fecha_hora = fechaEvento;
  fetch("/api/eventos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  }).then(() => {
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  }).catch(() => {});
}

function registrarMapaNodosEvento({ resumen, detalle, contenedores, meta, fechaEvento, noteType, tipoEvento } = {}) {
  const lista = Array.isArray(contenedores) ? contenedores.filter(Boolean) : [];
  const vistos = new Map();
  lista.forEach(cont => {
    const key = `${cont.tipo}:${cont.id}`;
    if (!vistos.has(key)) vistos.set(key, cont);
  });
  const unicos = [...vistos.values()];
  if (unicos.length) {
    unicos.forEach(cont => {
      registrarEventoContenedorMapaNodos(cont, resumen, detalle, meta, fechaEvento, tipoEvento);
    });
    return;
  }
  const texto = [resumen, detalle].filter(Boolean).join("\n").trim();
  if (texto) {
    registrarBitacoraMapaNodosGeneral(texto, noteType || "accion");
  }
}

function describirNodoMapaNodos(nodo) {
  const base = obtenerEtiquetaNodoMapa(nodo);
  const operacion = obtenerOperacionNodoMapa(nodo);
  if (operacion && !base.includes(operacion)) return `${base} (${operacion})`;
  return base;
}

function construirCantidadConexionMapa(origen, destino) {
  const volumen = obtenerVolumenTransferenciaEntreNodos(origen, destino);
  if (volumen > 0) return formatearVolumenPlano(volumen);
  return "";
}

function construirDetalleConexionMapa(origen, destino, cantidad) {
  const lineas = [];
  const origenTxt = describirNodoMapaNodos(origen);
  const destinoTxt = describirNodoMapaNodos(destino);
  agregarLineaMapa(lineas, "Origen", origenTxt);
  agregarLineaMapa(lineas, "Destino", destinoTxt);
  agregarLineaMapa(lineas, "Volumen", cantidad);
  const variedad = obtenerVariedadVisibleNodo(origen) || obtenerVariedadVisibleNodo(destino);
  agregarLineaMapa(lineas, "Variedad", variedad);
  const opOrigen = obtenerOperacionNodoMapa(origen);
  const opDestino = obtenerOperacionNodoMapa(destino);
  agregarLineaMapa(lineas, "Operación origen", opOrigen);
  agregarLineaMapa(lineas, "Operación destino", opDestino);
  return lineas;
}

function registrarConexionMapaNodos(origen, destino) {
  if (!origen || !destino) return;
  const cantidad = construirCantidadConexionMapa(origen, destino);
  const cantidadTexto = cantidad ? `Volumen ${cantidad}` : "";
  const origenTxt = describirNodoMapaNodos(origen);
  const destinoTxt = describirNodoMapaNodos(destino);
  const resumenBase = `${origenTxt} → ${destinoTxt}`;
  const resumen = `${resumenBase}${cantidadTexto ? ` · ${cantidadTexto}` : ""} · mapa de nodos`;
  const detalleLineas = construirDetalleConexionMapa(origen, destino, cantidad);
  const detalle = detalleLineas.join("\n");
  const contenedores = [
    resolverContenedorDesdeNodoControl(origen),
    resolverContenedorDesdeNodoControl(destino),
  ];
  const meta = {
    accion: "mapa_nodos",
    evento: "conexion",
    tipo_movimiento: "conexion",
    origen: origenTxt,
    destino: destinoTxt,
    cantidad: cantidadTexto || null,
    observacion: "mapa de nodos",
    origen_nodo: origen.id,
    destino_nodo: destino.id,
    origen_tipo: origen.tipo,
    destino_tipo: destino.tipo,
  };
  const fechaEvento = obtenerFechaEventoNodo(destino) || obtenerFechaEventoNodo(origen);
  registrarMapaNodosEvento({
    resumen,
    detalle,
    contenedores,
    meta,
    fechaEvento,
    noteType: "accion",
    tipoEvento: "movimiento",
  });
}

function registrarPrensadoMapaNodos(origen, destino, salida) {
  if (!origen || !salida?.ok) return;
  const contenedor = resolverContenedorDesdeNodoControl(origen);

  const nombre = obtenerNombreContenedorNodo(origen);
  const resumen = `PRENSADO ${nombre}: entrada ${salida.volumenEntrada}, salida ${salida.volumenFinal}, merma ${salida.mermaAbs} (${salida.mermaPct}%)`;
  const meta = {
    accion: "mapa_nodos",
    tipo_evento: "prensado",
    volumen_entrada: salida.volumenEntrada,
    volumen_salida: salida.volumenFinal,
    litros: salida.volumenFinal,
    merma_abs: salida.mermaAbs,
    merma_pct: salida.mermaPct,
    origen_id: contenedor?.id ?? null,
    destino: destino?.titulo || "",
  };
  const fechaEvento = obtenerFechaEventoNodo(origen) || obtenerFechaEventoNodo(destino);
  registrarMapaNodosEvento({
    resumen,
    detalle: resumen,
    contenedores: contenedor ? [contenedor] : [],
    meta,
    fechaEvento,
    noteType: "accion",
    tipoEvento: "prensado",
  });
}

function registrarAccionNodoMapa(accion, nodo, { noteType = "accion", extraLineas = [] } = {}) {
  if (!nodo) return;
  const nombre = describirNodoMapaNodos(nodo);
  const resumen = `${accion}: ${nombre} · mapa de nodos`;
  const detalleLineas = construirDetalleNodoMapa(nodo);
  const lineas = [resumen, ...detalleLineas, ...extraLineas].filter(Boolean);
  const detalle = [...detalleLineas, ...extraLineas].join("\n");
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  const meta = {
    accion: "mapa_nodos",
    evento: accion.toLowerCase().replace(/\s+/g, "_"),
    nodo_id: nodo.id,
    nodo_tipo: nodo.tipo,
  };
  const fechaEvento = obtenerFechaEventoNodo(nodo);
  registrarMapaNodosEvento({
    resumen,
    detalle,
    contenedores: contenedor ? [contenedor] : [],
    meta,
    fechaEvento,
    noteType,
  });
}

function construirConexionesNodoMapa(nodo) {
  const conexiones = [];
  if (!nodo) return conexiones;
  const nodoId = normalizarIdNodo(nodo);
  (nodo.targets || []).forEach(targetId => {
    const destino = buscarNodoPorId(targetId);
    if (destino) conexiones.push({ origen: nodo, destino });
  });
  flujoNodos.forEach(other => {
    if (!other.targets) return;
    if (other.targets.includes(nodoId)) {
      conexiones.push({ origen: other, destino: nodo });
    }
  });
  return conexiones;
}

function registrarDesconexionMapaNodos(nodo, conexiones) {
  const lista = Array.isArray(conexiones) ? conexiones : [];
  if (!lista.length) return;
  const resumen = `Conexiones eliminadas · mapa de nodos`;
  const lineas = [];
  lista.forEach(con => {
    const cantidad = construirCantidadConexionMapa(con.origen, con.destino);
    const origenTxt = describirNodoMapaNodos(con.origen);
    const destinoTxt = describirNodoMapaNodos(con.destino);
    lineas.push(`${origenTxt} → ${destinoTxt}${cantidad ? ` · ${cantidad}` : ""}`);
  });
  const detalle = lineas.join("\n");
  const contenedores = [];
  lista.forEach(con => {
    contenedores.push(resolverContenedorDesdeNodoControl(con.origen));
    contenedores.push(resolverContenedorDesdeNodoControl(con.destino));
  });
  const meta = {
    accion: "mapa_nodos",
    evento: "desconexion",
    nodo_id: nodo?.id || null,
    nodo_tipo: nodo?.tipo || null,
  };
  registrarMapaNodosEvento({ resumen, detalle, contenedores, meta, noteType: "accion" });
}

function abrirBitacoraDesdeNodo(nodo) {
  if (!nodo) return;
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor para abrir la bitácora.", "error");
    return;
  }
  if (typeof window.abrirModalBitacora !== "function") {
    mostrarAviso("No se pudo abrir la bitácora.", "error");
    return;
  }
  const nombre = obtenerNombreContenedorNodo(nodo);
  window.abrirModalBitacora({
    contenedorTipo: contenedor.tipo,
    contenedorId: contenedor.id,
    nombre,
  });
}

function abrirLimpiezaNodo(nodoId) {
  if (flowReplay?.activo) {
    mostrarAviso("Sal del replay para limpiar nodos.", "info");
    return;
  }
  const nodo = flujoNodos.find(n => n.id === nodoId);
  if (!nodo) return;
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor antes de limpiar el nodo.", "error");
    return;
  }
  nodoLimpiezaId = nodo.id;
  const modal = document.getElementById("flowCleanModal");
  const titulo = document.getElementById("flowCleanTitulo");
  const detalle = document.getElementById("flowCleanDetalle");
  const check = document.getElementById("flowCleanCheck");
  const btnConfirmar = document.getElementById("flowCleanConfirm");
  const nombre = obtenerNombreContenedorNodo(nodo);
  if (titulo) titulo.textContent = `Limpieza de nodo · ${nombre}`;
  if (detalle) {
    detalle.textContent =
      "Vas a resetear la información del vino de este contenedor para iniciar una nueva línea. " +
      "Se borra: variedades, volumen, estado del vino, flags de vino activo/datos actuales. " +
      "Se mantiene: el nodo, el depósito/barrica y la Bitácora completa (NO se borra).";
  }
  if (check) {
    check.checked = false;
    check.onchange = () => {
      if (btnConfirmar) btnConfirmar.disabled = !check.checked;
    };
  }
  if (btnConfirmar) btnConfirmar.disabled = true;
  if (modal) modal.classList.add("visible");
}

function cerrarLimpiezaNodo() {
  const modal = document.getElementById("flowCleanModal");
  if (modal) modal.classList.remove("visible");
  nodoLimpiezaId = null;
}

function abrirLimpiezaNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  abrirLimpiezaNodo(nodoEnEdicion.id);
}

async function registrarBitacoraLimpieza(nodo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return;
  const meta = {
    accion: "limpieza",
    accion_texto: "Limpieza de nodo",
  };
  try {
    await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contenedor_tipo: contenedor.tipo,
        contenedor_id: contenedor.id,
        tipo: "accion",
        resumen: "Limpieza",
        detalle: "Reset de contenedor para iniciar nueva línea de vino (desde modal del nodo).",
        origen: "control",
        meta,
      }),
    });
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  } catch (_err) {
    // Silencioso para no romper el flujo.
  }
}

async function confirmarLimpiezaNodo() {
  if (!nodoLimpiezaId) return;
  const check = document.getElementById("flowCleanCheck");
  if (check && !check.checked) {
    mostrarAviso("Confirma la limpieza antes de continuar.", "info");
    return;
  }
  const nodo = flujoNodos.find(n => n.id === nodoLimpiezaId);
  if (!nodo) {
    cerrarLimpiezaNodo();
    return;
  }
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) {
    mostrarAviso("Asigna un contenedor antes de limpiar el nodo.", "error");
    cerrarLimpiezaNodo();
    return;
  }
  limpiarEstadoEnologicoNodo(nodo);
  cerrarLimpiezaNodo();
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarInfoNodo(nodo.id);
  if (nodoEnEdicion && nodoEnEdicion.id === nodo.id) {
    abrirFlowModal(nodo.id);
  }
  await registrarBitacoraLimpieza(nodo);
  try {
    await Promise.all([cargarDepositos(), cargarBarricas()]);
  } catch (err) {
    console.warn("No se pudieron refrescar los contenedores tras la limpieza:", err);
  }
  mostrarAviso("Nodo limpiado y listo para nueva línea.", "success");
}

function eliminarNodoPorId(id) {
  const nodo = flujoNodos.find(n => n.id === id) || null;
  const conexionesPrevias = nodo ? construirConexionesNodoMapa(nodo) : [];
  const afectados = new Set();
  flujoNodos = flujoNodos.filter(n => n.id !== id);
  flujoNodos.forEach(n => {
    if (n.targets) {
      const longitudInicial = n.targets.length;
      n.targets = n.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== n.targets.length) {
        afectados.add(n.id);
        if (n.datos?.distribucion) {
          limpiarDistribucionEstilo(n);
        }
      }
    }
  });
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAportesOrfanos(n));
  flujoNodos.forEach(n => recalcularDatosDesdeAportes(n));
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  nodoEnEdicion = null;
  mostrarInfoNodo(null);
  cerrarFlowModal();
  if (nodo) {
    registrarAccionNodoMapa("Nodo eliminado", nodo, { noteType: "accion", extraLineas: conexionesPrevias.map(con => {
      const cantidad = construirCantidadConexionMapa(con.origen, con.destino);
      const origenTxt = describirNodoMapaNodos(con.origen);
      const destinoTxt = describirNodoMapaNodos(con.destino);
      return `Conexión: ${origenTxt} → ${destinoTxt}${cantidad ? ` · ${cantidad}` : ""}`;
    }) });
  }
  mostrarAviso("Nodo eliminado.", "error");
}

async function actualizarDepositoContenido(idRef, variedad, volumen, anada) {
  if (!idRef) return;
  const dep = buscarDepositoPorId(idRef);
  if (!dep) return;
  const materialActual = dep.material || dep.contenido || "";
  // Intentar usar la mezcla real del nodo de flujo si existe
  let variedadNodo = "";
  const nodoDepo = flujoNodos.find(
    n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idRef)
  );
  if (nodoDepo) {
    try {
      const comp = calcularComposicionVariedades(nodoDepo);
      if (comp.mix.size) {
        guardarComposicionEnNodo(nodoDepo, comp.mix, comp.total);
        variedadNodo = formatearComposicionVariedades(comp.mix, comp.total);
      } else {
        variedadNodo = nodoDepo.datos?.variedad || nodoDepo.datos?.variedadBase || "";
      }
    } catch (e) {
      console.warn("No se pudo calcular mezcla del depósito para guardar:", e);
    }
  }
  const volumenNum = normalizarNumero(volumen);
  const hayVino = volumenNum == null ? true : volumenNum > 0;
  const variedadFinal = hayVino ? (variedadNodo || variedad || dep.vino_tipo) : "";
  try {
    const res = await fetch(`/api/depositos/${idRef}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo: dep.codigo,
        tipo: dep.tipo,
        capacidad_l:
          dep.capacidad_l != null ? dep.capacidad_l : dep.capacidad_hl != null ? dep.capacidad_hl * 100 : null,
        material: materialActual,
        contenido: materialActual,
        elaboracion: dep.elaboracion,
        vino_tipo: variedadFinal,
        vino_anio: anada || dep.vino_anio,
        fecha_uso: dep.fecha_uso,
        clase: dep.clase || "deposito",
        estado: dep.estado || "vacio",
      }),
    });
    if (res.ok) {
      await cargarDepositos();
    }
  } catch (err) {
    console.error("No se pudo actualizar el depósito:", err);
  }
}

	function mostrarInfoNodo(id) {
	  const panel = document.getElementById("flowNodeInfo");
	  if (!panel) return;
	  const escapeHtml = value =>
	    String(value ?? "")
	      .replace(/&/g, "&amp;")
	      .replace(/</g, "&lt;")
	      .replace(/>/g, "&gt;")
	      .replace(/\"/g, "&quot;")
	      .replace(/'/g, "&#39;");

	  const minimapHtml = `
	    <div class="flow-minimap-world" id="flowMinimapWorld" aria-label="Minimapa del mapa de nodos" role="img">
	      <div class="flow-minimap-grid"></div>
	      <div class="flow-minimap-dots" id="flowMinimapDots"></div>
	      <div class="flow-minimap-viewport" id="flowMinimapViewport"></div>
	    </div>
	    <div class="flow-minimap-hint">Minimapa: clic o arrastra para moverte · Zoom: botones ±</div>
	  `;

	  const renderEmpty = () => {
	    panel.innerHTML = `
	      <div class="flow-inspector-header">
	        <div class="flow-inspector-icon">🔎</div>
	        <div>
	          <div class="flow-inspector-title">Inspector</div>
	          <div class="flow-inspector-sub">Selecciona un nodo en el mapa para ver detalles.</div>
	        </div>
	      </div>
	      ${minimapHtml}
	      <div class="flow-inspector-tags">
	        <span class="flow-tag">Doble clic: editar</span>
	        <span class="flow-tag">Conectar: origen → destino</span>
	        <span class="flow-tag">Arrastrar: mover</span>
	        <span class="flow-tag">Click fuera: limpiar</span>
	      </div>
	      <dl class="flow-inspector-fields">
	        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Exportar imagen” para compartir el flujo.</dd></div>
	      </dl>
	    `;
	    inicializarMinimapFlow();
	    programarActualizacionMinimapFlow();
	  };

	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) {
	    renderEmpty();
	    return;
	  }

	  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
	  const iconHtml =
	    config.icono && config.icono.trim().startsWith("<")
	      ? config.icono
	      : escapeHtml(config.icono || "●");
	  const tituloNodo = escapeHtml(nodo.titulo || config.label);
	  const tipoLabel = escapeHtml(config.label || nodo.tipo || "Nodo");

	  const entradas = obtenerPredecesores(nodo.id).length;
	  const salidas = (nodo.targets || []).length;
	  const unidad = obtenerUnidadVisual(nodo);
	  const textoVolumen = obtenerTextoVolumenNodo(nodo);

	  const tags = [
	    `Tipo: ${tipoLabel}`,
	    `Entradas: ${entradas}`,
	    `Salidas: ${salidas}`,
	    `Unidad: ${unidad}`,
	  ];

	  const campos = (config.campos || []).filter(campo => campo && campo.tipo !== "tablaControl");
	  const filas = campos
	    .map(campo => ({
	      label: campo.label,
	      value: obtenerValorCampoVisual(nodo, campo),
	    }))
	    .filter(item => item.label && item.value);

	  const detalles =
	    filas.length > 0
	      ? `<dl class="flow-inspector-fields">${filas
	          .map(
	            item =>
	              `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
	          )
	          .join("")}</dl>`
	      : `<div class="flow-inspector-sub">Sin datos adicionales.</div>`;

	  panel.innerHTML = `
	    <div class="flow-inspector-header">
	      <div class="flow-inspector-icon">${iconHtml}</div>
	      <div>
	        <div class="flow-inspector-title">${tituloNodo}</div>
	        <div class="flow-inspector-sub">${escapeHtml(textoVolumen || "")}</div>
	      </div>
	    </div>
	    ${minimapHtml}
	    <div class="flow-inspector-tags">${tags
	      .map(t => `<span class="flow-tag">${escapeHtml(t)}</span>`)
	      .join("")}</div>
	    ${detalles}
	  `;
	  inicializarMinimapFlow();
	  programarActualizacionMinimapFlow();
	}

	function abrirFlowModal(id) {
	  if (flowReplay?.activo) {
	    mostrarAviso("Sal del replay para editar nodos.", "info");
	    return;
	  }
	  const nodo = flujoNodos.find(n => n.id === id);
	  if (!nodo) return;
	  // Asegurar que la mezcla/variedad esté recalculada antes de pintar el formulario (modal).
	  try {
    const comp = calcularComposicionVariedades(nodo);
    if (comp.mix && comp.mix.size) {
      guardarComposicionEnNodo(nodo, comp.mix, comp.total);
    }
  } catch (e) {
    // noop
  }
  nodoEnEdicion = nodo;
  nodoEnEdicionPrevio = JSON.parse(JSON.stringify(nodo));
  const modal = document.getElementById("flowModal");
  const titulo = document.getElementById("flowModalTitulo");
  const form = document.getElementById("flowModalForm");
  if (!modal || !titulo || !form) return;
  const btnLimpieza = document.getElementById("flowCleanBtn");
  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
  let nombreExtra = "";
  if (nodo.tipo === "deposito") {
    const infoDep = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const nom = nodo.datos?.codigo || infoDep?.codigo;
    if (nom) nombreExtra = ` ${nom}`;
  } else if (nodo.tipo === "barrica") {
    const infoBar = nodo.datos?.contenedor_id ? buscarBarricaPorId(nodo.datos.contenedor_id) : null;
    const nom = nodo.datos?.tipo || infoBar?.codigo || (nodo.datos?.contenedor_id ? `#${nodo.datos.contenedor_id}` : "");
    if (nom) nombreExtra = ` ${nom}`;
  }
  const tituloTexto = `Editar ${config.label}${nombreExtra}`;
  if (config.icono && config.icono.trim().startsWith("<")) {
    titulo.innerHTML = `${config.icono} ${tituloTexto}`;
  } else if (config.icono) {
    titulo.textContent = `${config.icono} ${tituloTexto}`;
  } else {
    titulo.textContent = tituloTexto;
  }
  form.innerHTML = "";
  if (btnLimpieza) {
    const esContenedorAccion = nodo.tipo === "deposito" || nodo.tipo === "barrica";
    btnLimpieza.style.display = esContenedorAccion ? "inline-flex" : "none";
  }
  const camposOrdenados = ordenarCamposParaModal(config.campos);
  camposOrdenados.forEach(campo => {
    const label = document.createElement("label");
    label.textContent = campo.label;
    form.appendChild(label);
    if (campo.tipo === "tablaControl") {
      const tabla = crearTablaControlFermentacion(nodo);
      form.appendChild(tabla);
      return;
    }
    if (campo.tipo === "estadoVino") {
      const wrapper = document.createElement("div");
      wrapper.style.display = "grid";
      wrapper.style.gap = "6px";

      const select = document.createElement("select");
      select.id = `flowField-${campo.id}`;
      const optionEmpty = document.createElement("option");
      optionEmpty.value = "";
      optionEmpty.textContent = "Sin estado";
      select.appendChild(optionEmpty);
      ESTADOS_VINO.forEach(item => {
        const option = document.createElement("option");
        option.value = item.value;
        option.textContent = item.label;
        select.appendChild(option);
      });
      select.value = nodo.datos ? nodo.datos[campo.id] || "" : "";

      const input = document.createElement("input");
      input.type = "text";
      input.id = `flowField-${campo.id}-texto`;
      input.placeholder = "Estado personalizado";
      input.maxLength = 40;
      input.value = nodo.datos ? nodo.datos[`${campo.id}_texto`] || "" : "";
      input.style.display = select.value === ESTADO_PERSONALIZADO ? "block" : "none";

      select.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = select.value;
        const mostrar = select.value === ESTADO_PERSONALIZADO;
        input.style.display = mostrar ? "block" : "none";
        if (!mostrar) {
          input.value = "";
          nodo.datos[`${campo.id}_texto`] = "";
        }
      });
      input.addEventListener("input", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[`${campo.id}_texto`] = input.value;
      });

      wrapper.appendChild(select);
      wrapper.appendChild(input);
      form.appendChild(wrapper);
      return;
    }
    if (campo.tipo === "info") {
      const info = document.createElement("div");
      info.className = "campo-info";
      info.id = `flowField-${campo.id}-display`;
      const texto = obtenerValorCampoVisual(nodo, campo);
      info.textContent = texto || "—";
      form.appendChild(info);
      const hidden = document.createElement("input");
      hidden.type = "hidden";
      hidden.id = `flowField-${campo.id}`;
      hidden.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
      form.appendChild(hidden);
      return;
    }
    const esCampoProtegido =
      (nodo.tipo === "entrada" && campo.id !== "id_ref" && campo.id !== "merma") ||
      (["variedad", "fecha"].includes(campo.id) && nodo.tipo !== "entrada");
  const esCampoUnidadBloqueada =
      ["kilos", "litros", "litros_directos", "volumen"].includes(campo.id) &&
      nodo.tipo !== "entrada";
    let input;
    if (campo.tipo === "textarea") {
      input = document.createElement("textarea");
    } else if (campo.tipo === "select") {
      input = document.createElement("select");
      if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
        const tipoSeleccionado = nodo.datos?.contenedor_tipo || "";
        poblarSelectContenedorCrianza(input, tipoSeleccionado, nodo.datos?.contenedor_id || "");
      } else {
        if (campo.placeholder) {
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = campo.placeholder;
          placeholderOption.disabled = true;
          placeholderOption.selected = true;
          input.appendChild(placeholderOption);
        }
        (campo.opciones || []).forEach(op => {
          const option = document.createElement("option");
          option.value = op;
          option.textContent = op;
          input.appendChild(option);
        });
      }
    } else if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input = document.createElement("select");
      const ids = nodo.tipo === "entrada"
        ? (cacheEntradas || []).map(e => {
            const dens = formatearDensidad(e.densidad);
            const temp = normalizarNumero(e.temperatura);
            const kilosVal = normalizarNumero(e.kilos);
            const mixEntrada = formatearResumenVariedades(e.composicionVariedades || e.composicion_variedades);
            const variedadesTexto = mixEntrada || e.variedad || "";
            const partes = [];
            if (variedadesTexto) partes.push(variedadesTexto);
            if (kilosVal != null) partes.push(`${kilosVal.toFixed(0)} kg`);
            if (dens) partes.push(`${dens} dens`);
            if (temp != null) partes.push(`${temp.toFixed(1)}°C`);
            const sufijo = partes.length ? ` (${partes.join(" · ")})` : "";
            return { id: e.id, label: `Entrada #${e.id}${sufijo}` };
          })
        : ([...(cacheDepositos || []), ...(cacheMastelones || [])].map(d => {
            const mixDep = formatearResumenVariedades(d.composicionVariedades || d.composicion_variedades);
            const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
            const volumenActual = Number.isFinite(estadoNodo?.volumen)
              ? Number(estadoNodo.volumen)
              : Number(d.litros_actuales || 0);
            const tieneVino = Number.isFinite(volumenActual) && volumenActual > 0;
            let variedades = tieneVino ? (mixDep || d.vino_tipo || "") : "";
            // Si el depósito está en el mapa de nodos, usar su mezcla real aunque aún no esté persistida en la BD.
            try {
              const nodoDepo = flujoNodos.find(
                n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(d.id)
              );
              if (nodoDepo && tieneVino) {
                const comp = calcularComposicionVariedades(nodoDepo);
                const texto = formatearComposicionVariedades(comp.mix, comp.total);
                if (texto) variedades = texto;
              }
            } catch (e) {
              // noop
            }
            const labelVar = variedades ? ` · ${variedades}` : "";
            return {
              id: d.id,
              label: (d.codigo || `Depósito #${d.id}`) + labelVar,
            };
          }));
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = nodo.tipo === "entrada" ? "Selecciona ID" : "Selecciona depósito/mastelone";
      input.appendChild(empty);
      ids.forEach(item => {
        const option = document.createElement("option");
        option.value = item.id;
        option.textContent = item.label;
        input.appendChild(option);
      });
    } else {
      input = document.createElement("input");
      input.type = campo.tipo || "text";
    }
    input.id = `flowField-${campo.id}`;
    if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      const clave = claveContenedor(nodo.datos?.contenedor_tipo);
      input.value =
        clave && nodo.datos?.contenedor_id
          ? `${clave}:${nodo.datos.contenedor_id}`
          : "";
    } else {
      input.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
    }
    if (campo.placeholder) input.placeholder = campo.placeholder;
    if (esCampoProtegido || campo.soloLectura || esCampoUnidadBloqueada) {
      if (input.tagName === "SELECT") {
        input.disabled = true;
      } else {
        input.readOnly = true;
      }
      input.classList.add("field-readonly");
      input.title = esCampoProtegido
        ? "Dato sincronizado desde Entrada de uva"
        : "El volumen se calcula automáticamente en el flujo";
    }
    if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos.id_ref = input.value;
        if (nodo.tipo === "entrada") {
          intentarPoblarNodoEntrada(nodo);
        } else {
          intentarPoblarNodoDeposito(nodo);
        }
        config.campos.forEach(c => {
          const campoInput = document.getElementById(`flowField-${c.id}`);
          if (campoInput && nodo.datos[c.id] != null) {
            campoInput.value = nodo.datos[c.id];
          }
          const displayEl = document.getElementById(`flowField-${c.id}-display`);
          if (displayEl) {
            const texto = obtenerValorCampoVisual(nodo, c) || "—";
            displayEl.textContent = texto;
          }
        });
        renderFlowNodes();
        mostrarInfoNodo(nodo.id);
      });
    } else if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        const valor = input.value;
        if (!valor) {
          nodo.datos.contenedor_id = "";
          nodo.datos.contenedor_tipo = "";
          nodo.datos.tipo = "";
          guardarEstadoNodos();
          renderFlowNodes();
          return;
        }
        const [tipoSeleccionado, idSeleccionado] = valor.split(":");
        const idNumerico = idSeleccionado ? Number(idSeleccionado) : "";
        nodo.datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
        nodo.datos.contenedor_id = idNumerico;
        const infoCont = obtenerInfoContenedor(
          nodo.datos.contenedor_tipo === "Barrica" ? "barrica" : "deposito",
          idNumerico
        );
        const descripcion = describirContenedor(infoCont, nodo.datos.contenedor_tipo);
        nodo.datos.tipo = descripcion || nodo.datos.contenedor_tipo || "";
        // Rellenamos capacidad/volumen de la crianza al seleccionar contenedor para que el llenado funcione como en depósitos.
        if (infoCont) {
          const capInfo =
            infoCont.capacidad_l ??
            (infoCont.capacidad_hl != null ? infoCont.capacidad_hl * 100 : null);
          if (capInfo != null) {
            nodo.datos.capacidad = capInfo;
            nodo.datos.capacidad_l = capInfo;
          }
          if (infoCont.litros_actuales != null || infoCont.volumen != null) {
            const vol = infoCont.litros_actuales ?? infoCont.volumen;
            aplicarVolumenAbsoluto(nodo, vol, "litros", "seleccionar_contenedor");
          }
          nodo.datos.vino_tipo = nodo.datos.vino_tipo || infoCont.vino_tipo;
          nodo.datos.variedadBase = nodo.datos.variedadBase || infoCont.vino_tipo || "";
          if (!Array.isArray(nodo.datos.composicionVariedades) || !nodo.datos.composicionVariedades.length) {
            nodo.datos.variedad = nodo.datos.variedad || nodo.datos.variedadBase;
          }
        }
        const tipoInput = document.getElementById("flowField-tipo");
        if (tipoInput) {
          tipoInput.value = nodo.datos.tipo;
        }
        guardarEstadoNodos();
        renderFlowNodes();
      });
    }
    if (
      nodo.tipo === "barrica" &&
      (campo.id === "tiempo" || campo.id === "fecha_operacion")
    ) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = input.value;
        refrescarDuracionModal(nodo);
      });
    }
    if (nodo.tipo === "embotellado" && campo.id === "botella") {
      input.addEventListener("change", () => actualizarBotellasResultantes(nodo));
    }
    form.appendChild(input);
  });
  if (nodo.tipo === "barrica") {
    refrescarDuracionModal(nodo);
  }
  if (nodo.tipo === "embotellado") {
    actualizarBotellasResultantes(nodo);
    const labelFormatos = document.createElement("label");
    labelFormatos.textContent = "Formatos mixtos (opcional)";
    form.appendChild(labelFormatos);
    form.appendChild(crearTablaFormatosEmbotellado(nodo));
  }
  if (nodo.tipo === "coupage") {
    const labelAsign = document.createElement("label");
    labelAsign.textContent =
      "Selecciona el volumen de cada depósito para el blend";
    form.appendChild(labelAsign);
    form.appendChild(crearTablaAsignacionesDeposito(nodo));
  }
  if (nodo.tipo === "estilo") {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de volumen hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEstilo(nodo));
  }
  if (nodo.tipo === "entrada" && (nodo.targets || []).length > 1) {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de kilos hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEntrada(nodo));
  }
  modal.classList.add("visible");
}

function cerrarFlowModal() {
  const modal = document.getElementById("flowModal");
  if (modal) modal.classList.remove("visible");
  nodoEnEdicion = null;
  nodoEnEdicionPrevio = null;
}

function resolverContenedorDesdeNodoControl(nodo) {
  if (!nodo) return null;
  if (nodo.tipo === "deposito") {
    const idRef = nodo.datos?.id_ref || nodo.datos?.contenedor_id;
    const idNum = Number(idRef);
    if (!Number.isFinite(idNum) || idNum <= 0) return null;
    const info = typeof buscarDepositoPorId === "function" ? buscarDepositoPorId(idNum) : null;
    const tipo = info?.clase === "mastelone" ? "mastelone" : "deposito";
    return { tipo, id: idNum };
  }
  if (nodo.tipo === "barrica") {
    const idNum = Number(nodo.datos?.contenedor_id);
    if (!Number.isFinite(idNum) || idNum <= 0) return null;
    const tipoRaw = (nodo.datos?.contenedor_tipo || "").toString().toLowerCase();
    const tipo = tipoRaw.includes("barrica") ? "barrica" : "deposito";
    return { tipo, id: idNum };
  }
  return null;
}

async function registrarBitacoraControl(nodo, previo) {
  const contenedor = resolverContenedorDesdeNodoControl(nodo);
  if (!contenedor) return;

  let resumen = "";
  let detalle = "";
  let tipo = "accion";
  let accion = "control";
  const meta = {};
  let fechaEvento = "";

  if (nodo.tipo === "deposito") {
    const controlPrevio = JSON.stringify(previo?.datos?.control || []);
    const controlActual = JSON.stringify(nodo.datos?.control || []);
    if (controlPrevio === controlActual) return;
    const registros = Array.isArray(nodo.datos?.control) ? nodo.datos.control : [];
    const ultimo = registros.length ? registros[registros.length - 1] : null;
    if (!ultimo) return;
    const densidad = ultimo.densidad ? Number(ultimo.densidad) : null;
    const temperatura = ultimo.temperatura ? Number(ultimo.temperatura) : null;
    const productos = (ultimo.productos || "").toString().trim();
    const estadoValor = (ultimo.estado_vino || "").toString().trim();
    const estadoTexto = (ultimo.estado_vino_texto || "").toString().trim();
    if (ultimo.fecha) {
      fechaEvento = ultimo.fecha;
    }
    const partes = [];
    if (Number.isFinite(densidad)) partes.push(`Densidad ${densidad}`);
    if (Number.isFinite(temperatura)) partes.push(`Temperatura ${temperatura}°C`);
    if (productos) partes.push(`Productos: ${productos}`);
    resumen = partes.join(" · ") || "Control de depósito";
    detalle = ultimo.fecha ? `Fecha: ${ultimo.fecha}` : "";
    tipo = Number.isFinite(densidad) || Number.isFinite(temperatura) ? "analitica" : "accion";
    if (Number.isFinite(densidad) && Number.isFinite(temperatura)) {
      accion = "densidad_temperatura";
    } else if (Number.isFinite(densidad)) {
      accion = "densidad";
    } else if (Number.isFinite(temperatura)) {
      accion = "temperatura";
    } else if (productos) {
      accion = "tratamiento";
    }
    meta.densidad = Number.isFinite(densidad) ? densidad : null;
    meta.temperatura = Number.isFinite(temperatura) ? temperatura : null;
    meta.productos = productos || null;
    meta.fecha = ultimo.fecha || null;
    if (estadoValor) {
      meta.estado = estadoValor === ESTADO_PERSONALIZADO
        ? { valor: ESTADO_PERSONALIZADO, texto: estadoTexto || "Personalizado" }
        : { valor: estadoValor };
    }
  } else if (nodo.tipo === "barrica") {
    const notaPrev = (previo?.datos?.notas || "").toString().trim();
    const notaActual = (nodo.datos?.notas || "").toString().trim();
    const estadoPrev = (previo?.datos?.estado_vino || "").toString().trim();
    const estadoPrevTexto = (previo?.datos?.estado_vino_texto || "").toString().trim();
    const estadoActual = (nodo.datos?.estado_vino || "").toString().trim();
    const estadoTexto = (nodo.datos?.estado_vino_texto || "").toString().trim();
    const estadoCambio = estadoPrev !== estadoActual || estadoPrevTexto !== estadoTexto;
    if (notaPrev === notaActual && !estadoCambio) return;
    const nota = (nodo.datos?.notas || "").toString().trim();
    if (!nota && !estadoActual) return;
    if (nota) {
      resumen = "Nota de crianza";
      detalle = nota;
      tipo = "nota";
      accion = "nota";
      meta.nota = nota;
    } else {
      resumen = "Estado del vino";
      detalle = "";
      tipo = "accion";
      accion = "estado_vino";
    }
    if (estadoActual) {
      meta.estado = estadoActual === ESTADO_PERSONALIZADO
        ? { valor: ESTADO_PERSONALIZADO, texto: estadoTexto || "Personalizado" }
        : { valor: estadoActual };
    }
  } else {
    return;
  }

  meta.accion = accion;
  try {
    const payload = {
      contenedor_tipo: contenedor.tipo,
      contenedor_id: contenedor.id,
      tipo,
      resumen,
      detalle,
      origen: "control",
      meta,
    };
    if (fechaEvento) {
      payload.fecha_hora = fechaEvento;
    }
    await fetch("/api/eventos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (typeof window.emitirEventoBitacora === "function") {
      window.emitirEventoBitacora(contenedor.tipo, contenedor.id);
    } else {
      window.dispatchEvent(new CustomEvent("bitacora:nueva", { detail: { contenedor_tipo: contenedor.tipo, contenedor_id: contenedor.id } }));
    }
  } catch (_err) {
    // Silencioso para no romper el flujo del modal.
  }
}

function guardarNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  const nodoId = nodoEnEdicion.id;
  const snapshot = JSON.parse(JSON.stringify(flujoNodos));
  const config = FLOW_NODE_TYPES[nodoEnEdicion.tipo];
  const datos = {};
  const metodoPrevio = nodoEnEdicion.datos?.metodo || "";
  const eraConversorAntes =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoPrevio) ||
    esMetodoSangrado(metodoPrevio);
	  if (config) {
	    config.campos.forEach(campo => {
	      if (campo.tipo === "tablaControl" || campo.tipo === "info") return;
	      const input = document.getElementById(`flowField-${campo.id}`);
      if (input) {
        if (campo.tipo === "estadoVino") {
          datos[campo.id] = input.value;
          const inputTexto = document.getElementById(`flowField-${campo.id}-texto`);
          if (inputTexto) {
            datos[`${campo.id}_texto`] = inputTexto.value;
          }
        } else if (campo.id === "contenedor_id" && nodoEnEdicion.tipo === "barrica") {
          const valor = input.value;
          if (!valor) {
            datos.contenedor_id = "";
            datos.contenedor_tipo = "";
          } else {
            const [tipoSeleccionado, idSeleccionado] = valor.split(":");
            datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Depósito";
            datos.contenedor_id = idSeleccionado ? Number(idSeleccionado) : "";
          }
        } else {
          datos[campo.id] = input.value;
        }
      } else if (nodoEnEdicion.datos && nodoEnEdicion.datos[campo.id] != null) {
        datos[campo.id] = nodoEnEdicion.datos[campo.id];
      }
    });
  }
	  const metodoCandidato = datos.metodo != null ? datos.metodo : metodoPrevio;
	  const esConversorCandidato =
	    nodoEnEdicion.tipo === "prensado" ||
	    esMetodoPrensado(metodoCandidato) ||
	    esMetodoSangrado(metodoCandidato);
	  nodoEnEdicion.datos = { ...(nodoEnEdicion.datos || {}), ...datos };
	  asegurarMermaPorDefecto(nodoEnEdicion);
  actualizarDuracionPrevista(nodoEnEdicion);
	  recalcularVolumenNodo(nodoEnEdicion, "guardar_modal");
	  actualizarTituloNodo(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "entrada") {
    intentarPoblarNodoEntrada(nodoEnEdicion);
  } else if (nodoEnEdicion.tipo === "deposito") {
    intentarPoblarNodoDeposito(nodoEnEdicion);
    actualizarVariedadDesdeAportes(nodoEnEdicion);
  }
  redistribuirCargas(nodoEnEdicion);
  const validacion = validarLimitesFlujo();
  if (!validacion.ok) {
    flujoNodos = snapshot;
    nodoEnEdicion = flujoNodos.find(n => n.id === nodoId) || null;
    renderFlowNodes();
    const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
    const unidad = validacion.unidad || "u.";
    mostrarAviso(
      `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}. Reduce la cantidad antes de continuar.`,
      "error"
    );
    return;
  }
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarInfoNodo(nodoId);
  sincronizarNodoConSistema(nodoEnEdicion);
  const nodoPrevio = nodoEnEdicionPrevio || snapshot.find(n => n.id === nodoId) || null;
  registrarBitacoraControl(nodoEnEdicion, nodoPrevio);
  const datosPrevios = JSON.stringify(nodoPrevio?.datos || {});
  const datosActuales = JSON.stringify(nodoEnEdicion?.datos || {});
  const tituloPrevio = nodoPrevio?.titulo || "";
  const tituloActual = nodoEnEdicion?.titulo || "";
  if (datosPrevios !== datosActuales || tituloPrevio !== tituloActual) {
    registrarAccionNodoMapa("Nodo actualizado", nodoEnEdicion, { noteType: "accion" });
  }
  cerrarFlowModal();
}

function intentarPoblarNodoEntrada(nodo, silencioso = false) {
  const id = Number(nodo.datos.id_ref);
  if (!id || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => e.id === id);
  if (!entrada) {
    if (!silencioso) {
      mostrarAviso("No se encontró la entrada con ese ID.", "error");
    }
    return;
  }
  nodo.datos.fecha = entrada.fecha ? entrada.fecha.slice(0, 10) : nodo.datos.fecha;
  if (!nodo.datos.fecha_operacion && nodo.datos.fecha) {
    nodo.datos.fecha_operacion = nodo.datos.fecha;
  }
  nodo.datos.kilos = entrada.kilos ?? nodo.datos.kilos;
  nodo.datos.variedad = entrada.variedad || nodo.datos.variedad;
  nodo.datos.parcela = entrada.parcela || nodo.datos.parcela;
  const anadaEntrada = entrada.anada || obtenerAnadaDesdeFecha(entrada.fecha);
  nodo.datos.anada = anadaEntrada || nodo.datos.anada;
  nodo.datos.viticultor = entrada.viticultor || nodo.datos.viticultor;
  nodo.datos.tipo_suelo = entrada.tipo_suelo || nodo.datos.tipo_suelo;
  nodo.datos.anos_vid = entrada.anos_vid || nodo.datos.anos_vid;
  nodo.datos.densidad = entrada.densidad ?? nodo.datos.densidad;
  nodo.datos.temperatura = entrada.temperatura ?? nodo.datos.temperatura;
  recalcularVolumenNodo(nodo, "cache_entrada");
  actualizarTituloNodo(nodo);
  if (!silencioso) {
    mostrarAviso("Datos del nodo cargados desde la entrada.", "success");
  }
  redistribuirCargas(nodo);
}

function intentarPoblarNodoDeposito(nodo, silencioso = false) {
  const idRef = nodo?.datos?.id_ref;
  if (idRef == null || idRef === "") return;
  const deposito = buscarDepositoPorId(idRef) || buscarDepositoPorCodigo(idRef);
  if (!deposito) {
    if (!silencioso) {
      mostrarAviso("No se encontró el depósito/mastelone con ese ID o código.", "error");
    }
    return;
  }
  const esRaiz = nodo?.id ? obtenerPredecesores(nodo.id).length === 0 : false;
  // Normalizar: si venía un código (p.ej. 'M1'), guardamos el id real para el resto del flujo.
  if (nodo.datos && deposito.id != null && String(nodo.datos.id_ref) !== String(deposito.id)) {
    nodo.datos.id_ref = deposito.id;
  }
  const camposResguardar = ["volumen", "tipo", "material", "fase", "kilos", "variedad"];
  const valoresPrevios = {};
  camposResguardar.forEach(campo => {
    if (!nodo.datos) return;
    const valor = nodo.datos[campo];
    if (valor == null || valor === "") return;
    // Si viene a 0 (default), dejamos que el depósito real rellene el volumen/kilos.
    if (["volumen", "kilos"].includes(campo)) {
      const num = normalizarNumero(valor);
      if (num != null && num !== 0) {
        valoresPrevios[campo] = valor;
      }
      return;
    }
    valoresPrevios[campo] = valor;
  });
  const controlPrevio = Array.isArray(nodo.datos.control)
    ? nodo.datos.control.map(item => ({ ...item }))
    : null;
  const asignacionesPrevias = nodo.datos.asignaciones
    ? JSON.parse(JSON.stringify(nodo.datos.asignaciones))
    : null;
  nodo.datos.codigo = deposito.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    deposito.capacidad_l ||
    (deposito.capacidad_hl ? deposito.capacidad_hl * 100 : nodo.datos.capacidad);
  // Solo rellenamos volumen desde el sistema cuando el nodo es un "punto de partida" (sin entradas).
  // En nodos intermedios, el volumen se reconstruye por asignaciones/aportes del flujo.
  if (esRaiz) {
    const volBase = deposito.litros_actuales ?? nodo.datos.volumen;
    if (volBase != null) {
      aplicarVolumenAbsoluto(nodo, volBase, "litros", "cache_deposito");
    }
  }
  nodo.datos.vino = deposito.vino_tipo || nodo.datos.vino;
  // No sobreescribir variedad: se hereda desde la entrada/asignaciones
  nodo.datos.estado = deposito.estado || nodo.datos.estado;
  nodo.datos.fecha = deposito.fecha_uso ? deposito.fecha_uso.slice(0, 10) : nodo.datos.fecha;
  nodo.datos.material = deposito.material || deposito.contenido || nodo.datos.material;
  nodo.datos.tipo = deposito.tipo || nodo.datos.tipo;
  Object.entries(valoresPrevios).forEach(([campo, valor]) => {
    nodo.datos[campo] = valor;
  });
  if (controlPrevio) {
    nodo.datos.control = controlPrevio;
  }
  if (asignacionesPrevias) {
    nodo.datos.asignaciones = asignacionesPrevias;
  }
  recalcularVolumenNodo(nodo, "cache_deposito");
  actualizarTituloNodo(nodo);
  if (!silencioso) {
    mostrarAviso("Datos del nodo cargados desde el depósito.", "success");
  }
  redistribuirCargas(nodo);
}

function eliminarNodoActivo() {
  if (!nodoEnEdicion) return;
  eliminarNodoPorId(nodoEnEdicion.id);
}

function guardarEstadoNodos() {
  try {
    localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
    if (flowDebugActivo()) {
      console.debug("[flow][persist]", { destino: "localStorage", nodos: flujoNodos.length });
    }
  } catch (err) {
    console.warn("No se pudo guardar nodos en localStorage:", err);
  }
  if (temporizadorGuardadoFlujo) {
    clearTimeout(temporizadorGuardadoFlujo);
  }
  temporizadorGuardadoFlujo = setTimeout(() => {
    temporizadorGuardadoFlujo = null;
    guardarFlujoEnServidor();
  }, RETARDO_GUARDADO_FLUJO);
}

async function cargarNodosGuardados() {
  try {
    const res = await fetch("/api/flujo");
    if (res.ok) {
      const data = await res.json();
      if (Array.isArray(data.nodos)) {
        flujoNodos = data.nodos;
        normalizarFlujoNodos();
        flujoNodos.forEach(n => {
          limpiarAportesOrfanos(n);
          recalcularDatosDesdeAportes(n);
          actualizarTituloNodo(n);
          actualizarVariedadDesdeAportes(n);
          asegurarMermaPorDefecto(n);
          if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
            intentarPoblarNodoDeposito(n, true);
          }
        });
        limpiarNodosSinEntradas();
        localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
        return;
      }
    }
  } catch (err) {
    console.warn("No se pudo cargar flujo del servidor:", err);
  }
  try {
    const guardados = JSON.parse(localStorage.getItem("flowNodes"));
    if (Array.isArray(guardados)) {
      flujoNodos = guardados;
      normalizarFlujoNodos();
      flujoNodos.forEach(n => {
        limpiarAportesOrfanos(n);
        recalcularDatosDesdeAportes(n);
        actualizarTituloNodo(n);
        actualizarVariedadDesdeAportes(n);
        asegurarMermaPorDefecto(n);
        if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
          intentarPoblarNodoDeposito(n, true);
        }
      });
      limpiarNodosSinEntradas();
      localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
    }
  } catch (err) {
    flujoNodos = [];
  }
}

async function guardarFlujoEnServidor() {
  try {
    const res = await fetch("/api/flujo", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ nodos: flujoNodos }),
    });
    if (flowDebugActivo()) {
      console.debug("[flow][persist]", {
        destino: "servidor",
        ok: res.ok,
        status: res.status,
        nodos: flujoNodos.length,
      });
    }
  } catch (err) {
    console.warn("No se pudo sincronizar el flujo con el servidor:", err);
  }
}

function limpiarNodosFlujo() {
  if (!confirm("¿Eliminar todos los nodos del mapa?")) return;
  flujoNodos = [];
  guardarEstadoNodos();
  renderFlowNodes();
  guardarFlujoEnServidor();
  registrarBitacoraMapaNodosGeneral("Mapa de nodos vaciado · mapa de nodos", "accion");
}

// Resetea el mapa localmente sin pedir confirmación extra (botón rápido)
function resetMapaFlujoLocal() {
  flujoNodos = [];
  guardarEstadoNodos();
  guardarFlujoEnServidor();
  renderFlowNodes();
  mostrarAviso("Mapa vaciado.", "success");
  registrarBitacoraMapaNodosGeneral("Mapa de nodos vaciado · mapa de nodos", "accion");
}

// Carga un mapa mínimo con entrada → depósito para probar desde cero
function seedMapaSimple() {
  const entradaId = generarIdNodo();
  const depositoId = generarIdNodo();
  const entrada = {
    id: entradaId,
    tipo: "entrada",
    titulo: "Entrada de uva",
    x: 120,
    y: 140,
    datos: {
      variedad: "Tempranillo",
      kilos: 1000,
      fecha: new Date().toISOString().slice(0, 10),
    },
    targets: [depositoId],
  };
  asegurarMermaPorDefecto(entrada);
  const deposito = {
    id: depositoId,
    tipo: "deposito",
    titulo: "Depósito A1",
    x: 380,
    y: 160,
    datos: {
      codigo: "A1",
      capacidad: 1500,
      volumen: 0,
      variedad: "",
    },
    targets: [],
  };
  asegurarMermaPorDefecto(deposito);
  flujoNodos = [entrada, deposito];
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Mapa simple cargado.", "success");
}

async function sincronizarNodoConSistema(nodo) {
  if (!nodo || nodo.datos?.sincronizado) return;
  try {
    switch (nodo.tipo) {
      case "entrada":
        await sincronizarEntradaDesdeNodo(nodo);
        break;
      case "embotellado":
        await sincronizarEmbotelladoDesdeNodo(nodo);
        break;
      default:
        // Para depósitos y barricas solo se crea desde el formulario manual.
        break;
    }
  } catch (err) {
    console.error("No se pudo sincronizar nodo:", err);
    mostrarAviso("No se pudo sincronizar el nodo con la base de datos.", "error");
  }
}

async function sincronizarEntradaDesdeNodo(nodo) {
  if (nodo.datos.id_ref) {
    mostrarAviso("La entrada ya existe en la base de datos.", "info");
    nodo.datos.sincronizado = true;
    return;
  }
  const kilos = Number(nodo.datos.kilos || 0);
  if (!kilos) {
    mostrarAviso("Indica kilos para sincronizar la entrada.", "error");
    return;
  }
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    variedad: nodo.datos.variedad || "Variedad nodo",
    viticultor: "",
    tipo_suelo: "",
    parcela: nodo.datos.parcela || "",
    anos_vid: null,
    kilos,
    destinos: [],
  };
  const res = await fetch("/api/entradas_uva", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la entrada desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Entrada creada desde el nodo.", "success");
    await cargarEntradas();
  }
}

async function sincronizarDepositoDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || nodo.datos.volumen || 0);
  if (!capacidad) {
    mostrarAviso("Indica capacidad para el depósito.", "error");
    return;
  }
  const material = nodo.datos.material || nodo.datos.contenido || "";
  const body = {
    codigo,
    clase: "deposito",
    tipo: nodo.datos.tipo || "",
    capacidad_l: capacidad,
    material,
    contenido: material,
    vino_tipo: nodo.datos.variedad || nodo.datos.vino || "",
    vino_anio: nodo.datos.anada || "",
    elaboracion: nodo.datos.elaboracion || "",
    fecha_uso: nodo.datos.fecha || null,
    estado: nodo.datos.estado || "vacio",
  };
  const res = await fetch("/api/depositos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el depósito desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Depósito creado desde el nodo.", "success");
    await cargarDepositos();
  }
}

async function sincronizarBarricaDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || 225);
  const body = {
    codigo,
    capacidad_l: capacidad,
    tipo_roble: nodo.datos.tipo || "",
    tostado: nodo.datos.tostado || "",
    marca: nodo.datos.marca || "",
    anio: nodo.datos.anio || "",
    vino_anio: nodo.datos.anada || "",
    vino_tipo: nodo.datos.vino || "",
  };
  const res = await fetch("/api/barricas", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la barrica desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Barrica creada desde el nodo.", "success");
    await cargarBarricas();
  }
}

async function sincronizarEmbotelladoDesdeNodo(nodo) {
  const litros = Number(nodo.datos.litros || 0);
  if (!litros) {
    mostrarAviso("Indica volumen para el embotellado.", "error");
    return;
  }
  const formatos = Array.isArray(nodo.datos?.formatos_botella)
    ? nodo.datos.formatos_botella
    : null;
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    contenedor_tipo: nodo.datos.origen_tipo || "deposito",
    contenedor_id: Number(nodo.datos.origen_id || 1),
    litros,
    botellas: Number(nodo.datos.botellas || 0) || null,
    lote: nodo.datos.lote || "",
    nota: nodo.datos.notas || "",
    formatos: formatos && formatos.length ? formatos : null,
  };
  const res = await fetch("/api/embotellados", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el embotellado desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Embotellado creado desde el nodo.", "success");
    await cargarEmbotellados();
  }
}

function toggleNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (!menu || !toggle) return;
  const abierto = menu.classList.toggle("visible");
  toggle.classList.toggle("open", abierto);
  if (abierto) {
    prepararNavMenuAbierto();
  } else {
    limpiarNavBusqueda();
  }
}

function cerrarNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (menu) menu.classList.remove("visible");
  if (toggle) toggle.classList.remove("open");
  limpiarNavBusqueda();
}

function prepararNavMenuAbierto() {
  const input = document.getElementById("navSearch");
  if (!input) return;
  try {
    input.focus({ preventScroll: true });
    input.select();
  } catch (e) {
    // noop
  }
}

function normalizarTextoBusqueda(texto) {
  return (texto || "")
    .toString()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim();
}

function filtrarNavMenu(valor) {
  const menu = document.getElementById("navMenu");
  if (!menu) return;
  const empty = document.getElementById("navSearchEmpty");
  const q = normalizarTextoBusqueda(valor);
  const enlaces = Array.from(menu.querySelectorAll("a"));
  let visibles = 0;
  enlaces.forEach(a => {
    if (!q) {
      a.classList.remove("nav-item-hidden");
      return;
    }
    const txt = normalizarTextoBusqueda(
      [
        a.textContent,
        a.dataset.section || "",
        a.dataset.keywords || "",
        a.getAttribute("title") || "",
      ].join(" ")
    );
    const visible = txt.includes(q);
    a.classList.toggle("nav-item-hidden", !visible);
    if (visible) visibles += 1;
  });
  if (empty) {
    empty.style.display = q && visibles === 0 ? "block" : "none";
  }
}

function limpiarNavBusqueda() {
  const input = document.getElementById("navSearch");
  if (input) input.value = "";
  filtrarNavMenu("");
}

function onNavSearchKeydown(ev) {
  const menu = document.getElementById("navMenu");
  if (!menu) return;
  const key = ev.key || "";
  if (key === "Escape") {
    ev.preventDefault();
    cerrarNavMenu();
    return;
  }
  if (key === "Enter") {
    ev.preventDefault();
    const first = menu.querySelector("a:not(.nav-item-hidden)");
    if (first) {
      first.click();
    }
    return;
  }
  if (key === "ArrowDown") {
    ev.preventDefault();
    const first = menu.querySelector("a:not(.nav-item-hidden)");
    if (first) first.focus();
    return;
  }
}

function obtenerInicialesUsuario(usuario) {
  if (!usuario) return "--";
  const partes = usuario
    .split(/[^A-Za-z0-9]+/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) {
    return usuario.slice(0, 2).toUpperCase();
  }
  if (partes.length === 1) {
    return (partes[0][0] || partes[0]).toUpperCase().slice(0, 2);
  }
  return (
    (partes[0][0] || "") +
    (partes[1][0] || "")
  ).toUpperCase();
}

function obtenerIdentificadoresContenedor(tipo, idRef) {
  const ids = new Set();
  if (idRef != null && idRef !== "") ids.add(String(idRef));
  if (tipo === "deposito") {
    const dep = buscarDepositoPorId(idRef) || buscarDepositoPorCodigo(idRef);
    if (dep?.id != null) ids.add(String(dep.id));
    if (dep?.codigo) ids.add(String(dep.codigo));
  } else if (tipo === "barrica") {
    const bar = buscarBarricaPorId(idRef) || buscarBarricaPorCodigo(idRef);
    if (bar?.id != null) ids.add(String(bar.id));
    if (bar?.codigo) ids.add(String(bar.codigo));
  }
  return Array.from(ids).filter(Boolean);
}

function obtenerNodoFinalContenedor(tipo, idRef) {
  if (idRef == null || !Array.isArray(flujoNodos)) return null;
  const ids = obtenerIdentificadoresContenedor(tipo, idRef);
  if (!ids.length) return null;
  const normalizarClave = valor =>
    valor == null ? "" : String(valor).trim().toLowerCase();
  const idsSet = new Set(ids.map(normalizarClave).filter(Boolean));
  const coincide = n => {
    if (!n || n.tipo !== tipo) return false;
    const datos = n.datos || {};
    const candidatos = [
      datos.id_ref,
      datos.contenedor_id,
      datos.codigo,
      n.titulo,
      n.id,
    ].filter(v => v != null && v !== "");
    return candidatos.some(v => idsSet.has(normalizarClave(v)));
  };
  const candidatos = flujoNodos.filter(coincide);
  if (!candidatos.length) return null;
  const esFinal = nodo => {
    const targets = nodo.targets || [];
    return !targets.some(tid => {
      const target = obtenerNodoPorId(tid);
      return target && TIPOS_CONTENEDOR_FLUJO.has(target.tipo);
    });
  };
  const finales = candidatos.filter(esFinal);
  const elegidos = finales.length ? finales : candidatos;
  return elegidos[elegidos.length - 1] || null;
}

function obtenerEstadoContenedorDesdeNodo(tipo, idRef) {
  if (!idRef || !Array.isArray(flujoNodos)) return null;
  const nodo = obtenerNodoFinalContenedor(tipo, idRef);
  if (!nodo) return null;
  let variedadTexto = "";
  try {
    variedadTexto = obtenerVariedadVisibleNodo(nodo) || "";
  } catch (e) {
    // noop
  }
  const volumen = obtenerVolumenNumericoNodo(nodo);
  const volumenNum = Number.isFinite(volumen) ? Number(volumen) : null;
  if (!Number.isFinite(volumenNum) || volumenNum <= 0) {
    variedadTexto = "";
  }
  return {
    volumen: volumenNum,
    variedad: variedadTexto,
    enMapa: true,
  };
}

function obtenerVolumenFinalNodoContenedor(tipo, idRef) {
  const ultimo = obtenerNodoFinalContenedor(tipo, idRef);
  if (!ultimo) return null;
  const volumen = obtenerVolumenNumericoNodo(ultimo);
  return Number.isFinite(volumen) ? volumen : null;
}

function obtenerEstadoBarricaDesdeNodo(idBarrica) {
  return obtenerEstadoContenedorDesdeNodo("barrica", idBarrica);
}

async function cargarUsuarioActivo() {
  const badge = document.getElementById("userBadge");
  const marca = document.getElementById("marcaTexto");
  const submarca = document.getElementById("submarcaTexto");
  if (!badge) return;
  badge.textContent = "—";
  try {
    const res = await fetch("/api/me", { credentials: "same-origin" });
    if (!res.ok) {
      badge.textContent = "??";
      return;
    }
    const data = await res.json();
    badge.textContent = obtenerInicialesUsuario(data.usuario);
    badge.setAttribute("title", data.usuario);
    if (marca && data.bodega_nombre) {
      const nombre = data.bodega_nombre || "";
      const prefijo = /^bodega\b/i.test(nombre.trim()) ? nombre.trim() : `Bodega ${nombre.trim()}`;
      marca.textContent = prefijo;
    }
    if (submarca) {
      submarca.textContent = "";
    }
  } catch (err) {
    console.error("Error cargando usuario:", err);
    badge.textContent = "!!";
  }
}

function irAFormulario(seccion, campo) {
  mostrarSeccion(seccion);
  setTimeout(() => {
    const elemento = document.getElementById(campo);
    if (elemento) {
      elemento.scrollIntoView({ behavior: "smooth", block: "center" });
      elemento.focus();
    }
  }, 320);
}

document.addEventListener("click", event => {
  const navMenu = document.getElementById("navMenu");
  const navToggle = document.getElementById("navToggle");
  if (
    navMenu &&
    navToggle &&
    !navMenu.contains(event.target) &&
    !navToggle.contains(event.target)
  ) {
    cerrarNavMenu();
  }
  if (
    !event.target.closest(".flow-node-menu") &&
    !event.target.closest(".flow-node-controls")
  ) {
    cerrarMenusNodo();
  }
});

document.addEventListener("keydown", ev => {
  const menu = document.getElementById("navMenu");
  const target = ev.target;
  const esEditable =
    target &&
    (target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.tagName === "SELECT" ||
      target.isContentEditable);

  if (!esEditable && (ev.metaKey || ev.ctrlKey) && (ev.key || "").toLowerCase() === "k") {
    ev.preventDefault();
    toggleNavMenu();
    return;
  }

  if ((ev.key || "") === "Escape" && menu && menu.classList.contains("visible")) {
    cerrarNavMenu();
  }
});

document.addEventListener("DOMContentLoaded", () => {
  mostrarSeccion("bodega");
  poblarSelectOpciones("depTipo", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterial", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectOpciones("depTipoEdit", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterialEdit", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectEstados("depEstadoEdit");
  const navToggleBtn = document.getElementById("navToggle");
  if (navToggleBtn) {
    navToggleBtn.addEventListener("click", event => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }
  const navSearch = document.getElementById("navSearch");
  if (navSearch) {
    navSearch.addEventListener("input", () => filtrarNavMenu(navSearch.value));
    navSearch.addEventListener("keydown", onNavSearchKeydown);
  }
  const navLogout = document.getElementById("navLogout");
  if (navLogout) {
    navLogout.addEventListener("click", async event => {
      event.preventDefault();
      cerrarNavMenu();
      try {
        const res = await fetch("/logout", { method: "POST", credentials: "same-origin" });
        if (!res.ok) {
          mostrarAviso("No se pudo cerrar la sesión.", "error");
          return;
        }
      } catch (err) {
        console.error("Error cerrando sesión:", err);
        mostrarAviso("No se pudo cerrar la sesión.", "error");
        return;
      }
      window.location.assign("/login");
    });
  }
  inicializarFlowEditor();
  renderFormatosEmbotelladoFormulario();
  cargarUsuarioActivo();
});
let planoDrag = null;
let planoSeleccion = null;
let planoSeleccionItemActual = null;
let planoZoom = 1;
let planoWorldBase = { width: 2800, height: 1600 };
let planoUIInicializada = false;
let planoPanBloqueado = false;
let planoPanSpace = false;
let planoPanDrag = null;
let planoMinimapDrag = null;
let planoMinimapRaf = null;
const PLANO_ZOOM_MIN = 0.2;
const PLANO_ZOOM_MAX = 2.5;
const PLANO_ZOOM_STEP = 0.1;
const PLANO_DRAG_THRESHOLD_PX = 4;
const PLANO_CARD_WIDTH = 148;
const PLANO_CARD_HEIGHT_BASE = 176;
const PLANO_CARD_HEIGHT_MAX = 420;
let mapaDepositosPorId = new Map();
let mapaBarricasPorId = new Map();
let mapaMastelonesPorId = new Map();
let entradaEditandoId = null;
const MERMA_DEFAULT_PRENSADO = 30;
const MERMA_DEFAULT_SANGRADO = 40;
const MERMA_DEFAULT_GENERAL = 0;
const FACTOR_MERMA_PRENSA = MERMA_DEFAULT_PRENSADO / 100;
const FACTOR_MERMA_TRASIEGO = 0.02;
const ESTADOS_DEPOSITO_UI = [
  { id: "fa", label: "FA", descripcion: "Fermentación alcohólica", color: "#d85c5c" },
  { id: "fml", label: "FML", descripcion: "Fermentación maloláctica", color: "#c47d21" },
  { id: "reposo", label: "Reposo", descripcion: "Reposo / Crianza", color: "#8c6ff7" },
  { id: "limpio", label: "Limpio", descripcion: "Limpio y listo", color: "#40a578" },
  { id: "vacio", label: "Vacío", descripcion: "Vacío", color: "#9ba1b0" },
  { id: "mantenimiento", label: "Mant.", descripcion: "Mantenimiento / Limpieza", color: "#f0a500" },
  { id: "analitica", label: "Analítica", descripcion: "Analítica pendiente", color: "#ff7aa8" },
];
const TIPOS_NODO_CONTENEDOR = new Set(["deposito", "barrica", "almacen", "coupage"]);
const VOLUMEN_BOTELLA_L = {
  "Split 0,187 L": 0.187,
  "Demi 0,375 L": 0.375,
  "Borgoña 0,75 L": 0.75,
  "Bordelesa 0,75 L": 0.75,
  "Magnum 1,5 L": 1.5,
  "Doble Magnum 3 L": 3,
  "Jeroboam 3 L": 3,
  "Rehoboam 4,5 L": 4.5,
  "Methuselah 6 L": 6,
  "Salmanazar 9 L": 9,
  "Balthazar 12 L": 12,
  "Nebuchadnezzar 15 L": 15,
};

function obtenerInfoEstadoDeposito(id) {
  if (!id) return ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
  return ESTADOS_DEPOSITO_UI.find(e => e.id === id) || ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
}

function poblarSelectEstados(selectId, placeholder = "Selecciona estado") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder;
    opt.disabled = true;
    opt.selected = true;
    select.appendChild(opt);
  }
  ESTADOS_DEPOSITO_UI.forEach(estado => {
    const option = document.createElement("option");
    option.value = estado.id;
    option.textContent = `${estado.label} · ${estado.descripcion}`;
    select.appendChild(option);
  });
  if (valorActual) {
    const existente = Array.from(select.options).find(op => op.value === valorActual);
    if (existente) {
      select.value = valorActual;
    }
  }
}

function claveContenedor(tipo) {
  if (!tipo) return "";
  const normal = tipo.toString().toLowerCase();
  if (normal.includes("barrica")) return "barrica";
  return "deposito";
}

function poblarSelectContenedorCrianza(select, tipoPreferido = "", valorId = "") {
  if (!select) return;
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Selecciona depósito o barrica";
  placeholder.disabled = true;
  if (!valorId) {
    placeholder.selected = true;
  }
  select.appendChild(placeholder);
  const agregarOpciones = (lista, tipoLabel) => {
    if (!Array.isArray(lista)) return;
    const tipoKey = tipoLabel === "Barrica" ? "barrica" : "deposito";
    lista.forEach(item => {
      const option = document.createElement("option");
      option.value = `${tipoKey}:${item.id}`;
      option.dataset.tipo = tipoKey;
      option.dataset.id = item.id;
      const etiquetaBase = item.codigo || item.nombre || item.etiqueta || "";
      const fallback = tipoLabel === "Barrica" ? `Barrica #${item.id}` : `Depósito #${item.id}`;
      option.textContent = `${tipoLabel} · ${etiquetaBase || fallback}`;
      select.appendChild(option);
    });
  };
  agregarOpciones(cacheDepositos, "Depósito");
  agregarOpciones(cacheBarricas, "Barrica");
  let valorSeleccionado = "";
  if (valorId) {
    const tipoKey = claveContenedor(tipoPreferido) || "deposito";
    valorSeleccionado = `${tipoKey}:${valorId}`;
  }
  if (valorSeleccionado) {
    select.value = valorSeleccionado;
  } else {
    select.selectedIndex = 0;
  }
}

async function manejarRespuesta(res, mensajeError) {
  if (res.ok) return true;
  let info = null;
  try {
    info = await res.json();
  } catch (e) {}
  mostrarAviso((info && info.error) || mensajeError, "error");
  return false;
}

function actualizarBarra(idBar, idLabel, valor, unidad, max) {
  const bar = document.getElementById(idBar);
  const label = document.getElementById(idLabel);
  if (label) {
    const rounded = Math.round(valor).toLocaleString();
    label.textContent = `${rounded} ${unidad}`;
  }
  if (bar) {
    const porcentaje = max > 0 ? Math.max(8, (valor / max) * 100) : 0;
    bar.style.width = `${Math.min(100, porcentaje)}%`;
  }
}

function calcularLitrosResumenDesdeCaches() {
  const sumarLitros = (lista, tipoNodo) =>
    (lista || []).reduce((acc, item) => {
      const capacidad = Number(item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)) || 0;
      const volNodo = tipoNodo ? obtenerVolumenFinalNodoContenedor(tipoNodo, item.id) : null;
      const volumenFallback = Number(item.litros_actuales ?? 0) || 0;
      const volumen = Number.isFinite(volNodo) ? Number(volNodo) : volumenFallback;
      return { capacidad: acc.capacidad + capacidad, volumen: acc.volumen + (Number.isFinite(volumen) ? volumen : 0) };
    }, { capacidad: 0, volumen: 0 });

  const dep = sumarLitros(cacheDepositos, "deposito");
  const mast = sumarLitros(cacheMastelones, "deposito");
  const bar = sumarLitros(cacheBarricas, "barrica");
  const kilos = (cacheEntradas || []).reduce((acc, e) => acc + (Number(e.kilos) || 0), 0);

  return {
    kilos_entrados: kilos,
    litros_depositos: dep.volumen,
    litros_mastelones: mast.volumen,
    litros_barricas: bar.volumen,
  };
}

function refrescarGraficosResumenDesdeCaches() {
  const chartKilos = document.getElementById("chartKilosValue");
  const chartLitros = document.getElementById("chartLitrosValue");
  if (!chartKilos || !chartLitros) return;
  const calculado = calcularLitrosResumenDesdeCaches();
  actualizarGraficosResumen(calculado);
}

function actualizarGraficosResumen(data) {
  const calculado = calcularLitrosResumenDesdeCaches();
  const elegir = (valorApi, valorLocal) => {
    const apiNum = Number(valorApi);
    if (Number.isFinite(apiNum) && apiNum > 0) return apiNum;
    const localNum = Number(valorLocal);
    return Number.isFinite(localNum) ? localNum : 0;
  };
  const kilos = elegir(data?.kilos_entrados, calculado.kilos_entrados);
  const litrosDepositos = elegir(data?.litros_depositos, calculado.litros_depositos);
  const litrosMastelones = elegir(data?.litros_mastelones, calculado.litros_mastelones);
  const litrosBarricas = elegir(data?.litros_barricas, calculado.litros_barricas);
  const litrosTotales = litrosDepositos + litrosMastelones + litrosBarricas;
  const maxValor = Math.max(kilos, litrosTotales, 1);

  actualizarBarra("chartKilosBar", "chartKilosValue", kilos, "kg", maxValor);
  actualizarBarra("chartLitrosBar", "chartLitrosValue", litrosTotales, "L", maxValor);

  const detalle = document.getElementById("chartLitrosDetalle");
  if (detalle) {
    const depTxt = `${Math.round(litrosDepositos).toLocaleString()} L`;
    const mastTxt = `${Math.round(litrosMastelones).toLocaleString()} L`;
    const barrTxt = `${Math.round(litrosBarricas).toLocaleString()} L`;
    detalle.innerHTML = `
      🛢 Depósitos: ${depTxt} ·
      🪣 Mastelones: ${mastTxt} ·
      <span style="display:inline-flex; align-items:center; gap:4px;">
        <img src="/barricas.png" alt="Barricas" style="width:16px; height:16px; object-fit:contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); mix-blend-mode:multiply; background:transparent;">
        Barricas: ${barrTxt}
      </span>
    `;
  }
}

function formatearNumeroCorto(valor) {
  const num = Number(valor) || 0;
  if (Math.abs(num) >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (Math.abs(num) >= 1000) return `${(num / 1000).toFixed(1)}k`;
  return num.toLocaleString("es-ES", { maximumFractionDigits: 0 });
}

function actualizarIndicadores() {
  const depPrincipal = document.getElementById("indicadorDepositosPrincipal");
  if (!depPrincipal) return;

  const calcularTotales = (lista, tipoNodo) =>
    (lista || []).reduce(
      (acc, item) => {
        const capacidad = Number(
          item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)
        ) || 0;
        const volNodo = tipoNodo ? obtenerVolumenFinalNodoContenedor(tipoNodo, item.id) : null;
        const volumen = Number.isFinite(volNodo)
          ? Number(volNodo)
          : (Number(item.litros_actuales || 0) || 0);
        return {
          capacidad: acc.capacidad + capacidad,
          volumen: acc.volumen + volumen,
        };
      },
      { capacidad: 0, volumen: 0 }
    );

  const dep = calcularTotales(cacheDepositos, "deposito");
  const depPorcentaje = dep.capacidad > 0 ? Math.round((dep.volumen / dep.capacidad) * 100) : 0;
  depPrincipal.textContent = `${depPorcentaje}% ocupado`;
  const depDetalle = document.getElementById("indicadorDepositosDetalle");
  if (depDetalle) {
    depDetalle.textContent = `${formatearLitrosPlano(dep.volumen)} de ${formatearLitrosPlano(
      dep.capacidad
    )}`;
  }
  const depExtra = document.getElementById("indicadorDepositosExtra");
  if (depExtra) {
    const libre = Math.max(dep.capacidad - dep.volumen, 0);
    depExtra.textContent = libre
      ? `${formatearLitrosPlano(libre)} libres`
      : "Sin capacidad libre";
  }

  const mast = calcularTotales(cacheMastelones, "deposito");
  const mastPrincipal = document.getElementById("indicadorMastelonesPrincipal");
  if (mastPrincipal) {
    const mastPorcentaje =
      mast.capacidad > 0 ? Math.round((mast.volumen / mast.capacidad) * 100) : 0;
    mastPrincipal.textContent = `${mastPorcentaje}% ocupado`;
    const mastDetalle = document.getElementById("indicadorMastelonesDetalle");
    if (mastDetalle) {
      mastDetalle.textContent = `${formatearLitrosPlano(mast.volumen)} de ${formatearLitrosPlano(
        mast.capacidad
      )}`;
    }
    const mastExtra = document.getElementById("indicadorMastelonesExtra");
    if (mastExtra) {
      const libre = Math.max(mast.capacidad - mast.volumen, 0);
      mastExtra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Sin capacidad libre";
    }
  }

  const bar = calcularTotales(cacheBarricas, "barrica");
  const barPrincipal = document.getElementById("indicadorBarricasPrincipal");
  if (barPrincipal) {
    const barPorcentaje = bar.capacidad > 0 ? Math.round((bar.volumen / bar.capacidad) * 100) : 0;
    barPrincipal.textContent = `${barPorcentaje}% ocupado`;
    const detalle = document.getElementById("indicadorBarricasDetalle");
    if (detalle) {
      detalle.textContent = `${formatearLitrosPlano(bar.volumen)} de ${formatearLitrosPlano(
        bar.capacidad
      )}`;
    }
    const extra = document.getElementById("indicadorBarricasExtra");
    if (extra) {
      const libre = Math.max(bar.capacidad - bar.volumen, 0);
      extra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Barricas al máximo";
    }
  }

  const totalBotellas = (cacheEmbotellados || []).reduce(
    (acc, e) => acc + (Number(e.botellas) || 0),
    0
  );
  const embPrincipal = document.getElementById("indicadorEmbotelladosPrincipal");
  if (embPrincipal) {
    embPrincipal.textContent = `${formatearNumeroCorto(totalBotellas)} botellas`;
    const detalle = document.getElementById("indicadorEmbotelladosDetalle");
    if (detalle) {
      detalle.textContent = totalBotellas
        ? `${totalBotellas.toLocaleString("es-ES")} botellas embotelladas`
        : "Aún no hay embotellados recientes";
    }
  }
}
function actualizarAprovechamientoAnual() {
  const tbody = document.getElementById("tablaAprovechamiento");
  if (!tbody) return;

  const kilosPorAnada = {};
  (cacheEntradas || []).forEach(e => {
    const anada = (e.anada || obtenerAnadaDesdeFecha(e.fecha || "") || "Sin añada").toString();
    const kilos = Number(e.kilos || 0);
    kilosPorAnada[anada] = (kilosPorAnada[anada] || 0) + kilos;
  });

  const litrosPorAnada = {};
  const acumularLitros = (coleccion, campoAnada) => {
    coleccion.forEach(item => {
      const litros = Number(item.litros_actuales || 0);
      if (!litros) return;
      const anada = (item[campoAnada] || "Sin añada").toString();
      litrosPorAnada[anada] = (litrosPorAnada[anada] || 0) + litros;
    });
  };
  acumularLitros(cacheDepositos || [], "vino_anio");
  acumularLitros(cacheMastelones || [], "vino_anio");
  acumularLitros(cacheBarricas || [], "vino_anio");

  const todas = Array.from(new Set([...Object.keys(kilosPorAnada), ...Object.keys(litrosPorAnada)]));
  todas.sort((a, b) => {
    const numA = Number(a);
    const numB = Number(b);
    if (Number.isNaN(numA) || Number.isNaN(numB)) return a.localeCompare(b);
    return numB - numA;
  });

  tbody.innerHTML = "";
  if (!todas.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="4">No hay datos disponibles todavía.</td>';
    tbody.appendChild(tr);
    return;
  }

  todas.forEach(anada => {
    const kilos = kilosPorAnada[anada] || 0;
    const litros = litrosPorAnada[anada] || 0;
    const aprovechamiento = kilos > 0 ? ((litros / kilos) * 100) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${anada}</td>
      <td>${kilos.toLocaleString("es-ES", { maximumFractionDigits: 0 })} kg</td>
      <td>${litros.toLocaleString("es-ES", { maximumFractionDigits: 1 })} L</td>
      <td>${aprovechamiento.toFixed(1)} %</td>
    `;
    tbody.appendChild(tr);
  });
}

function limitarZoomPlanoBodega(valor) {
  const z = Number(valor);
  if (!Number.isFinite(z)) return 1;
  return Math.max(PLANO_ZOOM_MIN, Math.min(PLANO_ZOOM_MAX, z));
}

function actualizarZoomPlanoBodegaUI() {
  const label = document.getElementById("planoZoomLabel");
  if (label) {
    label.textContent = `${Math.round((planoZoom || 1) * 100)}%`;
  }
  const range = document.getElementById("planoZoomRange");
  if (range) {
    range.value = String(Math.round((planoZoom || 1) * 100));
  }
}

function aplicarZoomPlanoBodega(nuevoZoom, opciones = {}) {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const prevZoom = planoZoom || 1;
  const centroWorld = opciones.centroWorld || {
    x: (editor.scrollLeft + editor.clientWidth / 2) / prevZoom,
    y: (editor.scrollTop + editor.clientHeight / 2) / prevZoom,
  };

  planoZoom = limitarZoomPlanoBodega(nuevoZoom);
  try {
    localStorage.setItem("planoZoom", String(planoZoom));
  } catch (e) {
    // noop
  }

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;
  canvas.style.transform = `scale(${planoZoom})`;
  stage.style.width = `${planoWorldBase.width * planoZoom}px`;
  stage.style.height = `${planoWorldBase.height * planoZoom}px`;

  editor.scrollLeft = Math.max(0, centroWorld.x * planoZoom - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centroWorld.y * planoZoom - editor.clientHeight / 2);

  actualizarZoomPlanoBodegaUI();
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function zoomPlanoBodega(direccion) {
  const signo = direccion < 0 ? -1 : 1;
  aplicarZoomPlanoBodega((planoZoom || 1) + signo * PLANO_ZOOM_STEP);
}

function resetZoomPlanoBodega() {
  aplicarZoomPlanoBodega(1);
}

function setZoomPlanoBodega(valorPorcentaje) {
  const pct = Number(valorPorcentaje);
  if (!Number.isFinite(pct)) return;
  aplicarZoomPlanoBodega(pct / 100);
}

function esSeccionPlanoActiva() {
  const sec = document.getElementById("plano");
  return Boolean(sec && sec.classList.contains("visible"));
}

function actualizarModoManoPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const activo = Boolean(planoPanBloqueado || planoPanSpace);
  editor.classList.toggle("pan-activo", activo);
}

function toggleModoManoPlanoBodega() {
  planoPanBloqueado = !planoPanBloqueado;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarPanPlanoBodega(ev, editor) {
  if (!editor) return;
  if (planoPanDrag) return;
  ev.preventDefault();
  planoPanDrag = {
    editor,
    pointerId: ev.pointerId,
    startX: ev.clientX,
    startY: ev.clientY,
    startScrollLeft: editor.scrollLeft,
    startScrollTop: editor.scrollTop,
  };
  editor.classList.add("panning");
  try {
    editor.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  editor.addEventListener("pointermove", moverPanPlanoBodega);
  editor.addEventListener("pointerup", finalizarPanPlanoBodega);
  editor.addEventListener("pointercancel", finalizarPanPlanoBodega);
}

function moverPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, startX, startY, startScrollLeft, startScrollTop } = planoPanDrag;
  const dx = ev.clientX - startX;
  const dy = ev.clientY - startY;
  editor.scrollLeft = startScrollLeft - dx;
  editor.scrollTop = startScrollTop - dy;
  programarActualizacionMinimapPlanoBodega();
}

function finalizarPanPlanoBodega(ev) {
  if (!planoPanDrag || ev.pointerId !== planoPanDrag.pointerId) return;
  const { editor, pointerId } = planoPanDrag;
  try {
    editor.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  editor.classList.remove("panning");
  editor.removeEventListener("pointermove", moverPanPlanoBodega);
  editor.removeEventListener("pointerup", finalizarPanPlanoBodega);
  editor.removeEventListener("pointercancel", finalizarPanPlanoBodega);
  planoPanDrag = null;
}

function manejarPointerDownPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;
  const target = ev.target;
  if (target && target.closest && target.closest(".plano-item")) return;

  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanBloqueado || planoPanSpace || boton === 1);
  if (esPan) {
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  limpiarSeleccionPlanoBodega();
}

function manejarWheelPlanoEditor(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (!(ev.ctrlKey || ev.metaKey)) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  ev.preventDefault();
  const signo = ev.deltaY < 0 ? 1 : -1;
  const nuevoZoom = (planoZoom || 1) + signo * PLANO_ZOOM_STEP;
  const rect = editor.getBoundingClientRect();
  const pointerX = ev.clientX - rect.left;
  const pointerY = ev.clientY - rect.top;
  const centroWorld = {
    x: (editor.scrollLeft + pointerX) / (planoZoom || 1),
    y: (editor.scrollTop + pointerY) / (planoZoom || 1),
  };
  aplicarZoomPlanoBodega(nuevoZoom, { centroWorld });
}

function onPlanoKeyDown(ev) {
  if (!esSeccionPlanoActiva()) return;
  if (ev.code !== "Space") return;
  const target = ev.target;
  if (
    target &&
    (target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.tagName === "SELECT" ||
      target.isContentEditable)
  ) {
    return;
  }
  if (planoPanSpace) return;
  planoPanSpace = true;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function onPlanoKeyUp(ev) {
  if (ev.code !== "Space") return;
  if (!planoPanSpace) return;
  planoPanSpace = false;
  actualizarModoManoPlanoBodegaUI();
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  ev.preventDefault();
}

function programarActualizacionMinimapPlanoBodega() {
  if (planoMinimapRaf) return;
  planoMinimapRaf = requestAnimationFrame(() => {
    planoMinimapRaf = null;
    actualizarMinimapPlanoBodega();
  });
}

function seleccionarPlanoBodegaPorClave(tipo, id, opciones = {}) {
  if (!tipo || id == null) return;
  planoSeleccion = { tipo, id };
  renderPlano();
  if (opciones.centrar) {
    requestAnimationFrame(() => centrarSeleccionPlanoBodega());
  }
}

function inicializarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const viewport = document.getElementById("planoMinimapViewport");
  if (!world || !viewport) return;
  const editor = document.getElementById("planoEditor");
  if (!editor) return;

  const iniciar = ev => {
    if (ev.button != null && ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    try {
      world.setPointerCapture(ev.pointerId);
    } catch (e) {
      // noop
    }
    planoMinimapDrag = { pointerId: ev.pointerId, world, editor };
    moverDesdeMinimapPlanoBodega(ev);
    world.addEventListener("pointermove", moverDesdeMinimapPlanoBodega);
    world.addEventListener("pointerup", finalizarMinimapPlanoBodega);
    world.addEventListener("pointercancel", finalizarMinimapPlanoBodega);
  };

  world.onpointerdown = iniciar;
  viewport.onpointerdown = ev => {
    ev.stopPropagation();
    iniciar(ev);
  };
}

function moverDesdeMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, editor } = planoMinimapDrag;
  const rect = world.getBoundingClientRect();
  const relX = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
  const worldX = (relX / rect.width) * (planoWorldBase.width || 1);
  const worldY = (relY / rect.height) * (planoWorldBase.height || 1);
  editor.scrollLeft = Math.max(0, worldX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, worldY * (planoZoom || 1) - editor.clientHeight / 2);
  programarActualizacionMinimapPlanoBodega();
}

function finalizarMinimapPlanoBodega(ev) {
  if (!planoMinimapDrag || ev.pointerId !== planoMinimapDrag.pointerId) return;
  const { world, pointerId } = planoMinimapDrag;
  try {
    world.releasePointerCapture(pointerId);
  } catch (e) {
    // noop
  }
  world.removeEventListener("pointermove", moverDesdeMinimapPlanoBodega);
  world.removeEventListener("pointerup", finalizarMinimapPlanoBodega);
  world.removeEventListener("pointercancel", finalizarMinimapPlanoBodega);
  planoMinimapDrag = null;
}

function actualizarMinimapPlanoBodega() {
  const world = document.getElementById("planoMinimapWorld");
  const dotsHost = document.getElementById("planoMinimapDots");
  const viewport = document.getElementById("planoMinimapViewport");
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!world || !dotsHost || !viewport || !editor || !canvas) return;

  const aspect = (planoWorldBase.height || 1) / (planoWorldBase.width || 1);
  const targetH = Math.round(world.clientWidth * aspect);
  world.style.height = `${Math.max(120, Math.min(220, targetH))}px`;

  const mmRect = world.getBoundingClientRect();
  const mmW = mmRect.width || 1;
  const mmH = mmRect.height || 1;
  const zoom = planoZoom || 1;
  const worldW = planoWorldBase.width || 1;
  const worldH = planoWorldBase.height || 1;

  const viewX = editor.scrollLeft / zoom;
  const viewY = editor.scrollTop / zoom;
  const viewW = editor.clientWidth / zoom;
  const viewH = editor.clientHeight / zoom;

  viewport.style.left = `${(viewX / worldW) * mmW}px`;
  viewport.style.top = `${(viewY / worldH) * mmH}px`;
  viewport.style.width = `${(viewW / worldW) * mmW}px`;
  viewport.style.height = `${(viewH / worldH) * mmH}px`;

  const cardWidth = PLANO_CARD_WIDTH;
  const itemEls = Array.from(canvas.querySelectorAll(".plano-item"));
  dotsHost.innerHTML = "";
  itemEls.forEach(el => {
    const tipo = el.dataset.tipo || "";
    const id = el.dataset.id || "";
    const codigo = el.dataset.codigo || "";
    const xPct = parseFloat(el.dataset.posx || "") || 0;
    const yPct = parseFloat(el.dataset.posy || "") || 0;
    const elH = el.offsetHeight || PLANO_CARD_HEIGHT_BASE;
    const worldX = (xPct / 100) * worldW + cardWidth / 2;
    const worldY = (yPct / 100) * worldH + elH / 2;
    const x = (worldX / worldW) * mmW;
    const y = (worldY / worldH) * mmH;
    const dot = document.createElement("div");
    dot.className = `plano-minimap-dot ${tipo}`;
    if (el.classList.contains("seleccionado")) dot.classList.add("seleccionado");
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.title = tipo ? `${tipo} ${codigo || `#${id}`}` : "Contenedor";
    dot.addEventListener("pointerdown", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      seleccionarPlanoBodegaPorClave(tipo, id, { centrar: true });
    });
    dotsHost.appendChild(dot);
  });
}

function limpiarSeleccionPlanoBodega() {
  planoSeleccion = null;
  planoSeleccionItemActual = null;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  renderInspectorPlanoBodega(null);
}

function seleccionarPlanoBodega(item, elemento) {
  if (!item || !item.tipo || item.id == null) return;
  planoSeleccion = { tipo: item.tipo, id: item.id };
  planoSeleccionItemActual = item;
  const canvas = document.getElementById("planoCanvas");
  if (canvas) {
    canvas.querySelectorAll(".plano-item.seleccionado").forEach(el => el.classList.remove("seleccionado"));
  }
  if (elemento) elemento.classList.add("seleccionado");
  renderInspectorPlanoBodega(item);
}

function abrirSeleccionPlanoBodega() {
  if (!planoSeleccionItemActual) return;
  irAlContenedor(planoSeleccionItemActual);
}

function centrarSeleccionPlanoBodega() {
  if (!planoSeleccion) return;
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const selector = `.plano-item[data-tipo="${planoSeleccion.tipo}"][data-id="${planoSeleccion.id}"]`;
  const el = canvas.querySelector(selector);
  if (!el) return;

  const xPct = parseFloat(el.dataset.posx || "") || 0;
  const yPct = parseFloat(el.dataset.posy || "") || 0;
  const centerX = (xPct / 100) * planoWorldBase.width + el.offsetWidth / 2;
  const centerY = (yPct / 100) * planoWorldBase.height + el.offsetHeight / 2;
  editor.scrollLeft = Math.max(0, centerX * (planoZoom || 1) - editor.clientWidth / 2);
  editor.scrollTop = Math.max(0, centerY * (planoZoom || 1) - editor.clientHeight / 2);
}

function ajustarVistaPlanoBodega() {
  const editor = document.getElementById("planoEditor");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !canvas) return;
  const items = Array.from(canvas.querySelectorAll(".plano-item"));
  if (!items.length) {
    resetZoomPlanoBodega();
    editor.scrollLeft = 0;
    editor.scrollTop = 0;
    return;
  }

  const baseW = planoWorldBase.width || canvas.clientWidth || 1200;
  const baseH = planoWorldBase.height || canvas.clientHeight || 620;
  const cardWidth = PLANO_CARD_WIDTH;
  const cardWPercent = (cardWidth / baseW) * 100;

  let minX = 100;
  let minY = 100;
  let maxX = 0;
  let maxY = 0;
  items.forEach(el => {
    const x = parseFloat(el.dataset.posx || "") || 0;
    const y = parseFloat(el.dataset.posy || "") || 0;
    const cardHPercent = ((el.offsetHeight || PLANO_CARD_HEIGHT_BASE) / baseH) * 100;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + cardWPercent);
    maxY = Math.max(maxY, y + cardHPercent);
  });

  const bboxW = ((maxX - minX) / 100) * baseW;
  const bboxH = ((maxY - minY) / 100) * baseH;
  if (!(bboxW > 0 && bboxH > 0)) return;

  const padding = 0.92;
  const zoom = padding * Math.min(editor.clientWidth / bboxW, editor.clientHeight / bboxH);
  const centerX = (((minX + maxX) / 2) / 100) * baseW;
  const centerY = (((minY + maxY) / 2) / 100) * baseH;
  aplicarZoomPlanoBodega(zoom, { centroWorld: { x: centerX, y: centerY } });
}

function inicializarPlanoBodegaUI() {
  const editor = document.getElementById("planoEditor");
  const stage = document.getElementById("planoStage");
  const canvas = document.getElementById("planoCanvas");
  if (!editor || !stage || !canvas) return;

  const baseW = parseFloat(canvas.style.width) || canvas.clientWidth || canvas.offsetWidth || 2800;
  const baseH = parseFloat(canvas.style.height) || canvas.clientHeight || canvas.offsetHeight || 1600;
  planoWorldBase = {
    width: Math.max(600, Math.round(baseW)),
    height: Math.max(520, Math.round(baseH)),
  };

  canvas.style.width = `${planoWorldBase.width}px`;
  canvas.style.height = `${planoWorldBase.height}px`;

  if (!planoUIInicializada) {
    editor.addEventListener("pointerdown", manejarPointerDownPlanoEditor);
    editor.addEventListener("wheel", manejarWheelPlanoEditor, { passive: false });
    editor.addEventListener("scroll", programarActualizacionMinimapPlanoBodega, { passive: true });
    window.addEventListener("keydown", onPlanoKeyDown);
    window.addEventListener("keyup", onPlanoKeyUp);
    window.addEventListener("resize", programarActualizacionMinimapPlanoBodega);
    planoUIInicializada = true;
  }

  let initZoom = 1;
  try {
    const saved = Number(localStorage.getItem("planoZoom"));
    if (Number.isFinite(saved) && saved > 0) {
      initZoom = saved;
    } else {
      const fit = Math.min(
        1,
        (editor.clientWidth || planoWorldBase.width) / planoWorldBase.width,
        (editor.clientHeight || planoWorldBase.height) / planoWorldBase.height
      );
      initZoom = fit;
    }
  } catch (e) {
    // noop
  }
  aplicarZoomPlanoBodega(initZoom);
  renderInspectorPlanoBodega(planoSeleccionItemActual);
  actualizarModoManoPlanoBodegaUI();
  programarActualizacionMinimapPlanoBodega();
}

function renderInspectorPlanoBodega(item) {
  const panel = document.getElementById("planoInfo");
  if (!panel) return;
  const escapeHtml = value =>
    String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");

  const zoomPct = Math.round((planoZoom || 1) * 100);
  const zoomMin = Math.round(PLANO_ZOOM_MIN * 100);
  const zoomMax = Math.round(PLANO_ZOOM_MAX * 100);
  const modoManoActivo = Boolean(planoPanBloqueado);
  const modoManoBtnClass = modoManoActivo ? "btnPrimario" : "btnSecundario";
  const modoManoBtnLabel = modoManoActivo ? "🖐 Mano: ON" : "🖐 Mano";

  const zoomHtml = `
    <div class="plano-zoom-controls">
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(-1)" title="Alejar" aria-label="Alejar">−</button>
      <button class="btnSecundario plano-zoom-label" id="planoZoomLabel" type="button" onclick="resetZoomPlanoBodega()" title="Reset zoom" aria-label="Reset zoom">${zoomPct}%</button>
      <button class="btnSecundario plano-zoom-btn" type="button" onclick="zoomPlanoBodega(1)" title="Acercar" aria-label="Acercar">+</button>
    </div>
    <input class="plano-zoom-range" id="planoZoomRange" type="range" min="${zoomMin}" max="${zoomMax}" step="5" value="${zoomPct}" oninput="setZoomPlanoBodega(this.value)" aria-label="Zoom del plano" />
  `;

  const minimapHtml = `
    <div class="plano-minimap-world" id="planoMinimapWorld" aria-label="Minimapa del plano" role="img">
      <div class="plano-minimap-grid"></div>
      <div class="plano-minimap-dots" id="planoMinimapDots"></div>
      <div class="plano-minimap-viewport" id="planoMinimapViewport"></div>
    </div>
    <div class="plano-minimap-hint">Minimapa: clic o arrastra para moverte · Space o “Mano” para arrastrar el lienzo</div>
  `;

  const baseHeader = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🛢</div>
      <div>
        <div class="flow-inspector-title">Inspector del plano</div>
        <div class="flow-inspector-sub">Selecciona un depósito, mastelone o barrica para ver el desglose.</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
  `;

  if (!item) {
    panel.innerHTML = `
      ${baseHeader}
      <div class="flow-inspector-tags">
        <span class="flow-tag">Click: seleccionar</span>
        <span class="flow-tag">Arrastrar: mover</span>
        <span class="flow-tag">Doble clic: abrir ficha</span>
        <span class="flow-tag">Space/Mano: pan</span>
        <span class="flow-tag">Click fuera: limpiar</span>
      </div>
      <dl class="flow-inspector-fields">
        <div class="flow-field"><dt>Consejo</dt><dd>Usa “Ajustar vista” para ver todos los contenedores.</dd></div>
      </dl>
    `;
    inicializarMinimapPlanoBodega();
    programarActualizacionMinimapPlanoBodega();
    actualizarModoManoPlanoBodegaUI();
    return;
  }

  const etiquetaBase = item.tipo === "deposito" ? "Dep" : item.tipo === "mastelone" ? "Mas" : "Bar";
  const etiqueta = item.codigo ? `${etiquetaBase} ${item.codigo}` : `${etiquetaBase} #${item.id}`;
  const subtitulo = item.tipo === "deposito" ? "Depósito" : item.tipo === "mastelone" ? "Mastelone" : "Barrica";
  const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
  const volumen = item.volumen != null ? Number(item.volumen) : 0;
  const libre = capacidad && capacidad > 0 ? Math.max(capacidad - volumen, 0) : null;
  const porcentaje =
    capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

  const estadoTexto =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? obtenerInfoEstadoDeposito(item.estado)?.descripcion || ""
      : "";
  const vinoTipo = item.variedadNodo || item.vino_tipo || "";
  const vinoAnio = item.vino_anio || "";

  const tags = [
    `Tipo: ${subtitulo}`,
    capacidad && capacidad > 0 ? `Llenado: ${porcentaje}%` : "Sin capacidad",
    item.enMapa ? "Fuente: mapa de nodos" : "Fuente: ficha",
  ];

  const filas = [
    { label: "Código", value: etiqueta },
    { label: "Capacidad", value: capacidad != null ? formatearLitrosPlano(capacidad) : "—" },
    { label: "Contenido", value: formatearLitrosPlano(volumen) },
    { label: "Libre", value: libre != null ? formatearLitrosPlano(libre) : "—" },
    vinoTipo ? { label: "Vino", value: vinoTipo } : null,
    vinoAnio ? { label: "Añada", value: vinoAnio } : null,
    estadoTexto ? { label: "Estado", value: estadoTexto } : null,
    item.tipo !== "barrica" && item.contenido ? { label: "Material", value: item.contenido } : null,
    item.tipo !== "barrica" && item.elaboracion ? { label: "Elaboración", value: item.elaboracion } : null,
    item.tipo === "barrica" && item.detalle ? { label: "Roble / tostado", value: item.detalle } : null,
    item.tipo === "barrica" && item.marca ? { label: "Marca", value: item.marca } : null,
    item.tipo === "barrica" && item.anio ? { label: "Año barrica", value: item.anio } : null,
    item.tipo !== "barrica" && item.detalle ? { label: "Notas", value: item.detalle } : null,
  ].filter(Boolean);

  panel.innerHTML = `
    <div class="flow-inspector-header">
      <div class="flow-inspector-icon">🧭</div>
      <div>
        <div class="flow-inspector-title">${escapeHtml(etiqueta)}</div>
        <div class="flow-inspector-sub">${escapeHtml(subtitulo)}</div>
      </div>
    </div>
    ${zoomHtml}
    <div class="plano-inspector-actions">
      <button class="${modoManoBtnClass}" type="button" onclick="toggleModoManoPlanoBodega()">${modoManoBtnLabel}</button>
      <button class="btnSecundario" type="button" onclick="ajustarVistaPlanoBodega()">Ajustar vista</button>
      <button class="btnSecundario" type="button" onclick="centrarSeleccionPlanoBodega()">Centrar</button>
      <button class="btnPrimario" type="button" onclick="abrirSeleccionPlanoBodega()">Abrir ficha</button>
      <button class="btnSecundario" type="button" onclick="limpiarSeleccionPlanoBodega()">Limpiar</button>
    </div>
    ${minimapHtml}
    <div class="flow-inspector-tags">${tags.map(t => `<span class="flow-tag">${escapeHtml(t)}</span>`).join("")}</div>
    <dl class="flow-inspector-fields">${filas
      .map(
        item =>
          `<div class="flow-field"><dt>${escapeHtml(item.label)}</dt><dd>${escapeHtml(item.value)}</dd></div>`
      )
      .join("")}</dl>
  `;
  inicializarMinimapPlanoBodega();
  programarActualizacionMinimapPlanoBodega();
  actualizarModoManoPlanoBodegaUI();
}

function renderPlano() {
  const canvas = document.getElementById("planoCanvas");
  const mensaje = document.getElementById("planoMensaje");
  if (!canvas || !mensaje) return;

  const canvasWidth = canvas.clientWidth || canvas.offsetWidth || 600;
  const canvasHeight = canvas.clientHeight || canvas.offsetHeight || 400;
  const cardWidth = PLANO_CARD_WIDTH;
  const offsetXPercent = (cardWidth / canvasWidth) * 100;
  const offsetYPercent = (PLANO_CARD_HEIGHT_MAX / canvasHeight) * 100;

  canvas.innerHTML = "";
  const elementos = [
    ...cacheDepositos.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "deposito",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
    ...cacheMastelones.map(d => {
      const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
      const volumenNodo =
        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(d.composicionVariedades || d.composicion_variedades) ||
        (esVariedadGenerica(d.vino_tipo) ? "" : (d.vino_tipo || ""));
      return {
        tipo: "mastelone",
        id: d.id,
        codigo: d.codigo,
        pos_x: d.pos_x,
        pos_y: d.pos_y,
        capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
        volumen: volumenNodo != null ? volumenNodo : d.litros_actuales ?? 0,
        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
        variedadNodo: variedades,
        detalle: d.material || d.contenido || d.elaboracion || "",
        vino_tipo: d.vino_tipo || "",
        vino_anio: d.vino_anio || "",
        contenido: d.material || d.contenido || "",
        elaboracion: d.elaboracion || "",
        estado: d.estado || "vacio",
        colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
      };
    }),
	    ...cacheBarricas.map(b => {
	      const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
	      const volumenNodo =
	        estadoNodo && estadoNodo.enMapa && estadoNodo.volumen != null ? Number(estadoNodo.volumen) : null;
      const variedades =
        filtrarVariedadesMultilinea(estadoNodo?.variedad || "") ||
        formatearVariedadesMultilinea(b.composicionVariedades || b.composicion_variedades) ||
        (esVariedadGenerica(b.vino_tipo) ? "" : (b.vino_tipo || ""));
	      return {
	        tipo: "barrica",
	        id: b.id,
	        codigo: b.codigo,
	        pos_x: b.pos_x,
	        pos_y: b.pos_y,
	        capacidad: b.capacidad_l ?? null,
	        // Si la barrica no está representada en el mapa de nodos, no mostramos contenido “fantasma”.
	        volumen: volumenNodo != null ? volumenNodo : estadoNodo ? b.litros_actuales ?? 0 : 0,
	        enMapa: Boolean(estadoNodo && estadoNodo.enMapa),
	        variedadNodo: variedades,
	        detalle: [b.tipo_roble, b.tostado].filter(Boolean).join(" · "),
	        vino_tipo: b.vino_tipo || "",
        vino_anio: b.vino_anio || "",
        marca: b.marca || "",
        anio: b.anio || "",
        colorReferencia: b.vino_tipo || "",
      };
    }),
  ];

  if (!elementos.length) {
    mensaje.textContent = "Añade depósitos, mastelones o barricas para empezar.";
    limpiarSeleccionPlanoBodega();
    const placeholder = document.createElement("div");
    placeholder.className = "plano-placeholder";
    placeholder.textContent = "Sin elementos todavía";
    canvas.appendChild(placeholder);
    return;
  }

  mensaje.textContent = "Arrastra las tarjetas para guardar su posición.";
  let seleccionEncontrada = false;
  elementos.forEach((item, idx) => {
    const bloque = document.createElement("div");
    bloque.className = `plano-item ${item.tipo}`;
    bloque.dataset.id = String(item.id);
    bloque.dataset.tipo = item.tipo;
    if (item.codigo != null) bloque.dataset.codigo = String(item.codigo);
    if (planoSeleccion && planoSeleccion.tipo === item.tipo && String(planoSeleccion.id) === String(item.id)) {
      bloque.classList.add("seleccionado");
      seleccionEncontrada = true;
      planoSeleccionItemActual = item;
    }
    const etiqueta = item.codigo ? String(item.codigo) : String(item.id);
    const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
    const volumen = item.volumen != null ? Number(item.volumen) : 0;
    const porcentaje =
      capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

    const header = document.createElement("div");
    header.className = "plano-card-header";
    const subtitulo =
      item.tipo === "deposito"
        ? "Depósito"
        : item.tipo === "mastelone"
        ? "Mastelone"
        : "Barrica";
    header.innerHTML = `
      <div class="plano-card-title-row">
        <span class="plano-card-dot" aria-hidden="true"></span>
        <span class="plano-card-code">${etiqueta}</span>
        <span class="plano-card-pct" title="Porcentaje de llenado">${porcentaje}%</span>
      </div>
      <small><span class="plano-card-material-dot" aria-hidden="true"></span>${subtitulo}</small>
    `;
    const estaVacio = !Number.isFinite(volumen) || volumen <= 0;
    bloque.appendChild(header);

    const body = document.createElement("div");
    body.className = "plano-card-body";
    const materialColor = obtenerColorMaterialContenedor(
      item.tipo === "barrica" ? "Madera" : item.contenido || item.detalle || "",
      item.tipo
    );

    const info = document.createElement("div");
    info.className = "plano-card-info";
    info.innerHTML = `
      <div>
        <small>Capacidad</small>
        <strong>${formatearLitrosPlano(capacidad)}</strong>
      </div>
      <div>
        <small>Contenido</small>
        <strong>${formatearLitrosPlano(volumen)}</strong>
      </div>
    `;
    const visual = document.createElement("div");
    visual.className = "plano-card-visual";
    const icono = document.createElement("div");
    icono.className = "plano-card-icon";
    icono.setAttribute("aria-hidden", "true");
    visual.appendChild(icono);
    visual.appendChild(info);
    body.appendChild(visual);

    const colorTarjeta = materialColor || "#8f97a8";
    const colorPuntoVino = obtenerColorPuntoVinoPlano(item.variedadNodo || item.vino_tipo || "");
    try {
      const acento = colorTarjeta.toString();
      const acentoMaterial = (materialColor || acento).toString();
      bloque.style.setProperty("--plano-accent", acento);
      bloque.style.setProperty("--plano-accent-soft", mezclarHexConBlanco(acento, 0.10, 0.62));
      bloque.style.setProperty("--plano-accent-wash", mezclarHexConBlanco(acento, 0.18, 0.46));
      bloque.style.setProperty("--plano-material", acentoMaterial);
      bloque.style.setProperty("--plano-material-wash", mezclarHexConBlanco(acentoMaterial, 0.18, 0.40));
      bloque.style.setProperty("--plano-wine-dot", colorPuntoVino);
      const pastel = mezclarHexConBlanco(acento, 0.40, 0.72);
      const pastel2 = mezclarHexConBlanco(acento, 0.34, 0.58);
      const pastelMaterial = mezclarHexConBlanco(acentoMaterial, 0.38, 0.52);
      const glow = mezclarHexConBlanco(acento, 0.52, 0.38);
      bloque.style.setProperty(
        "--plano-card-bg",
        `radial-gradient(circle at 14% 10%, ${pastel} 0%, rgba(255,255,255,0) 58%),` +
          `radial-gradient(circle at 88% 86%, ${pastel2} 0%, rgba(255,255,255,0) 62%),` +
          `radial-gradient(circle at 12% 92%, ${pastelMaterial} 0%, rgba(255,255,255,0) 64%),` +
          `linear-gradient(180deg, rgba(255,255,255,0.88), rgba(255,255,255,0.68))`
      );
      bloque.style.setProperty("--plano-card-glow", glow);
    } catch (e) {
      // noop
    }
    const progress = document.createElement("div");
    progress.className = "plano-card-progress";
    const barra = document.createElement("div");
    barra.className = "plano-card-progress-bar";
    barra.style.background = colorTarjeta;
    const alturaBarra = capacidad && capacidad > 0 ? porcentaje : 0;
    barra.style.height = `${alturaBarra}%`;
    const etiquetaPorcentaje = document.createElement("span");
    etiquetaPorcentaje.textContent = `${porcentaje}%`;
    progress.appendChild(barra);
    progress.appendChild(etiquetaPorcentaje);

    bloque.appendChild(progress);
    bloque.appendChild(body);

    const extra = document.createElement("div");
    extra.className = "plano-card-extra";
    const uvasTexto = (item.variedadNodo || item.vino_tipo || "").toString();
    const anioTxt = (item.vino_anio || "").toString().trim();

    if (estaVacio) {
      const estadoInfo = obtenerInfoEstadoDeposito("vacio");
      const vacioBtn = document.createElement("button");
      vacioBtn.type = "button";
      vacioBtn.className = `plano-card-vacio estado-pill estado-${estadoInfo.id}`;
      vacioBtn.textContent = estadoInfo.label;
      vacioBtn.title = "Vacío";
      vacioBtn.addEventListener("pointerdown", ev => {
        ev.stopPropagation();
      });
      vacioBtn.addEventListener("click", ev => {
        ev.stopPropagation();
        seleccionarPlanoBodega(item, bloque);
      });
      extra.appendChild(vacioBtn);
    } else {
      if (anioTxt) {
        const anada = document.createElement("div");
        anada.className = "plano-card-anada";
        anada.textContent = anioTxt;
        anada.title = "Añada";
        extra.appendChild(anada);
      }

      const uvas = document.createElement("div");
      uvas.className = "plano-card-uvas";
      const lineas = (uvasTexto || "")
        .toString()
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(Boolean);
      const visibles = lineas.length ? lineas : ["Sin uva"];
      visibles.forEach(txt => {
        const chip = document.createElement("span");
        chip.className = "plano-card-uva-chip";
        chip.textContent = txt;
        uvas.appendChild(chip);
      });
      uvas.title = uvasTexto || "";
      extra.appendChild(uvas);
    }
    bloque.appendChild(extra);

    // Altura base (luego se ajusta con el contenido real tras insertarla en el DOM).
    bloque.style.setProperty("--plano-card-h", `${PLANO_CARD_HEIGHT_BASE}px`);

  const defaultX = 6 + (idx * 13) % 80;
  const defaultY = 8 + (idx * 17) % 70;
  const x = item.pos_x != null ? item.pos_x : defaultX;
  const y = item.pos_y != null ? item.pos_y : defaultY;

  const clampedX = Math.max(0, Math.min(100 - offsetXPercent, x));
  const clampedY = Math.max(0, Math.min(100 - offsetYPercent, y));
    bloque.style.left = `${clampedX}%`;
    bloque.style.top = `${clampedY}%`;
  bloque.dataset.posx = clampedX;
  bloque.dataset.posy = clampedY;
  bloque.addEventListener("dblclick", () => irAlContenedor(item));

  bloque.addEventListener("pointerdown", ev => iniciarArrastrePlano(ev, item, bloque));
  canvas.appendChild(bloque);

  // Ajuste de altura: crece si el contenido no cabe (variedades, añada, etc.).
  // Antes sólo se ajustaba cuando había saltos de línea en variedades; si una variedad era larga (wrap)
  // o el contenido excedía por tipografía/dispositivo, se quedaba cortado por el overflow.
  if (!estaVacio) {
    const altoNecesario = bloque.scrollHeight || PLANO_CARD_HEIGHT_BASE;
    if (altoNecesario > PLANO_CARD_HEIGHT_BASE) {
      const alto = Math.min(PLANO_CARD_HEIGHT_MAX, Math.max(PLANO_CARD_HEIGHT_BASE, altoNecesario));
      bloque.style.setProperty("--plano-card-h", `${alto}px`);
    }
  }
});

  if (planoSeleccion && !seleccionEncontrada) {
    planoSeleccion = null;
    planoSeleccionItemActual = null;
  }
  renderInspectorPlanoBodega(planoSeleccionItemActual);
}

function iniciarArrastrePlano(ev, item, elemento) {
  const editor = document.getElementById("planoEditor");
  const boton = ev.button ?? 0;
  const esPan = Boolean(planoPanBloqueado || planoPanSpace || boton === 1);
  if (esPan && editor) {
    ev.stopPropagation();
    iniciarPanPlanoBodega(ev, editor);
    return;
  }

  ev.stopPropagation();
  ev.preventDefault();
  const canvas = document.getElementById("planoCanvas");
  if (!canvas) return;
  seleccionarPlanoBodega(item, elemento);
  const rect = elemento.getBoundingClientRect();

  planoDrag = {
    item,
    elemento,
    pointerId: ev.pointerId,
    canvas,
    offsetX: ev.clientX - rect.left,
    offsetY: ev.clientY - rect.top,
    startClientX: ev.clientX,
    startClientY: ev.clientY,
    moved: false,
    startPos: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
    current: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
  };

  try {
    elemento.setPointerCapture(ev.pointerId);
  } catch (e) {
    // noop
  }
  window.addEventListener("pointermove", moverElementoPlano);
  window.addEventListener("pointerup", soltarElementoPlano);
  window.addEventListener("pointercancel", cancelarArrastrePlano);
}

function moverElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  const { canvas, elemento, offsetX, offsetY } = planoDrag;
  const rect = canvas.getBoundingClientRect();
  const elRect = elemento.getBoundingClientRect();

  if (!planoDrag.moved) {
    const dx = ev.clientX - (planoDrag.startClientX || 0);
    const dy = ev.clientY - (planoDrag.startClientY || 0);
    if (Math.hypot(dx, dy) < PLANO_DRAG_THRESHOLD_PX) return;
    planoDrag.moved = true;
    elemento.classList.add("arrastrando");
  }

  let px = ev.clientX - rect.left - offsetX;
  let py = ev.clientY - rect.top - offsetY;

  const maxX = rect.width - elRect.width;
  const maxY = rect.height - elRect.height;

  px = Math.max(0, Math.min(maxX, px));
  py = Math.max(0, Math.min(maxY, py));

  const xPercent = (px / rect.width) * 100;
  const yPercent = (py / rect.height) * 100;

  elemento.style.left = `${xPercent}%`;
  elemento.style.top = `${yPercent}%`;
  elemento.dataset.posx = xPercent;
  elemento.dataset.posy = yPercent;
  planoDrag.current = { x: xPercent, y: yPercent };
}

function soltarElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  finalizarArrastrePlano(true);
}

function cancelarArrastrePlano() {
  finalizarArrastrePlano(false);
}

function finalizarArrastrePlano(guardar) {
  if (!planoDrag) return;
  window.removeEventListener("pointermove", moverElementoPlano);
  window.removeEventListener("pointerup", soltarElementoPlano);
  window.removeEventListener("pointercancel", cancelarArrastrePlano);

  if (planoDrag.elemento) {
    try {
      planoDrag.elemento.releasePointerCapture(planoDrag.pointerId);
    } catch (e) {
      // noop
    }
    planoDrag.elemento.classList.remove("arrastrando");
  }

  if (!planoDrag.moved) {
    planoDrag = null;
    return;
  }

  if (guardar && planoDrag.current) {
    guardarPosicionPlano(planoDrag.item, planoDrag.current.x, planoDrag.current.y);
  } else {
    renderPlano();
  }

  planoDrag = null;
}

async function guardarPosicionPlano(item, x, y) {
  const url =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? `/api/depositos/${item.id}/posicion`
      : `/api/barricas/${item.id}/posicion`;
  const pos = {
    pos_x: Math.round(x * 100) / 100,
    pos_y: Math.round(y * 100) / 100,
  };

  try {
    const res = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pos),
    });
    if (!res.ok) throw new Error("Error HTTP " + res.status);
    actualizarCachePlano(item, pos.pos_x, pos.pos_y);
  } catch (err) {
    console.error("Error guardando posición:", err);
    alert("No se pudo guardar la nueva ubicación. Se restaurará la vista.");
    renderPlano();
  }
}

function actualizarCachePlano(item, x, y) {
  if (item.tipo === "deposito") {
    const dep = cacheDepositos.find(d => d.id === item.id);
    if (dep) {
      dep.pos_x = x;
      dep.pos_y = y;
    }
  } else if (item.tipo === "mastelone") {
    const mas = cacheMastelones.find(d => d.id === item.id);
    if (mas) {
      mas.pos_x = x;
      mas.pos_y = y;
    }
  } else {
    const bar = cacheBarricas.find(b => b.id === item.id);
    if (bar) {
      bar.pos_x = x;
      bar.pos_y = y;
    }
  }
}

// ---------- Resumen (bodega) ----------
async function cargarResumen() {
  try {
    // 1) Resumen principal (kilos, depósitos, barricas)
    const res = await fetch("/api/resumen");
    if (!res.ok) return;
    const data = await res.json();
    const calculado = calcularLitrosResumenDesdeCaches();

    document.getElementById("resumenKilos").textContent =
      (Number(calculado.kilos_entrados || 0) || Number(data.kilos_entrados || 0) || 0).toFixed(0) + " kg";

    document.getElementById("resumenDepositos").textContent =
      data.depositos || 0;

    document.getElementById("resumenBarricas").textContent =
      data.barricas || 0;
    actualizarGraficosResumen({ ...data, ...calculado });

  } catch (err) {
    console.error("Error cargando resumen:", err);
  }
}
        // ---------- Entradas de uva ----------
        async function cargarEntradas() {
            try {
                mostrarSkeletonTabla("tablaEntradas", 13, 4);
                const res = await fetch("/api/entradas-uva");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEntradas = datos;

                const tbody = document.getElementById("tablaEntradas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="13">No hay entradas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const anada = e.anada || obtenerAnadaDesdeFecha(e.fecha || "");
                    const fechaEntrada = formatearFechaCorta(e.fecha);
                    const densidad = formatearDensidad(e.densidad);
                    const temperaturaVal = Number(e.temperatura);
                    const temperatura = Number.isFinite(temperaturaVal) ? temperaturaVal.toFixed(1) : "";
                    const cajasVal = Number(e.cajas_total ?? e.cajas);
                    const cajasTexto = Number.isFinite(cajasVal) && cajasVal > 0 ? cajasVal : "—";
                    let variedadTexto = e.variedad || "";
                    const esMixto = Number(e.mixto || 0) === 1 || String(variedadTexto).toUpperCase() === "MIXTO";
                    if (esMixto) {
                        let contador = Number(e.lineas_count || 0) || 0;
                        if (!contador && typeof e.observaciones === "string") {
                            const linea = e.observaciones.split("\n").find(l => l.startsWith("LINEAS_JSON="));
                            if (linea) {
                                try {
                                    const json = linea.replace("LINEAS_JSON=", "");
                                    const lineas = JSON.parse(json);
                                    if (Array.isArray(lineas)) contador = lineas.length;
                                } catch (_err) {
                                    contador = 0;
                                }
                            }
                        }
                        variedadTexto = contador ? `MIXTO (${contador})` : "MIXTO";
                    }
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${e.id}</td>
                        <td>${fechaEntrada}</td>
                        <td>${anada}</td>
                        <td>${variedadTexto}</td>
                        <td>${e.viticultor || ""}</td>
                        <td>${e.tipo_suelo || ""}</td>
                        <td>${e.parcela || ""}</td>
                        <td>${e.anos_vid || ""}</td>
                        <td>${e.kilos ?? ""}</td>
                        <td>${cajasTexto}</td>
                        <td>${densidad}</td>
                        <td>${temperatura}</td>
                        <td>
                            <button class="small-btn" style="margin-right:6px;"
                                onclick="editarEntradaUva(${e.id})">
                                Editar
                            </button>
                            <button class="small-btn" style="background:#c00; color:#fff;"
                                onclick="eliminarEntradaUva(${e.id})">
                                Borrar
                            </button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
                renderResumenParcelas();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
                renderFlowNodes();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando entradas:", err);
            }
        }

function renderResumenParcelas() {
            const tbody = document.getElementById("tablaResumenParcelas");
            if (!tbody) return;
            tbody.innerHTML = "";

            if (!cacheEntradas.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin datos todavía.</td>';
                tbody.appendChild(tr);
                return;
            }

            const resumen = {};
            cacheEntradas.forEach(e => {
                const parcela = (e.parcela || "Sin nombre").trim() || "Sin nombre";
                if (!resumen[parcela]) {
                    resumen[parcela] = { viajes: 0, kilos: 0, ultima: null };
                }
                resumen[parcela].viajes += 1;
                const kilos = Number(e.kilos || 0);
                resumen[parcela].kilos += Number.isNaN(kilos) ? 0 : kilos;
                const fecha = e.fecha || "";
                if (!resumen[parcela].ultima || fecha > resumen[parcela].ultima) {
                    resumen[parcela].ultima = fecha;
                }
            });

            Object.entries(resumen).forEach(([parcela, info]) => {
                const fecha = info.ultima ? new Date(info.ultima) : null;
                const fechaStr = formatearFechaCorta(info.ultima);
                const horaStr =
                    fecha && !Number.isNaN(fecha)
                        ? fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })
                        : "";
                const kilosValor = Number(info.kilos || 0);
                const kilosTexto =
                    kilosValor > 0
                        ? `${kilosValor.toLocaleString("es-ES", { minimumFractionDigits: 0 })} kg`
                        : "0 kg";
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${parcela}</td>
                    <td>${info.viajes}</td>
                    <td>${kilosTexto}</td>
                    <td>${fechaStr}</td>
                    <td>${horaStr}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function cancelarEdicionEntrada() {
            entradaEditandoId = null;
            const form = document.getElementById("formEntradaUva");
            if (form) form.reset();
            limpiarLineasEntrada();
            const mixto = document.getElementById("entradaMixto");
            if (mixto) mixto.checked = false;
            const modo = document.getElementById("entradaModoKilos");
            if (modo) modo.value = "total";
            actualizarEntradaMixtoUI();
            establecerFechaEntradaActual();
            actualizarAnadaEntrada();
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Registrar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "none";
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        function establecerFechaEntradaActual() {
            const campoFecha = document.getElementById("entradaFecha");
            if (!campoFecha) return;
            const ahora = new Date();
            campoFecha.value = ahora.toISOString().slice(0, 16);
            campoFecha.disabled = !entradaEditandoId;
            actualizarAnadaEntrada();
            actualizarResumenAdministracion();
        }

        function actualizarEntradaMixtoUI() {
            const mixto = document.getElementById("entradaMixto");
            const modo = document.getElementById("entradaModoKilos");
            const wrapVariedad = document.getElementById("entradaVariedadWrap");
            const wrapKilos = document.getElementById("entradaKilosWrap");
            const wrapLineas = document.getElementById("entradaLineasWrap");
            const wrapModo = document.getElementById("entradaModoKilosWrap");
            const inputVariedad = document.getElementById("entradaVariedad");
            const inputKilos = document.getElementById("entradaKilos");
            const modoSeleccionado = modo ? modo.value : "total";
            const activo = mixto ? mixto.checked : false;

            if (wrapVariedad) wrapVariedad.style.display = activo ? "none" : "";
            if (wrapLineas) wrapLineas.style.display = activo ? "block" : "none";
            if (wrapModo) wrapModo.style.display = activo ? "block" : "none";
            if (wrapKilos) wrapKilos.style.display = !activo || modoSeleccionado === "total" ? "block" : "none";
            if (inputVariedad) inputVariedad.required = !activo;
            if (inputKilos) inputKilos.required = !activo || modoSeleccionado === "total";

            document.querySelectorAll("#entradaLineas .entrada-linea").forEach(linea => {
                const inputK = linea.querySelector(".entrada-linea-kilos");
                if (!inputK) return;
                if (modoSeleccionado === "por_variedad") {
                    inputK.style.display = "";
                    linea.style.gridTemplateColumns = "minmax(0,1fr) 90px 90px 110px 36px";
                } else {
                    inputK.style.display = "none";
                    linea.style.gridTemplateColumns = "minmax(0,1fr) 90px 110px 36px";
                }
            });
            actualizarResumenAdministracion();
        }

        function crearLineaEntradaUI(data = {}) {
            const contenedor = document.getElementById("entradaLineas");
            if (!contenedor) return;
            const fila = document.createElement("div");
            fila.className = "entrada-linea";
            fila.style.display = "grid";
            fila.style.gap = "6px";
            fila.style.alignItems = "center";
            fila.style.padding = "8px";
            fila.style.border = "1px dashed #ddd";
            fila.style.borderRadius = "10px";

            const inputVariedad = document.createElement("input");
            inputVariedad.type = "text";
            inputVariedad.placeholder = "Variedad";
            inputVariedad.value = data.variedad || "";
            inputVariedad.className = "entrada-linea-variedad";

            const inputCajas = document.createElement("input");
            inputCajas.type = "number";
            inputCajas.placeholder = "Cajas";
            inputCajas.value = data.cajas != null ? data.cajas : "";
            inputCajas.className = "entrada-linea-cajas";

            const inputKilos = document.createElement("input");
            inputKilos.type = "number";
            inputKilos.step = "0.1";
            inputKilos.placeholder = "Kilos";
            inputKilos.value = data.kilos != null ? data.kilos : "";
            inputKilos.className = "entrada-linea-kilos";

            const selectTipo = document.createElement("select");
            selectTipo.className = "entrada-linea-tipo";
            const opciones = ["", "10", "12", "15", "18", "Otro"];
            opciones.forEach(valor => {
                const option = document.createElement("option");
                option.value = valor;
                option.textContent = valor ? valor : "Tipo caja";
                selectTipo.appendChild(option);
            });
            selectTipo.value = data.tipo_caja || document.getElementById("entradaTipoCaja").value || "";

            const btnEliminar = document.createElement("button");
            btnEliminar.type = "button";
            btnEliminar.textContent = "✕";
            btnEliminar.style.border = "none";
            btnEliminar.style.background = "#f3f3f3";
            btnEliminar.style.borderRadius = "8px";
            btnEliminar.style.cursor = "pointer";
            btnEliminar.style.padding = "8px";
            btnEliminar.addEventListener("click", () => {
                fila.remove();
                recalcularResumenLineas();
            });

            [inputVariedad, inputCajas, inputKilos, selectTipo].forEach(input => {
                input.addEventListener("input", recalcularResumenLineas);
                input.addEventListener("change", recalcularResumenLineas);
            });

            fila.appendChild(inputVariedad);
            fila.appendChild(inputCajas);
            fila.appendChild(inputKilos);
            fila.appendChild(selectTipo);
            fila.appendChild(btnEliminar);
            contenedor.appendChild(fila);
            actualizarEntradaMixtoUI();
            recalcularResumenLineas();
        }

        function limpiarLineasEntrada() {
            const contenedor = document.getElementById("entradaLineas");
            if (contenedor) contenedor.innerHTML = "";
            const resumen = document.getElementById("entradaResumenLineas");
            if (resumen) resumen.textContent = "";
            actualizarResumenAdministracion();
        }

        function obtenerLineasEntrada() {
            const modo = document.getElementById("entradaModoKilos").value || "total";
            const filas = Array.from(document.querySelectorAll("#entradaLineas .entrada-linea"));
            return filas.map(fila => {
                const variedad = (fila.querySelector(".entrada-linea-variedad")?.value || "").trim();
                const cajas = Number(fila.querySelector(".entrada-linea-cajas")?.value || 0);
                const kilosInput = fila.querySelector(".entrada-linea-kilos");
                const kilos = modo === "por_variedad" ? Number(kilosInput?.value || 0) : null;
                const tipo_caja = fila.querySelector(".entrada-linea-tipo")?.value || "";
                return { variedad, cajas, kilos, tipo_caja: tipo_caja || null };
            });
        }

        function recalcularResumenLineas() {
            const resumen = document.getElementById("entradaResumenLineas");
            const mixto = document.getElementById("entradaMixto").checked;
            if (!resumen || !mixto) {
                if (resumen) resumen.textContent = "";
                actualizarResumenAdministracion();
                return;
            }
            const modo = document.getElementById("entradaModoKilos").value || "total";
            const cajasTotal = Number(document.getElementById("entradaCajas").value || 0);
            const kilosTotal = Number(document.getElementById("entradaKilos").value || 0);
            const lineas = obtenerLineasEntrada();
            const cajasLineas = lineas.reduce((sum, l) => sum + (Number(l.cajas) || 0), 0);
            const kilosLineas = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
            let texto = `Cajas líneas: ${cajasLineas || 0} / Cajas total: ${Number.isFinite(cajasTotal) && cajasTotal > 0 ? cajasTotal : "-"}`;
            if (modo === "por_variedad") {
                const kilosTexto = kilosLineas > 0 ? kilosLineas.toFixed(1) : "0";
                texto += ` — Kilos líneas: ${kilosTexto} / Kilos total: ${kilosTexto}`;
            } else {
                texto += ` — Kilos total: ${Number.isFinite(kilosTotal) && kilosTotal > 0 ? kilosTotal : "-"}`;
            }
            resumen.textContent = texto;
            actualizarResumenAdministracion();
        }

        async function cargarLineasEntradaUI(entradaId) {
            limpiarLineasEntrada();
            if (!entradaId) return;
            try {
                const res = await fetch(`/api/entradas-uva/${entradaId}/lineas`);
                if (!res.ok) return;
                const data = await res.json();
                const lineas = Array.isArray(data.lineas) ? data.lineas : [];
                if (!lineas.length) {
                    crearLineaEntradaUI();
                    return;
                }
                lineas.forEach(linea => {
                    crearLineaEntradaUI({
                        variedad: linea.variedad,
                        cajas: linea.cajas,
                        kilos: linea.kilos,
                        tipo_caja: linea.tipo_caja,
                    });
                });
            } catch (err) {
                console.error("Error cargando líneas de entrada:", err);
            }
        }

        function initEntradaMixtoUI() {
            const checkMixto = document.getElementById("entradaMixto");
            const selectModo = document.getElementById("entradaModoKilos");
            const btnAgregar = document.getElementById("btnEntradaAgregarLinea");
            const inputCajas = document.getElementById("entradaCajas");
            const inputKilos = document.getElementById("entradaKilos");
            const selectTipoCaja = document.getElementById("entradaTipoCaja");

            if (checkMixto) {
                checkMixto.addEventListener("change", () => {
                    if (checkMixto.checked && !document.querySelector("#entradaLineas .entrada-linea")) {
                        crearLineaEntradaUI();
                    }
                    actualizarEntradaMixtoUI();
                    recalcularResumenLineas();
                });
            }
            if (selectModo) {
                selectModo.addEventListener("change", () => {
                    actualizarEntradaMixtoUI();
                    recalcularResumenLineas();
                });
            }
            if (btnAgregar) {
                btnAgregar.addEventListener("click", () => {
                    crearLineaEntradaUI();
                });
            }
            if (inputCajas) {
                inputCajas.addEventListener("input", recalcularResumenLineas);
            }
            if (inputKilos) {
                inputKilos.addEventListener("input", recalcularResumenLineas);
            }
            if (selectTipoCaja) {
                selectTipoCaja.addEventListener("change", () => {
                    const valor = selectTipoCaja.value;
                    if (!valor) return;
                    document.querySelectorAll("#entradaLineas select").forEach(select => {
                        if (!select.value) select.value = valor;
                    });
                });
            }

            actualizarEntradaMixtoUI();
            establecerFechaEntradaActual();
        }

        const PLANTILLAS_PROCEDENCIA_KEY = "plantillas_procedencia_uva";

        function normalizarRc(valor) {
            return (valor || "").toString().toUpperCase().replace(/[^0-9A-Z]/g, "");
        }

        function obtenerDatosProcedenciaForm() {
            return {
                catastro_rc: normalizarRc(document.getElementById("entradaRc")?.value || ""),
                catastro_provincia: (document.getElementById("entradaProvincia")?.value || "").toString().trim(),
                catastro_municipio: (document.getElementById("entradaMunicipio")?.value || "").toString().trim(),
                catastro_poligono: (document.getElementById("entradaPoligono")?.value || "").toString().trim(),
                catastro_parcela: (document.getElementById("entradaParcelaCat")?.value || "").toString().trim(),
                catastro_recinto: (document.getElementById("entradaRecinto")?.value || "").toString().trim(),
                parcela: (document.getElementById("entradaParcela")?.value || "").toString().trim(),
                viticultor: (document.getElementById("entradaViticultor")?.value || "").toString().trim(),
                viticultor_nif: (document.getElementById("entradaViticultorNif")?.value || "").toString().trim(),
                viticultor_contacto: (document.getElementById("entradaViticultorContacto")?.value || "").toString().trim(),
            };
        }

        function aplicarDatosProcedenciaForm(data = {}) {
            const map = {
                entradaRc: data.catastro_rc || "",
                entradaProvincia: data.catastro_provincia || "",
                entradaMunicipio: data.catastro_municipio || "",
                entradaPoligono: data.catastro_poligono || "",
                entradaParcelaCat: data.catastro_parcela || "",
                entradaRecinto: data.catastro_recinto || "",
                entradaParcela: data.parcela || "",
                entradaViticultor: data.viticultor || "",
                entradaViticultorNif: data.viticultor_nif || "",
                entradaViticultorContacto: data.viticultor_contacto || "",
            };
            Object.entries(map).forEach(([id, valor]) => {
                const input = document.getElementById(id);
                if (input) input.value = valor;
            });
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        function leerPlantillasProcedencia() {
            try {
                const raw = localStorage.getItem(PLANTILLAS_PROCEDENCIA_KEY);
                const data = JSON.parse(raw || "[]");
                return Array.isArray(data) ? data : [];
            } catch (_err) {
                return [];
            }
        }

        function guardarPlantillasProcedencia(lista) {
            localStorage.setItem(PLANTILLAS_PROCEDENCIA_KEY, JSON.stringify(lista));
        }

        function sugerirNombrePlantilla(data) {
            const viticultor = data.viticultor || "Procedencia";
            const municipio = data.catastro_municipio || data.catastro_provincia || "";
            const rc = data.catastro_rc ? `RC ${data.catastro_rc.slice(-6)}` : "";
            const polPar = data.catastro_poligono || data.catastro_parcela
                ? `P${data.catastro_poligono || "-"} ${data.catastro_parcela || "-"}`
                : "";
            const partes = [viticultor, municipio, rc || polPar].filter(Boolean);
            return partes.join(" · ") || "Procedencia";
        }

        function actualizarPlantillasSelect() {
            const select = document.getElementById("entradaPlantillaSelect");
            if (!select) return;
            const actual = select.value;
            const plantillas = leerPlantillasProcedencia();
            select.innerHTML = '<option value="">(Sin plantilla)</option>';
            plantillas.forEach((plantilla, idx) => {
                const option = document.createElement("option");
                option.value = String(idx);
                option.textContent = plantilla.nombre || `Plantilla ${idx + 1}`;
                select.appendChild(option);
            });
            if (actual) select.value = actual;
        }

        function guardarPlantillaProcedencia() {
            const data = obtenerDatosProcedenciaForm();
            if (!data.catastro_rc && !data.catastro_municipio && !data.catastro_parcela && !data.parcela) {
                mostrarAviso("Completa algún dato de procedencia antes de guardar la plantilla.", "info");
                return;
            }
            const sugerido = sugerirNombrePlantilla(data);
            const nombre = prompt("Nombre de la plantilla", sugerido);
            if (!nombre) return;
            const plantillas = leerPlantillasProcedencia();
            plantillas.push({ nombre: nombre.trim(), data });
            guardarPlantillasProcedencia(plantillas);
            actualizarPlantillasSelect();
            mostrarAviso("Plantilla guardada.", "success");
        }

        function cargarPlantillaProcedencia() {
            const select = document.getElementById("entradaPlantillaSelect");
            const idx = select?.value;
            if (!select || !idx) return;
            const plantillas = leerPlantillasProcedencia();
            const plantilla = plantillas[Number(idx)];
            if (!plantilla) return;
            aplicarDatosProcedenciaForm(plantilla.data || {});
            mostrarAviso("Procedencia cargada.", "success");
        }

        function actualizarAvisoRc(rc) {
            const aviso = document.getElementById("entradaRcAviso");
            if (!aviso) return;
            if (!rc) {
                aviso.textContent = "";
                return;
            }
            aviso.textContent = rc.length === 20 ? "" : "La RC suele tener 20 caracteres.";
        }

        function construirUrlCatastroRc(rc) {
            const base = "https://www1.sedecatastro.gob.es/CYCBienInmueble/OVCConsulta.aspx";
            const limpio = normalizarRc(rc);
            const rcFull = limpio.length > 20 ? limpio.slice(0, 20) : limpio;
            const params = new URLSearchParams();
            if (rcFull) params.set("RC", rcFull);
            if (rcFull.length === 20) {
                params.set("RC1", rcFull.slice(0, 14));
                params.set("RC2", rcFull.slice(14, 20));
            }
            return `${base}?${params.toString()}`;
        }

        function construirUrlCatastroParcela({ provincia, municipio, poligono, parcela, recinto }) {
            const base = "https://www1.sedecatastro.gob.es/CYCBienInmueble/OVCListaBienes.aspx";
            const params = new URLSearchParams({
                provincia,
                municipio,
                poligono,
                parcela,
            });
            if (recinto) params.set("recinto", recinto);
            return `${base}?${params.toString()}`;
        }

        function abrirUrlSeguro(url) {
            const win = window.open(url, "_blank", "noopener");
            if (win) {
                win.focus?.();
                return;
            }
            window.location.href = url;
        }

        function actualizarCatastroUI() {
            const datos = obtenerDatosProcedenciaForm();
            const btnRc = document.getElementById("btnCatastroRc");
            const btnParcela = document.getElementById("btnCatastroParcela");
            const hint = document.getElementById("entradaCatastroHint");
            const linkRc = document.getElementById("entradaCatastroLinkRc");
            const linkParcela = document.getElementById("entradaCatastroLinkParcela");
            const tieneRc = Boolean(datos.catastro_rc);
            const tieneParcela = Boolean(
                datos.catastro_provincia &&
                datos.catastro_municipio &&
                datos.catastro_poligono &&
                datos.catastro_parcela
            );
            if (btnRc) btnRc.disabled = !tieneRc;
            if (btnParcela) btnParcela.disabled = !tieneParcela;
            if (hint) {
                if (tieneRc || tieneParcela) {
                    hint.textContent = "Listo para abrir Catastro.";
                } else {
                    hint.textContent = "Faltan datos para abrir Catastro.";
                }
            }
            if (linkRc) {
                linkRc.href = tieneRc ? construirUrlCatastroRc(datos.catastro_rc) : "#";
                linkRc.setAttribute("aria-disabled", tieneRc ? "false" : "true");
            }
            if (linkParcela) {
                linkParcela.href = tieneParcela
                    ? construirUrlCatastroParcela({
                        provincia: datos.catastro_provincia,
                        municipio: datos.catastro_municipio,
                        poligono: datos.catastro_poligono,
                        parcela: datos.catastro_parcela,
                        recinto: datos.catastro_recinto,
                    })
                    : "#";
                linkParcela.setAttribute("aria-disabled", tieneParcela ? "false" : "true");
            }
            actualizarAvisoRc(datos.catastro_rc);
        }

        function abrirCatastroRc() {
            const rc = normalizarRc(document.getElementById("entradaRc")?.value || "");
            if (!rc) {
                mostrarAviso("Introduce una RC valida para abrir Catastro.", "info");
                return;
            }
            abrirUrlSeguro(construirUrlCatastroRc(rc));
        }

        function abrirCatastroParcela() {
            const datos = obtenerDatosProcedenciaForm();
            if (!datos.catastro_provincia || !datos.catastro_municipio || !datos.catastro_poligono || !datos.catastro_parcela) {
                mostrarAviso("Completa provincia, municipio, poligono y parcela para abrir Catastro.", "info");
                return;
            }
            const url = construirUrlCatastroParcela({
                provincia: datos.catastro_provincia,
                municipio: datos.catastro_municipio,
                poligono: datos.catastro_poligono,
                parcela: datos.catastro_parcela,
                recinto: datos.catastro_recinto,
            });
            abrirUrlSeguro(url);
        }

        function construirResumenAdministracion() {
            const fechaRaw = document.getElementById("entradaFecha")?.value || "";
            const fecha = fechaRaw ? new Date(fechaRaw) : null;
            const fechaTexto = fecha && !Number.isNaN(fecha.getTime())
                ? fecha.toLocaleString("es-ES", { dateStyle: "medium", timeStyle: "short" })
                : "";
            const observaciones = (document.getElementById("entradaObservaciones")?.value || "").toString().trim();
            const mixto = document.getElementById("entradaMixto")?.checked;
            const modoKilos = document.getElementById("entradaModoKilos")?.value || "total";
            const variedad = (document.getElementById("entradaVariedad")?.value || "").toString().trim();

            const datos = obtenerDatosProcedenciaForm();
            const cajasTotal = Number(document.getElementById("entradaCajas")?.value || 0);
            let kilosTotal = Number(document.getElementById("entradaKilos")?.value || 0);
            if (mixto && modoKilos === "por_variedad") {
                const lineas = obtenerLineasEntrada();
                kilosTotal = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
            }

            let variedadesTexto = "";
            if (mixto) {
                const lineas = obtenerLineasEntrada();
                const totalKilos = lineas.reduce((sum, l) => sum + (Number(l.kilos) || 0), 0);
                const partes = lineas.map(linea => {
                    const nombre = linea.variedad || "Variedad";
                    if (modoKilos === "por_variedad" && totalKilos > 0) {
                        const kilos = Number(linea.kilos) || 0;
                        const pct = Math.round((kilos / totalKilos) * 100);
                        return `${nombre} ${pct}% (${kilos.toFixed(1)} kg)`;
                    }
                    const cajas = Number(linea.cajas) || 0;
                    return `${nombre} (${cajas} cajas)`;
                });
                variedadesTexto = partes.length ? `MIXTO · ${partes.join(" · ")}` : "MIXTO";
            } else {
                variedadesTexto = variedad;
            }

            const partes = [];
            if (fechaTexto) partes.push(`Fecha entrada: ${fechaTexto}`);
            if (datos.viticultor) partes.push(`Proveedor/viticultor: ${datos.viticultor}`);
            if (datos.catastro_rc) partes.push(`Referencia Catastral (RC): ${datos.catastro_rc}`);
            if (datos.catastro_provincia || datos.catastro_municipio) {
                partes.push(`Provincia / Municipio: ${datos.catastro_provincia || "—"} / ${datos.catastro_municipio || "—"}`);
            }
            if (datos.catastro_poligono || datos.catastro_parcela || datos.catastro_recinto) {
                const pol = datos.catastro_poligono || "—";
                const par = datos.catastro_parcela || "—";
                const rec = datos.catastro_recinto ? ` / Recinto ${datos.catastro_recinto}` : "";
                partes.push(`Polígono / Parcela: ${pol} / ${par}${rec}`);
            }
            if (variedadesTexto) partes.push(`Variedades: ${variedadesTexto}`);
            const kilosTexto = kilosTotal ? `${kilosTotal.toFixed(1)} kg` : "—";
            const cajasTexto = cajasTotal ? `${cajasTotal} cajas` : "—";
            partes.push(`Kilos / cajas: ${kilosTexto} / ${cajasTexto}`);
            if (observaciones) partes.push(`Observaciones: ${observaciones}`);
            return partes.join("\n");
        }

        function actualizarResumenAdministracion() {
            const textarea = document.getElementById("entradaResumenAdminTexto");
            if (!textarea) return;
            textarea.value = construirResumenAdministracion();
        }

        function copiarResumenAdministracion() {
            const texto = construirResumenAdministracion();
            if (!texto) return;
            if (navigator.clipboard?.writeText) {
                navigator.clipboard.writeText(texto).then(() => {
                    mostrarAviso("Resumen copiado.", "success");
                }).catch(() => {
                    mostrarAviso("No se pudo copiar el resumen.", "error");
                });
                return;
            }
            const textarea = document.getElementById("entradaResumenAdminTexto");
            if (textarea) {
                textarea.focus();
                textarea.select();
                document.execCommand("copy");
                mostrarAviso("Resumen copiado.", "success");
            }
        }

        function initEntradaProcedenciaUI() {
            const rcInput = document.getElementById("entradaRc");
            const inputs = [
                "entradaFecha",
                "entradaRc",
                "entradaProvincia",
                "entradaMunicipio",
                "entradaPoligono",
                "entradaParcelaCat",
                "entradaRecinto",
                "entradaParcela",
                "entradaViticultor",
                "entradaViticultorNif",
                "entradaViticultorContacto",
                "entradaVariedad",
                "entradaKilos",
                "entradaCajas",
                "entradaObservaciones",
            ];
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (!input) return;
                const handler = () => {
                    if (id === "entradaRc" && rcInput) {
                        const normalizado = normalizarRc(rcInput.value);
                        if (rcInput.value !== normalizado) rcInput.value = normalizado;
                    }
                    if (id === "entradaFecha") {
                        actualizarAnadaEntrada();
                    }
                    actualizarCatastroUI();
                    actualizarResumenAdministracion();
                };
                input.addEventListener("input", handler);
                input.addEventListener("change", handler);
            });

            const btnRc = document.getElementById("btnCatastroRc");
            if (btnRc) btnRc.addEventListener("click", abrirCatastroRc);
            const btnParcela = document.getElementById("btnCatastroParcela");
            if (btnParcela) btnParcela.addEventListener("click", abrirCatastroParcela);

            const selectPlantilla = document.getElementById("entradaPlantillaSelect");
            if (selectPlantilla) {
                selectPlantilla.addEventListener("change", cargarPlantillaProcedencia);
            }
            const btnAplicar = document.getElementById("btnAplicarPlantilla");
            if (btnAplicar) btnAplicar.addEventListener("click", cargarPlantillaProcedencia);
            const btnGuardar = document.getElementById("btnGuardarPlantilla");
            if (btnGuardar) btnGuardar.addEventListener("click", guardarPlantillaProcedencia);

            const btnCopiar = document.getElementById("btnCopiarResumenEntrada");
            if (btnCopiar) btnCopiar.addEventListener("click", copiarResumenAdministracion);

            actualizarPlantillasSelect();
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        async function crearEntradaUva(ev) {
            ev.preventDefault();
            setFormFeedback("feedbackEntradaUva", "");
            const fecha = document.getElementById("entradaFecha").value;
            const variedad = document.getElementById("entradaVariedad").value.trim();
            const viticultor = document.getElementById("entradaViticultor").value.trim();
            const parcela = document.getElementById("entradaParcela").value.trim();
            const catastro_rc = normalizarRc(document.getElementById("entradaRc").value);
            const catastro_provincia = document.getElementById("entradaProvincia").value.trim();
            const catastro_municipio = document.getElementById("entradaMunicipio").value.trim();
            const catastro_poligono = document.getElementById("entradaPoligono").value.trim();
            const catastro_parcela = document.getElementById("entradaParcelaCat").value.trim();
            const catastro_recinto = document.getElementById("entradaRecinto").value.trim();
            const viticultor_nif = document.getElementById("entradaViticultorNif").value.trim();
            const viticultor_contacto = document.getElementById("entradaViticultorContacto").value.trim();
            const tipo_suelo = document.getElementById("entradaSuelo").value;
            const anos_vid = document.getElementById("entradaAnosVid").value;
            const observaciones = document.getElementById("entradaObservaciones").value.trim();
            const mixto = document.getElementById("entradaMixto").checked;
            const modo_kilos = document.getElementById("entradaModoKilos").value || "total";
            const tipo_caja = document.getElementById("entradaTipoCaja").value;
            const parseValor = (id) => {
                const raw = (document.getElementById(id).value || "").toString().trim();
                if (!raw) return null;
                const limpio = raw.replace(",", ".");
                const num = parseFloat(limpio);
                return Number.isFinite(num) ? num : null;
            };
            const parseEntero = (id) => {
                const raw = (document.getElementById(id).value || "").toString().trim();
                if (!raw) return null;
                const limpio = raw.replace(",", ".");
                const num = Number(limpio);
                return Number.isInteger(num) ? num : null;
            };
            const kilos = parseValor("entradaKilos") || 0;
            const cajas = parseEntero("entradaCajas") || 0;
            const densidad = parseValor("entradaDensidad");
            const temperatura = parseValor("entradaTemperatura");

            if (!cajas) {
                setFormFeedback("feedbackEntradaUva", "Las cajas son obligatorias.", "error");
                return;
            }
            if (!mixto || modo_kilos === "total") {
                if (!kilos) {
                    setFormFeedback("feedbackEntradaUva", "Los kilos son obligatorios.", "error");
                    return;
                }
            }
            if (!mixto && !variedad) {
                setFormFeedback("feedbackEntradaUva", "La variedad es obligatoria.", "error");
                return;
            }
            if (entradaEditandoId && !fecha) {
                setFormFeedback("feedbackEntradaUva", "La fecha es obligatoria.", "error");
                return;
            }

            try {
                const mensajePorDefecto = entradaEditandoId
                    ? "Error al actualizar la entrada de uva."
                    : "Error al registrar la entrada de uva.";
                const body = {
                    parcela: parcela || null,
                    viticultor,
                    viticultor_nif: viticultor_nif || null,
                    viticultor_contacto: viticultor_contacto || null,
                    tipo_suelo,
                    anos_vid,
                    densidad,
                    temperatura,
                    observaciones: observaciones || null,
                    catastro_rc: catastro_rc || null,
                    catastro_provincia: catastro_provincia || null,
                    catastro_municipio: catastro_municipio || null,
                    catastro_poligono: catastro_poligono || null,
                    catastro_parcela: catastro_parcela || null,
                    catastro_recinto: catastro_recinto || null,
                    cajas_total: cajas,
                    tipo_caja: tipo_caja || null,
                    mixto,
                    modo_kilos: mixto ? modo_kilos : "total",
                };
                if (!mixto || modo_kilos === "total") {
                    body.kilos_total = kilos;
                }
                if (!mixto) {
                    body.variedad = variedad;
                } else {
                    const lineas = obtenerLineasEntrada();
                    if (!lineas.length) {
                        setFormFeedback("feedbackEntradaUva", "Añade al menos una variedad.", "error");
                        return;
                    }
                    for (const [idx, linea] of lineas.entries()) {
                        if (!linea.variedad) {
                            setFormFeedback("feedbackEntradaUva", `Variedad obligatoria en la línea ${idx + 1}.`, "error");
                            return;
                        }
                        if (!Number.isFinite(linea.cajas) || linea.cajas <= 0 || !Number.isInteger(linea.cajas)) {
                            setFormFeedback("feedbackEntradaUva", `Cajas inválidas en la línea ${idx + 1}.`, "error");
                            return;
                        }
                        if (modo_kilos === "por_variedad") {
                            if (!Number.isFinite(linea.kilos) || linea.kilos <= 0) {
                                setFormFeedback("feedbackEntradaUva", `Kilos inválidos en la línea ${idx + 1}.`, "error");
                                return;
                            }
                        }
                    }
                    const sumaCajas = lineas.reduce((sum, l) => sum + l.cajas, 0);
                    if (sumaCajas !== cajas) {
                        setFormFeedback("feedbackEntradaUva", "Las cajas de las líneas no cuadran con el total.", "error");
                        return;
                    }
                    if (modo_kilos === "por_variedad") {
                        const sumaKilos = lineas.reduce((sum, l) => sum + l.kilos, 0);
                        if (!sumaKilos) {
                            setFormFeedback("feedbackEntradaUva", "Los kilos por variedad son obligatorios.", "error");
                            return;
                        }
                        body.kilos_total = sumaKilos;
                    }
                    body.lineas = lineas;
                }
                if (entradaEditandoId) {
                    body.fecha = fecha;
                }
                const url = entradaEditandoId ? `/api/entradas-uva/${entradaEditandoId}` : "/api/entradas-uva";
                const metodo = entradaEditandoId ? "PUT" : "POST";
                const res = await fetch(url, {
                    method: metodo,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) {
                    let mensaje = mensajePorDefecto;
                    try {
                        const data = await res.json();
                        if (data?.error) mensaje = data.error;
                    } catch (_err) {
                        // Si falla el parseo, dejamos el mensaje por defecto.
                    }
                    throw new Error(mensaje);
                }

                cancelarEdicionEntrada();
                await Promise.all([
                    cargarEntradas(),
                    cargarResumen(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarMovimientos(),
                ]);
                setFormFeedback("feedbackEntradaUva", "Entrada registrada correctamente.", "success");
                mostrarAviso("Entrada registrada en la bodega.", "success");
            } catch (err) {
                console.error("Error creando entrada:", err);
                const mensaje = err?.message || "Error al registrar la entrada de uva.";
                setFormFeedback("feedbackEntradaUva", mensaje, "error");
                mostrarAviso(mensaje, "error");
            }
        }

        async function editarEntradaUva(id) {
            const entrada = cacheEntradas.find(e => e.id === id);
            if (!entrada) {
                mostrarAviso("No encuentro esa entrada.", "error");
                return;
            }
            entradaEditandoId = id;
            const campoFecha = document.getElementById("entradaFecha");
            if (campoFecha) {
                campoFecha.disabled = false;
                campoFecha.value = formatearFechaParaInput(entrada.fecha);
            }
            document.getElementById("entradaVariedad").value = entrada.variedad || "";
            document.getElementById("entradaParcela").value = entrada.parcela || "";
            document.getElementById("entradaViticultor").value = entrada.viticultor || "";
            document.getElementById("entradaViticultorNif").value = entrada.viticultor_nif || "";
            document.getElementById("entradaViticultorContacto").value = entrada.viticultor_contacto || "";
            document.getElementById("entradaRc").value = normalizarRc(entrada.catastro_rc || "");
            document.getElementById("entradaProvincia").value = entrada.catastro_provincia || "";
            document.getElementById("entradaMunicipio").value = entrada.catastro_municipio || "";
            document.getElementById("entradaPoligono").value = entrada.catastro_poligono || "";
            document.getElementById("entradaParcelaCat").value = entrada.catastro_parcela || "";
            document.getElementById("entradaRecinto").value = entrada.catastro_recinto || "";
            document.getElementById("entradaSuelo").value = entrada.tipo_suelo || "";
            document.getElementById("entradaAnosVid").value = entrada.anos_vid || "";
            document.getElementById("entradaKilos").value = entrada.kilos ?? "";
            document.getElementById("entradaCajas").value = entrada.cajas_total ?? entrada.cajas ?? "";
            document.getElementById("entradaDensidad").value = entrada.densidad ?? "";
            document.getElementById("entradaTemperatura").value = entrada.temperatura ?? "";
            document.getElementById("entradaObservaciones").value = entrada.observaciones || "";
            document.getElementById("entradaTipoCaja").value = "";

            const esMixto = Number(entrada.mixto || 0) === 1 || String(entrada.variedad || "").toUpperCase() === "MIXTO";
            const modo = entrada.modo_kilos || "total";
            const checkMixto = document.getElementById("entradaMixto");
            if (checkMixto) checkMixto.checked = esMixto;
            const selectModo = document.getElementById("entradaModoKilos");
            if (selectModo) selectModo.value = modo;

            if (esMixto) {
                await cargarLineasEntradaUI(id);
            } else {
                limpiarLineasEntrada();
            }
            actualizarEntradaMixtoUI();
            recalcularResumenLineas();

            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Actualizar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "inline-flex";
            document.getElementById("entradas").scrollIntoView({ behavior: "smooth", block: "start" });
            actualizarAnadaEntrada();
            actualizarCatastroUI();
            actualizarResumenAdministracion();
        }

        async function eliminarEntradaUva(id) {
            if (!confirm("¿Seguro que quieres borrar esta entrada de uva?")) return;
            try {
                const res = await fetch(`/api/entradas-uva/${id}`, { method: "DELETE" });
                if (!res.ok) throw new Error();
                if (entradaEditandoId === id) {
                    cancelarEdicionEntrada();
                }
                await Promise.all([cargarEntradas(), cargarResumen(), cargarDepositos(), cargarBarricas(), cargarMovimientos()]);
            } catch (err) {
                console.error("Error borrando entrada:", err);
                alert("No se pudo borrar la entrada.");
            }
        }
// ---------- Depósitos (con edición de volumen, contenido y fecha) ----------
async function cargarDepositos() {
  try {
    mostrarSkeletonTabla("tablaDepositos", 10);
    const res = await fetch("/api/depositos");
    if (!res.ok) {
      console.error("Error HTTP al cargar depósitos:", res.status);
      return;
    }

    const datos = await res.json();
    const separados = datos.reduce(
      (acc, item) => {
        const clase = (item.clase || "deposito").toLowerCase();
        if (clase === "mastelone") {
          acc.mastelones.push(item);
        } else {
          acc.depositos.push(item);
        }
        return acc;
      },
      { depositos: [], mastelones: [] }
    );

    cacheDepositos = separados.depositos;
    cacheMastelones = separados.mastelones;
    // Volúmenes desde nodos (último eslabón)
    cacheDepositos.forEach(d => {
      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
      if (Number.isFinite(volNodo)) {
        d.litros_actuales = volNodo;
      }
    });
    cacheMastelones.forEach(d => {
      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
      if (Number.isFinite(volNodo)) {
        d.litros_actuales = volNodo;
      }
    });
    mapaDepositosPorId = new Map(cacheDepositos.map(d => [d.id, d]));
    mapaMastelonesPorId = new Map(cacheMastelones.map(d => [d.id, d]));
    if (typeof poblarSelectBitacoraContenedores === "function") {
      poblarSelectBitacoraContenedores();
    } else if (!window.__bitacoraSelectWarned) {
      console.warn("[bitacora] falta poblarSelectBitacoraContenedores; se omite para no cortar carga");
      window.__bitacoraSelectWarned = true;
    }

    const listaTabla = [...cacheDepositos, ...cacheMastelones];
    renderTablaContenedores(listaTabla, "tablaDepositos", "No hay depósitos ni mastelones.");
    renderPlano();
    renderAnalisisLab();
    actualizarIndicadores();
    refrescarGraficosResumenDesdeCaches();
    actualizarAprovechamientoAnual();
    actualizarMapaFlujo();
    renderCatas();
    programarActualizacionCopiloto();
  } catch (err) {
    console.error("Error cargando depósitos:", err);
  }
}

function renderTablaContenedores(lista, tablaId, mensajeVacio) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  tbody.innerHTML = "";

  if (!lista.length) {
    tbody.innerHTML = `<tr><td colspan="10">${mensajeVacio}</td></tr>`;
    return;
  }

  lista.forEach(d => {
    const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
    const enMapa = Boolean(estadoNodo && estadoNodo.enMapa);
    const volumenNodo = Number.isFinite(estadoNodo?.volumen) ? Number(estadoNodo.volumen) : null;
    const variedadNodo = formatearVariedadLinea(estadoNodo?.variedad || "");
    const tieneVino = enMapa && volumenNodo != null && volumenNodo > 0;
    const etiquetaVacio = enMapa ? "Vacío" : "Sin vino";
    const variedadVisible = tieneVino ? (variedadNodo || "—") : etiquetaVacio;
    const volumenVisible = enMapa ? formatearLitrosPlano(tieneVino ? volumenNodo : 0) : "—";
    const volumenParaEliminar = enMapa ? (Number.isFinite(volumenNodo) ? volumenNodo : 0) : 0;
    const capacidad =
      d.capacidad_l != null
        ? Number(d.capacidad_l).toFixed(0)
        : d.capacidad_hl != null
        ? Number(d.capacidad_hl * 100).toFixed(0)
        : "";
    const material = d.material || d.contenido || "";
    const tipoBitacora = (d.clase || "deposito").toLowerCase() === "mastelone" ? "mastelone" : "deposito";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${d.id}</td>
      <td>${d.codigo || ""}</td>
      <td>${capacidad}</td>
      <td>${d.tipo || ""}</td>
      <td>${material}</td>
      <td>${variedadVisible}</td>
      <td>${volumenVisible}</td>
      <td>
        <button class="small-btn"
          onclick="editarDepositoDatos(${d.id})">
          Editar
        </button>
      </td>
      <td>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button class="small-btn"
            onclick="abrirBitacoraContenedor('${tipoBitacora}', ${d.id})">
            Bitácora
          </button>
        </div>
      </td>
      <td>
        <button
          onclick="eliminarDeposito(${d.id}, ${volumenParaEliminar})"
          style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
          Borrar
        </button>
      </td>
    `;
    tbody.appendChild(tr);
  });
}
function abrirBitacoraContenedor(tipo, id) {
  const tipoNorm = (tipo || "").toString().trim().toLowerCase();
  const idNum = Number(id);
  if (!tipoNorm || !Number.isFinite(idNum)) return;
  let nombre = "";
  if (tipoNorm === "deposito") {
    nombre = obtenerNombreDeposito(idNum);
  } else if (tipoNorm === "mastelone") {
    nombre = obtenerNombreMastelone(idNum);
  } else if (tipoNorm === "barrica") {
    nombre = obtenerNombreBarrica(idNum);
  } else {
    nombre = `Contenedor ${idNum}`;
  }
  if (typeof window.abrirModalBitacora !== "function") {
    mostrarAviso("No se pudo abrir la bitácora.", "error");
    return;
  }
  window.abrirModalBitacora({ contenedorTipo: tipoNorm, contenedorId: idNum, nombre });
}
  // No dejar borrar si tiene vino dentro
async function eliminarDeposito(id, volumen) {
  const registro =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  const clase = registro ? (registro.clase || "deposito") : "deposito";
  const etiqueta = clase === "mastelone" ? "mastelone" : "depósito";

  if (volumen > 0) {
    alert(`No puedes borrar un ${etiqueta} que todavía tiene vino. Pon el volumen a 0 primero.`);
    return;
  }

  const ok = confirm(`¿Seguro que quieres borrar este ${etiqueta}?`);
  if (!ok) return;

  try {
    const res = await fetch(`/api/depositos/${id}`, {
      method: "DELETE"
    });

    if (!res.ok) {
      alert("Error borrando el depósito.");
      console.error("Error HTTP al borrar depósito:", res.status);
      return;
    }

    alert("Depósito borrado.");
    cargarDepositos();
  } catch (err) {
    console.error("Error borrando depósito:", err);
    alert("Error borrando el depósito (mira la consola del servidor).");
  }
}
async function crearDeposito(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackDepositos", "");

  const codigo = document.getElementById("depCodigo").value.trim();
  const tipo = document.getElementById("depTipo").value;
  const clase = (tipo || "").trim().toLowerCase() === "mastelone" ? "mastelone" : "deposito";
  const capacidad_l = Number(document.getElementById("depCapacidad").value || 0);
  const estado = "vacio";
  const material = document.getElementById("depMaterial").value;
  const vino_tipo = "";
  const vino_anio = "";
  const elaboracion = "";
  const fecha_uso = null;
  if (!codigo) {
    setFormFeedback("feedbackDepositos", "El código del contenedor es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackDepositos", "Introduce una capacidad válida en litros.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackDepositos", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackDepositos", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch("/api/depositos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        clase,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        vino_tipo,
        vino_anio,
        elaboracion,
        fecha_uso,
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "Error creando depósito");
    if (!ok) return;

    // Limpia el formulario
    document.getElementById("formDeposito").reset();
    // Vuelve a cargar la tabla
    await Promise.all([cargarDepositos(), cargarResumen()]);
    setFormFeedback("feedbackDepositos", "Contenedor creado correctamente.", "success");
    mostrarAviso("Nuevo contenedor registrado.", "success");
  } catch (err) {
    console.error("Error creando depósito:", err);
    setFormFeedback("feedbackDepositos", "Error creando depósito.", "error");
    mostrarAviso("No se pudo crear el contenedor.", "error");
  }
}
function editarDepositoDatos(id) {
  const dep =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  if (!dep) {
    mostrarAviso("No encuentro ese depósito.", "error");
    return;
  }
  abrirModalDeposito(dep);
}

function abrirModalDeposito(dep) {
  depositoEditando = { ...dep };
  const modal = document.getElementById("modalDeposito");
  if (!modal) return;
  const capacidad =
    dep.capacidad_l != null
      ? Number(dep.capacidad_l)
      : dep.capacidad_hl != null
      ? Number(dep.capacidad_hl * 100)
      : "";
  const campos = {
    depCodigoEdit: dep.codigo || "",
    depCapacidadEdit: capacidad || "",
    depVolumenEdit: dep.litros_actuales != null ? Number(dep.litros_actuales).toFixed(1) : "0",
  };
  Object.entries(campos).forEach(([id, valor]) => {
    const input = document.getElementById(id);
    if (input) input.value = valor ?? "";
  });
  const tipoSelect = document.getElementById("depTipoEdit");
  if (tipoSelect) {
    tipoSelect.value = dep.tipo || "";
  }
  const materialSelect = document.getElementById("depMaterialEdit");
  if (materialSelect) {
    materialSelect.value = dep.material || dep.contenido || "";
  }
  const estadoSelect = document.getElementById("depEstadoEdit");
  if (estadoSelect) {
    estadoSelect.value = dep.estado || "vacio";
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    const estadoNodo = obtenerEstadoDepositoDesdeNodo(dep.id);
    const enMapa = Boolean(estadoNodo && estadoNodo.enMapa);
    const volumenActual = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : null;
    const tieneVino = enMapa && volumenActual != null && volumenActual > 0;
    const variedadNodo = formatearVariedadLinea(estadoNodo?.variedad || "");
    if (tieneVino) {
      variedadInfo.textContent = variedadNodo || "Sin variedad";
    } else {
      variedadInfo.textContent = enMapa ? "Vacío" : "Sin vino";
    }
  }
  setFormFeedback("feedbackEditarDeposito", "");
  modal.classList.add("visible");
}

function cerrarModalDeposito() {
  depositoEditando = null;
  const modal = document.getElementById("modalDeposito");
  if (modal) {
    modal.classList.remove("visible");
  }
  const form = document.getElementById("formEditarDeposito");
  if (form) {
    form.reset();
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = "—";
  }
  setFormFeedback("feedbackEditarDeposito", "");
}

async function guardarEdicionDeposito(ev) {
  ev.preventDefault();
  if (!depositoEditando) return;
  const codigo = document.getElementById("depCodigoEdit").value.trim();
  const capacidad_l = Number(document.getElementById("depCapacidadEdit").value || 0);
  const volumenNuevo = Number(document.getElementById("depVolumenEdit").value || 0);
  const tipo = document.getElementById("depTipoEdit").value;
  const material = document.getElementById("depMaterialEdit").value;
  const estado = document.getElementById("depEstadoEdit").value || "vacio";
  const vinoTipo = volumenNuevo > 0 ? depositoEditando.vino_tipo : "";

  if (!codigo) {
    setFormFeedback("feedbackEditarDeposito", "El código es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackEditarDeposito", "Introduce una capacidad válida.", "error");
    return;
  }
  if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
    setFormFeedback("feedbackEditarDeposito", "El volumen debe ser un número positivo.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch(`/api/depositos/${depositoEditando.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        elaboracion: depositoEditando.elaboracion,
        vino_tipo: vinoTipo,
        vino_anio: depositoEditando.vino_anio,
        fecha_uso: depositoEditando.fecha_uso,
        clase: depositoEditando.clase || "deposito",
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo actualizar el depósito.");
    if (!ok) return;
    await aplicarAjusteDeposito(
      depositoEditando.id,
      Number(depositoEditando.litros_actuales || 0),
      volumenNuevo,
      depositoEditando.clase || "deposito"
    );
    await Promise.all([cargarDepositos(), cargarMovimientos(), cargarResumen()]);
    mostrarAviso("Depósito actualizado.", "success");
    cerrarModalDeposito();
  } catch (err) {
    console.error("Error actualizando depósito:", err);
    setFormFeedback("feedbackEditarDeposito", "No se pudo actualizar el depósito.", "error");
  }
}
async function aplicarAjusteDeposito(id, volumenActual, nuevo, clase = "deposito") {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const tipoMovimiento = clase === "mastelone" ? "mastelone" : "deposito";
  const etiqueta = tipoMovimiento === "mastelone" ? "mastelone" : "depósito";
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: tipoMovimiento,
        destino_id: id,
        litros: delta,
        perdida_litros: null,
        nota: `Ajuste de volumen desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: tipoMovimiento,
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        perdida_litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) desde edición de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste de volumen:", err);
    alert("No se pudo registrar el ajuste de volumen.");
  }
}

// ---------- Catas sensoriales ----------
async function cargarCatas() {
  try {
    const res = await fetch("/api/catas");
    if (!res.ok) return;
    cacheCatas = await res.json();
    renderCatas();
  } catch (err) {
    console.error("Error cargando catas:", err);
  }
}

function recortarTexto(texto, max = 120) {
  if (!texto) return "";
  const limpio = texto.toString().trim();
  if (limpio.length <= max) return limpio;
  return `${limpio.slice(0, max).trim()}…`;
}

function resumenCata(cata) {
  if (!cata) return "Sin catas todavía.";
  const partes = [cata.vista, cata.nariz, cata.boca, cata.equilibrio, cata.defectos]
    .map(p => (p || "").toString().trim())
    .filter(Boolean);
  const base = partes.join(" · ");
  const nota = cata.nota ? cata.nota.toString().trim() : "";
  return recortarTexto(base || nota || "Cata registrada.");
}

function formatearFechaHoraLarga(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
  return `${fecha.toLocaleDateString("es-ES")} ${hora}`;
}

function renderCatas() {
  renderCatasEnGrid(
    [...(cacheDepositos || []), ...(cacheMastelones || [])],
    "cataGrid",
    cont => ((cont.clase || "").toLowerCase() === "mastelone" ? "mastelone" : "deposito"),
    "No hay depósitos todavía."
  );
  renderCatasEnGrid(cacheBarricas || [], "cataGridBarricas", () => "barrica", "No hay barricas todavía.");
}

function renderCatasEnGrid(contenedores, gridId, resolverTipo, mensajeVacio) {
  const grid = document.getElementById(gridId);
  if (!grid) return;
  grid.innerHTML = "";
  if (!contenedores.length) {
    grid.appendChild(crearElementoCopilotoEmpty(mensajeVacio || "Sin datos."));
    return;
  }

  contenedores.forEach(cont => {
    const tipo = typeof resolverTipo === "function" ? resolverTipo(cont) : resolverTipo;
    const id = cont.id;
    const codigo = cont.codigo || "";
    const contenedorRef = { ...cont, tipo, id, codigo };
    const catas = (cacheCatas || [])
      .filter(c => c.contenedor_tipo === tipo && Number(c.contenedor_id) === id)
      .sort((a, b) => {
        const aMs = parseFechaMs(a.fecha) || 0;
        const bMs = parseFechaMs(b.fecha) || 0;
        return bMs - aMs;
      });
    const ultima = catas[0] || null;

    const card = document.createElement("div");
    card.className = "cata-card";

    const header = document.createElement("div");
    header.className = "cata-card-header";
    const title = document.createElement("div");
    title.className = "cata-card-title";
    const tipoLabel =
      tipo === "barrica" ? "Barrica" : tipo === "mastelone" ? "Mastelone" : "Depósito";
    title.textContent = `${tipoLabel} ${codigo || "#" + id}`;
    const estado = document.createElement("div");
    estado.className = "cata-card-meta";
    const capacidad =
      cont.capacidad_l != null
        ? Number(cont.capacidad_l)
        : cont.capacidad_hl != null
        ? Number(cont.capacidad_hl * 100)
        : null;
    const estadoNodo =
      tipo === "barrica" ? obtenerEstadoBarricaDesdeNodo(cont.id) : obtenerEstadoDepositoDesdeNodo(cont.id);
    const volumenActual = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : cont.litros_actuales;
    estado.textContent = `${formatearLitrosPlano(volumenActual)} / ${capacidad ? formatearLitrosPlano(capacidad) : "—"}`;
    header.appendChild(title);
    header.appendChild(estado);

    const meta = document.createElement("div");
    meta.className = "cata-card-meta";
    const fechaTxt = ultima?.fecha ? formatearFechaCorta(ultima.fecha) : "Sin cata";
    meta.textContent = `Última cata: ${fechaTxt}`;

    const resumen = document.createElement("div");
    resumen.className = "cata-card-meta";
    resumen.textContent = resumenCata(ultima);

    const acciones = document.createElement("div");
    acciones.className = "cata-card-actions";
    const nuevaBtn = document.createElement("button");
    nuevaBtn.type = "button";
    nuevaBtn.className = "btnPrimario";
    nuevaBtn.textContent = "Nueva cata";
    nuevaBtn.addEventListener("click", () => abrirModalCata(tipo, id));
    const verBtn = document.createElement("button");
    verBtn.type = "button";
    verBtn.className = "btnSecundario";
    verBtn.textContent = tipo === "barrica" ? "Ver barrica" : "Ver depósito";
    verBtn.addEventListener("click", () => irAlContenedor({ tipo, id, codigo }));
    acciones.appendChild(nuevaBtn);
    acciones.appendChild(verBtn);
    if (ultima) {
      acciones.appendChild(crearBotonPdfCata(ultima, contenedorRef, "PDF última cata", "btnSecundario"));
    }

    card.appendChild(header);
    card.appendChild(meta);
    card.appendChild(resumen);
    card.appendChild(acciones);

    if (catas.length) {
      const historial = document.createElement("details");
      historial.className = "cata-history";
      const summary = document.createElement("summary");
      summary.textContent = `Historial (${catas.length})`;
      const lista = document.createElement("ul");
      catas.forEach(cata => {
        const li = document.createElement("li");
        const fila = document.createElement("div");
        fila.style.display = "flex";
        fila.style.alignItems = "center";
        fila.style.justifyContent = "space-between";
        fila.style.gap = "10px";
        const texto = document.createElement("span");
        const fecha = cata.fecha ? formatearFechaCorta(cata.fecha) : "—";
        const intensidad = cata.intensidad ? ` · ${cata.intensidad}` : "";
        texto.textContent = `${fecha}${intensidad} · ${resumenCata(cata)}`;
        fila.appendChild(texto);
        fila.appendChild(crearBotonPdfCata(cata, contenedorRef, "PDF", "small-btn"));
        li.appendChild(fila);
        lista.appendChild(li);
      });
      historial.appendChild(summary);
      historial.appendChild(lista);
      card.appendChild(historial);
    }

    grid.appendChild(card);
  });
}

function crearBotonPdfCata(cata, contenedorRef, label = "PDF", clase = "small-btn") {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = clase;
  btn.textContent = label;
  btn.addEventListener("click", () => exportarCataPDF(cata, contenedorRef));
  return btn;
}

async function exportarCataPDF(cata, contenedorRef) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se cargó). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const tipoLabel =
      contenedorRef.tipo === "barrica"
        ? "Barrica"
        : contenedorRef.tipo === "mastelone"
        ? "Mastelone"
        : "Depósito";
    const info = obtenerInfoContenedor(contenedorRef.tipo, contenedorRef.id) || contenedorRef;
    const codigo = info.codigo || contenedorRef.codigo || `#${contenedorRef.id}`;
    const variedad = info.vino_tipo || contenedorRef.vino_tipo || "";
    const anada = info.vino_anio || contenedorRef.vino_anio || "";
    const capacidadRaw =
      info.capacidad_l != null
        ? Number(info.capacidad_l)
        : info.capacidad_hl != null
        ? Number(info.capacidad_hl * 100)
        : null;
    const estadoNodo =
      contenedorRef.tipo === "barrica"
        ? obtenerEstadoBarricaDesdeNodo(contenedorRef.id)
        : obtenerEstadoDepositoDesdeNodo(contenedorRef.id);
    const volumenRaw = Number.isFinite(estadoNodo?.volumen)
      ? Number(estadoNodo.volumen)
      : info.litros_actuales;
    const capacidad = Number.isFinite(capacidadRaw) ? formatearLitrosPlano(capacidadRaw) : "—";
    const volumen = Number.isFinite(Number(volumenRaw)) ? formatearLitrosPlano(volumenRaw) : "—";
    const fecha = formatearFechaHoraLarga(cata.fecha) || "—";

    doc.setFontSize(16);
    doc.text(`Hoja de cata · ${tipoLabel} ${codigo}`, 14, 18);
    doc.setFontSize(11);
    let y = 26;
    const lineas = [
      `Fecha: ${fecha}`,
      `Variedad / vino: ${variedad || "—"}`,
      `Añada: ${anada || "—"}`,
      `Capacidad: ${capacidad}`,
      `Volumen: ${volumen}`,
      `Intensidad: ${cata.intensidad || "—"}`,
    ];
    lineas.forEach(linea => {
      doc.text(linea, 14, y);
      y += 6;
    });

    const pageHeight = doc.internal.pageSize.getHeight
      ? doc.internal.pageSize.getHeight()
      : doc.internal.pageSize.height;
    const maxWidth = (doc.internal.pageSize.getWidth
      ? doc.internal.pageSize.getWidth()
      : doc.internal.pageSize.width) - 28;
    const escribirBloque = (titulo, texto) => {
      if (y > pageHeight - 24) {
        doc.addPage();
        y = 18;
      }
      doc.setFont(undefined, "bold");
      doc.text(titulo, 14, y);
      y += 6;
      doc.setFont(undefined, "normal");
      const contenido = (texto || "").toString().trim() || "—";
      const lineasTexto = doc.splitTextToSize ? doc.splitTextToSize(contenido, maxWidth) : [contenido];
      lineasTexto.forEach(linea => {
        if (y > pageHeight - 14) {
          doc.addPage();
          y = 18;
        }
        doc.text(linea, 14, y);
        y += 6;
      });
      y += 4;
    };

    escribirBloque("Vista", cata.vista);
    escribirBloque("Nariz", cata.nariz);
    escribirBloque("Boca", cata.boca);
    escribirBloque("Equilibrio", cata.equilibrio);
    escribirBloque("Defectos / alertas", cata.defectos);
    escribirBloque("Nota general", cata.nota);

    const safeTipo = tipoLabel
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    const safeCodigo = codigo.toString().replace(/[^a-z0-9_-]+/gi, "-");
    const nombreArchivo = `cata-${safeTipo}-${safeCodigo || contenedorRef.id}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de cata:", err);
    alert("No se pudo generar el PDF.");
  }
}

function abrirModalCata(tipo, id) {
  const modal = document.getElementById("modalCata");
  if (!modal) return;
  const info = obtenerInfoContenedor(tipo, id);
  const etiqueta = info?.codigo ? info.codigo : `#${id}`;
  const contenedorTxt =
    tipo === "mastelone"
      ? `Mastelone ${etiqueta}`
      : tipo === "barrica"
      ? `Barrica ${etiqueta}`
      : `Depósito ${etiqueta}`;
  const infoTexto = info ? describirContenedor(info, contenedorTxt) : contenedorTxt;
  const label = document.getElementById("cataContenedorInfo");
  if (label) label.textContent = infoTexto;
  const form = document.getElementById("formCata");
  if (form) form.reset();
  const fechaInput = document.getElementById("cataFecha");
  if (fechaInput) fechaInput.value = formatearFechaParaInput(new Date());
  const tipoInput = document.getElementById("cataTipo");
  const idInput = document.getElementById("cataId");
  if (tipoInput) tipoInput.value = tipo;
  if (idInput) idInput.value = id;
  setFormFeedback("feedbackCata", "");
  modal.classList.add("visible");
}

function cerrarModalCata() {
  const modal = document.getElementById("modalCata");
  if (modal) modal.classList.remove("visible");
  const form = document.getElementById("formCata");
  if (form) form.reset();
  const label = document.getElementById("cataContenedorInfo");
  if (label) label.textContent = "";
  setFormFeedback("feedbackCata", "");
}

async function guardarCata(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackCata", "");
  const contenedor_tipo = document.getElementById("cataTipo").value;
  const contenedor_id = Number(document.getElementById("cataId").value);
  const fecha = document.getElementById("cataFecha").value;
  const vista = document.getElementById("cataVista").value.trim();
  const nariz = document.getElementById("cataNariz").value.trim();
  const boca = document.getElementById("cataBoca").value.trim();
  const equilibrio = document.getElementById("cataEquilibrio").value.trim();
  const defectos = document.getElementById("cataDefectos").value.trim();
  const intensidad = document.getElementById("cataIntensidad").value;
  const nota = document.getElementById("cataNota").value.trim();

  if (!contenedor_tipo || !contenedor_id || !fecha) {
    setFormFeedback("feedbackCata", "Faltan datos: contenedor y fecha.", "error");
    return;
  }

  try {
    const res = await fetch("/api/catas", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contenedor_tipo,
        contenedor_id,
        fecha,
        vista,
        nariz,
        boca,
        equilibrio,
        defectos,
        intensidad,
        nota,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo guardar la cata.");
    if (!ok) return;
    cerrarModalCata();
    await cargarCatas();
    mostrarAviso("Cata registrada.", "success");
  } catch (err) {
    console.error("Error guardando cata:", err);
    setFormFeedback("feedbackCata", "Error al guardar la cata.", "error");
  }
}

async function editarBarricaDatos(id) {
    const bar = cacheBarricas.find(b => b.id === id);
    if (!bar) {
        alert("No encuentro esa barrica.");
        return;
    }

    const codigo = prompt("Código:", bar.codigo || "");
    if (codigo === null || !codigo.trim()) return;

    const capacidadStr = prompt(
        "Capacidad (L):",
        bar.capacidad_l != null ? bar.capacidad_l : ""
    );
    if (capacidadStr === null) return;
    const capacidad_l = Number(capacidadStr);
    if (Number.isNaN(capacidad_l) || capacidad_l <= 0) {
        alert("Introduce una capacidad válida.");
        return;
    }

    const volumenStr = prompt(
        "Volumen actual (L):",
        bar.litros_actuales != null ? bar.litros_actuales : 0
    );
    if (volumenStr === null) return;
    const volumenNuevo = Number(volumenStr);
    if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
        alert("Introduce un volumen válido.");
        return;
    }

    const tipoResp = prompt("Tipo de roble:", bar.tipo_roble || "");
    if (tipoResp === null) return;
    const tipo_roble = tipoResp.trim() || null;

    const tostadoResp = prompt("Tostado:", bar.tostado || "");
    if (tostadoResp === null) return;
    const tostado = tostadoResp.trim() || null;

    const marcaResp = prompt("Marca:", bar.marca || "");
    if (marcaResp === null) return;
    const marca = marcaResp.trim() || null;

    const anioResp = prompt("Año:", bar.anio || "");
    if (anioResp === null) return;
    const anio = anioResp.trim() || null;

    const vinoAnioResp = prompt("Añada:", bar.vino_anio || "");
    if (vinoAnioResp === null) return;
    const vino_anio = vinoAnioResp.trim() || null;

    const vinoResp = prompt(
        "Tipo de vino (1=tinto, 2=blanco, 3=rosado/clarete o escribe texto):",
        bar.vino_tipo || ""
    );
    if (vinoResp === null) return;
    const vino_tipo_normalizado = normalizarTipoVino(vinoResp, bar.vino_tipo);
    const vino_tipo = vino_tipo_normalizado || null;

    try {
        const res = await fetch(`/api/barricas/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                codigo: codigo.trim(),
                capacidad_l,
                tipo_roble,
                tostado,
                marca,
                anio,
                vino_anio,
                vino_tipo,
            }),
        });
        const ok = await manejarRespuesta(res, "No se pudo actualizar la barrica.");
        if (!ok) return;
        await aplicarAjusteBarrica(id, Number(bar.litros_actuales || 0), volumenNuevo);
        await cargarBarricas();
        await cargarMovimientos();
        await cargarResumen();
    } catch (err) {
        console.error("Error actualizando barrica:", err);
        alert("No se pudo actualizar la barrica.");
    }
}

async function eliminarBarrica(id, volumen) {
    if (volumen > 0) {
        alert("No puedes borrar una barrica que aún tiene vino. Ajusta el volumen a 0 primero.");
        return;
    }

    if (!confirm("¿Seguro que quieres borrar esta barrica?")) return;

    try {
        const res = await fetch(`/api/barricas/${id}`, { method: "DELETE" });
        if (!res.ok) throw new Error();
        alert("Barrica borrada.");
        await cargarBarricas();
        await cargarResumen();
    } catch (err) {
        console.error("Error borrando barrica:", err);
        alert("No se pudo borrar la barrica.");
    }
}
async function aplicarAjusteBarrica(id, volumenActual, nuevo) {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: "barrica",
        destino_id: id,
        litros: delta,
        nota: `Ajuste de volumen en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: "barrica",
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste en barrica:", err);
    alert("No se pudo registrar el ajuste de volumen en la barrica.");
  }
}

function obtenerNombreDeposito(id) {
  const dep = mapaDepositosPorId.get(id);
  return dep ? dep.codigo || `Depósito ${id}` : `Depósito ${id}`;
}

function obtenerNombreMastelone(id) {
  const mas = mapaMastelonesPorId.get(id);
  return mas ? mas.codigo || `Mastelone ${id}` : `Mastelone ${id}`;
}

function obtenerNombreBarrica(id) {
  const bar = mapaBarricasPorId.get(id);
  return bar ? bar.codigo || `Barrica ${id}` : `Barrica ${id}`;
}

function formatearUbicacionMovimiento(tipo, id) {
  if (!tipo || !id) return "";
  if (tipo === "deposito") {
    return obtenerNombreDeposito(Number(id));
  }
  if (tipo === "mastelone") {
    return obtenerNombreMastelone(Number(id));
  }
  if (tipo === "barrica") {
    return obtenerNombreBarrica(Number(id));
  }
  return `${tipo.charAt(0).toUpperCase() + tipo.slice(1)} ${id}`;
}

function formatearLitrosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "—";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} L`;
}

function formatearFechaCorta(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  return fecha.toLocaleDateString("es-ES");
}

function formatearFechaParaInput(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const pad = numero => numero.toString().padStart(2, "0");
  const año = fecha.getFullYear();
  const mes = pad(fecha.getMonth() + 1);
  const dia = pad(fecha.getDate());
  const horas = pad(fecha.getHours());
  const minutos = pad(fecha.getMinutes());
  return `${año}-${mes}-${dia}T${horas}:${minutos}`;
}

function obtenerColorVinoReferencia(texto) {
  if (!texto) return null;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (t.includes("blanc")) return "#f5d372";
  if (t.includes("ros") || t.includes("clarete")) return "#f48fb1";
  if (t.includes("tinto") || t.includes("red") || t.includes("tannat")) return "#7b1b47";
  return null;
}

function obtenerColorMaterialContenedor(material, tipo = "") {
  const base = (material || tipo || "")
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();

  if (!base && tipo === "barrica") return "#c69c6d"; // madera (por defecto)

  if (base.includes("inox")) return "#c0c7d1"; // plata
  if (base.includes("fibra")) return "#ff8a3d"; // anaranjado
  if (base.includes("cement")) return "#4a4f59"; // gris oscuro
  if (base.includes("barro") || base.includes("anfora") || base.includes("tinaja")) return "#8a5a3c"; // marrón
  if (base.includes("madera") || base.includes("roble") || base.includes("wood")) return "#c69c6d"; // marrón claro
  if (base.includes("cristal") || base.includes("vidrio") || base.includes("glass")) return "#8fd3ff"; // azul claro
  if (base.includes("plast") || base.includes("plastico")) return "#7b1b47"; // granate

  // fallback por tipo
  if (tipo === "barrica") return "#c69c6d";
  return "#8f97a8";
}

function obtenerColorPuntoVinoPlano(variedadTexto) {
  const granate = "#7b1b47";
  const amarillo = "#f3c77b";
  if (!variedadTexto) return "rgba(143,151,168,0.95)";
  const lineas = variedadTexto
    .toString()
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean);
  let hayBlancas = false;
  let hayTintas = false;
  lineas.forEach(linea => {
    const sinPct = linea.replace(/^\d+(?:[.,]\d+)?%\s*/g, "").trim();
    if (!sinPct) return;
    sinPct
      .split(/[\/·,]/)
      .map(p => p.trim())
      .filter(Boolean)
      .forEach(part => {
        const base = part.replace(/^\d+(?:[.,]\d+)?%?\s*/g, "").trim();
        if (!base || esVariedadGenerica(base)) return;
        const norm = normalizarTextoUva(base);
        if (esVariedadBlanca(norm)) hayBlancas = true;
        else hayTintas = true;
      });
  });
  if (hayBlancas && hayTintas) return mezclarHexConBlanco(granate, 0.5, 1);
  if (hayBlancas) return amarillo;
  if (hayTintas) return granate;
  return "rgba(143,151,168,0.95)";
}

function esColorOscuroHex(hex) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  if (!match) return false;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const luminancia = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminancia < 0.55;
}

function mezclarHexConBlanco(hex, factorBlanco = 0.75, alpha = 0.32) {
  const match = (hex || "").toString().trim().match(/^#?([0-9a-f]{6})$/i);
  const f = Number(factorBlanco);
  const factor = Number.isFinite(f) ? Math.max(0, Math.min(1, f)) : 0.75;
  const a = Number(alpha);
  const opacidad = Number.isFinite(a) ? Math.max(0, Math.min(1, a)) : 0.32;
  if (!match) return `rgba(255,255,255,${opacidad})`;
  const valor = match[1];
  const r = parseInt(valor.slice(0, 2), 16);
  const g = parseInt(valor.slice(2, 4), 16);
  const b = parseInt(valor.slice(4, 6), 16);
  const rr = Math.round(r + (255 - r) * factor);
  const gg = Math.round(g + (255 - g) * factor);
  const bb = Math.round(b + (255 - b) * factor);
  return `rgba(${rr},${gg},${bb},${opacidad})`;
}

function esVariedadGenerica(texto) {
  if (!texto) return false;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();
  if (!t) return false;
  if (t === "tinto" || t === "vino tinto") return true;
  if (t === "blanco" || t === "vino blanco") return true;
  if (t === "rosado" || t === "vino rosado") return true;
  if (t === "clarete" || t === "vino clarete") return true;
  if (t.includes("vino rosado") && t.includes("clarete")) return true;
  if (t === "vino rosado / clarete") return true;
  return false;
}

function filtrarVariedadesMultilinea(texto) {
  if (!texto) return "";
  const lineas = texto
    .toString()
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => {
      const sinPct = l.replace(/^\d+(?:[.,]\d+)?%\s*/g, "").trim();
      return !esVariedadGenerica(sinPct);
    });
  return lineas.join("\n");
}

function formatearVariedadLinea(texto) {
  if (!texto) return "";
  const limpio = filtrarVariedadesMultilinea(texto);
  if (!limpio) return "";
  return limpio
    .split(/\r?\n/)
    .map(linea => linea.trim())
    .filter(Boolean)
    .join(" / ");
}

function formatearVariedadesMultilinea(lista) {
  if (!Array.isArray(lista) || !lista.length) return "";
  return lista
    .map(item => {
      const nombre = (item?.nombre || item?.variedad || "").toString().trim();
      if (!nombre || esVariedadGenerica(nombre)) return "";
      const porcentaje = Number.isFinite(item?.porcentaje) ? item.porcentaje : Number(item?.pct);
      const pct = formatearPctVariedad(Number(porcentaje));
      return pct && pct !== "0%" ? `${pct} ${nombre}` : nombre;
    })
    .filter(Boolean)
    .join("\n");
}

function normalizarTipoVino(entrada, actual = "") {
  if (entrada == null) return actual || "";
  const textoOriginal = entrada.toString().trim();
  if (!textoOriginal) return actual || "";
  const limpio = textoOriginal
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();

  if (["1", "tinto", "vino tinto"].includes(limpio)) return "Vino tinto";
  if (["2", "blanco", "vino blanco"].includes(limpio)) return "Vino blanco";
  if (
    ["3", "rosado", "rosa", "clarete", "vino rosado", "vino clarete"].includes(limpio)
  ) {
    return "Vino rosado / Clarete";
  }
  return textoOriginal;
}

function obtenerAnadaDesdeFecha(fecha) {
  if (!fecha) return "";
  const match = fecha.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function actualizarAnadaEntrada() {
  const fecha = document.getElementById("entradaFecha");
  const campo = document.getElementById("entradaAnada");
  if (!campo) return;
  campo.value = fecha ? obtenerAnadaDesdeFecha(fecha.value) : "";
  const lectura = document.getElementById("entradaFechaLectura");
  if (lectura) {
    if (fecha && fecha.value) {
      const fechaValor = new Date(fecha.value);
      lectura.textContent = Number.isNaN(fechaValor.getTime())
        ? "Fecha —"
        : fechaValor.toLocaleString("es-ES", { dateStyle: "medium", timeStyle: "short" });
    } else {
      lectura.textContent = "Fecha —";
    }
  }
  const chip = document.getElementById("entradaChipAnada");
  if (chip) {
    chip.textContent = campo.value ? `Vendimia ${campo.value}` : "Vendimia —";
  }
}

function resolverContenedorId(tipo, valor) {
  if (!valor) return null;
  if (/^\d+$/.test(valor)) {
    return Number(valor);
  }
  const normalizado = valor.toLowerCase();
  if (tipo === "deposito") {
    const dep = cacheDepositos.find(d => (d.codigo || "").toLowerCase() === normalizado);
    return dep ? dep.id : null;
  }
  if (tipo === "mastelone") {
    const mas = cacheMastelones.find(m => (m.codigo || "").toLowerCase() === normalizado);
    return mas ? mas.id : null;
  }
  if (tipo === "barrica") {
    const bar = cacheBarricas.find(b => (b.codigo || "").toLowerCase() === normalizado);
    return bar ? bar.id : null;
  }
  return null;
}

function irAlContenedor(item) {
  if (!item || !item.tipo) return;
  if (item.tipo === "deposito" || item.tipo === "mastelone") {
    mostrarSeccion("depositos");
    scrollToContenedor("tablaDepositos", dep => dep.codigo === item.codigo || dep.id === item.id);
  } else if (item.tipo === "barrica") {
    mostrarSeccion("barricas");
    scrollToContenedor("tablaBarricas", bar => bar.codigo === item.codigo || bar.id === item.id);
  }
}

function scrollToContenedor(tablaId, predicate) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  const filas = Array.from(tbody.querySelectorAll("tr"));
  const target = filas.find(tr => {
    const celdas = tr.querySelectorAll("td");
    if (!celdas.length) return false;
    const id = Number(celdas[0].textContent.trim());
    const codigo = celdas[1] ? celdas[1].textContent.trim() : "";
    return predicate({ id, codigo });
  });
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    target.classList.add("resaltado");
    setTimeout(() => target.classList.remove("resaltado"), 1500);
  }
}

function obtenerMovimientosFiltrados() {
  let datos = Array.isArray(cacheMovimientos) ? [...cacheMovimientos] : [];
  const { tipo, desde, hasta, contenedor, contenedor_tipo } = filtrosMovimientos;
  if (tipo) {
    const filtroTipo = tipo.toLowerCase();
    datos = datos.filter(m => (m.tipo || "").toLowerCase() === filtroTipo);
  }

  const fechaDesde = desde ? new Date(desde) : null;
  const fechaHasta = hasta ? new Date(hasta) : null;

  if (fechaDesde instanceof Date && !Number.isNaN(fechaDesde.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp >= fechaDesde.getTime();
    });
  }

  if (fechaHasta instanceof Date && !Number.isNaN(fechaHasta.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp <= fechaHasta.getTime();
    });
  }

  if (contenedor) {
    const valor = contenedor.trim();
    const candidatos = [];
    if (!contenedor_tipo || contenedor_tipo === "deposito") {
      const idDep = resolverContenedorId("deposito", valor);
      if (idDep) candidatos.push({ tipo: "deposito", id: idDep });
    }
    if (!contenedor_tipo || contenedor_tipo === "mastelone") {
      const idMas = resolverContenedorId("mastelone", valor);
      if (idMas) candidatos.push({ tipo: "mastelone", id: idMas });
    }
    if (!contenedor_tipo || contenedor_tipo === "barrica") {
      const idBar = resolverContenedorId("barrica", valor);
      if (idBar) candidatos.push({ tipo: "barrica", id: idBar });
    }
    if (!candidatos.length) {
      return [];
    }
    datos = datos.filter(m =>
      candidatos.some(
        info =>
          (m.origen_tipo === info.tipo && Number(m.origen_id) === info.id) ||
          (m.destino_tipo === info.tipo && Number(m.destino_id) === info.id)
      )
    );
  }

  return datos;
}

function renderMovimientos() {
  const tbody = document.getElementById("tablaMovimientos");
  if (!tbody) return;
  const datos = obtenerMovimientosFiltrados();
  tbody.innerHTML = "";

  if (!datos.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="8">No hay movimientos registrados.</td>';
    tbody.appendChild(tr);
    return;
  }

  datos.forEach(m => {
    const fecha = m.fecha || m.fecha_hora || "";
    const fechaTexto = formatearFechaCorta(fecha);
    const litros = m.litros != null ? m.litros : m.volumen_l ?? "";
    const origen = formatearUbicacionMovimiento(m.origen_tipo, m.origen_id);
    const destino = formatearUbicacionMovimiento(m.destino_tipo, m.destino_id);
    const tr = document.createElement("tr");
    tr.innerHTML = `
        <td>${fechaTexto}</td>
        <td>${m.tipo || ""}</td>
        <td>${litros}</td>
        <td>${m.perdida_litros != null ? m.perdida_litros : ""}</td>
        <td>${origen.trim()}</td>
        <td>${destino.trim()}</td>
        <td>${m.nota || ""}</td>
        <td><button class="small-btn" style="background:#c04b4b; color:#fff;" onclick="eliminarMovimiento(${m.id})">Borrar</button></td>
    `;
    tbody.appendChild(tr);
  });
}

async function limpiarHistorialMovimientos() {
  const confirmar = confirm(
    "¿Seguro que quieres borrar todo el historial de movimientos? Esta acción no se puede deshacer."
  );
  if (!confirmar) return;

  try {
    const res = await fetch("/api/movimientos", { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo limpiar el historial.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error limpiando historial de movimientos:", err);
    alert("Error al limpiar el historial de movimientos.");
  }
}

async function eliminarMovimiento(id) {
  const confirmar = confirm("¿Borrar este movimiento? Esta acción no se puede deshacer.");
  if (!confirmar) return;
  try {
    const res = await fetch(`/api/movimientos/${id}`, { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo borrar el movimiento.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error borrando movimiento:", err);
    alert("No se pudo borrar el movimiento.");
  }
}

function aplicarFiltrosMovimientos() {
  filtrosMovimientos = {
    tipo: (document.getElementById("filtroMovTipo").value || "").toLowerCase(),
    desde: document.getElementById("filtroMovDesde").value || "",
    hasta: document.getElementById("filtroMovHasta").value || "",
    contenedor: document.getElementById("filtroMovContenedor").value.trim(),
    contenedor_tipo: document.getElementById("filtroMovContTipo").value || "",
  };
  renderMovimientos();
}

function limpiarFiltrosMovimientos() {
  document.getElementById("filtroMovTipo").value = "";
  document.getElementById("filtroMovDesde").value = "";
  document.getElementById("filtroMovHasta").value = "";
  document.getElementById("filtroMovContenedor").value = "";
  document.getElementById("filtroMovContTipo").value = "";
  filtrosMovimientos = { tipo: "", desde: "", hasta: "", contenedor: "", contenedor_tipo: "" };
  renderMovimientos();
}

async function exportarMovimientosCSV() {
  try {
    const res = await fetch("/api/export/movimientos");
    if (!res.ok) throw new Error();
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const enlace = document.createElement("a");
    const fecha = new Date().toISOString().slice(0, 10);
    enlace.href = url;
    enlace.download = `movimientos-${fecha}.csv`;
    document.body.appendChild(enlace);
    enlace.click();
    enlace.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Error exportando movimientos:", err);
    alert("No se pudo exportar el historial de movimientos.");
  }
}

async function obtenerHistorialCompleto(tipo, id) {
  try {
    const res = await fetch(`/api/contenedores/${tipo}/${id}/historial`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (err) {
    console.warn("Fallo al usar endpoint combinado, usando modo local:", err);
    return await construirHistorialLocal(tipo, id);
  }
}

async function construirHistorialLocal(tipo, id) {
  const registrosRes = await fetch(`/api/registros/${tipo}/${id}`);
  if (!registrosRes.ok) throw new Error("No se pudieron obtener registros analíticos");
  const registros = await registrosRes.json();

  let movimientos = cacheMovimientos;
  if (!movimientos || !movimientos.length) {
    const movRes = await fetch("/api/movimientos");
    if (!movRes.ok) throw new Error("No se pudieron obtener movimientos");
    movimientos = await movRes.json();
  }

  const analiticosNormalizados = registros.map(r => ({
    categoria: "analitico",
    fecha: r.fecha_hora,
    densidad: r.densidad,
    temperatura_c: r.temperatura_c,
    nota_sensorial: r.nota_sensorial,
    nota: r.nota,
  }));

  const movimientosRelacionados = movimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .map(m => ({
      categoria: "movimiento",
      fecha: m.fecha,
      tipo: m.tipo,
      litros: m.litros,
      origen_tipo: m.origen_tipo,
      origen_id: m.origen_id,
      destino_tipo: m.destino_tipo,
      destino_id: m.destino_id,
      nota: m.nota,
    }));

  return [...analiticosNormalizados, ...movimientosRelacionados].sort(
    (a, b) => new Date(b.fecha || 0) - new Date(a.fecha || 0)
  );
}
        // ---------- Barricas ----------
        async function cargarBarricas() {
            try {
                mostrarSkeletonTabla("tablaBarricas", 12);
                const res = await fetch("/api/barricas");
                if (!res.ok) return;
                const datos = await res.json();
                cacheBarricas = datos;
                cacheBarricas.forEach(b => {
                    const volNodo = obtenerVolumenFinalNodoContenedor("barrica", b.id);
                    if (Number.isFinite(volNodo)) {
                        b.litros_actuales = volNodo;
                    }
                });
                mapaBarricasPorId = new Map(datos.map(b => [b.id, b]));
                if (typeof poblarSelectBitacoraContenedores === "function") {
                    poblarSelectBitacoraContenedores();
                } else if (!window.__bitacoraSelectWarned) {
                    console.warn("[bitacora] falta poblarSelectBitacoraContenedores; se omite para no cortar carga");
                    window.__bitacoraSelectWarned = true;
                }
                renderPlano();

                const tbody = document.getElementById("tablaBarricas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="12">No hay barricas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

               datos.forEach(b => {
                    const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
                    const enMapa = Boolean(estadoNodo && estadoNodo.enMapa);
                    const volumenNodo = Number.isFinite(estadoNodo?.volumen) ? Number(estadoNodo.volumen) : null;
                    const variedadNodo = formatearVariedadLinea(estadoNodo?.variedad || "");
                    const tieneVino = enMapa && volumenNodo != null && volumenNodo > 0;
                    const etiquetaVacio = enMapa ? "Vacío" : "Sin vino";
                    const variedadVisible = tieneVino ? (variedadNodo || "—") : etiquetaVacio;
                    const volumenVisible = enMapa ? formatearLitrosPlano(tieneVino ? volumenNodo : 0) : "—";
                    const volumenParaEliminar = enMapa ? (Number.isFinite(volumenNodo) ? volumenNodo : 0) : 0;
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
        <td>${b.id}</td>
        <td>${b.codigo || ""}</td>
        <td>${b.capacidad_l ?? ""}</td>
        <td>${(b.tipo_roble || "")} ${b.tostado || ""}</td>
        <td>${b.marca || ""}</td>
        <td>${b.anio || ""}</td>
        <td>${b.vino_anio || ""}</td>
        <td>${variedadVisible}</td>
        <td>${volumenVisible}</td>
        <td>
            <button class="small-btn"
                onclick="editarBarricaDatos(${b.id})">
                Editar
            </button>
        </td>
        <td>
            <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <button class="small-btn"
                    onclick="abrirBitacoraContenedor('barrica', ${b.id})">
                    Bitácora
                </button>
            </div>
        </td>
        <td>
            <button
                onclick="eliminarBarrica(${b.id}, ${volumenParaEliminar})"
                style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                Borrar
            </button>
        </td>
    `;
                    tbody.appendChild(tr);
});
                actualizarIndicadores();
                refrescarGraficosResumenDesdeCaches();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando barricas:", err);
            }
        }

        async function crearBarrica(ev) {
            ev.preventDefault();
            const codigo = document.getElementById("barCodigo").value;
            const capacidad_l = parseFloat(document.getElementById("barCapacidad").value || "0");
            const tipo_roble = document.getElementById("barTipo").value;
            const tostado = document.getElementById("barTostado").value;
            const marca = document.getElementById("barMarca").value;
            const anio = document.getElementById("barAnio").value;
            const vino_anio = document.getElementById("barVinoAnio").value;
            const vino_tipo = document.getElementById("barVinoTipo").value;

            if (!codigo || !capacidad_l) {
                alert("Faltan datos de la barrica (código, capacidad).");
                return;
            }

            try {
                const body = { codigo, capacidad_l, tipo_roble, tostado, marca, anio, vino_anio, vino_tipo };
                const res = await fetch("/api/barricas", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al crear la barrica.");
                if (!ok) return;

                document.getElementById("formBarrica").reset();
                cargarBarricas();
                cargarResumen();
            } catch (err) {
                console.error("Error creando barrica:", err);
            }
        }

        // ---------- Almacén de limpieza ----------
        async function cargarLimpieza() {
            try {
                const res = await fetch("/api/limpieza");
                if (!res.ok) return;
                const datos = await res.json();
                cacheLimpieza = datos;

                const tbody = document.getElementById("tablaLimpieza");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoLimpieza(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos de limpieza:", err);
            }
        }

        async function crearProductoLimpieza(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("limNombre").value.trim();
            const lote = document.getElementById("limLote").value.trim();
            const cantidad = parseFloat(document.getElementById("limCantidad").value || "0");
            const unidad = document.getElementById("limUnidad").value.trim();
            const nota = document.getElementById("limNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/limpieza", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formLimpieza").reset();
                cargarLimpieza();
            } catch (err) {
                console.error("Error creando producto de limpieza:", err);
            }
        }

        async function registrarUsoLimpieza(id) {
            const prod = cacheLimpieza.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inválida.");
                return;
            }

            let destino_tipo = null;
            let destino_id = null;
            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vacío:", "")
                .trim()
                .toLowerCase();
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("Código o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor válido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/limpieza/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarLimpieza();
            } catch (err) {
                console.error("Error registrando consumo de limpieza:", err);
            }
        }

        // ---------- Productos enológicos ----------
        async function cargarEnologicos() {
            try {
                const res = await fetch("/api/enologicos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEnologicos = datos;
                const tbody = document.getElementById("tablaEnologicos");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoEnologico(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos enológicos:", err);
            }
        }

        async function crearProductoEnologico(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("enoNombre").value.trim();
            const lote = document.getElementById("enoLote").value.trim();
            const cantidad = parseFloat(document.getElementById("enoCantidad").value || "0");
            const unidad = document.getElementById("enoUnidad").value.trim();
            const nota = document.getElementById("enoNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad válida.");
                return;
            }

            try {
                const res = await fetch("/api/enologicos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formEnologicos").reset();
                cargarEnologicos();
            } catch (err) {
                console.error("Error creando producto enológico:", err);
            }
        }

async function registrarUsoEnologico(id) {
            const prod = cacheEnologicos.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inválida.");
                return;
            }

            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vacío:", "")
                .trim()
                .toLowerCase();
            let destino_tipo = null;
            let destino_id = null;
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("Código o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor válido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/enologicos/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarEnologicos();
            } catch (err) {
                console.error("Error registrando consumo enológico:", err);
            }
        }

        // ---------- Movimientos ----------
        async function cargarMovimientos() {
            try {
                mostrarSkeletonTabla("tablaMovimientos", 8, 4);
                const res = await fetch("/api/movimientos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheMovimientos = datos;
                renderMovimientos();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando movimientos:", err);
            }
        }

        function actualizarCamposMovimiento() {
            const tipoSelect = document.getElementById("movTipo");
            const origenTipo = document.getElementById("movOrigenTipo");
            const origenId = document.getElementById("movOrigenId");
            const origenNota = document.getElementById("movOrigenNota");
            const esPrensado = tipoSelect && tipoSelect.value === "prensado";

            if (esPrensado) {
                if (origenTipo) {
                    origenTipo.value = "";
                    origenTipo.disabled = true;
                }
                if (origenId) {
                    origenId.value = "";
                    origenId.disabled = true;
                }
                if (origenNota) {
                    origenNota.style.display = "block";
                }
            } else {
                if (origenTipo) {
                    origenTipo.disabled = false;
                }
                if (origenId) {
                    origenId.disabled = false;
                }
                if (origenNota) {
                    origenNota.style.display = "none";
                }
            }
        }

        async function crearMovimiento(ev) {
            ev.preventDefault();
            let fecha = document.getElementById("movFecha").value;
            if (!fecha) {
                fecha = new Date().toISOString();
            }
            const fecha_hora = fecha;

            const tipo = document.getElementById("movTipo").value;
            const destino_tipo = document.getElementById("movDestinoTipo").value || null;
            const origenTipoEl = document.getElementById("movOrigenTipo");
            const origenIdEl = document.getElementById("movOrigenId");
            let origen_tipo = origenTipoEl ? (origenTipoEl.value || null) : null;
            const origenRaw = origenIdEl ? origenIdEl.value.trim() : "";
            const destinoRaw = document.getElementById("movDestinoId").value.trim();

            let origen_id = null;
            let destino_id = null;
            const esPrensado = tipo === "prensado";

            if (!esPrensado && origenRaw) {
                if (/^\d+$/.test(origenRaw)) {
                    origen_id = parseInt(origenRaw, 10);
                } else if (origen_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === origenRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = dep.id;
                } else if (origen_tipo === "mastelone") {
                    const mas = cacheMastelones.find(m => m.codigo === origenRaw);
                    if (!mas) {
                        setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = mas.id;
                } else if (origen_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === origenRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + origenRaw, "error");
                        return;
                    }
                    origen_id = bar.id;
                } else {
                    setFormFeedback("feedbackMovimientos", "Para usar un código como origen, el tipo debe ser depósito, mastelone o barrica.", "error");
                    return;
                }
            }

            if (esPrensado) {
                origen_tipo = null;
                origen_id = null;
            }

            if (destinoRaw) {
                if (/^\d+$/.test(destinoRaw)) {
                    destino_id = parseInt(destinoRaw, 10);
                } else if (destino_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === destinoRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro depósito con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = dep.id;
                } else if (destino_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === destinoRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con código " + destinoRaw, "error");
                        return;
                    }
                    destino_id = bar.id;
    } else if (destino_tipo === "mastelone") {
        const mas = cacheMastelones.find(m => m.codigo === destinoRaw);
        if (!mas) {
            setFormFeedback("feedbackMovimientos", "No encuentro mastelone con código " + destinoRaw, "error");
            return;
        }
        destino_id = mas.id;
    } else {
        setFormFeedback("feedbackMovimientos", "Para usar un código como destino, el tipo debe ser depósito, mastelone o barrica.", "error");
        return;
    }
}

            const litros = parseFloat(document.getElementById("movLitros").value || "0");
            const perdida_litros = document.getElementById("movPerdida").value
                ? parseFloat(document.getElementById("movPerdida").value)
                : null;
            const nota = document.getElementById("movNota").value;

            if (!litros || litros <= 0) {
                setFormFeedback("feedbackMovimientos", "Los litros deben ser mayores que 0.", "error");
                return;
            }

            const body = {
                fecha,
                fecha_hora,
                tipo,
                origen_tipo,
                origen_id,
                destino_tipo,
                destino_id,
                litros,
                perdida_litros,
                nota,
            };

            try {
                const res = await fetch("/api/movimientos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al guardar el movimiento.");
                if (!ok) return;

                document.getElementById("formMovimiento").reset();
                actualizarCamposMovimiento();
                await Promise.all([
                    cargarMovimientos(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarResumen(),
                ]);
                setFormFeedback("feedbackMovimientos", "Movimiento registrado.", "success");
                mostrarAviso("Movimiento registrado.", "success");
            } catch (err) {
                console.error("Error creando movimiento:", err);
                setFormFeedback("feedbackMovimientos", "No se pudo crear el movimiento.", "error");
                mostrarAviso("Error al crear el movimiento.", "error");
            }
        }

        // ---------- Embotellado ----------
        let embotelladoFormatos = [];

        function parsearFormatosEmbotellado(valor) {
            if (!valor) return [];
            if (Array.isArray(valor)) return valor;
            if (typeof valor === "string") {
                try {
                    const parsed = JSON.parse(valor);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (err) {
                    return [];
                }
            }
            return [];
        }

        function obtenerFormatosEmbotelladoFormulario() {
            const lista = normalizarFormatosBotellaLista(embotelladoFormatos);
            return lista.map(item => ({ formato: item.formato, botellas: item.botellas }));
        }

        function actualizarEstadoFormularioEmbotellado() {
            const resumen = calcularResumenFormatosBotellaDesdeLista(embotelladoFormatos);
            const botellasInput = document.getElementById("embBotellas");
            const formatoSelect = document.getElementById("embFormato");
            if (botellasInput) {
                if (resumen.totalBotellas > 0) {
                    botellasInput.value = resumen.totalBotellas;
                    botellasInput.readOnly = true;
                    botellasInput.classList.add("field-readonly");
                } else {
                    botellasInput.readOnly = false;
                    botellasInput.classList.remove("field-readonly");
                }
            }
            if (formatoSelect) {
                formatoSelect.disabled = resumen.totalBotellas > 0;
            }
        }

        function renderFormatosEmbotelladoFormulario() {
            const wrapper = document.getElementById("embFormatosWrapper");
            if (!wrapper) return;
            wrapper.innerHTML = "";
            const tabla = document.createElement("table");
            const thead = document.createElement("thead");
            thead.innerHTML = `
                <tr>
                    <th>Formato</th>
                    <th>Botellas</th>
                    <th>L calc.</th>
                    <th></th>
                </tr>`;
            tabla.appendChild(thead);
            const tbody = document.createElement("tbody");
            tabla.appendChild(tbody);
            const resumenEl = document.createElement("div");
            resumenEl.className = "tabla-formatos-resumen";
            const formatosDisponibles = Object.keys(VOLUMEN_BOTELLA_L);

            const calcularLitrosTexto = registro => {
                if (!registro) return "";
                const formato = registro.formato;
                const botellasRaw = normalizarNumero(registro.botellas);
                const botellas = Number.isFinite(botellasRaw) ? Math.max(0, Math.floor(botellasRaw)) : 0;
                const volBotella = VOLUMEN_BOTELLA_L[formato] || 0;
                if (volBotella > 0 && botellas > 0) {
                    return (botellas * volBotella).toFixed(2);
                }
                return "";
            };

            const actualizarResumen = () => {
                const resumen = calcularResumenFormatosBotellaDesdeLista(embotelladoFormatos);
                const botellasTxt = resumen.totalBotellas
                    ? `${resumen.totalBotellas.toLocaleString("es-ES")} botellas`
                    : "0 botellas";
                const litrosTxt = resumen.totalLitros
                    ? ` · ${resumen.totalLitros.toFixed(2)} L`
                    : "";
                resumenEl.textContent = `Total: ${botellasTxt}${litrosTxt}`;
                actualizarEstadoFormularioEmbotellado();
            };

            const renderFilas = () => {
                tbody.innerHTML = "";
                if (!embotelladoFormatos.length) {
                    const fila = document.createElement("tr");
                    fila.innerHTML = `<td colspan="4" style="text-align:center; color:#777;">Sin formatos mixtos</td>`;
                    tbody.appendChild(fila);
                    actualizarResumen();
                    return;
                }
                embotelladoFormatos.forEach((registro, index) => {
                    const tr = document.createElement("tr");
                    const tdFormato = document.createElement("td");
                    const select = document.createElement("select");
                    select.dataset.index = index;
                    select.dataset.campo = "formato";
                    const placeholder = document.createElement("option");
                    placeholder.value = "";
                    placeholder.textContent = "Selecciona formato";
                    if (!registro.formato) placeholder.selected = true;
                    select.appendChild(placeholder);
                    formatosDisponibles.forEach(op => {
                        const option = document.createElement("option");
                        option.value = op;
                        option.textContent = op;
                        select.appendChild(option);
                    });
                    if (registro.formato) select.value = registro.formato;
                    tdFormato.appendChild(select);
                    const tdBotellas = document.createElement("td");
                    const input = document.createElement("input");
                    input.type = "number";
                    input.min = "0";
                    input.step = "1";
                    input.dataset.index = index;
                    input.dataset.campo = "botellas";
                    input.value = registro.botellas != null ? registro.botellas : "";
                    tdBotellas.appendChild(input);
                    const tdLitros = document.createElement("td");
                    tdLitros.dataset.index = index;
                    tdLitros.dataset.campo = "litros";
                    tdLitros.textContent = calcularLitrosTexto(registro);
                    const tdAccion = document.createElement("td");
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "small-btn";
                    btn.textContent = "✕";
                    btn.dataset.index = index;
                    btn.dataset.accion = "eliminar";
                    tdAccion.appendChild(btn);
                    tr.appendChild(tdFormato);
                    tr.appendChild(tdBotellas);
                    tr.appendChild(tdLitros);
                    tr.appendChild(tdAccion);
                    tbody.appendChild(tr);
                });
                actualizarResumen();
            };

            tbody.addEventListener("input", e => {
                const target = e.target;
                const index = target.dataset.index;
                const campo = target.dataset.campo;
                if (index == null || !campo) return;
                if (!embotelladoFormatos[index]) return;
                embotelladoFormatos[index][campo] = target.value;
                const litrosCell = tbody.querySelector(
                    `td[data-index="${index}"][data-campo="litros"]`
                );
                if (litrosCell) {
                    litrosCell.textContent = calcularLitrosTexto(embotelladoFormatos[index]);
                }
                actualizarResumen();
            });

            tbody.addEventListener("change", e => {
                const target = e.target;
                const index = target.dataset.index;
                const campo = target.dataset.campo;
                if (index == null || !campo) return;
                if (!embotelladoFormatos[index]) return;
                embotelladoFormatos[index][campo] = target.value;
                const litrosCell = tbody.querySelector(
                    `td[data-index="${index}"][data-campo="litros"]`
                );
                if (litrosCell) {
                    litrosCell.textContent = calcularLitrosTexto(embotelladoFormatos[index]);
                }
                actualizarResumen();
            });

            tbody.addEventListener("click", e => {
                const btn = e.target.closest("button[data-accion='eliminar']");
                if (!btn) return;
                const index = Number(btn.dataset.index);
                if (!Number.isFinite(index)) return;
                embotelladoFormatos.splice(index, 1);
                renderFilas();
            });

            const btnAdd = document.createElement("button");
            btnAdd.type = "button";
            btnAdd.className = "btnSecundario";
            btnAdd.style.marginTop = "8px";
            btnAdd.textContent = "+ Añadir formato";
            btnAdd.addEventListener("click", () => {
                const formatoSelect = document.getElementById("embFormato");
                const formatoBase =
                    (formatoSelect &&
                    formatoSelect.value &&
                    VOLUMEN_BOTELLA_L[formatoSelect.value] != null)
                        ? formatoSelect.value
                        : formatosDisponibles[0];
                embotelladoFormatos.push({ formato: formatoBase || "", botellas: "" });
                renderFilas();
            });

            renderFilas();
            wrapper.appendChild(tabla);
            wrapper.appendChild(btnAdd);
            wrapper.appendChild(resumenEl);
        }

        function limpiarFormatosEmbotelladoFormulario() {
            embotelladoFormatos = [];
            renderFormatosEmbotelladoFormulario();
        }

        async function cargarEmbotellados() {
            try {
                const res = await fetch("/api/embotellados");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEmbotellados = datos;
                const tbody = document.getElementById("tablaEmbotellados");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="6">Aún no hay embotellados registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                const crearCelda = (texto, title = "") => {
                    const td = document.createElement("td");
                    td.textContent = texto || "";
                    if (title) td.title = title;
                    return td;
                };

                datos.forEach(e => {
                    const origen = formatearUbicacionMovimiento(e.contenedor_tipo, e.contenedor_id);
                    const fecha = formatearFechaCorta(e.fecha);
                    const formatos = parsearFormatosEmbotellado(e.formatos);
                    const resumen = calcularResumenFormatosBotellaDesdeLista(formatos);
                    const formatosResumen = formatearResumenFormatosEmbotellado(formatos) || "—";
                    const formatosDetalle = construirDetalleFormatosBotella(formatos);
                    const botellasTxt = e.botellas != null
                        ? String(e.botellas)
                        : resumen.totalBotellas > 0
                        ? String(resumen.totalBotellas)
                        : "";
                    const tr = document.createElement("tr");
                    tr.appendChild(crearCelda(fecha));
                    tr.appendChild(crearCelda(origen));
                    tr.appendChild(crearCelda(botellasTxt));
                    tr.appendChild(crearCelda(formatosResumen, formatosDetalle));
                    tr.appendChild(crearCelda(e.lote || ""));
                    tr.appendChild(crearCelda(e.nota || ""));
                    tbody.appendChild(tr);
                });
                actualizarIndicadores();
                actualizarMapaFlujo();
                programarActualizacionCopiloto();
            } catch (err) {
                console.error("Error cargando embotellados:", err);
            }
        }

        async function crearEmbotellado(ev) {
            ev.preventDefault();
            const fecha = document.getElementById("embFecha").value;
            const contenedor_tipo = document.getElementById("embTipo").value;
            const contenedorValor = document.getElementById("embContenedor").value.trim();
            const botellasInput = parseInt(document.getElementById("embBotellas").value || "0", 10) || null;
            const formatoUnico = document.getElementById("embFormato").value;
            const lote = document.getElementById("embLote").value.trim();
            const nota = document.getElementById("embNota").value.trim();

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id) {
                alert("No encuentro ese contenedor.");
                return;
            }

            const formatosFormulario = obtenerFormatosEmbotelladoFormulario();
            let botellas = botellasInput;
            let litros = 0;
            let formatosPayload = [];
            if (formatosFormulario.length) {
                const resumen = calcularResumenFormatosBotellaDesdeLista(formatosFormulario);
                botellas = resumen.totalBotellas || null;
                litros = resumen.totalLitros || 0;
                formatosPayload = formatosFormulario;
            } else {
                if (!botellas || botellas <= 0) {
                    alert("Las botellas deben ser mayores que 0.");
                    return;
                }
                const volBotella = VOLUMEN_BOTELLA_L[formatoUnico] || 0;
                if (!(volBotella > 0)) {
                    alert("Selecciona un formato de botella válido.");
                    return;
                }
                litros = botellas * volBotella;
                formatosPayload = [{ formato: formatoUnico, botellas }];
            }

            if (!botellas || botellas <= 0) {
                alert("Las botellas deben ser mayores que 0.");
                return;
            }
            if (!(litros > 0)) {
                alert("No se pudo calcular litros para el embotellado.");
                return;
            }

            const body = {
                fecha,
                contenedor_tipo,
                contenedor_id,
                litros: Number(litros.toFixed(3)),
                botellas,
                lote,
                nota,
                formatos: formatosPayload,
            };

            try {
                const res = await fetch("/api/embotellados", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el embotellado.");
                if (!ok) return;
                document.getElementById("formEmbotellado").reset();
                limpiarFormatosEmbotelladoFormulario();
                await Promise.all([cargarEmbotellados(), cargarBarricas(), cargarDepositos(), cargarMovimientos(), cargarResumen()]);
            } catch (err) {
                console.error("Error creando embotellado:", err);
            }
        }

        // ---------- Registros analíticos ----------
        async function crearRegistroAnalitico(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("regTipo").value;
            const contenedorValor = document.getElementById("regId").value.trim();
            const fecha_hora = document.getElementById("regFecha").value;
            const densidad = document.getElementById("regDensidad").value
                ? parseFloat(document.getElementById("regDensidad").value)
                : null;
            const temperatura_c = document.getElementById("regTemperatura").value
                ? parseFloat(document.getElementById("regTemperatura").value)
                : null;
            const nota_sensorial = document.getElementById("regNotaSensorial").value;
            const nota = document.getElementById("regNota").value;

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id || !fecha_hora) {
                alert("Indica un contenedor válido y la fecha/hora.");
                return;
            }

            const body = {
                contenedor_tipo,
                contenedor_id,
                fecha_hora,
                densidad,
                temperatura_c,
                nota_sensorial,
                nota,
            };

            try {
                const res = await fetch("/api/registros", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                document.getElementById("formAnalitico").reset();
                cargarResumen();
                copilotoAnaliticosCache.clear();
                copilotoAnaliticosTs.clear();
                programarActualizacionCopiloto(true);
                alert("Registro analítico guardado.");
            } catch (err) {
                console.error("Error guardando registro analítico:", err);
                alert("Error al guardar el registro analítico.");
            }
        }

        async function cargarHistorialAnalitico() {
            const tipo = document.getElementById("histTipo").value;
            const valor = document.getElementById("histId").value.trim();
            const id = resolverContenedorId(tipo, valor);
            const tbody = document.getElementById("tablaRegistros");
            tbody.innerHTML = "";

            if (!id) {
                alert("Indica un contenedor válido (número o código).");
                return;
            }

            try {
                const datos = await obtenerHistorialCompleto(tipo, id);

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="4">No hay registros para este contenedor.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(r => {
                    const tr = document.createElement("tr");
                    const fecha = formatearFechaCorta(r.fecha || r.fecha_hora);
                    let evento = "";
                    let detalle = "";

                    if (r.categoria === "analitico") {
                        evento = "Registro analítico";
                        const partes = [];
                        if (r.densidad != null) partes.push(`Densidad: ${r.densidad}`);
                        if (r.temperatura_c != null) partes.push(`Temp: ${r.temperatura_c} °C`);
                        detalle = partes.join(" · ");
                    } else if (r.categoria === "movimiento") {
                        evento = `Movimiento: ${r.tipo || ""}`;
                        const origen = formatearUbicacionMovimiento(r.origen_tipo, r.origen_id);
                        const destino = formatearUbicacionMovimiento(r.destino_tipo, r.destino_id);
                        detalle = `${r.litros || 0} L · ${origen || "—"} → ${destino || "—"}`;
                    } else {
                        evento = "Evento";
                        detalle = "";
                    }
                    const notas = [];
                    if (r.nota_sensorial) {
                        notas.push(`Sensorial: ${r.nota_sensorial}`);
                    }
                    if (r.nota) {
                        const textoNota = r.categoria === "analitico" ? `Nota: ${r.nota}` : r.nota;
                        notas.push(textoNota);
                    }
                    const notaTexto = notas.join(" · ");

                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${evento}</td>
                        <td>${detalle}</td>
                        <td>${notaTexto}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando historial analítico:", err);
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="4">Error al cargar el historial.</td>';
                tbody.appendChild(tr);
            }
        }

        // ---------- Análisis Laboratorio ----------
        async function crearAnalisisLab(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("labTipoContenedor").value;
            const depositoValor = document.getElementById("labDeposito").value.trim();
            const contenedor_id = resolverContenedorId(contenedor_tipo, depositoValor);
            const fecha = document.getElementById("labFecha").value;
            const laboratorio = document.getElementById("labLaboratorio").value;
            const descripcion = document.getElementById("labDescripcion").value;
            const archivoInput = document.getElementById("labArchivo");
            const archivo = archivoInput.files[0];
            const mensaje = document.getElementById("labMensaje");

            if (!contenedor_id) {
                mensaje.textContent = "Indica un contenedor válido.";
                return;
            }
            if (!archivo) {
                mensaje.textContent = "Selecciona un PDF.";
                return;
            }
            if (archivo.type && archivo.type !== "application/pdf") {
                mensaje.textContent = "Solo se permiten PDF.";
                return;
            }

            try {
                mensaje.textContent = "Subiendo PDF...";
                const archivo_base64 = await leerArchivoBase64(archivo);
                const body = {
                    contenedor_id,
                    contenedor_tipo,
                    fecha,
                    laboratorio,
                    descripcion,
                    archivo_nombre: archivo.name,
                    archivo_base64,
                };
                const res = await fetch("/api/analisis-lab", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al subir el análisis.");
                if (!ok) {
                    mensaje.textContent = "No se pudo guardar.";
                    return;
                }
                document.getElementById("formAnalisisLab").reset();
                mensaje.textContent = "Análisis guardado correctamente.";
                await cargarAnalisisLab(filtroAnalisisDeposito);
                setTimeout(() => (mensaje.textContent = ""), 3000);
            } catch (err) {
                console.error("Error subiendo PDF:", err);
                mensaje.textContent = "Error al guardar el análisis.";
            }
        }

        async function cargarAnalisisLab(nuevoFiltro) {
            if (arguments.length > 0) {
                filtroAnalisisDeposito = nuevoFiltro;
            }
            const filtroActual = filtroAnalisisDeposito;
            mostrarSkeletonTabla("tablaAnalisisLab", 5);
            try {
                let url = "/api/analisis-lab";
                if (filtroActual && (filtroActual.id || filtroActual.tipo)) {
                    const params = new URLSearchParams();
                    if (filtroActual.id) params.set("contenedor_id", filtroActual.id);
                    if (filtroActual.tipo) params.set("tipo", filtroActual.tipo);
                    const qs = params.toString();
                    if (qs) {
                        url += `?${qs}`;
                    }
                }
                const res = await fetch(url);
                if (!res.ok) throw new Error();
                cacheAnalisisLab = await res.json();
                renderAnalisisLab();
            } catch (err) {
                console.error("Error cargando análisis:", err);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="5">No se pudieron cargar los análisis.</td></tr>';
                }
            }
        }

        function renderAnalisisLab() {
            const tbody = document.getElementById("tablaAnalisisLab");
            if (!tbody) return;
            tbody.innerHTML = "";
            if (!cacheAnalisisLab.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin análisis registrados todavía.</td>';
                tbody.appendChild(tr);
                return;
            }
            cacheAnalisisLab.forEach(reg => {
                const tr = document.createElement("tr");
                const fecha = reg.fecha ? formatearFechaCorta(reg.fecha) : "—";
                const tipoCont = reg.contenedor_tipo || "deposito";
                const contenedor =
                    formatearUbicacionMovimiento(tipoCont, reg.contenedor_id) ||
                    `${tipoCont} ${reg.contenedor_id}`;
                const laboratorio = reg.laboratorio || "—";
                const descripcion = reg.descripcion || "—";
                const archivo =
                    reg.archivo_url
                        ? `<a href="${reg.archivo_url}" target="_blank" rel="noopener">Descargar PDF</a>`
                        : "—";
                tr.innerHTML = `
                    <td>${fecha}</td>
                    <td>${contenedor}</td>
                    <td>${laboratorio}</td>
                    <td>${descripcion}</td>
                    <td>${archivo}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function aplicarFiltroAnalisisLab() {
            const valor = document.getElementById("labFiltroDeposito").value.trim();
            const tipoSelect = document.getElementById("labFiltroTipo").value;
            if (!valor && !tipoSelect) {
                await cargarAnalisisLab(null);
                return;
            }
            let filtro = null;
            if (valor) {
                let tipoCont = tipoSelect || "";
                let id = null;
                if (tipoCont) {
                    id = resolverContenedorId(tipoCont, valor);
                } else {
                    id = resolverContenedorId("deposito", valor);
                    tipoCont = id ? "deposito" : "";
                    if (!id) {
                        id = resolverContenedorId("mastelone", valor);
                        if (id) tipoCont = "mastelone";
                    }
                }
                if (!id) {
                    alert("No encuentro un contenedor con ese código/ID.");
                    return;
                }
                filtro = { id, tipo: tipoCont };
            } else if (tipoSelect) {
                filtro = { id: null, tipo: tipoSelect };
            }
            await cargarAnalisisLab(filtro);
        }

        async function limpiarFiltroAnalisisLab() {
            document.getElementById("labFiltroDeposito").value = "";
            document.getElementById("labFiltroTipo").value = "";
            await cargarAnalisisLab(null);
        }

function leerArchivoBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error("No se pudo leer el archivo"));
                reader.readAsDataURL(file);
            });
        }

        // ---------- Demo ligera de drag & drop de tanques/barricas ----------
        const tanques = [
            { id: "T101", tipo: "Tanque", vino: "Tempranillo", volumen: 8000, capacidad: 10000, estado: "FA", x: 80, y: 60 },
            { id: "B045", tipo: "Barrica", vino: "Crianza Lote 5", volumen: 225, capacidad: 225, estado: "Reposo", x: 320, y: 120 },
            { id: "T204", tipo: "Tanque", vino: "Garnacha", volumen: 5200, capacidad: 8000, estado: "FML", x: 180, y: 200 },
        ];
        let demoDrag = null;

        function renderDemoFlow() {
            const stage = document.getElementById("demoFlowStage");
            if (!stage) return;
            stage.innerHTML = "";
            tanques.forEach((nodo, idx) => {
                const el = document.createElement("div");
                el.className = "flow-node demo-flow-node";
                el.style.left = `${nodo.x}px`;
                el.style.top = `${nodo.y}px`;
                el.dataset.index = idx;
                el.innerHTML = `
                    <h4 style="margin:0 0 4px;">${nodo.id}</h4>
                    <div class="flow-node-subtitle">${nodo.tipo} · ${nodo.vino}</div>
                    <div class="flow-node-subtitle">Volumen ${nodo.volumen} / ${nodo.capacidad}</div>
                    <div class="estado-pill estado-${(nodo.estado || "").toLowerCase()}" style="margin-top:6px;">${nodo.estado}</div>
                `;
                el.addEventListener("pointerdown", ev => startDemoDrag(ev, idx));
                stage.appendChild(el);
            });
        }

        function startDemoDrag(ev, idx) {
            const stage = document.getElementById("demoFlowStage");
            const nodeEl = ev.currentTarget;
            if (!stage || !nodeEl) return;
            const rect = stage.getBoundingClientRect();
            demoDrag = {
                idx,
                nodeEl,
                stage,
                pointerId: ev.pointerId,
                offsetX: ev.clientX - rect.left - tanques[idx].x,
                offsetY: ev.clientY - rect.top - tanques[idx].y,
            };
            nodeEl.setPointerCapture(ev.pointerId);
            nodeEl.classList.add("dragging");
            nodeEl.addEventListener("pointermove", moveDemoDrag);
            nodeEl.addEventListener("pointerup", endDemoDrag);
            nodeEl.addEventListener("pointercancel", endDemoDrag);
        }

        function moveDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { stage, nodeEl, idx, offsetX, offsetY } = demoDrag;
            const stageRect = stage.getBoundingClientRect();
            const nodeRect = nodeEl.getBoundingClientRect();
            let x = ev.clientX - stageRect.left - offsetX;
            let y = ev.clientY - stageRect.top - offsetY;
            const maxX = stageRect.width - nodeRect.width;
            const maxY = stageRect.height - nodeRect.height;
            x = Math.max(0, Math.min(maxX, x));
            y = Math.max(0, Math.min(maxY, y));
            tanques[idx].x = Math.round(x);
            tanques[idx].y = Math.round(y);
            nodeEl.style.left = `${tanques[idx].x}px`;
            nodeEl.style.top = `${tanques[idx].y}px`;
        }

        function endDemoDrag(ev) {
            if (!demoDrag || ev.pointerId !== demoDrag.pointerId) return;
            const { nodeEl, pointerId } = demoDrag;
            try {
                nodeEl.releasePointerCapture(pointerId);
            } catch (e) {
                // noop
            }
            nodeEl.classList.remove("dragging");
            nodeEl.removeEventListener("pointermove", moveDemoDrag);
            nodeEl.removeEventListener("pointerup", endDemoDrag);
            nodeEl.removeEventListener("pointercancel", endDemoDrag);
            demoDrag = null;
        }

        // ---------- Bitácora ----------
        let bitacoraEntries = [];
        let bitacoraCargando = false;

        function obtenerNombreBitacoraDeposito(id) {
            const dep = buscarDepositoPorId ? buscarDepositoPorId(Number(id)) : null;
            if (dep) return obtenerNombreDeposito(Number(id));
            const mast = (cacheMastelones || []).find(item => String(item.id) === String(id));
            if (mast) return obtenerNombreMastelone(Number(id));
            return `Depósito ${id}`;
        }

        function obtenerNombreBitacoraMadera(id) {
            return obtenerNombreBarrica ? obtenerNombreBarrica(Number(id)) : `Barrica ${id}`;
        }

        function setEstadoBitacora(texto) {
            const estado = document.getElementById("bitacoraEstado");
            if (estado) estado.textContent = texto || "";
        }

        function normalizarTipoContenedorBitacora(valor) {
            const limpio = (valor || "").toString().trim().toLowerCase();
            return ["deposito", "mastelone", "barrica"].includes(limpio) ? limpio : "";
        }

        function formatearTimestampBitacora(valor) {
            if (!valor) return "";
            const fecha = new Date(valor);
            if (Number.isNaN(fecha.getTime())) return "";
            const dia = fecha.toLocaleDateString("es-ES", {
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
            });
            const hora = fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
            return `${dia} ${hora}`;
        }

        function textoPlanoBitacora(valor) {
            if (valor === null || valor === undefined) return "";
            if (typeof valor === "number" && Number.isFinite(valor)) return String(valor);
            return String(valor).trim();
        }

        function textoConFallbackBitacora(valor, fallback) {
            const texto = textoPlanoBitacora(valor);
            return texto ? texto : fallback;
        }

        function textoSiNoBitacora(valor) {
            const limpio = textoPlanoBitacora(valor).toLowerCase();
            if (valor === true || valor === 1 || limpio === "si" || limpio === "sí") return "sí";
            if (valor === false || valor === 0 || limpio === "no") return "no";
            return "no registrado";
        }

        function normalizarTimestampClaveBitacora(valor) {
            if (!valor) return "";
            const fecha = new Date(valor);
            if (Number.isNaN(fecha.getTime())) return "";
            return fecha.toISOString().slice(0, 16);
        }

        function obtenerTipoMovimientoBitacora(entry) {
            return textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["tipo_movimiento", "movimiento_tipo", "tipo"])
            ).toLowerCase();
        }

        function obtenerCampoBitacora(evento, claves) {
            const fuentes = [evento?.payload, evento?.meta, evento];
            for (const fuente of fuentes) {
                if (!fuente) continue;
                for (const clave of claves) {
                    const valor = fuente[clave];
                    if (valor !== undefined && valor !== null && String(valor).trim() !== "") {
                        return valor;
                    }
                }
            }
            return null;
        }

        function resolverDosisBitacora(evento) {
            const dosis = obtenerCampoBitacora(evento, ["dosis"]);
            if (dosis && typeof dosis === "object" && !Array.isArray(dosis)) {
                return {
                    cantidad: dosis.cantidad ?? dosis.valor ?? dosis.cant ?? null,
                    unidad: (dosis.unidad ?? dosis.unid ?? "").toString().trim(),
                };
            }
            return {
                cantidad: obtenerCampoBitacora(evento, ["dosis_cantidad", "dosisCantidad", "dosis"]),
                unidad: (obtenerCampoBitacora(evento, ["dosis_unidad", "dosisUnidad", "unidad"]) || "").toString().trim(),
            };
        }

        function etiquetaContenedorPlano(tipo) {
            if (tipo === "barrica") return "Barrica";
            if (tipo === "mastelone") return "Mastelone";
            return "Depósito";
        }

        function formatearContenedorPlano(tipo, id) {
            if (!id) return "";
            return `${etiquetaContenedorPlano(tipo)} ${id}`.trim();
        }

        function extraerLineasTexto(texto) {
            return (texto || "")
                .toString()
                .split(/\r?\n/)
                .map(linea => linea.trim())
                .filter(Boolean);
        }

        function detectarTipoEventoBitacora(evento) {
            const tipoMeta = textoPlanoBitacora(
                obtenerCampoBitacora(evento, ["tipo_evento", "tipoEvento", "event_type", "eventType", "evento"])
            ).toLowerCase();
            if (tipoMeta) {
                if (tipoMeta === "conexion" || tipoMeta === "desconexion" || tipoMeta === "mapa_nodos") {
                    return "movimiento";
                }
                return tipoMeta;
            }

            const tipoBase = textoPlanoBitacora(evento?.tipo).toLowerCase();
            const accion = textoPlanoBitacora(obtenerCampoBitacora(evento, ["accion"])).toLowerCase();
            const texto = [
                evento?.resumen,
                evento?.detalle,
                evento?.texto,
                evento?.text
            ].filter(Boolean).join(" ").toLowerCase();

            if (texto.includes("entrada de uva")) return "entrada_uva";
            if (texto.includes("recuento")) return "recuento";
            if (texto.includes("despalillado")) return "despalillado";
            if (texto.includes("descube")) return "descube";
            if (texto.includes("prensado")) return "prensado";
            if (texto.includes("coupage")) return "coupage";
            if (texto.includes("clarificacion") || texto.includes("clarificación") ||
                texto.includes("filtracion") || texto.includes("filtración")) {
                return "clarificacion_filtracion";
            }
            if (texto.includes("embotellado")) return "embotellado";
            if (texto.includes("entrada en barrica") || texto.includes("entrada barrica")) return "entrada_barrica";
            if (texto.includes("relleno de barrica") || texto.includes("relleno barrica")) return "relleno_barrica";
            if (texto.includes("trasvase") || texto.includes("trasiego")) return "trasvase";
            if (texto.includes("fermentación") && texto.includes("inicio")) return "inicio_fermentacion";

            if (tipoBase === "entrada_uva") return "entrada_uva";
            if (tipoBase === "entrada") return "entrada_uva";
            if (tipoBase === "embotellado") return "embotellado";
            if (tipoBase === "movimiento") {
                const tipoMov = obtenerTipoMovimientoBitacora(evento);
                if (tipoMov === "trasiego" || tipoMov === "trasvase") return "trasvase";
                if (tipoMov === "prensado") return "prensado";
                if (tipoMov === "descube") return "descube";
                if (tipoMov === "embotellado") return "embotellado";
                if (tipoMov === "merma" || tipoMov === "ajuste" || tipoMov === "salida") return "recuento";
                return "movimiento";
            }
            if (accion === "mapa_nodos") return "movimiento";
            if (tipoBase === "fermentacion") {
                if (obtenerCampoBitacora(evento, ["bazuqueo"]) || obtenerCampoBitacora(evento, ["remontado"])) {
                    return "bazuqueo_remontado";
                }
                if (obtenerCampoBitacora(evento, ["densidad"]) || obtenerCampoBitacora(evento, ["temperatura", "temperatura_c"])) {
                    return "medicion";
                }
                if (obtenerCampoBitacora(evento, ["levadura"])) return "inicio_fermentacion";
                return "nota";
            }
            if (tipoBase === "crianza") {
                if (obtenerCampoBitacora(evento, ["trasiego"])) return "trasvase";
                if (obtenerCampoBitacora(evento, ["so2"])) return "adicion";
                return "nota";
            }

            if (accion === "bazuqueo" || accion === "remontado" || accion === "bazuqueo_remontado") {
                return "bazuqueo_remontado";
            }
            if (accion === "trasiego" || accion === "trasvase") return "trasvase";
            if (accion === "relleno" && normalizarTipoContenedorBitacora(evento?.contenedor_tipo) === "barrica") {
                return "relleno_barrica";
            }
            if (accion === "sulfitado" || accion === "correccion" || accion === "tratamiento" || accion === "so2") {
                return "adicion";
            }
            if (accion === "densidad" || accion === "temperatura" || accion === "densidad_temperatura" || tipoBase === "analitica") {
                return "medicion";
            }
            if (tipoBase === "nota") return "nota";
            return "nota";
        }

        function puntuarEventoBitacora(entry) {
            let score = Number(entry?.prioridad) || 0;
            const payload = entry?.payload && typeof entry.payload === "object" ? Object.keys(entry.payload).length : 0;
            const meta = entry?.meta && typeof entry.meta === "object" ? Object.keys(entry.meta).length : 0;
            if (payload) score += 6;
            if (meta) score += 4;
            if (entry?.detalle || entry?.resumen || entry?.texto || entry?.text) score += 2;
            return score;
        }

        function construirClaveBitacora(entry) {
            if (!entry) return "";
            const tipo = detectarTipoEventoBitacora(entry);
            const ts = normalizarTimestampClaveBitacora(entry.ts || entry.created_at || entry.fecha_hora || entry.fecha);
            const contTipo = normalizarTipoContenedorBitacora(entry.contenedor_tipo || entry.entidad_tipo);
            const contId = entry.contenedor_id || entry.entidad_id;
            const contenedor = contTipo && contId ? `${contTipo}:${contId}` : "";
            const origen = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["origen_tipo", "origen_id", "origen"])
            ).toLowerCase();
            const destino = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["destino_tipo", "destino_id", "destino"])
            ).toLowerCase();
            const cantidad = textoPlanoBitacora(
                obtenerCampoBitacora(entry, ["kilos", "litros", "botellas", "valor_nuevo"])
            );
            const texto = textoPlanoBitacora(
                entry.texto || entry.text || entry.resumen || entry.detalle
            ).toLowerCase().slice(0, 80);
            const partesBase = [tipo, ts, contenedor, origen, destino, cantidad];
            const base = partesBase.filter(Boolean).join("|");
            const baseTieneDatos = contenedor || origen || destino || cantidad;
            if (!base && texto) return `texto|${texto}`;
            if (!baseTieneDatos && texto) return `${base}|${texto}`;
            return base;
        }

        function deduplicarBitacora(entries) {
            const mapa = new Map();
            const sinClave = [];
            entries.forEach(entry => {
                const clave = construirClaveBitacora(entry);
                if (!clave) {
                    sinClave.push(entry);
                    return;
                }
                const score = puntuarEventoBitacora(entry);
                const existente = mapa.get(clave);
                if (!existente || score > existente.score) {
                    mapa.set(clave, { entry, score });
                }
            });
            return [...mapa.values().map(item => item.entry), ...sinClave];
        }

        function construirLineasBitacora(entry) {
            const lineas = [];
            if (!entry) return lineas;
            const tipoEvento = detectarTipoEventoBitacora(entry);
            const ts = formatearTimestampBitacora(entry.ts || entry.created_at || entry.fecha_hora || entry.fecha) || "—";
            const contenedorTipo = normalizarTipoContenedorBitacora(entry.contenedor_tipo || entry.entidad_tipo);
            const contenedorId = entry.contenedor_id || entry.entidad_id;
            const ubicacion = contenedorTipo && contenedorId
                ? formatearContenedorPlano(contenedorTipo, contenedorId)
                : "no registrado";
            const depositoId = contenedorTipo && contenedorTipo !== "barrica"
                ? contenedorId
                : obtenerCampoBitacora(entry, ["deposito_id", "depositoId"]);
            const barricaId = contenedorTipo === "barrica"
                ? contenedorId
                : obtenerCampoBitacora(entry, ["madera_id", "maderaId", "barrica_id", "barricaId"]);
            const tipoMovimiento = obtenerTipoMovimientoBitacora(entry);
            const perdidaLitros = obtenerCampoBitacora(entry, ["perdida_litros", "perdidaLitros"]);

            const resolverOrigen = () => {
                const tipo = normalizarTipoContenedorBitacora(obtenerCampoBitacora(entry, ["origen_tipo", "origenTipo"]));
                const id = obtenerCampoBitacora(entry, ["origen_id", "origenId"]);
                if (tipo && id) return formatearContenedorPlano(tipo, id);
                const texto = obtenerCampoBitacora(entry, ["origen"]);
                if (texto) return textoPlanoBitacora(texto);
                return ubicacion !== "no registrado" ? ubicacion : "no registrado";
            };

            const resolverDestino = () => {
                const tipo = normalizarTipoContenedorBitacora(obtenerCampoBitacora(entry, ["destino_tipo", "destinoTipo"]));
                const id = obtenerCampoBitacora(entry, ["destino_id", "destinoId"]);
                if (tipo && id) return formatearContenedorPlano(tipo, id);
                const texto = obtenerCampoBitacora(entry, ["destino"]);
                if (texto) return textoPlanoBitacora(texto);
                if (["merma", "ajuste", "salida"].includes(tipoMovimiento)) return "Salida de bodega";
                return "no registrado";
            };

            if (tipoEvento === "entrada_uva") {
                const mixto = obtenerCampoBitacora(entry, ["mixto"]);
                const totalVariedades = obtenerCampoBitacora(entry, ["lineas_count", "lineasCount", "variedades_count"]);
                let variedad = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["variedad", "variedades", "uva_variedad", "uva"]),
                    "no registrado"
                );
                if (mixto === 1 || mixto === true || String(mixto).toLowerCase() === "true") {
                    const totalTxt = Number(totalVariedades) > 0 ? ` (${totalVariedades} variedades)` : "";
                    variedad = `Mixto${totalTxt}`;
                }
                const kilos = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["kilos", "kg", "peso", "uva_kilos", "uva_kg"]),
                    "no registrado"
                );
                const cajas = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["cajas", "cajas_total", "cajas_uva"]),
                    "no registrado"
                );
                const estado = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["estado_uva", "estado", "uva_estado"]),
                    "no registrado"
                );
                const destino = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const so2 = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["so2_g", "so2", "metabisulfito", "so2_metabisulfito"]),
                    "no registrado"
                );
                const nota = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["nota", "observacion", "observaciones", "detalle", "resumen"]),
                    "no registrado"
                );
                lineas.push(
                    ts,
                    "Entrada de uva",
                    `Variedad: ${variedad} – ${kilos} kg`,
                    `Cajas: ${cajas}`,
                    `Estado: ${estado}`,
                    `Destino: ${destino}`,
                    `SO2: ${so2} g metabisulfito`,
                    `Observación: ${nota}`
                );
                return lineas;
            }

            if (tipoEvento === "recuento") {
                const elemento = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["elemento", "tipo"]), "no registrado");
                const anterior = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["valor_anterior", "anterior"]), "no registrado");
                const nuevoBase = obtenerCampoBitacora(entry, ["valor_nuevo", "nuevo"]);
                const litros = obtenerCampoBitacora(entry, ["litros"]);
                const nuevo = textoConFallbackBitacora(nuevoBase ?? litros, "no registrado");
                const motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota"]), "no registrado");
                lineas.push(
                    ts,
                    "Recuento",
                    `Elemento: ${elemento}`,
                    `Valor anterior: ${anterior}`,
                    `Valor nuevo: ${nuevo}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "despalillado") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const raspon = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["raspon", "raspón"]), "no registrado");
                const nota = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["nota", "detalle"]), "no registrado");
                lineas.push(
                    ts,
                    "Despalillado",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Raspón: ${raspon}`,
                    `Observación: ${nota}`
                );
                return lineas;
            }

            if (tipoEvento === "adicion") {
                const producto = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["producto", "productos", "producto_nombre"]),
                    "no registrado"
                );
                const dosis = resolverDosisBitacora(entry);
                const dosisTxt = textoConFallbackBitacora(dosis.cantidad, "no registrado");
                const unidadTxt = textoPlanoBitacora(dosis.unidad) || "no registrado";
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota", "observacion"]), "no registrado");
                lineas.push(
                    ts,
                    "Adición",
                    `Producto: ${producto}`,
                    `Dosis: ${dosisTxt} ${unidadTxt}`,
                    `Destino: ${destino}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "medicion") {
                const densidad = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["densidad"]), "no registrado");
                const temperatura = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["temperatura_c", "temperatura"]),
                    "no registrado"
                );
                const ph = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["ph", "pH"]), "no registrado");
                const so2Libre = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["so2_libre", "so2Libre"]), "no registrado");
                lineas.push(
                    ts,
                    "Medición",
                    `Ubicación: ${ubicacion}`,
                    `Densidad: ${densidad}`,
                    `Temperatura: ${temperatura} ºC`,
                    `pH: ${ph}`,
                    `SO2 Libre: ${so2Libre} mg/L`
                );
                return lineas;
            }

            if (tipoEvento === "inicio_fermentacion") {
                const levadura = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["levadura"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                lineas.push(
                    ts,
                    "Fermentación",
                    "Inicio fermentación alcohólica",
                    `Depósito: ${depositoTxt}`,
                    `Levadura: ${levadura}`
                );
                return lineas;
            }

            if (tipoEvento === "bazuqueo_remontado") {
                const bazuqueo = obtenerCampoBitacora(entry, ["bazuqueo"]);
                const remontado = obtenerCampoBitacora(entry, ["remontado"]);
                const operacion = bazuqueo && remontado
                    ? "bazuqueo + remontado"
                    : bazuqueo
                    ? "bazuqueo"
                    : remontado
                    ? "remontado"
                    : textoConFallbackBitacora(obtenerCampoBitacora(entry, ["operacion", "accion"]), "no registrado");
                const duracion = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["duracion", "minutos"]), "no registrado");
                const intensidad = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["intensidad"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                lineas.push(
                    ts,
                    "Acción",
                    `Operación: ${operacion}`,
                    `Depósito: ${depositoTxt}`,
                    `Duración: ${duracion}`,
                    `Intensidad: ${intensidad}`
                );
                return lineas;
            }

            if (tipoEvento === "movimiento") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]);
                const kilos = obtenerCampoBitacora(entry, ["kilos", "kg", "peso"]);
                const cantidadMeta = obtenerCampoBitacora(entry, ["cantidad"]);
                let cantidadTxt = "no registrado";
                if (litros !== null && litros !== undefined && String(litros).trim() !== "") {
                    cantidadTxt = `${textoPlanoBitacora(litros)} L`;
                } else if (kilos !== null && kilos !== undefined && String(kilos).trim() !== "") {
                    cantidadTxt = `${textoPlanoBitacora(kilos)} kg`;
                } else if (cantidadMeta !== null && cantidadMeta !== undefined && String(cantidadMeta).trim() !== "") {
                    cantidadTxt = textoPlanoBitacora(cantidadMeta);
                }
                const observacion = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["motivo", "nota", "observacion", "detalle"]),
                    "no registrado"
                );
                lineas.push(
                    ts,
                    "Movimiento",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Cantidad: ${cantidadTxt}`,
                    `Observación: ${observacion}`
                );
                return lineas;
            }

            if (tipoEvento === "trasvase") {
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const filtrado = textoSiNoBitacora(obtenerCampoBitacora(entry, ["filtrado", "filtro"]));
                let motivo = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["motivo", "nota"]), "no registrado");
                const perdidaNumero = Number(perdidaLitros);
                if (Number.isFinite(perdidaNumero) && perdidaNumero > 0) {
                    const perdidaTxt = `${perdidaNumero} L pérdida`;
                    motivo = motivo === "no registrado" ? perdidaTxt : `${motivo} · ${perdidaTxt}`;
                }
                lineas.push(
                    ts,
                    "Trasvase",
                    `Origen: ${origen}`,
                    `Destino: ${destino}`,
                    `Volumen: ${litros} L`,
                    `Filtrado: ${filtrado}`,
                    `Motivo: ${motivo}`
                );
                return lineas;
            }

            if (tipoEvento === "prensado") {
                const origenIdRaw = obtenerCampoBitacora(entry, ["origen_id", "origenId"]);
                const origenId = textoConFallbackBitacora(
                    origenIdRaw ?? (tipoMovimiento === "prensado" ? null : depositoId),
                    "no registrado"
                );
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const volumenEntrada = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["volumen_entrada", "entrada", "volumenEntrada"]),
                    ""
                );
                const mermaAbs = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["merma_abs", "mermaAbs", "merma_litros"]),
                    ""
                );
                const mermaPct = textoConFallbackBitacora(
                    obtenerCampoBitacora(entry, ["merma_pct", "mermaPct", "merma_pct"]),
                    ""
                );
                const fraccion = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["fraccion", "fracción"]), "no registrado");
                lineas.push(
                    ts,
                    "Prensado",
                    `Origen: Depósito ${origenId}`,
                    `Destino: ${destino}`,
                    `Entrada: ${volumenEntrada ? `${volumenEntrada} L` : "no registrado"}`,
                    `Salida: ${litros} L`,
                    `Merma: ${mermaAbs ? `${mermaAbs} L` : "no registrado"}${mermaPct ? ` (${mermaPct}%)` : ""}`,
                    `Fracción: ${fraccion}`,
                    "Nota: (auto) Ejecutado desde mapa de nodos"
                );
                return lineas;
            }

            if (tipoEvento === "descube") {
                const origenId = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["origen_id", "origenId"]) || depositoId, "no registrado");
                const destinoId = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["destino_id", "destinoId"]), "no registrado");
                const litrosVino = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_vino", "volumen_vino"]), "no registrado");
                const litrosPastas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_pastas", "volumen_pastas"]), "no registrado");
                lineas.push(
                    ts,
                    "Descube",
                    `Origen: Depósito ${origenId}`,
                    `Destino: Depósito ${destinoId}`,
                    `Volumen vino: ${litrosVino} L`,
                    `Volumen lías/pastas: ${litrosPastas} L`
                );
                return lineas;
            }

            if (tipoEvento === "entrada_barrica") {
                const barricaTxt = barricaId ? `${barricaId}` : "no registrado";
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                lineas.push(
                    ts,
                    "Madera",
                    "Entrada en barrica",
                    `Barrica: ${barricaTxt}`,
                    `Origen: ${origen}`,
                    `Volumen: ${litros} L`
                );
                return lineas;
            }

            if (tipoEvento === "relleno_barrica") {
                const barricaTxt = barricaId ? `${barricaId}` : "no registrado";
                const litros = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros", "volumen", "volumen_l"]), "no registrado");
                const gas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["gas", "gas_inerte", "gasInerte"]), "no registrado");
                lineas.push(
                    ts,
                    "Madera",
                    "Relleno de barrica",
                    `Barrica: ${barricaTxt}`,
                    `Volumen añadido: ${litros} L`,
                    `Gas inerte: ${gas}`
                );
                return lineas;
            }

            if (tipoEvento === "coupage") {
                let origen1 = obtenerCampoBitacora(entry, ["origen1", "origen_1"]);
                let litros1 = obtenerCampoBitacora(entry, ["litros1", "litros_1"]);
                let origen2 = obtenerCampoBitacora(entry, ["origen2", "origen_2"]);
                let litros2 = obtenerCampoBitacora(entry, ["litros2", "litros_2"]);
                const componentes = obtenerCampoBitacora(entry, ["componentes"]);
                if (Array.isArray(componentes) && componentes.length) {
                    const primero = componentes[0] || {};
                    const segundo = componentes[1] || {};
                    origen1 = origen1 || primero.origen || primero.nombre;
                    litros1 = litros1 || primero.litros;
                    origen2 = origen2 || segundo.origen || segundo.nombre;
                    litros2 = litros2 || segundo.litros;
                }
                const destino = textoConFallbackBitacora(resolverDestino(), "no registrado");
                const total = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["litros_total", "total_litros", "litros"]), "no registrado");
                lineas.push(
                    ts,
                    "Coupage",
                    `Destino: ${destino}`,
                    "Componentes:",
                    `- ${textoConFallbackBitacora(origen1, "no registrado")}: ${textoConFallbackBitacora(litros1, "no registrado")} L`,
                    `- ${textoConFallbackBitacora(origen2, "no registrado")}: ${textoConFallbackBitacora(litros2, "no registrado")} L`,
                    `Resultado: ${total} L`
                );
                return lineas;
            }

            if (tipoEvento === "clarificacion_filtracion") {
                const producto = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["producto", "productos"]), "no registrado");
                const dosis = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["dosis", "dosis_cantidad", "dosisCantidad"]), "no registrado");
                const depositoTxt = depositoId ? `Depósito ${depositoId}` : "no registrado";
                const reposo = textoSiNoBitacora(obtenerCampoBitacora(entry, ["reposo_frio", "reposoFrio"]));
                lineas.push(
                    ts,
                    "Clarificación / Filtración",
                    `Producto: ${producto}`,
                    `Dosis: ${dosis}`,
                    `Depósito: ${depositoTxt}`,
                    `Reposo en frío: ${reposo}`
                );
                return lineas;
            }

            if (tipoEvento === "embotellado") {
                const linea = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["linea_id", "lineaId"]), "no registrado");
                const origen = textoConFallbackBitacora(resolverOrigen(), "no registrado");
                const botellas = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["botellas"]), "no registrado");
                const formato = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["formato"]), "no registrado");
                const cierre = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["cierre"]), "no registrado");
                const so2 = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["so2", "so2_pre"]), "no registrado");
                const lote = textoConFallbackBitacora(obtenerCampoBitacora(entry, ["lote"]), "no registrado");
                lineas.push(
                    ts,
                    "Embotellado",
                    `Línea de vino: ${linea}`,
                    `Origen: ${origen}`,
                    `Botellas: ${botellas}`,
                    `Formato: ${formato}`,
                    `Cierre: ${cierre}`,
                    `SO2 pre-embotellado: ${so2}`,
                    `Lote: ${lote}`
                );
                return lineas;
            }

            const textoNota = textoConFallbackBitacora(
                obtenerCampoBitacora(entry, ["texto", "text", "nota", "detalle", "resumen"]),
                "no registrado"
            );
            lineas.push(ts, "Nota");
            extraerLineasTexto(textoNota).forEach(linea => lineas.push(linea));
            return lineas;
        }

        function claseCabeceraBitacora(tipoEvento) {
            const mapa = {
                entrada_uva: "entrada",
                recuento: "recuento",
                despalillado: "accion",
                adicion: "adicion",
                medicion: "medicion",
                inicio_fermentacion: "fermentacion",
                bazuqueo_remontado: "accion",
                trasvase: "trasvase",
                prensado: "prensado",
                descube: "descube",
                entrada_barrica: "madera",
                relleno_barrica: "madera",
                coupage: "coupage",
                clarificacion_filtracion: "clarificacion",
                embotellado: "embotellado",
                movimiento: "movimiento",
                nota: "nota",
            };
            return mapa[tipoEvento] || "accion";
        }

        function obtenerDeleteInfoBitacora(entry) {
            if (!entry) return null;
            const id = entry.id;
            if (id === undefined || id === null || id === "") return null;
            const idTxt = encodeURIComponent(String(id));
            switch (entry.fuente) {
                case "contenedor":
                    return { url: `/api/eventos/${idTxt}?scope=contenedor` };
                case "bodega":
                    return { url: `/api/eventos/${idTxt}?scope=bodega` };
                case "movimiento":
                    return { url: `/api/movimientos/${idTxt}` };
                case "entrada_uva":
                    return { url: `/api/entradas_uva/${idTxt}` };
                case "embotellado":
                    return { url: `/api/embotellados/${idTxt}` };
                case "nota":
                case "mapa_nodos":
                    return { url: `/api/bitacora/${idTxt}` };
                default:
                    return null;
            }
        }

        async function eliminarEntradaBitacora(entry) {
            const info = obtenerDeleteInfoBitacora(entry);
            if (!info) return;
            const confirmado = window.confirm("Eliminar esta entrada de la bitacora?");
            if (!confirmado) return;
            setEstadoBitacora("Eliminando...");
            try {
                const res = await fetch(info.url, { method: "DELETE" });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) {
                    throw new Error(data?.error || "No se pudo eliminar la entrada.");
                }
                bitacoraEntries = bitacoraEntries.filter(item => {
                    return !(item.fuente === entry.fuente && String(item.id) === String(entry.id));
                });
                setEstadoBitacora("");
                aplicarFiltroBitacora();
            } catch (err) {
                console.error("Error eliminando bitacora:", err);
                setEstadoBitacora(err?.message || "No se pudo eliminar la entrada.");
            }
        }

        function crearLineaBitacora(
            texto,
            { esTs = false, esCabecera = false, tipoCabecera = "", onDelete = null } = {}
        ) {
            const line = document.createElement("div");
            line.className = "bitacora-line";
            if (!texto) {
                line.classList.add("bitacora-line--blank");
                return line;
            }
            if (esTs) {
                line.classList.add("bitacora-line--ts");
                line.textContent = texto;
                return line;
            }
            if (esCabecera) {
                line.classList.add("bitacora-line--header");
                const tag = document.createElement("span");
                tag.className = `bitacora-tag bitacora-tag--${tipoCabecera || "accion"}`;
                tag.textContent = texto;
                line.appendChild(tag);
                if (typeof onDelete === "function") {
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "bitacora-delete";
                    btn.textContent = "Eliminar";
                    btn.addEventListener("click", onDelete);
                    line.appendChild(btn);
                }
                return line;
            }
            line.textContent = texto;
            return line;
        }

        function renderBitacoraEntries(entries) {
            const salida = document.getElementById("bitacoraTexto");
            if (!salida) return;
            salida.innerHTML = "";
            if (!entries.length) {
                salida.textContent = "Sin registros.";
                return;
            }
            const fragment = document.createDocumentFragment();
            entries.forEach((entry, idx) => {
                const lineasEntrada = construirLineasBitacora(entry);
                if (!lineasEntrada.length) return;
                const tipoCabecera = claseCabeceraBitacora(detectarTipoEventoBitacora(entry));
                const deleteInfo = obtenerDeleteInfoBitacora(entry);
                lineasEntrada.forEach((linea, lineaIdx) => {
                    if (lineaIdx === 0) {
                        fragment.appendChild(crearLineaBitacora(linea, { esTs: true }));
                        return;
                    }
                    if (lineaIdx === 1) {
                        fragment.appendChild(crearLineaBitacora(linea, {
                            esCabecera: true,
                            tipoCabecera,
                            onDelete: deleteInfo ? () => eliminarEntradaBitacora(entry) : null,
                        }));
                        return;
                    }
                    fragment.appendChild(crearLineaBitacora(linea));
                });
                if (idx < entries.length - 1) {
                    fragment.appendChild(crearLineaBitacora(""));
                }
            });
            salida.appendChild(fragment);
        }

        function aplicarFiltroBitacora() {
            const input = document.getElementById("bitacoraBuscar");
            const termino = (input?.value || "").trim().toLowerCase();
            if (!termino) {
                renderBitacoraEntries(bitacoraEntries);
                return;
            }
            const filtradas = bitacoraEntries.filter(entry => {
                const texto = construirLineasBitacora(entry).join(" ").toLowerCase();
                return texto.includes(termino);
            });
            renderBitacoraEntries(filtradas);
        }

        async function cargarBitacora() {
            if (bitacoraCargando) return;
            bitacoraCargando = true;
            setEstadoBitacora("Cargando bitácora...");
            try {
                const [resCont, resBodega, resNotas, resMovs, resEntradas, resEmbotellados] = await Promise.all([
                    fetch("/api/eventos?scope=contenedor&limit=300"),
                    fetch("/api/eventos?limit=300"),
                    fetch("/api/bitacora?limit=300"),
                    fetch("/api/movimientos"),
                    fetch("/api/entradas_uva"),
                    fetch("/api/embotellados"),
                ]);

                const dataCont = resCont.ok ? await resCont.json().catch(() => ({})) : {};
                const dataBodega = resBodega.ok ? await resBodega.json().catch(() => ({})) : {};
                const dataNotas = resNotas.ok ? await resNotas.json().catch(() => ({})) : {};
                const dataMovs = resMovs.ok ? await resMovs.json().catch(() => ([])) : [];
                const dataEntradas = resEntradas.ok ? await resEntradas.json().catch(() => ([])) : [];
                const dataEmbotellados = resEmbotellados.ok ? await resEmbotellados.json().catch(() => ([])) : [];

                const eventosCont = Array.isArray(dataCont.eventos) ? dataCont.eventos : [];
                const eventosBodega = Array.isArray(dataBodega.eventos) ? dataBodega.eventos : [];
                const entradas = Array.isArray(dataNotas.entries) ? dataNotas.entries : [];
                const entradasManual = entradas.filter(entry => entry?.origin === "bitacora");
                const entradasMapa = entradas.filter(entry => entry?.origin === "mapa_nodos");
                const movimientos = Array.isArray(dataMovs) ? dataMovs : [];
                const entradasUva = Array.isArray(dataEntradas) ? dataEntradas : [];
                const embotellados = Array.isArray(dataEmbotellados) ? dataEmbotellados : [];

                const normalizados = [
                    ...eventosCont.map(ev => ({
                        fuente: "contenedor",
                        id: ev.id,
                        prioridad: 90,
                        ts: ev.fecha_hora,
                        tipo: ev.tipo,
                        resumen: ev.resumen,
                        detalle: ev.detalle,
                        meta: ev.meta || {},
                        contenedor_tipo: ev.contenedor_tipo,
                        contenedor_id: ev.contenedor_id,
                        origen: ev.origen,
                    })),
                    ...eventosBodega.map(ev => ({
                        fuente: "bodega",
                        id: ev.id,
                        prioridad: 70,
                        ts: ev.fecha_hora,
                        tipo: ev.tipo,
                        resumen: ev.resumen,
                        payload: ev.payload || {},
                        entidad_tipo: ev.entidad_tipo,
                        entidad_id: ev.entidad_id,
                    })),
                    ...movimientos.slice(0, 500).map(mov => ({
                        fuente: "movimiento",
                        id: mov.id,
                        prioridad: 85,
                        ts: mov.fecha,
                        tipo: "movimiento",
                        resumen: mov.tipo ? `Movimiento ${mov.tipo}` : "Movimiento",
                        payload: (() => {
                            const tipoMov = (mov.tipo || "").toString().trim().toLowerCase();
                            const payload = {
                                tipo: mov.tipo,
                                litros: mov.litros,
                                perdida_litros: mov.perdida_litros,
                                nota: mov.nota,
                                origen_tipo: mov.origen_tipo,
                                origen_id: mov.origen_id,
                                destino_tipo: mov.destino_tipo,
                                destino_id: mov.destino_id,
                            };
                            if (["merma", "ajuste", "salida"].includes(tipoMov)) {
                                payload.elemento = "litros";
                                payload.valor_nuevo = mov.litros;
                                payload.motivo = tipoMov;
                            }
                            return payload;
                        })(),
                        contenedor_tipo: mov.origen_tipo || mov.destino_tipo,
                        contenedor_id: mov.origen_id || mov.destino_id,
                    })),
                    ...entradasUva.slice(0, 400).map(entrada => {
                        const mixto = entrada.mixto === 1 || entrada.mixto === true;
                        const totalVariedades = Number(entrada.lineas_count || 0);
                        const variedadTxt = mixto
                            ? `Mixto${totalVariedades ? ` (${totalVariedades} variedades)` : ""}`
                            : (entrada.variedad || "");
                        return {
                            fuente: "entrada_uva",
                            id: entrada.id,
                            prioridad: 86,
                            ts: entrada.fecha,
                            tipo: "entrada_uva",
                            resumen: "Entrada de uva",
                            payload: {
                                variedad: variedadTxt,
                                kilos: entrada.kilos,
                                cajas: entrada.cajas_total ?? entrada.cajas,
                                cajas_total: entrada.cajas_total,
                                mixto: entrada.mixto,
                                modo_kilos: entrada.modo_kilos,
                                densidad: entrada.densidad,
                                temperatura: entrada.temperatura,
                                observaciones: entrada.observaciones,
                            },
                        };
                    }),
                    ...embotellados.slice(0, 400).map(emb => ({
                        fuente: "embotellado",
                        id: emb.id,
                        prioridad: 88,
                        ts: emb.fecha,
                        tipo: "embotellado",
                        resumen: "Embotellado",
                        payload: {
                            litros: emb.litros,
                            botellas: emb.botellas,
                            lote: emb.lote,
                            formatos: emb.formatos,
                            nota: emb.nota,
                            origen_tipo: emb.contenedor_tipo,
                            origen_id: emb.contenedor_id,
                        },
                        contenedor_tipo: emb.contenedor_tipo,
                        contenedor_id: emb.contenedor_id,
                    })),
                    ...entradasManual.map(entry => ({
                        fuente: "nota",
                        id: entry.id,
                        prioridad: 60,
                        ts: entry.created_at,
                        tipo: "nota",
                        texto: entry.text,
                        deposito_id: entry.deposito_id,
                        madera_id: entry.madera_id,
                        linea_id: entry.linea_id,
                        variedades: entry.variedades,
                        origin: entry.origin,
                        note_type: entry.note_type,
                    })),
                    ...entradasMapa.map(entry => ({
                        fuente: "mapa_nodos",
                        id: entry.id,
                        prioridad: 50,
                        ts: entry.created_at,
                        tipo: "nota",
                        texto: entry.text,
                        deposito_id: entry.deposito_id,
                        madera_id: entry.madera_id,
                        linea_id: entry.linea_id,
                        variedades: entry.variedades,
                        origin: entry.origin,
                        note_type: entry.note_type,
                    })),
                ];

                bitacoraEntries = deduplicarBitacora(normalizados)
                    .filter(item => item.ts)
                    .sort((a, b) => new Date(a.ts).getTime() - new Date(b.ts).getTime());
            } catch (err) {
                console.error("Error cargando bitácora:", err);
                setEstadoBitacora("No se pudo cargar la bitácora.");
                bitacoraCargando = false;
                return;
            }
            setEstadoBitacora("");
            bitacoraCargando = false;
            aplicarFiltroBitacora();
        }

        function initBitacoraIndomitaUI() {
            const input = document.getElementById("bitacoraBuscar");
            if (input) input.addEventListener("input", aplicarFiltroBitacora);
            const link = document.querySelector('[data-section="bitacora"]');
            if (link) link.addEventListener("click", () => cargarBitacora());
        }

        function abrirCuadernoContenedor(_tipo, _id) {
            mostrarSeccion("bitacora");
            cargarBitacora();
        }

        function abrirCuadernoDesdeNodo(nodo) {
            if (!nodo) return;
            const contenedor = resolverContenedorDesdeNodoControl(nodo);
            if (!contenedor) {
                mostrarAviso("Asigna un contenedor para abrir el cuaderno.", "error");
                return;
            }
            mostrarSeccion("bitacora");
            cargarBitacora();
        }

        // ---------- Inicialización ----------
        (async function init() {
            await cargarNodosGuardados();
            mostrarSeccion("bodega");
            await Promise.all([
                cargarResumen(),
                cargarDepositos(),
                cargarBarricas(),
                cargarEntradas(),
                cargarMovimientos(),
                cargarLimpieza(),
                cargarEnologicos(),
                cargarEmbotellados(),
                cargarAnalisisLab(),
                cargarCatas(),
            ]);
            initBitacoraIndomitaUI();
            cargarBitacora();
            inicializarCopilotoUI();
            actualizarCopiloto(true);
            renderDemoFlow();

            const campoFechaEntrada = document.getElementById("entradaFecha");
            if (campoFechaEntrada) {
                campoFechaEntrada.addEventListener("change", actualizarAnadaEntrada);
                actualizarAnadaEntrada();
            }
            initEntradaMixtoUI();
            initEntradaProcedenciaUI();
            const movTipoSelect = document.getElementById("movTipo");
            if (movTipoSelect) {
                movTipoSelect.addEventListener("change", actualizarCamposMovimiento);
                actualizarCamposMovimiento();
            }
        })();
    </script>
    <script type="module" src="/js/app.js"></script>
</body>
</html>
