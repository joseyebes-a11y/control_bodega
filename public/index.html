<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bodega serie -IND√ìMITO-</title>

    <style>
        :root {
            --vino-oscuro: #140818;
            --vino: #783c7b;
            --magenta: #f3789c;
            --rose: #fff1f8;
            --arena: #f8f0ff;
            --oro: #f3c77b;
            --texto: #201024;
            --linea: rgba(255, 255, 255, 0.35);
            --accent: #c2a9ff;
            --gris-ligero: rgba(255,255,255,0.65);
        }

        * {
            box-sizing: border-box;
        }

body {
    margin: 0;
    padding: 0;
    font-family: "Inter", system-ui, -apple-system, Helvetica, Arial, sans-serif;
    background: radial-gradient(circle at 15% 20%, #2b1a36, #0b0511 55%);
    min-height: 100vh;
    color: var(--texto);
    position: relative;
}

body::before,
body::after {
    content: "";
    position: fixed;
    width: 520px;
    height: 520px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(195,168,255,0.25), transparent 70%);
    z-index: 0;
    filter: blur(18px);
}

body::before {
    top: -80px;
    right: -100px;
}

body::after {
    bottom: -200px;
    left: -120px;
}

        .topbar {
            width: 100%;
            background: transparent;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 5;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .user-chip {
            display: none;
        }

        .topbar-title {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            position: relative;
        }

        .topbar-title button {
            color: inherit;
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            background:
              radial-gradient(circle at 28% 25%, rgba(255, 230, 180, 0.6), transparent 42%),
              linear-gradient(135deg, #f7c27c, #ff8ec7, #9b5de5);
            border: 1px solid rgba(255,255,255,0.38);
            cursor: pointer;
            padding: 16px 26px;
            border-radius: 28px;
            transition: transform 0.18s ease, box-shadow 0.22s ease, background 0.2s ease;
            box-shadow:
              0 22px 60px rgba(0,0,0,0.55),
              0 10px 26px rgba(0,0,0,0.32),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 6px rgba(255,255,255,0.06);
            min-width: 260px;
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }

        .topbar-title .microbrand {
            font-size: 11px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.75);
            margin-bottom: 4px;
        }

.topbar-title button::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 32px;
            background: conic-gradient(from 120deg, rgba(243,199,123,0.35), rgba(195,169,255,0.35), rgba(243,199,123,0.35));
            opacity: 0.2;
            filter: blur(6px);
            z-index: -1;
        }

.topbar-title button::after {
            content: "";
            position: absolute;
            top: -190%;
            left: -70%;
            width: 180%;
            height: 500%;
            background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.52) 55%, transparent 100%);
            transform: rotate(12deg) translateX(-300%);
            opacity: 0;
            transition: opacity 0.25s ease;
        }

.topbar-title button:hover,
.topbar-title button.open {
            background:
              radial-gradient(circle at 30% 30%, rgba(255, 235, 200, 0.7), transparent 42%),
              linear-gradient(135deg, #ffd79c, #ff9fdc, #b07bff);
            box-shadow:
              0 26px 70px rgba(0,0,0,0.65),
              0 12px 28px rgba(0,0,0,0.4),
              0 0 0 1px rgba(255,255,255,0.16) inset,
              0 0 0 10px rgba(255,255,255,0.08);
            transform: translateY(-4px) scale(1.01);
        }

.topbar-title button:hover::after,
.topbar-title button.open::after {
            opacity: 1;
            animation: shimmer 1s ease forwards;
        }

        .topbar-title .marca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 2.5px;
            text-transform: uppercase;
            font-size: 36px;
            color: #0b0b0b;
            background: none;
            background-clip: initial;
-webkit-background-clip: initial;
            text-shadow:
              0 8px 18px rgba(92, 14, 45, 0.4),
              0 4px 10px rgba(92, 14, 45, 0.25),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 14px rgba(92, 14, 45, 0.35);
            filter: drop-shadow(0 4px 10px rgba(92, 14, 45, 0.35));
        }

        .topbar-title .submarca {
            font-family: "Playfair Display", "Times New Roman", serif;
            font-weight: 600;
            letter-spacing: 6px;
            font-size: 20px;
            color: #1a1a1a;
            margin-top: 8px;
            text-shadow:
              0 6px 18px rgba(0,0,0,0.4),
              0 2px 0 rgba(255,255,255,0.08),
              0 0 12px rgba(50, 0, 70, 0.45);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.32));
        }

        /* =====================
           Adaptaci√≥n m√≥vil
        ===================== */
        @media (max-width: 768px) {
            body {
                margin: 0;
            }

            .topbar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                padding: 12px;
            }

            .topbar-title {
                width: 100%;
            }

            .topbar-title button {
                width: 100%;
                min-width: 0;
                padding: 14px 18px;
            }

            .nav-dropdown-menu {
                position: relative;
                top: 8px;
                left: 0;
                right: 0;
                width: 100%;
                min-width: 0;
                box-shadow: 0 16px 40px rgba(0,0,0,0.35);
                border: 1px solid rgba(255,255,255,0.16);
                background: linear-gradient(145deg, rgba(20,10,30,0.92), rgba(8,4,16,0.9));
            }

            .content {
                padding: 12px;
            }

            .card {
                padding: 16px;
            }

            /* Botones de la toolbar de nodos a ancho completo en m√≥vil */
            .flow-toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .flow-toolbar-group {
                width: 100%;
            }

            .flow-toolbar .btnPrimario,
            .flow-toolbar .btnSecundario {
                width: 100%;
                justify-content: center;
            }

            /* Formularios m√°s c√≥modos */
            form input,
            form select,
            form button,
            form textarea {
                width: 100%;
                box-sizing: border-box;
                font-size: 16px;
            }

            form .btnPrimario,
            form .btnSecundario {
                justify-content: center;
            }
            
            .nav-dropdown-menu a {
                font-size: 16px;
                padding: 12px 18px;
            }
        }

@keyframes shimmer {
        0% { transform: translateX(-300%) rotate(12deg); opacity: 0; }
        20% { opacity: 1; }
        100% { transform: translateX(300%) rotate(12deg); opacity: 0; }
}

        .topbar-title button .caret {
            margin-top: 6px;
            font-size: 14px;
            color: rgba(255,255,255,0.65);
            transition: transform 0.2s ease;
        }

        .topbar-title button.open .caret {
            transform: rotate(180deg);
        }

.nav-dropdown-menu {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            display: none;
            flex-direction: column;
            background: rgba(8, 4, 15, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 18px;
            padding: 12px;
            min-width: 230px;
            width: 240px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.45);
            backdrop-filter: blur(18px);
            z-index: 20;
        }

.nav-dropdown-menu.visible {
            display: flex;
        }

.nav-dropdown-menu a {
            display: flex;
            align-items: center;
            color: #f9e5ff;
            padding: 10px 18px;
            border-radius: 999px;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.9;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.04);
            margin: 4px 0;
            width: 100%;
            min-width: 210px;
            justify-content: flex-start;
            box-sizing: border-box;
            min-height: 44px;
        }

.nav-dropdown-menu a:hover {
            background: rgba(255,255,255,0.12);
            opacity: 1;
        }

.nav-dropdown-menu a .emoji-barrica-lateral {
            position: relative;
            width: 44px;
            height: 30px;
            margin-right: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-1px);
        }

        .emoji-barrica-lateral span {
            position: absolute;
            display: block;
        }

        .emoji-barrica-lateral .sobrio-shadow {
            inset: auto 10px -8px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.25), transparent 70%);
            filter: blur(2px);
        }

        .emoji-barrica-lateral .sobrio-body {
            inset: 4px 8px;
            border-radius: 20px / 13px;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #c08342, #7e4a1f 70%);
            box-shadow:
                inset 0 0 8px rgba(0,0,0,0.4),
                0 3px 5px rgba(0,0,0,0.25);
        }

        .emoji-barrica-lateral .sobrio-body::before {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: inherit;
            border: 1px solid rgba(255,255,255,0.15);
            opacity: 0.8;
        }

        .emoji-barrica-lateral .sobrio-ring {
            left: 14px;
            right: 14px;
            height: 3px;
            border-radius: 3px;
            background: linear-gradient(90deg, #bfc2c5, #7c8086);
            box-shadow:
                inset 0 0 1px rgba(0,0,0,0.5),
                0 0 1px rgba(0,0,0,0.3);
        }

        .emoji-barrica-lateral .sobrio-ring.superior { top: 9px; }
        .emoji-barrica-lateral .sobrio-ring.inferior { top: 18px; }

        .emoji-barrica-lateral .sobrio-head {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #2e1408;
            background: linear-gradient(135deg, #d19b5e, #8a5021);
            box-shadow: inset -2px -2px 3px rgba(0,0,0,0.35);
        }

        .emoji-barrica-lateral .sobrio-head.front { right: 3px; z-index: 2; }
        .emoji-barrica-lateral .sobrio-head.back {
            left: 3px;
            filter: brightness(0.85);
        }

.nav-barricas-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            width: 230px;
            box-sizing: border-box;
            height: 40px;
            padding-top: 8px;
            padding-bottom: 8px;
        }

.nav-barricas-icon {
            width: 30px;
            height: 30px;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.35));
            background: transparent;
            mix-blend-mode: multiply;
        }

.nav-dropdown-menu a.activo {
            background: linear-gradient(120deg, rgba(241,92,146,0.9), rgba(95,44,130,0.9));
            color: #fff;
            opacity: 1;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 6px 18px rgba(241, 92, 146, 0.35);
        }

.nav-dropdown-menu a .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .icon-barrica {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: linear-gradient(180deg, #c07b45, #7a3f1b);
            border: 2px solid #51260f;
            position: relative;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        }

        .icon-barrica::before,
        .icon-barrica::after {
            content: "";
            position: absolute;
            left: 2px;
            right: 2px;
            height: 2px;
            background: rgba(81,38,15,0.8);
            border-radius: 2px;
        }

        .icon-barrica::before { top: 4px; }
        .icon-barrica::after { bottom: 4px; }

.h1-emoji {
            font-size: 36px;
            display: inline-block;
            margin-right: 10px;
        }

        .content {
            padding: 60px 70px 110px;
            min-height: 100vh;
            position: relative;
            z-index: 1;
            max-width: 1920px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .content {
                padding: 35px 24px 70px;
                max-width: 100%;
            }
        }

       h1 {
           margin: 0 0 15px;
           font-size: 32px;
           font-weight: 700;
           color: var(--vino-oscuro);
           letter-spacing: 0.4px;
       }

        h2 {
            color: var(--vino);
            margin-top: 0;
            letter-spacing: 0.2px;
        }

        .topbar h2 {
            color: #fff;
        }

        .card {
            background: rgba(255, 255, 255, 0.92);
            padding: 36px;
            border-radius: 30px;
            margin-bottom: 36px;
            box-shadow: 0 25px 60px rgba(11, 5, 21, 0.35);
            border: 1px solid rgba(255,255,255,0.45);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(12px);
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 20%, rgba(241,92,146,0.2), transparent 55%),
                        radial-gradient(circle at 80% 0%, rgba(95,44,130,0.16), transparent 60%);
            pointer-events: none;
        }

        .card > * {
            position: relative;
            z-index: 1;
        }

        .chart-card {
            margin-top: 25px;
            background: rgba(255,255,255,0.55);
            border-radius: 24px;
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.35);
            backdrop-filter: blur(8px);
        }

       .indicadores-grid {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
           gap: 18px;
           margin-top: 24px;
       }

        .indicador-card {
            background: rgba(255,255,255,0.85);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 10px 30px rgba(20,8,32,0.2);
        }

        .indicador-card h4 {
            margin: 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(47,31,59,0.8);
        }

        .indicador-card p {
            margin: 10px 0 4px;
            font-size: 32px;
            font-weight: 700;
            color: var(--vino-oscuro);
        }

        .indicador-card small {
            color: rgba(47,31,59,0.7);
            display: block;
            font-size: 12px;
        }

        .estado-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #fff;
            min-width: 48px;
            text-transform: uppercase;
        }

        .estado-fa { background: #d85c5c; }
        .estado-fml { background: #c47d21; }
        .estado-reposo { background: #8c6ff7; }
        .estado-limpio { background: #40a578; }
        .estado-vacio { background: #9ba1b0; }
        .estado-mantenimiento { background: #f0a500; }
        .estado-analitica { background: #ff7aa8; }

        .estado-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #fff;
            margin-top: 6px;
        }

        .estado-pill.mini {
            position: absolute;
            top: 8px;
            right: 0;
            font-size: 9px;
            padding: 3px 8px;
        }

        .acciones-rapidas {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 28px 0 10px;
        }

       .acciones-rapidas button {
           background: rgba(255,255,255,0.15);
           border: 1px solid rgba(255,255,255,0.4);
           padding: 10px 18px;
           border-radius: 999px;
           color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s;
        }

        .acciones-rapidas button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        section.card {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        section.card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .flow-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 16px;
        }

        .flow-toolbar-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        /* Botones del mapa de nodos (m√°s grandes y c√≥modos) */
        .flow-toolbar .btnPrimario,
        .flow-toolbar .btnSecundario {
            font-size: 15px;
            padding: 14px 22px;
            border-radius: 16px;
            min-height: 46px;
        }

        .flow-toolbar .btnPrimario span,
        .flow-toolbar .btnPrimario img {
            vertical-align: middle;
        }

        .flow-editor {
            position: relative;
            border: 1px dashed rgba(255,255,255,0.25);
            border-radius: 24px;
            background: rgba(8,4,15,0.5);
            min-height: 520px;
            overflow: auto;
        }

        .flow-stage {
            position: relative;
            width: 1600px;
            height: 900px;
        }

        .flow-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: default;
            background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .flow-connections {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .flow-node {
            position: absolute;
            min-width: 72px;
            background: rgba(40, 18, 52, 0.95);
            border-radius: 7px;
            box-shadow: 0 8px 14px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.08);
            padding: 2px 5px 14px;
            cursor: grab;
            color: #f5e9ff;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .flow-node.dragging {
            cursor: grabbing;
            box-shadow: 0 25px 50px rgba(0,0,0,0.35);
        }

        .flow-node h4 {
            margin: 0;
            font-size: 14px;
            color: #f7f2ff;
        }

        .flow-node-subtitle {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 1px;
        }

        .flow-node-icon {
            font-size: 15px;
        }

        .flow-node small {
            display: none;
        }

        .flow-node .flow-unit {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255,255,255,0.16);
            color: #fff;
            font-size: 9px;
            margin-top: 4px;
            letter-spacing: 0.4px;
        }

        .flow-node .flow-node-controls {
            position: absolute;
            bottom: 3px;
            right: 4px;
            display: flex;
            gap: 4px;
        }

        .flow-node .flow-node-controls button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .flow-node .flow-node-controls button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .flow-node .flow-node-controls button.blue::before {
            background: #2f7df0;
        }

        .flow-node .flow-node-controls button.green::before {
            background: #4caf50;
        }

        .flow-node .flow-node-controls button.red::before {
            background: #f44336;
        }
        .flow-node .flow-node-controls button.blue::after {
            content: "";
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.9);
            inset: 0;
            margin: auto;
        }

        .flow-node .flow-node-controls button.green::after {
            content: "‚ûú";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }
        .flow-node .flow-node-controls button.green::after {
            content: "‚ûú";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
        }

        .flow-node .flow-node-controls button.red::after {
            content: "√ó";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 8px;
        }

        .flow-node .flow-node-controls button.conectando::before {
            box-shadow: 0 0 6px rgba(243,120,156,0.8);
        }

        .flow-connector-line {
            stroke: rgba(255,255,255,0.65);
            stroke-width: 1.6;
            fill: none;
            marker-end: url(#arrowHead);
        }

        .flow-node-info {
            margin-top: 16px;
            padding: 14px 18px;
            border-radius: 16px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.05);
            min-height: 80px;
            font-size: 14px;
        }

        .flow-helper {
            margin-top: 14px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        .flow-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding: 140px 20px 40px;
            z-index: 12000;
            overflow-y: auto;
        }

        .flow-modal.visible {
            display: flex;
        }

        .flow-modal-content {
            background: #fff;
            border-radius: 18px;
            padding: 18px 20px;
            max-width: 450px;
            width: min(450px, 94%);
            box-shadow: 0 30px 60px rgba(0,0,0,0.35);
        }

        .flow-modal-content form label {
            margin-top: 10px;
            display: block;
            font-weight: 500;
        }

        .flow-modal-content form input,
        .flow-modal-content form textarea,
        .flow-modal-content form select {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 14px;
        }

        .field-readonly {
            background: rgba(0,0,0,0.05);
            color: #5c5c5c;
            cursor: not-allowed;
        }

        .flow-modal-content form textarea {
            min-height: 70px;
        }

        .campo-info {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(0,0,0,0.04);
            border: 1px dashed rgba(0,0,0,0.12);
            font-size: 13px;
            color: #444;
        }

        .tabla-control-fermentacion table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        .tabla-control-fermentacion th,
        .tabla-control-fermentacion td {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            font-size: 13px;
            text-align: left;
        }

        .tabla-control-fermentacion input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.15);
            font-size: 13px;
        }

        .tabla-control-fermentacion th:nth-child(1),
        .tabla-control-fermentacion td:nth-child(1) {
            width: 140px;
        }

        .tabla-control-fermentacion th:nth-child(2),
        .tabla-control-fermentacion td:nth-child(2) {
            width: 80px;
        }

        .tabla-control-fermentacion th:nth-child(3),
        .tabla-control-fermentacion td:nth-child(3) {
            width: 60px;
        }

        .tabla-control-fermentacion th:nth-child(4),
        .tabla-control-fermentacion td:nth-child(4) {
            width: 140px;
        }

        .tabla-control-fermentacion tbody tr:last-child td {
            border-bottom: none;
        }

        .flow-modal-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .skeleton-line,
        .skeleton-block {
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .skeleton-line::before,
        .skeleton-block::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            animation: shimmer 1.3s infinite;
        }

        .skeleton-line {
            height: 10px;
            margin: 6px 0;
        }

        .skeleton-block {
            height: 36px;
            margin: 10px 0;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .form-feedback {
            margin-top: 12px;
            font-size: 13px;
            min-height: 18px;
            color: rgba(32, 16, 36, 0.7);
        }

        .form-feedback.success {
            color: #2f8f5b;
        }

        .form-feedback.error {
            color: #d95070;
        }
        .movimientos-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .movimientos-form {
            flex: 1.2;
            min-width: 320px;
        }

        .tabla-movimientos {
            flex: 1.6;
            min-width: 440px;
            min-height: 520px;
            overflow-x: auto;
            overflow-y: visible;
        }

        .movimientos-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            min-width: 760px;
        }

        .movimientos-table th,
        .movimientos-table td {
            font-size: 12px;
            white-space: nowrap;
            padding: 8px;
        }


        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 22px;
            margin-top: 16px;
        }

        .chart-item {
            background: linear-gradient(160deg, rgba(255,255,255,0.95), rgba(241,92,146,0.15));
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--vino);
        }

        .app-alerts {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .toast {
            min-width: 220px;
            background: rgba(15, 7, 20, 0.85);
            color: #fff;
            padding: 12px 18px;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.35);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(20px);
            animation: toast-in 0.25s forwards;
        }

        .toast.success { background: rgba(64, 165, 120, 0.9); }
        .toast.error { background: rgba(217, 80, 112, 0.9); }

        @keyframes toast-in {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chart-bar-bg {
            width: 100%;
            height: 12px;
            border-radius: 12px;
            background: rgba(75,15,77,0.15);
            overflow: hidden;
        }

        .chart-bar {
            height: 100%;
            border-radius: 12px;
            background: linear-gradient(90deg, #f76fb0, #5f2c82);
            width: 20%;
            transition: width 0.4s ease;
        }

        .chart-item small {
            display: block;
            margin-top: 8px;
            color: #6e5e6e;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
            background: rgba(255,255,255,0.95);
            border-radius: 22px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 10px 30px rgba(16,6,28,0.15);
        }

        th, td {
            padding: 13px;
            text-align: left;
        }

        th {
            border-bottom: 1px solid rgba(106,34,77,0.15);
            background: linear-gradient(90deg, rgba(95,44,130,0.15), rgba(241,92,146,0.15));
            font-weight: 600;
            color: var(--vino-oscuro);
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tbody tr:nth-child(even) {
            background: rgba(252,245,255,0.8);
        }

        tbody tr:hover {
            background-color: rgba(241, 92, 146, 0.08);
        }

        input, select {
            width: 100%;
            padding: 12px 14px;
            margin: 6px 0 14px;
            border-radius: 14px;
            border: 1px solid rgba(95,44,130,0.15);
            font-size: 14px;
            background: rgba(255, 255, 255, 0.85);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
            backdrop-filter: blur(4px);
        }

input:focus,
select:focus {
            outline: none;
            border-color: var(--magenta);
            box-shadow: 0 12px 25px rgba(241,92,146,0.2);
            transform: translateY(-1px);
        }

        button {
            padding: 12px 22px;
            border-radius: 14px;
            border: none;
            background: linear-gradient(120deg, #f76fb0, #5f2c82);
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            box-shadow: 0 15px 35px rgba(95, 44, 130, 0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 45px rgba(95, 44, 130, 0.4);
        }

        .small-btn {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 999px;
            background: rgba(95,44,130,0.15);
            color: var(--vino-oscuro);
            border: none;
            font-weight: 600;
            box-shadow: none;
        }

        .btnPrimario {
            width: fit-content;
        }

        .btnSecundario {
            background: transparent;
            color: var(--texto);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
        }

        .btnSecundario:hover {
            border-color: rgba(255, 255, 255, 0.7);
        }

        .btnActualizar {
            margin-bottom: 8px;
            background: var(--vino-oscuro);
            box-shadow: none;
        }

label {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: rgba(42,15,39,0.65);
}

.mensaje {
    font-size: 13px;
    color: var(--vino);
    min-height: 18px;
    margin-top: 4px;
}

.resaltado {
    animation: destello 1.5s ease;
}

@keyframes destello {
    0% { background-color: rgba(199, 144, 191, 0.3); }
    100% { background-color: transparent; }
}

        .filtros-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0 20px;
            background: rgba(255,255,255,0.65);
            padding: 22px;
            border-radius: 22px;
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 15px 40px rgba(17,7,30,0.12);
            backdrop-filter: blur(8px);
        }

        .filtros-movimientos > div {
            flex: 1;
            min-width: 160px;
        }

        .acciones-movimientos {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
        }

        .grid-almacen {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            margin-top: 10px;
        }

        .grid-almacen > div {
            flex: 1;
            min-width: 280px;
        }

        .plano-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .plano-canvas {
            flex: 2.6;
            min-width: 460px;
            height: 620px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 26px;
            background-image:
                linear-gradient(0deg, rgba(255,255,255,0.18) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.18) 1px, transparent 1px),
                linear-gradient(0deg, rgba(95,44,130,0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(95,44,130,0.08) 1px, transparent 1px);
            background-size: 26px 26px;
            background-color: rgba(14,6,24,0.6);
            box-shadow: inset 0 0 25px rgba(0,0,0,0.25);
            overflow: hidden;
            backdrop-filter: blur(6px);
        }

.plano-item {
    position: absolute;
    width: 102px;
    min-height: 108px;
    padding: 7px;
    padding-right: 26px;
    border-radius: 16px;
    color: var(--texto);
    font-size: 12px;
    cursor: grab;
    user-select: none;
    box-shadow: 0 25px 60px rgba(6,2,10,0.4);
    transition: box-shadow 0.2s, transform 0.2s;
    display: flex;
    flex-direction: column;
    gap: 6px;
    background: rgba(255,255,255,0.97);
    border: 1px solid rgba(255,255,255,0.6);
    backdrop-filter: blur(6px);
    align-items: center;
}

.plano-item.deposito {
    border-top: 4px solid #8f97a8;
}

.plano-item.mastelone {
    border-top: 4px solid #8b1b2b;
}

.plano-item.barrica {
    border-top: 4px solid #c48a1b;
}

.plano-item.arrastrando {
    opacity: 0.9;
    cursor: grabbing;
    box-shadow: 0 35px 70px rgba(0,0,0,0.45);
}

.plano-card-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 700;
    color: var(--vino-oscuro);
    text-align: center;
    gap: 2px;
    width: 100%;
    word-break: break-word;
    position: relative;
    padding-top: 4px;
}

.plano-card-header small {
    font-size: 9px;
    color: rgba(47,31,59,0.55);
}

.plano-card-body {
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: center;
    width: 100%;
}

.plano-card-barrel {
    width: 34px;
    height: 44px;
    border-radius: 22px / 16px;
    border: 3px solid rgba(139,92,64,0.4);
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    flex-shrink: 0;
    box-shadow: inset 0 -4px 0 rgba(0,0,0,0.08);
}

.plano-card-barrel span {
    font-size: 11px;
    letter-spacing: 0.05em;
}

.plano-card-barrel.deposito {
    background: linear-gradient(180deg, #e5e8ee, #b6bdc9);
    color: #3f4653;
    border-color: rgba(111,121,138,0.5);
}

.plano-card-barrel.mastelone {
    background: linear-gradient(180deg, #e9b2c0, #a3223c);
    color: #5a0f1f;
    border-color: rgba(163,34,60,0.55);
}

.plano-card-barrel.barrica {
    background: linear-gradient(180deg, #f3d48b, #c08c32);
    color: #5d3a0f;
    border-color: rgba(184,128,34,0.6);
}

.plano-card-barrel::before,
.plano-card-barrel::after {
    content: "";
    position: absolute;
    left: 7px;
    right: 7px;
    height: 2px;
    background: rgba(0,0,0,0.15);
    border-radius: 999px;
}

.plano-card-barrel::before {
    top: 10px;
}

.plano-card-barrel::after {
    bottom: 10px;
}

.plano-card-info {
    display: grid;
    gap: 2px;
    flex: 1;
    text-align: center;
    width: 100%;
}

.plano-card-info small {
    font-size: 8px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: rgba(47,31,59,0.6);
}

.plano-card-info strong {
    font-size: 11px;
    display: block;
    color: var(--vino-oscuro);
}

.plano-card-extra {
    font-size: 8px;
    color: rgba(47,31,59,0.75);
    text-align: center;
    width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.plano-card-progress {
    position: absolute;
    top: 8px;
    right: 6px;
    width: 12px;
    height: calc(100% - 16px);
    background: rgba(47,31,59,0.12);
    border-radius: 12px;
    overflow: hidden;
    display: flex;
    align-items: flex-end;
    justify-content: center;
}

.plano-card-progress-bar {
    width: 100%;
    border-radius: 12px;
    transition: height 0.3s ease;
}

.plano-card-progress span {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 10px;
    font-weight: 700;
    color: var(--vino-oscuro);
    white-space: nowrap;
}

        #planoMensaje {
            margin-top: 14px;
            color: rgba(255,255,255,0.85);
            font-size: 14px;
        }

        .plano-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }
    </style>
    <!-- Librer√≠as para exportar PDF de la tabla de control -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-5Bg/sA0tE5mr39QQcvKA3evSvKWK2Kx4UvHQ3UKQY6u1/JmgvXIL1sSTB+kJDd/KikJS9rBDjocM9V0bP7nU5w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js" integrity="sha512-V8bfSFHzEIE8KPQrX61/6LvTItI+ZXhWU1Yai0udDCR0Y9uRMq8eGX2WizzKkbKhYzZ0vjFaZ8WFtQ28gLeg4A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
    <div id="appAlerts" class="app-alerts"></div>
    <!-- Top navigation -->
    <div class="topbar">
        <div class="topbar-title">
            <button type="button" id="navToggle">
                <span class="microbrand">MicroCellerStudio</span>
                <span class="marca" id="marcaTexto">Bodega VegaLuna</span>
                <span class="submarca" id="submarcaTexto"></span>
                <span class="caret">‚ñº</span>
            </button>
            <div class="nav-dropdown-menu" id="navMenu">
                <a href="#" data-section="entradas" onclick="cerrarNavMenu(); mostrarSeccion('entradas')">üçá Entradas de uva</a>
                <a href="#" data-section="depositos" onclick="cerrarNavMenu(); mostrarSeccion('depositos')">üõ¢ Dep√≥sitos</a>
                <a href="#" data-section="barricas" onclick="cerrarNavMenu(); mostrarSeccion('barricas')" class="nav-barricas-link">
                    <img src="/barricas.png" alt="Barricas" class="nav-barricas-icon" />
                    Barricas
                </a>
                <a href="#" data-section="plano" onclick="cerrarNavMenu(); mostrarSeccion('plano')">üó∫ Plano bodega</a>
                <a href="#" data-section="flujo" onclick="cerrarNavMenu(); mostrarSeccion('flujo')">üîó Mapa de nodos</a>
                <a href="#" data-section="movimientos" onclick="cerrarNavMenu(); mostrarSeccion('movimientos')">üîÑ Movimientos</a>
                <a href="#" data-section="embotellado" onclick="cerrarNavMenu(); mostrarSeccion('embotellado')">üçæ Embotellado</a>
                <a href="#" data-section="enologicos" onclick="cerrarNavMenu(); mostrarSeccion('enologicos')">üß™ Productos enol√≥gicos</a>
                <a href="#" data-section="analiticos" onclick="cerrarNavMenu(); mostrarSeccion('analiticos')">üìä Registros anal√≠ticos</a>
                <a href="#" data-section="analisisLab" onclick="cerrarNavMenu(); mostrarSeccion('analisisLab')">üìÑ An√°lisis laboratorio</a>
                <a href="#" data-section="limpieza" onclick="cerrarNavMenu(); mostrarSeccion('limpieza')">üßΩ Almac√©n limpieza</a>
                <a href="#" id="navLogout">üö™ Cerrar sesi√≥n</a>
            </div>
        </div>
        <button type="button" class="user-chip" id="userBadge" title="Usuario activo">‚Äî</button>
    </div>

    <!-- Contenido principal -->
    <div class="content">

        <!-- SECCI√ìN BODEGA (RESUMEN GENERAL) -->
        <section id="bodega" class="card visible">
            <h1><span class="h1-emoji">üè†</span>Resumen de la bodega</h1>
            <p>Visi√≥n r√°pida de c√≥mo va todo.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div class="card" style="flex:1;">
                    <h3>üçá Kilos de uva entrados</h3>
                    <p id="resumenKilos" style="font-size:32px; font-weight:bold;">0 kg</p>
                </div>

                <div class="card" style="flex:1;">
                    <h3>üõ¢ Dep√≥sitos registrados</h3>
                    <p id="resumenDepositos" style="font-size:32px; font-weight:bold;">0</p>
                </div>

                <div class="card" style="flex:1;">
                    <h3 style="display:flex; align-items:center; gap:8px;">
                        <img src="/barricas.png" alt="Barricas" style="width:22px; height:22px; object-fit:contain; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas registradas
                    </h3>
                    <p id="resumenBarricas" style="font-size:32px; font-weight:bold;">0</p>
                </div>

            </div>
            <div class="chart-card">
                <h2>Gr√°ficos r√°pidos</h2>
                <div class="chart-grid">
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Kilos de uva</span>
                            <span id="chartKilosValue">0 kg</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartKilosBar"></div>
                        </div>
                        <small>Total registrado en entradas</small>
                    </div>
                    <div class="chart-item">
                        <div class="chart-header">
                            <span>Litros en bodega</span>
                            <span id="chartLitrosValue">0 L</span>
                        </div>
                        <div class="chart-bar-bg">
                            <div class="chart-bar" id="chartLitrosBar"></div>
                        </div>
                        <small id="chartLitrosDetalle">Dep√≥sitos, mastelones y barricas</small>
                    </div>
                </div>
            </div>

            <div class="indicadores-grid">
                <div class="indicador-card">
                    <h4>üõ¢ Dep√≥sitos</h4>
                    <p id="indicadorDepositosPrincipal">--</p>
                    <small id="indicadorDepositosDetalle">Calculando ocupaci√≥n...</small>
                    <small id="indicadorDepositosExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4><span style="color:#c94458;">ü™£</span> Mastelones</h4>
                    <p id="indicadorMastelonesPrincipal">--</p>
                    <small id="indicadorMastelonesDetalle">Calculando ocupaci√≥n...</small>
                    <small id="indicadorMastelonesExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4 style="display:flex; align-items:center; gap:6px;">
                        <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                        Barricas
                    </h4>
                    <p id="indicadorBarricasPrincipal">--</p>
                    <small id="indicadorBarricasDetalle">Calculando ocupaci√≥n...</small>
                    <small id="indicadorBarricasExtra"></small>
                </div>
                <div class="indicador-card">
                    <h4>üçæ Embotellado</h4>
                    <p id="indicadorEmbotelladosPrincipal">--</p>
                    <small id="indicadorEmbotelladosDetalle">Sin registros</small>
                </div>
            </div>

            <div class="card" style="margin-top:24px;">
                <h2>Aprovechamiento por a√±ada</h2>
                <p>Relaci√≥n entre los kilos de uva registrados y los litros actuales por cada a√±ada.</p>
                <table>
                    <thead>
                        <tr>
                            <th>A√±ada</th>
                            <th>Kilos de uva</th>
                            <th>Litros actuales</th>
                            <th>Aprovechamiento</th>
                        </tr>
                    </thead>
                    <tbody id="tablaAprovechamiento">
                        <tr><td colspan="4">Cargando...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
        <!-- SECCI√ìN FLUJO -->
        <section id="flujo" class="card" style="display:none;">
            <h1><span class="h1-emoji">üó∫</span>Mapa de nodos de vinificaci√≥n</h1>
            <p>Dise√±a visualmente el recorrido de cada partida: arrastra nodos, con√©ctalos y edita la informaci√≥n con doble clic.</p>
        <div class="flow-toolbar">
                <div class="flow-toolbar-group">
                    <button class="btnSecundario" type="button" onclick="sembrarNodosDesdeDatos()">Sembrar nodos desde datos</button>
                </div>
                <div class="flow-toolbar-group">
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('entrada')">üçá Entrada de uva</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('estilo')">‚öóÔ∏è Elaboraci√≥n</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('deposito')">üõ¢ Dep√≥sito</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('coupage')">üß™ Coupage / Blend</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('barrica')">
                        <span style="display:inline-flex; align-items:center; gap:6px;">
                          <img src="/barricas.png" alt="Barricas" style="width:18px; height:18px; object-fit:contain; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.25)); mix-blend-mode:multiply; background:transparent;">
                          Crianza
                        </span>
                    </button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('embotellado')">üçæ Embotellado</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('almacen')">üì¶ Almac√©n</button>
                    <button class="btnPrimario" type="button" onclick="crearNodoManual('salida')">üöõ Salida</button>
                </div>
                <div class="flow-toolbar-group">
                    <button class="btnSecundario" type="button" onclick="exportarNodosComoImagen()">Exportar imagen</button>
                </div>
            </div>
            <div class="flow-editor" id="flowEditor">
                <div class="flow-stage">
                    <svg id="flowConnections" class="flow-connections">
                        <defs>
                            <marker id="arrowHead" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="rgba(255,255,255,0.7)" />
                            </marker>
                        </defs>
                        <g id="flowConnectionsLayer"></g>
                    </svg>
                    <div id="flowCanvas" class="flow-canvas"></div>
                </div>
            </div>
            <div class="flow-helper">
                <p>Doble clic en un nodo para editarlo. Pulsa ‚ÄúConectar‚Äù en un nodo y luego haz clic sobre el destino para crear el hilo. Puedes arrastrar los nodos a cualquier punto del lienzo.</p>
            </div>
            <div id="flowNodeInfo" class="flow-node-info">Selecciona un nodo para ver los detalles.</div>
        </section>
        <div id="flowModal" class="flow-modal">
            <div class="flow-modal-content">
                <h3 id="flowModalTitulo">Editar nodo</h3>
                <form id="flowModalForm"></form>
                <div class="flow-modal-actions">
                    <button type="button" class="btnSecundario" onclick="cerrarFlowModal()">Cancelar</button>
                    <button type="button" class="btnSecundario" onclick="eliminarNodoActivo()">Eliminar</button>
                    <button type="button" class="btnPrimario" onclick="guardarNodoDesdeModal()">Guardar</button>
                </div>
            </div>
        </div>
        <!-- SECCI√ìN ENTRADAS DE UVA -->
        <section id="entradas" class="card" style="display:none;">
            <h1><span class="h1-emoji">üçá</span>Entradas de uva</h1>

            <form id="formEntradaUva" onsubmit="crearEntradaUva(event)">
                <label>Fecha</label>
                <input type="datetime-local" id="entradaFecha" required>

                <input type="hidden" id="entradaAnada">

                <label>Variedad</label>
                <input type="text" id="entradaVariedad" required>

                <label>Parcela</label>
                <input type="text" id="entradaParcela" placeholder="Parcela o referencia">

                <label>Viticultor</label>
                <input type="text" id="entradaViticultor" placeholder="Nombre del viticultor">

                <label>Tipo de suelo</label>
                <input type="text" id="entradaSuelo" placeholder="Arcilloso, calizo...">

                <label>A√±os de la vid</label>
                <input type="number" id="entradaAnosVid" min="0" placeholder="Edad aproximada">

                <label>Kilos</label>
                <input type="number" id="entradaKilos" required>

                <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:16px;">
                    <button type="submit" class="btnPrimario" id="btnGuardarEntrada">Registrar entrada</button>
                    <button type="button" class="btnSecundario" id="btnCancelarEdicionEntrada" style="display:none;" onclick="cancelarEdicionEntrada()">Cancelar edici√≥n</button>
                </div>
                <div class="form-feedback" id="feedbackEntradaUva"></div>
            </form>

            <h2 style="margin-top:30px;">Historial</h2>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Fecha</th>
                        <th>A√±ada</th>
                        <th>Variedad</th>
                        <th>Viticultor</th>
                        <th>Tipo de suelo</th>
                        <th>Parcela</th>
                        <th>A√±os de la vid</th>
                        <th>Kilos</th>
                        <th>Acciones</th>
                    </tr>
                </thead>
                <tbody id="tablaEntradas"></tbody>
            </table>
            <h2 style="margin-top:30px;">Resumen por parcela</h2>
            <table>
                <thead>
                    <tr>
                        <th>Parcela</th>
                        <th>Viajes</th>
                        <th>Kilos</th>
                        <th>√öltima fecha</th>
                        <th>Hora de entrada</th>
                    </tr>
                </thead>
                <tbody id="tablaResumenParcelas"></tbody>
            </table>
        </section>

        <!-- SECCI√ìN DEP√ìSITOS -->
        <section id="depositos" class="card" style="display:none;">
            <h1><span class="h1-emoji">üõ¢</span>Dep√≥sitos</h1>
            <p>Registro de dep√≥sitos con su capacidad, tipo y material. La variedad y los litros asignados se actualizan autom√°ticamente cuando un nodo se conecta al dep√≥sito.</p>

<table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Nombre de dep√≥sito</th>
        <th>Capacidad (L)</th>
        <th>Tipo</th>
        <th>Material</th>
        <th>Variedad asignada</th>
        <th>Volumen transferido</th>
        <th>Acciones</th>
        <th>Borrar</th>
      </tr>
    </thead>
    <tbody id="tablaDepositos"></tbody>
</table>

<h2 style="margin-top:40px;">Nuevo dep√≥sito</h2>

<form id="formDeposito" onsubmit="crearDeposito(event)">
  <div style="display:flex; gap:20px; flex-wrap:wrap;">
    <div style="flex:1;">
      <label>Nombre de dep√≥sito</label>
      <input type="text" id="depCodigo" required>
    </div>
    <div style="flex:1;">
      <label>Capacidad (L)</label>
      <input type="number" id="depCapacidad" min="0" step="0.1" required>
    </div>
    <div style="flex:1;">
      <label>Tipo</label>
      <select id="depTipo" required>
        <option value="">Selecciona tipo</option>
        <option value="Siempre lleno">Siempre lleno</option>
        <option value="Cerrado">Cerrado</option>
        <option value="Mastelone">Mastelone</option>
        <option value="√Ånfora">√Ånfora</option>
        <option value="Foudre">Foudre</option>
        <option value="Barrica">Barrica</option>
        <option value="Damajuana">Damajuana</option>
      </select>
    </div>
    <div style="flex:1;">
      <label>Material</label>
      <select id="depMaterial" required>
        <option value="">Selecciona material</option>
        <option value="Inox">Inox</option>
        <option value="Fibra de vidrio">Fibra de vidrio</option>
        <option value="Cemento">Cemento</option>
        <option value="Barro">Barro</option>
        <option value="Madera">Madera</option>
        <option value="Cristal">Cristal</option>
        <option value="Pl√°stico alimentario">Pl√°stico alimentario</option>
      </select>
    </div>
  </div>
  <button type="submit" class="btnPrimario">Crear dep√≥sito</button>
  <div class="form-feedback" id="feedbackDepositos"></div>
</form>
        </section>

        <div id="modalDeposito" class="flow-modal">
            <div class="flow-modal-content">
                <h3>Editar dep√≥sito</h3>
                <form id="formEditarDeposito" onsubmit="guardarEdicionDeposito(event)">
                    <label>Nombre de dep√≥sito</label>
                    <input type="text" id="depCodigoEdit" required>

                    <label>Capacidad (L)</label>
                    <input type="number" id="depCapacidadEdit" min="0" step="0.1" required>

                    <label>Volumen actual (L)</label>
                    <input type="number" id="depVolumenEdit" min="0" step="0.1" required>

                    <label>Tipo</label>
                    <select id="depTipoEdit" required></select>

                    <label>Material</label>
                    <select id="depMaterialEdit" required></select>

                    <label>Estado</label>
                    <select id="depEstadoEdit" required></select>

                    <p style="margin-top:10px; font-size:13px; opacity:0.7;">
                        Variedad asignada: <strong id="depVariedadInfo">‚Äî</strong>
                    </p>

                    <div class="flow-modal-actions" style="justify-content: space-between; align-items: center;">
                        <button type="button" class="btnSecundario" onclick="cerrarModalDeposito()">Cancelar</button>
                        <button type="submit" class="btnPrimario">Guardar cambios</button>
                    </div>
                    <div class="form-feedback" id="feedbackEditarDeposito"></div>
                </form>
            </div>
        </div>

        <!-- SECCI√ìN ALMAC√âN LIMPIEZA -->
        <section id="limpieza" class="card" style="display:none;">
            <h1><span class="h1-emoji">üßΩ</span>Almac√©n de limpieza</h1>
            <p>Control de stock y consumo de productos de limpieza con trazabilidad por lote.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaLimpieza"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formLimpieza" onsubmit="crearProductoLimpieza(event)">
                        <label>Producto</label>
                        <input type="text" id="limNombre" required>

                        <label>Lote</label>
                        <input type="text" id="limLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="limCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="limUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="limNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN PRODUCTOS ENOL√ìGICOS -->
        <section id="enologicos" class="card" style="display:none;">
            <h1><span class="h1-emoji">üß™</span>Productos enol√≥gicos</h1>
            <p>Registro de aditivos y productos empleados en la elaboraci√≥n del vino.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Stock disponible</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Producto</th>
                                <th>Lote</th>
                                <th>Unidad</th>
                                <th>Disponible</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEnologicos"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar producto</h2>
                    <form id="formEnologicos" onsubmit="crearProductoEnologico(event)">
                        <label>Producto</label>
                        <input type="text" id="enoNombre" required>

                        <label>Lote</label>
                        <input type="text" id="enoLote" required>

                        <label>Cantidad</label>
                        <input type="number" id="enoCantidad" min="0" step="0.01" required>

                        <label>Unidad</label>
                        <input type="text" id="enoUnidad" placeholder="kg, L, unidades...">

                        <label>Nota</label>
                        <input type="text" id="enoNota">

                        <button class="btnPrimario">Guardar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN EMBOTELLADO -->
        <section id="embotellado" class="card" style="display:none;">
            <h1><span class="h1-emoji">üçæ</span>Registro de embotellado</h1>
            <p>Documenta cada lote embotellado con trazabilidad completa.</p>

            <div class="grid-almacen">
                <div>
                    <h2>Historial</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Origen</th>
                                <th>Botellas</th>
                                <th>Lote</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaEmbotellados"></tbody>
                    </table>
                </div>
                <div>
                    <h2>Registrar embotellado</h2>
                    <form id="formEmbotellado" onsubmit="crearEmbotellado(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="embFecha">

                        <label>Tipo contenedor</label>
                        <select id="embTipo">
                            <option value="deposito">Dep√≥sito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor (ID o c√≥digo)</label>
                        <input type="text" id="embContenedor" placeholder="Ej. A1 o 3" required>

                        <label>Botellas</label>
                        <input type="number" id="embBotellas" min="0" step="1" required>

                        <label>Lote embotellado</label>
                        <input type="text" id="embLote" placeholder="Referencia de lote">

                        <label>Nota</label>
                        <input type="text" id="embNota">

                        <button class="btnPrimario">Registrar</button>
                    </form>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN PLANO BODEGA -->
        <section id="plano" class="card" style="display:none;">
            <h1><span class="h1-emoji">üó∫</span>Plano de la bodega</h1>
            <p>Arrastra los dep√≥sitos, mastelones y barricas sobre la cuadr√≠cula para ubicarlos en el espacio.</p>

            <div class="plano-wrapper">
                <div class="plano-canvas" id="planoCanvas">
                    <div class="plano-placeholder">A√±ade dep√≥sitos, mastelones o barricas para empezar</div>
                </div>
            </div>
            <p id="planoMensaje">A√±ade dep√≥sitos, mastelones o barricas para empezar.</p>
        </section>
        <!-- SECCI√ìN BARRICAS -->
        <section id="barricas" class="card" style="display:none;">
            <h1 style="display:flex; align-items:center; gap:10px;">
                <img src="/barricas.png" alt="Barricas" style="width:30px; height:30px; object-fit:contain; filter: drop-shadow(0 3px 6px rgba(0,0,0,0.35)); mix-blend-mode:multiply; background:transparent;">
                Barricas
            </h1>
            <p>Control de barricas y litros dentro.</p>

            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>C√≥digo</th>
                        <th>Capacidad&nbsp;(L)</th>
                        <th>Roble / tostado</th>
                        <th>Marca</th>
                        <th>A√±o barrica</th>
                        <th>A√±ada</th>
                        <th>Tipo de vino</th>
                        <th>Volumen actual (L)</th>
                        <th>Acciones</th>
                        <th>Borrar</th>
                    </tr>
                </thead>
                <tbody id="tablaBarricas"></tbody>
            </table>

            <h2 style="margin-top:40px;">Nueva barrica</h2>

            <form id="formBarrica" onsubmit="crearBarrica(event)">
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <div style="flex:1;">
                        <label>C√≥digo</label>
                        <input type="text" id="barCodigo" required>
                    </div>
                    <div style="flex:1;">
                        <label>Capacidad&nbsp;(L)</label>
                        <input type="number" id="barCapacidad" required>
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de roble</label>
                        <input type="text" id="barTipo" placeholder="Franc√©s, americano‚Ä¶">
                    </div>
                    <div style="flex:1;">
                        <label>Tostado</label>
                        <input type="text" id="barTostado" placeholder="Ligero, medio, fuerte‚Ä¶">
                    </div>
                    <div style="flex:1;">
                        <label>Marca</label>
                        <input type="text" id="barMarca" placeholder="Coperage, proveedor‚Ä¶">
                    </div>
                    <div style="flex:1;">
                        <label>A√±o</label>
                        <input type="number" id="barAnio" min="1900" max="2100" placeholder="2020">
                    </div>
                    <div style="flex:1;">
                        <label>A√±ada</label>
                        <input type="number" id="barVinoAnio" min="1900" max="2100" placeholder="2023">
                    </div>
                    <div style="flex:1;">
                        <label>Tipo de vino</label>
                        <select id="barVinoTipo">
                            <option value="">Selecciona</option>
                            <option value="Vino tinto">Vino tinto</option>
                            <option value="Vino blanco">Vino blanco</option>
                            <option value="Vino rosado">Vino rosado / Clarete</option>
                        </select>
                    </div>
                </div>

                <button>Crear barrica</button>
            </form>
        </section>

        <!-- SECCI√ìN MOVIMIENTOS -->
        <section id="movimientos" class="card" style="display:none;">
            <h1><span class="h1-emoji">üîÑ</span>Movimientos de vino</h1>
            <p>Trasiegos, mermas, embotellados, ajustes‚Ä¶ Todo queda registrado.</p>

            <div class="filtros-movimientos">
                <div>
                    <label>Tipo</label>
                    <select id="filtroMovTipo">
                        <option value="">Todos</option>
                        <option value="trasiego">Trasiego</option>
                        <option value="merma">Merma</option>
                        <option value="embotellado">Embotellado</option>
                        <option value="ajuste">Ajuste</option>
                        <option value="otro">Otro</option>
                    </select>
                </div>
                <div>
                    <label>Desde</label>
                    <input type="date" id="filtroMovDesde">
                </div>
                <div>
                    <label>Hasta</label>
                    <input type="date" id="filtroMovHasta">
                </div>
                <div>
                    <label>ID Contenedor</label>
                    <input type="text" id="filtroMovContenedor" placeholder="Ej. A1 o 3">
        </div>
        <div>
            <label>Tipo contenedor</label>
            <select id="filtroMovContTipo">
                <option value="">Cualquiera</option>
                        <option value="deposito">Dep√≥sito</option>
                        <option value="mastelone">Mastelone</option>
                        <option value="barrica">Barrica</option>
                    </select>
                </div>
                <div class="acciones-movimientos">
                    <button type="button" onclick="aplicarFiltrosMovimientos()">Aplicar filtros</button>
                    <button type="button" onclick="limpiarFiltrosMovimientos()">Limpiar</button>
                    <button type="button" onclick="exportarMovimientosCSV()">Exportar CSV</button>
                    <button type="button" style="background:#c94458; color:#fff;" onclick="limpiarHistorialMovimientos()">Limpiar historial</button>
                </div>
            </div>

            <div class="movimientos-layout">
                <div class="movimientos-form">
                    <h2>Nuevo movimiento</h2>

                    <form id="formMovimiento" onsubmit="crearMovimiento(event)">
                        <label>Fecha</label>
                        <input type="datetime-local" id="movFecha">

                        <label>Tipo de movimiento</label>
                        <select id="movTipo">
                            <option value="trasiego">Trasiego</option>
                            <option value="merma">Merma</option>
                            <option value="embotellado">Embotellado</option>
                            <option value="ajuste">Ajuste</option>
                            <option value="otro">Otro</option>
                            <option value="prensado">Prensado</option>
                        </select>

                        <h3>Origen</h3>
                        <label>Tipo origen</label>
                        <select id="movOrigenTipo">
                            <option value="">(Ninguno)</option>
                            <option value="deposito">Dep√≥sito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>ID Contenedor origen (ej. 1 o A1)</label>
<input type="text" id="movOrigenId">
                        <small id="movOrigenNota" style="display:none; color:#f5c66b;">
                            En los movimientos de prensado no es necesario indicar origen.
                        </small>

<h3>Destino</h3>
                        <label>Tipo destino</label>
                        <select id="movDestinoTipo">
                            <option value="">(Ninguno)</option>
                            <option value="deposito">Dep√≥sito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                            <option value="merma">Merma</option>
                            <option value="embotellado">Embotellado</option>
                            <option value="otro">Otro</option>
                        </select>

                    <label>ID Contenedor destino (ej. 1 o B1)</label>
                        <input type="text" id="movDestinoId">

                        <label>Litros</label>
                        <input type="number" id="movLitros" step="0.1" min="0">

                        <label>P√©rdida (L)</label>
                        <input type="number" id="movPerdida" step="0.1" min="0">

                        <label>Nota</label>
                        <input type="text" id="movNota">

                        <button>Guardar movimiento</button>
                        <div class="form-feedback" id="feedbackMovimientos"></div>
                    </form>
                </div>

                <div class="tabla-movimientos">
                    <h2>Historial de movimientos</h2>

                    <table class="movimientos-table">
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Tipo</th>
                                <th>Litros</th>
                                <th>P√©rdida</th>
                                <th>Origen</th>
                                <th>Destino</th>
                                <th>Nota</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tablaMovimientos"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN REGISTROS ANAL√çTICOS -->
        <section id="analiticos" class="card" style="display:none;">
            <h1><span class="h1-emoji">üìä</span>Registros anal√≠ticos</h1>
            <p>Densidad, temperatura, etc. por dep√≥sito, mastelone o barrica.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo registro</h2>

                    <form id="formAnalitico" onsubmit="crearRegistroAnalitico(event)">
                        <label>Tipo contenedor</label>
                        <select id="regTipo">
                            <option value="deposito">Dep√≥sito</option>
                            <option value="mastelone">Mastelone</option>
                            <option value="barrica">Barrica</option>
                        </select>

                        <label>Contenedor</label>
                        <input type="text" id="regId" placeholder="Ej. 3 o A1" required>

                        <label>Fecha y hora</label>
                        <input type="datetime-local" id="regFecha" required>

                        <label>Densidad</label>
                        <input type="number" id="regDensidad" step="0.1">

                        <label>Temperatura (¬∞C)</label>
                        <input type="number" id="regTemperatura" step="0.1">

                        <label>Nota sensorial</label>
                        <input type="text" id="regNotaSensorial" placeholder="Ej. frutos rojos, especias">

                        <label>Nota</label>
                        <input type="text" id="regNota">

                        <button>Guardar registro</button>
                        <div id="regMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.2; min-width:260px;">
                    <h2>Historial por contenedor</h2>

                    <div style="display:flex; gap:10px; align-items:flex-end;">
                        <div style="flex:1;">
                            <label>Tipo</label>
                            <select id="histTipo">
                                <option value="deposito">Dep√≥sito</option>
                                <option value="mastelone">Mastelone</option>
                                <option value="barrica">Barrica</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label>Contenedor</label>
                            <input type="text" id="histId" placeholder="Ej. 5 o B1">
                        </div>
                        <div>
                            <button class="small-btn" onclick="cargarHistorialAnalitico()">Ver</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Evento</th>
                                <th>Detalle</th>
                                <th>Nota</th>
                            </tr>
                        </thead>
                        <tbody id="tablaRegistros"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN AN√ÅLISIS LABORATORIO -->
        <section id="analisisLab" class="card" style="display:none;">
            <h1><span class="h1-emoji">üìÑ</span>An√°lisis de laboratorio externos</h1>
            <p>Sube PDFs de laboratorios externos y as√≥cialos a un dep√≥sito o mastelone.</p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:260px;">
                    <h2>Nuevo an√°lisis</h2>
                    <form id="formAnalisisLab" onsubmit="crearAnalisisLab(event)">
                        <label>Tipo de contenedor</label>
                        <select id="labTipoContenedor">
                            <option value="deposito">Dep√≥sito</option>
                            <option value="mastelone">Mastelone</option>
                        </select>

                        <label>Contenedor (ID o c√≥digo)</label>
                        <input type="text" id="labDeposito" placeholder="Ej. 2 o D3" required>

                        <label>Fecha del an√°lisis</label>
                        <input type="date" id="labFecha">

                        <label>Laboratorio</label>
                        <input type="text" id="labLaboratorio" placeholder="Nombre del laboratorio">

                        <label>Descripci√≥n / tipo de an√°lisis</label>
                        <input type="text" id="labDescripcion" placeholder="Ej. Microbiol√≥gico, f√≠sico-qu√≠mico">

                        <label>Archivo PDF</label>
                        <input type="file" id="labArchivo" accept="application/pdf" required>

                        <button>Subir an√°lisis</button>
                        <div id="labMensaje" class="mensaje"></div>
                    </form>
                </div>

                <div style="flex:1.3; min-width:280px;">
                    <h2>Historial de PDFs</h2>
                    <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
                        <div style="flex:1; min-width:160px;">
                            <label>Filtrar por contenedor</label>
                            <input type="text" id="labFiltroDeposito" placeholder="Ej. 2 o D3">
                        </div>
                        <div>
                            <label>Tipo</label>
                            <select id="labFiltroTipo">
                                <option value="">Todos</option>
                                <option value="deposito">Dep√≥sito</option>
                                <option value="mastelone">Mastelone</option>
                            </select>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="aplicarFiltroAnalisisLab()">Filtrar</button>
                        </div>
                        <div>
                            <button class="small-btn" type="button" onclick="limpiarFiltroAnalisisLab()">Limpiar</button>
                        </div>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Contenedor</th>
                                <th>Laboratorio</th>
                                <th>Descripci√≥n</th>
                                <th>Archivo</th>
                            </tr>
                        </thead>
                        <tbody id="tablaAnalisisLab"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div> <!-- fin .content -->

  <script>
// ---- Mostrar secciones del men√∫ lateral ---
function mostrarSeccion(id) {
  const secciones = document.querySelectorAll("section.card");
  secciones.forEach(sec => {
    const esObjetivo = sec.id === id;
    if (esObjetivo) {
      sec.style.display = "block";
      requestAnimationFrame(() => sec.classList.add("visible"));
    } else if (sec.classList.contains("visible")) {
      sec.classList.remove("visible");
      setTimeout(() => {
        sec.style.display = "none";
      }, 250);
    } else {
      sec.style.display = "none";
    }
  });
  const links = document.querySelectorAll("[data-section]");
  links.forEach(link => {
    link.classList.toggle("activo", link.dataset.section === id);
  });
}
let cacheEntradas = [];
let cacheDepositos = [];
let cacheBarricas  = [];
let cacheMastelones = [];
let cacheMovimientos = [];
let cacheLimpieza = [];
let cacheEnologicos = [];
let cacheEmbotellados = [];
let cacheAnalisisLab = [];
let depositoEditando = null;
let temporizadorGuardadoFlujo = null;
const RETARDO_GUARDADO_FLUJO = 600;
const TITULOS_DINAMICOS = {
  estilo: () => null,
  deposito: nodo => {
    const nombre = nodo?.datos?.codigo || "Dep√≥sito";
    const fase = nodo?.datos?.fase;
    return fase ? `${nombre} ¬∑ ${fase}` : nombre;
  },
};
const CAMPOS_PRIORITARIOS_MODAL = ["fecha", "fecha_operacion"];
const CAMPOS_CARGA_NUMERICOS = ["kilos", "litros", "litros_directos", "volumen"];
const CAMPOS_CARGA_TEXTO = ["variedad", "anada"];
const TIPOS_CONTENEDOR_FLUJO = new Set(["deposito", "barrica"]);
function obtenerNodoPorId(idBuscado) {
  const idNorm = normalizarIdNodo(idBuscado);
  return flujoNodos.find(n => normalizarIdNodo(n.id) === idNorm) || null;
}
function actualizarTituloNodo(nodo) {
  if (!nodo) return;
  const config = FLOW_NODE_TYPES[nodo.tipo];
  const generador = TITULOS_DINAMICOS[nodo.tipo];
  if (generador) {
    const titulo = generador(nodo);
    if (titulo) {
      nodo.titulo = titulo;
      return;
    }
  }
  nodo.titulo = config ? config.label : nodo.titulo || "Nodo";
}

function ordenarCamposParaModal(campos) {
  const originales = [...(campos || [])];
  const prioridad = CAMPOS_PRIORITARIOS_MODAL.map(id =>
    originales.find(campo => campo.id === id)
  ).filter(Boolean);
  const resto = originales.filter(campo => !CAMPOS_PRIORITARIOS_MODAL.includes(campo.id));
  return [...prioridad, ...resto];
}

function obtenerValorCampoVisual(nodo, campo) {
  if (!nodo || !campo) return "";
  const valor = nodo.datos ? nodo.datos[campo.id] : "";
  if (!valor) return "";
  if (campo.id === "fecha" || campo.id === "fecha_operacion") {
    return formatearFechaCorta(valor);
  }
  return valor;
}

function esMetodoPrensado(metodo) {
  return (metodo || "").toLowerCase() === "prensado";
}

function esMetodoSangrado(metodo) {
  return (metodo || "").toLowerCase() === "sangrado";
}

function esNodoSangrado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "estilo") {
    return esMetodoSangrado(nodo.datos?.metodo);
  }
  return false;
}

function esNodoPrensado(nodo) {
  if (!nodo) return false;
  if (nodo.tipo === "prensado") return true;
  if (nodo.tipo === "estilo") {
    const metodo = (nodo.datos?.metodo || "").toLowerCase();
    return metodo === "prensado" || metodo === "sangrado";
  }
  return false;
}

function esNodoConversor(nodo) {
  return esNodoPrensado(nodo) || esNodoSangrado(nodo);
}

function obtenerPredecesores(id) {
  return flujoNodos.filter(n => (n.targets || []).includes(id));
}

function obtenerUnidadNodo(nodo, memo = new Map()) {
  if (!nodo) return "kilos";
  const clave = nodo.id || nodo;
  if (memo.has(clave)) return memo.get(clave);
  let unidad = esNodoConversor(nodo) ? "litros" : "kilos";
  if (unidad === "kilos") {
    const padres = obtenerPredecesores(nodo.id);
    if (padres.some(pre => obtenerUnidadNodo(pre, memo) === "litros")) {
      unidad = "litros";
    }
  }
  memo.set(clave, unidad);
  return unidad;
}

function obtenerUnidadEntrante(nodo) {
  if (!nodo) return "kilos";
  const padres = obtenerPredecesores(nodo.id);
  if (!padres.length) return "kilos";
  return padres.some(pre => obtenerUnidadNodo(pre) === "litros") ? "litros" : "kilos";
}

function obtenerUnidadDisponible(origen) {
  return obtenerUnidadNodo(origen);
}

function obtenerUnidadVisual(nodo) {
  return obtenerUnidadNodo(nodo) === "litros" ? "L" : "kg";
}

function asegurarAsignacionRegistro(destino, origenId, kilosPorDefecto = 0, litrosPorDefecto = 0) {
  destino.datos = destino.datos || {};
  destino.datos.asignaciones = destino.datos.asignaciones || {};
  const key = origenId.toString();
  const existente = destino.datos.asignaciones[key];
  if (!existente) {
    destino.datos.asignaciones[key] = {
      kilos: kilosPorDefecto,
      litros: litrosPorDefecto,
    };
  } else {
    if (existente.kilos == null && kilosPorDefecto) existente.kilos = kilosPorDefecto;
    if (existente.litros == null && litrosPorDefecto) existente.litros = litrosPorDefecto;
  }
  return destino.datos.asignaciones[key];
}

function normalizarIdNodo(nodo) {
  if (!nodo) return "";
  return nodo.id != null ? String(nodo.id) : "";
}

function limpiarAsignacionesOrfanas(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo) || !nodo.datos?.asignaciones) return;
  const clavesPermitidas = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  Object.keys(nodo.datos.asignaciones).forEach(key => {
    if (!clavesPermitidas.has(key)) {
      delete nodo.datos.asignaciones[key];
    }
  });
  actualizarVariedadDesdeAportes(nodo);
}

function limpiarCargaNodo(nodo) {
  if (!nodo || !nodo.datos) return;
  CAMPOS_CARGA_NUMERICOS.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = 0;
    }
  });
  CAMPOS_CARGA_TEXTO.forEach(campo => {
    if (campo in nodo.datos) {
      nodo.datos[campo] = "";
    }
  });
}

function limpiarNodosSinEntradas() {
  flujoNodos.forEach(nodo => {
    if (nodo.tipo === "entrada") return;
    const predecesores = obtenerPredecesores(nodo.id);
    if (!predecesores.length) {
      limpiarCargaNodo(nodo);
      if (nodo.tipo === "deposito" || nodo.tipo === "coupage") {
        actualizarVariedadDesdeAportes(nodo);
      }
    }
  });
}

function construirCargaDesdeDatos(datos = {}) {
  const carga = {};
  if (datos.variedad) carga.variedad = datos.variedad;
  if (datos.anada) carga.anada = datos.anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  if (datos.fecha_operacion) carga.fecha_operacion = datos.fecha_operacion;
  const kilos = normalizarNumero(datos.kilos);
  if (kilos != null) carga.kilos = kilos;
  const litros = normalizarNumero(datos.litros);
  if (litros != null) carga.litros = litros;
  const litrosDirectos = normalizarNumero(datos.litros_directos);
  if (litrosDirectos != null) carga.litros_directos = litrosDirectos;
  return Object.keys(carga).length ? carga : null;
}

function obtenerCargaParaSembrar(origen) {
  if (!origen) return null;
  const visitados = new Set();
  const cola = [origen];
  while (cola.length) {
    const actual = cola.shift();
    if (!actual || visitados.has(actual.id)) continue;
    visitados.add(actual.id);
    if (actual.tipo === "entrada" && actual.datos?.id_ref) {
      intentarPoblarNodoEntrada(actual);
    }
    if (actual.tipo === "deposito" && actual.datos?.id_ref) {
      intentarPoblarNodoDeposito(actual);
    }
    let carga = obtenerCargaDesdeNodo(actual);
    if (!carga) {
      carga = construirCargaDesdeDatos(actual.datos);
    }
    if (carga) return carga;
    const padres = obtenerPredecesores(actual.id);
    padres.forEach(pre => {
      if (pre && !visitados.has(pre.id)) {
        cola.push(pre);
      }
    });
  }
  return null;
}

function sembrarDatosIniciales(origen, destino) {
  if (!origen || !destino) return;
  if (destino.tipo === "deposito") return;
  const carga = obtenerCargaParaSembrar(origen);
  if (!carga) return;
  aplicarCargaANodo(destino, carga);
  guardarEstadoNodos();
}

function obtenerVariedadVisibleNodo(nodo) {
  if (!nodo) return "";
  const texto = obtenerVariedadNodo(nodo);
  return texto ? texto.replace(/\s*¬∑\s*/g, "\n") : "";
}

function limpiarTextoVariedad(variedad) {
  if (!variedad) return "";
  return variedad
    .split("¬∑")
    .map(part => part.replace(/\s*\d+(\.\d+)?%/g, "").trim())
    .filter(Boolean)
    .join(" ¬∑ ");
}

function describirNodoOrigen(origen) {
  if (!origen) return "Nodo";
  const base = origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
  const variedad = obtenerVariedadVisibleNodo(origen);
  if (origen.tipo === "estilo") {
    const metodo = origen.datos?.metodo ? ` ¬∑ ${origen.datos.metodo}` : "";
    const variedadTexto = variedad ? ` (${variedad})` : "";
    return `${base}${metodo}${variedadTexto}`;
  }
  if (origen.tipo === "entrada") {
    if (origen.datos?.id_ref) {
      return obtenerEtiquetaEntrada(origen.datos.id_ref);
    }
    return variedad ? `${base} (${variedad})` : base;
  }
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    const info =
      origen.tipo === "deposito"
        ? buscarDepositoPorId(origen.datos?.id_ref)
        : buscarBarricaPorId(origen.datos?.id_ref);
    const nombre = info?.codigo || origen.datos?.codigo || origen.titulo || base;
    const varTexto =
      info?.vino_tipo ||
      origen.datos?.vino_tipo ||
      origen.datos?.variedad ||
      variedad ||
      "";
    const varLabel = varTexto ? ` (${varTexto})` : "";
    return `${nombre}${varLabel}`;
  }
  return variedad ? `${base} (${variedad})` : base;
}

function describirNodoDestino(dest) {
  if (!dest) return "Nodo";
  const contenedor = obtenerContenedorPorIdRef(dest.datos?.id_ref);
  if (contenedor) {
    const nombre =
      contenedor.codigo ||
      dest.datos?.codigo ||
      dest.titulo ||
      (contenedor.tipo === "barrica" ? "Barrica" : "Dep√≥sito");
    const variedad =
      contenedor.variedad ||
      dest.datos?.vino_tipo ||
      dest.datos?.variedad ||
      "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  if (dest.tipo === "deposito") {
    const info = dest.datos?.id_ref ? buscarDepositoPorId(dest.datos.id_ref) : null;
    const nodosMap = getNodosPorId();
    const mapaDep = crearMapaDeposPorRef(nodosMap);
    const refKey = dest.datos?.id_ref != null ? String(dest.datos.id_ref) : null;
    const nombreMapa = refKey && mapaDep[refKey] ? mapaDep[refKey].codigo : null;
    const nombre =
      info?.codigo ||
      nombreMapa ||
      dest.datos?.codigo ||
      dest.titulo ||
      (dest.datos?.id_ref ? `Dep√≥sito #${dest.datos.id_ref}` : "Dep√≥sito");
    const variedad = info?.vino_tipo || dest.datos?.vino_tipo || dest.datos?.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }
  return etiquetarDestinoFlow(dest);
}

function obtenerContenedorPrevio(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return null;
  visitados.add(origen.id);
  if (origen.tipo === "deposito" || origen.tipo === "barrica") {
    return origen;
  }
  const padres = obtenerPredecesores(origen.id);
  for (const pre of padres) {
    const encontrado = obtenerContenedorPrevio(pre, visitados);
    if (encontrado) return encontrado;
  }
  return null;
}

function nombreOrigenBlend(origen) {
  if (!origen) return "Origen";
  const datos = origen.datos || {};
  const contenedorPrevio = obtenerContenedorPrevio(origen);
  if (contenedorPrevio && contenedorPrevio !== origen) {
    return nombreOrigenBlend(contenedorPrevio);
  }
  if (origen.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    return (
      info?.codigo ||
      datos.codigo ||
      origen.titulo ||
      (datos.id_ref ? `Dep√≥sito ${datos.id_ref}` : "Dep√≥sito")
    );
  }
  if (origen.tipo === "barrica") {
    const info = datos.contenedor_id ? buscarBarricaPorId(datos.contenedor_id) : null;
    return (
      info?.codigo ||
      datos.tipo ||
      (datos.contenedor_id ? `Barrica ${datos.contenedor_id}` : origen.titulo || "Barrica")
    );
  }
  if (origen.tipo === "entrada") {
    return datos.id_ref ? obtenerEtiquetaEntrada(datos.id_ref) : origen.titulo || "Entrada";
  }
  return origen.titulo || FLOW_NODE_TYPES[origen.tipo]?.label || "Nodo";
}

function obtenerEtiquetaEntrada(id) {
  if (!id) return "";
  const entrada = cacheEntradas.find(e => String(e.id) === String(id));
  if (!entrada) return `Entrada #${id}`;
  const variedad = entrada.variedad ? ` (${entrada.variedad})` : "";
  return `Entrada #${id}${variedad}`;
}

function buscarEntradaPorId(id) {
  if (!id || !Array.isArray(cacheEntradas)) return null;
  return cacheEntradas.find(e => String(e.id) === String(id)) || null;
}

function buscarDepositoPorId(id) {
  if (!id || !Array.isArray(cacheDepositos)) return null;
  const dep = cacheDepositos.find(d => String(d.id) === String(id));
  if (dep) return dep;
  if (Array.isArray(cacheMastelones)) {
    const mas = cacheMastelones.find(m => String(m.id) === String(id));
    if (mas) return mas;
  }
  return null;
}

function buscarDepositoPorCodigo(codigo) {
  if (!codigo) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  const dep =
    (cacheDepositos || []).find(d => (d.codigo || "").toLowerCase() === codNorm) ||
    (cacheMastelones || []).find(d => (d.codigo || "").toLowerCase() === codNorm);
  return dep || null;
}

function resolverInfoDepositoDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "deposito") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.id_ref) {
    info = buscarDepositoPorId(datos.id_ref);
  }
  if (!info && datos.codigo) {
    info = buscarDepositoPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarDepositoPorCodigo(nodo.titulo);
  }
  return info;
}

function buscarBarricaPorId(id) {
  if (!id || !Array.isArray(cacheBarricas)) return null;
  return cacheBarricas.find(b => String(b.id) === String(id)) || null;
}

function buscarBarricaPorCodigo(codigo) {
  if (!codigo || !Array.isArray(cacheBarricas)) return null;
  const codNorm = codigo.toString().trim().toLowerCase();
  return cacheBarricas.find(b => (b.codigo || "").toLowerCase() === codNorm) || null;
}

function resolverInfoBarricaDesdeNodo(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return null;
  const datos = nodo.datos || {};
  let info = null;
  if (datos.contenedor_id) {
    info = buscarBarricaPorId(datos.contenedor_id);
  }
  if (!info && datos.codigo) {
    info = buscarBarricaPorCodigo(datos.codigo);
  }
  if (!info && nodo.titulo) {
    info = buscarBarricaPorCodigo(nodo.titulo);
  }
  return info;
}

function obtenerContenedorPorIdRef(idRef) {
  if (!idRef) return null;
  const dep = buscarDepositoPorId(idRef);
  if (dep) {
    return { tipo: "deposito", codigo: dep.codigo, variedad: dep.vino_tipo };
  }
  const bar = buscarBarricaPorId(idRef);
  if (bar) {
    return { tipo: "barrica", codigo: bar.codigo, variedad: bar.vino_tipo };
  }
  return null;
}

function rellenarDatosDepositoDesdeCache(nodo) {
  if (!nodo || nodo.tipo !== "deposito" || !nodo.datos?.id_ref) return;
  const info = buscarDepositoPorId(nodo.datos.id_ref);
  if (!info) return;
  nodo.datos.codigo = nodo.datos.codigo || info.codigo || nodo.datos.codigo;
  nodo.datos.capacidad =
    nodo.datos.capacidad ||
    info.capacidad_l ||
    (info.capacidad_hl != null ? info.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.vino_tipo = nodo.datos.vino_tipo || info.vino_tipo;
  nodo.datos.variedad = nodo.datos.variedad || info.vino_tipo;
}

// Cargar nodos (preferimos el estado en memoria) y mapear por id
function getNodosPorId() {
  const enMemoria = Array.isArray(flujoNodos) ? flujoNodos : [];
  const nodos =
    enMemoria.length > 0
      ? enMemoria
      : JSON.parse(localStorage.getItem("flowNodes") || "[]");
  return Object.fromEntries(nodos.map(n => [n.id, n]));
}

function crearMapaDeposPorRef(nodosPorId) {
  const mapa = {};
  Object.values(nodosPorId || {}).forEach(nodo => {
    if (nodo.tipo === "deposito" && nodo.datos?.id_ref != null) {
      const clave = String(nodo.datos.id_ref);
      rellenarDatosDepositoDesdeCache(nodo);
      if (!mapa[clave]) {
        mapa[clave] = {
          codigo: nodo.datos.codigo || nodo.titulo || `Dep√≥sito #${clave}`,
          nodoId: nodo.id,
        };
      }
    }
  });
  return mapa;
}

function getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef) {
  const nodo = nodosPorId[idNodoDestino];
  if (!nodo) return `Nodo ${idNodoDestino}`;

  const datos = nodo.datos || {};
  const mapa = mapaDepRef || crearMapaDeposPorRef(nodosPorId);

  switch (nodo.tipo) {
    case "deposito":
      // A1, A2, A3‚Ä¶
      if (datos.id_ref != null) {
        const depMap = mapa[String(datos.id_ref)];
        if (depMap?.codigo) return depMap.codigo;
        const info = buscarDepositoPorId(datos.id_ref);
        if (info?.codigo) return info.codigo;
      }
      return `${datos.codigo || nodo.titulo || "Dep√≥sito"}`;

    case "barrica":
      // Crianza / Barrica 500L Franc√©s, etc.
      return datos.tipo || nodo.titulo || "Crianza";

    case "entrada":
      // Solo por si alg√∫n d√≠a enlazas a otra entrada
      return `Entrada #${datos.id_ref || "?"}${
        datos.variedad ? ` (${datos.variedad})` : ""
      }`;

    default:
      return nodo.titulo || nodo.tipo || `Nodo ${idNodoDestino}`;
  }
}

function buildRepartoDestinos(nodoElaboracion) {
  if (!nodoElaboracion) return [];
  const nodosPorId = getNodosPorId();
  const mapaDepRef = crearMapaDeposPorRef(nodosPorId);
  const distribucion = nodoElaboracion.datos?.distribucion || {};
  return Object.entries(distribucion).map(([idNodoDestino, valores]) => {
    return {
      idNodoDestino,
      nombre: getNombreNodoDestino(idNodoDestino, nodosPorId, mapaDepRef),
      kilos: (valores && valores.kilos) || 0,
      litros: (valores && valores.litros) || 0,
    };
  });
}

function etiquetarDestinoFlow(dest) {
  if (!dest) return "Nodo";
  const datos = dest.datos || {};

  if (dest.tipo === "deposito") {
    const info = datos.id_ref ? buscarDepositoPorId(datos.id_ref) : null;
    const nombre =
      info?.codigo ||
      datos.codigo ||
      dest.titulo ||
      (datos.id_ref ? `Dep√≥sito #${datos.id_ref}` : "Dep√≥sito");
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "barrica") {
    const info = datos.contenedor_id ? buscarBarricaPorId(datos.contenedor_id) : null;
    const nombre =
      datos.tipo ||
      info?.codigo ||
      (datos.contenedor_id ? `Barrica ${datos.contenedor_id}` : dest.titulo || "Barrica");
    const variedad = info?.vino_tipo || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  if (dest.tipo === "entrada" && datos.id_ref) {
    return obtenerEtiquetaEntrada(datos.id_ref);
  }

  // Si viene con id_ref de contenedor aunque el tipo no sea dep√≥sito/barrica, intentamos resolverlo
  const contenedor = obtenerContenedorPorIdRef(datos.id_ref);
  if (contenedor) {
    const nombre = contenedor.codigo || dest.titulo || (contenedor.tipo === "barrica" ? "Barrica" : "Dep√≥sito");
    const variedad = contenedor.variedad || datos.vino_tipo || datos.variedad || "";
    return variedad ? `${nombre} (${variedad})` : nombre;
  }

  return dest.titulo || dest.tipo || "Nodo";
}

function obtenerEtiquetaNodoLimite(nodo) {
  if (!nodo) return "Este nodo";
  if (nodo.tipo === "entrada") {
    return obtenerEtiquetaEntrada(nodo.datos?.id_ref) || "Esta entrada";
  }
  if (nodo.tipo === "deposito") {
    return nodo.datos?.codigo || nodo.titulo || "Dep√≥sito";
  }
  return nodo.titulo || "Este nodo";
}

function obtenerNodoPorId(id) {
  return flujoNodos.find(n => String(n.id) === String(id));
}

function sumarConsumoDesdeNodo(origen) {
  if (!origen) return 0;
  const unidad = obtenerUnidadDisponible(origen);
  const origenKey = origen.id?.toString?.() ?? String(origen.id);
  return (origen.targets || []).reduce((total, targetId) => {
    const destino = obtenerNodoPorId(targetId);
    if (!destino) return total;
    const registro =
      destino.datos?.asignaciones?.[origenKey] || destino.datos?.asignaciones?.[origen.id];
    if (!registro) return total;
    let valor = 0;
    if (unidad === "litros") {
      const litros = normalizarNumero(registro.litros);
      const kilos = normalizarNumero(registro.kilos);
      if (litros > 0) {
        valor += litros;
      } else if (kilos > 0) {
        valor += kilos;
      }
    } else {
      const kilos = normalizarNumero(registro.kilos);
      if (kilos > 0) valor += kilos;
    }
    if (valor > 0) {
      return total + valor;
    }
    return total;
  }, 0);
}

function obtenerLimiteNodo(nodo) {
  if (!nodo) return null;
  const unidad = obtenerUnidadNodo(nodo);
  if (unidad === "litros") {
    const litros = normalizarNumero(
      nodo.datos?.volumen ?? nodo.datos?.litros ?? nodo.datos?.litros_directos
    );
    return Number.isFinite(litros) ? litros : null;
  }
  const kilos = normalizarNumero(nodo.datos?.kilos);
  return Number.isFinite(kilos) ? kilos : null;
}

function validarLimitesFlujo() {
  for (const nodo of flujoNodos) {
    const limite = obtenerLimiteNodo(nodo);
    if (limite == null) continue;
    const consumo = sumarConsumoDesdeNodo(nodo);
    if (consumo > limite + 0.0001) {
      return {
        ok: false,
        nodo,
        consumo,
        limite,
        unidad: obtenerUnidadVisual(nodo),
      };
    }
  }
  return { ok: true };
}

function crearTablaControlFermentacion(nodo) {
  nodo.datos = nodo.datos || {};
  if (!Array.isArray(nodo.datos.control)) {
    nodo.datos.control = [];
  }
  const contenedor = document.createElement("div");
  contenedor.className = "tabla-control-fermentacion";

  const toolbar = document.createElement("div");
  toolbar.style.display = "flex";
  toolbar.style.justifyContent = "flex-end";
  toolbar.style.marginBottom = "6px";
  const btnPdf = document.createElement("button");
  btnPdf.type = "button";
  btnPdf.className = "small-btn";
  btnPdf.textContent = "PDF";
  btnPdf.addEventListener("click", () => exportarTablaControlPDF(nodo));
  toolbar.appendChild(btnPdf);
  contenedor.appendChild(toolbar);

  const tabla = document.createElement("table");
  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Fecha</th>
      <th>Densidad</th>
      <th>¬∞C</th>
      <th>Productos</th>
      <th></th>
    </tr>`;
  tabla.appendChild(thead);
  const tbody = document.createElement("tbody");
  const renderFilas = () => {
    tbody.innerHTML = "";
    if (!nodo.datos.control.length) {
      const fila = document.createElement("tr");
      fila.innerHTML = `<td colspan="5" style="text-align:center; color:#777;">Sin registros</td>`;
      tbody.appendChild(fila);
      return;
    }
    nodo.datos.control.forEach((registro, index) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="date" value="${registro.fecha || ""}" data-index="${index}" data-campo="fecha"></td>
        <td><input type="number" step="0.001" value="${registro.densidad || ""}" data-index="${index}" data-campo="densidad"></td>
        <td><input type="number" step="0.1" value="${registro.temperatura || ""}" data-index="${index}" data-campo="temperatura"></td>
        <td><input type="text" value="${registro.productos || ""}" data-index="${index}" data-campo="productos"></td>
        <td><button type="button" class="small-btn" data-index="${index}" data-accion="eliminar">‚úï</button></td>`;
      tbody.appendChild(tr);
    });
  };
  renderFilas();
  tabla.appendChild(tbody);
  tabla.addEventListener("input", e => {
    const target = e.target;
    const index = target.dataset.index;
    const campo = target.dataset.campo;
    if (index == null || !campo) return;
    nodo.datos.control[index][campo] = target.value;
    guardarEstadoNodos();
  });
  tabla.addEventListener("click", e => {
    const btn = e.target.closest("button[data-accion='eliminar']");
    if (!btn) return;
    const index = btn.dataset.index;
    nodo.datos.control.splice(index, 1);
    guardarEstadoNodos();
    renderFilas();
  });
  const btnAdd = document.createElement("button");
  btnAdd.type = "button";
  btnAdd.className = "btnSecundario";
  btnAdd.style.marginTop = "8px";
  btnAdd.textContent = "+ A√±adir control";
  btnAdd.addEventListener("click", () => {
    nodo.datos.control.push({
      fecha: nodo.datos.fecha_operacion || nodo.datos.fecha || "",
      densidad: "",
      temperatura: "",
      productos: "",
    });
    guardarEstadoNodos();
    renderFilas();
  });
  contenedor.appendChild(tabla);
  contenedor.appendChild(btnAdd);
  return contenedor;
}

function crearTablaAsignacionesDeposito(nodo, soloLectura = false) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  limpiarAsignacionesOrfanas(nodo);
  const predecesores = obtenerPredecesores(nodo.id);
  if (!predecesores.length) {
    const mensaje =
      nodo.tipo === "coupage"
        ? "Conecta dep√≥sitos para seleccionar los litros de cada uno."
        : "Conecta este dep√≥sito para repartir kilos/litros.";
    wrapper.innerHTML = `<p style='font-size:13px; color:#666;'>${mensaje}</p>`;
    return wrapper;
  }
  nodo.datos = nodo.datos || {};
  nodo.datos.asignaciones = nodo.datos.asignaciones || {};
  const esCoupage = nodo.tipo === "coupage";
  if (esCoupage) {
    const infoDest = obtenerTotalesDestino(nodo);
    if (infoDest) {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#777";
      info.textContent = `Destino: capacidad ${infoDest.capTotal.toFixed(2)} L ¬∑ Libre ${infoDest.libre.toFixed(2)} L`;
      wrapper.appendChild(info);
    } else {
      const info = document.createElement("p");
      info.style.fontSize = "12px";
      info.style.color = "#c06";
      info.textContent = "Conecta este blend a un destino (dep√≥sito o barrica) para ver la capacidad libre, o revisa que el destino tenga capacidad/volumen definidos.";
      wrapper.appendChild(info);
    }
  }
  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Origen</th>
        ${esCoupage ? "" : "<th>Kilos</th>"}
        <th>Litros</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  predecesores.forEach(origen => {
    const key = origen.id.toString();
    const cargaOrigen = obtenerCargaDesdeNodo(origen) || {};
    const kilosPorDefecto = Number(cargaOrigen.kilos || 0);
    const litrosPorDefecto = Number(cargaOrigen.litros_directos ?? (cargaOrigen.litros || 0));
    const litrosNodoDisponibles = (() => {
      if (!esCoupage) return litrosPorDefecto;
      if (origen.tipo === "deposito") {
        const idRef = origen.datos?.id_ref || origen.datos?.contenedor_id || origen.id;
        const idNum = idRef != null ? Number(idRef) : null;
        const vol = obtenerVolumenFinalNodoContenedor("deposito", idNum);
        if (Number.isFinite(vol)) return vol;
        const fallbackVol =
          origen.datos?.volumen ??
          origen.datos?.litros ??
          origen.datos?.litros_directos ??
          litrosPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      if (origen.tipo === "barrica") {
        const idRef = origen.datos?.contenedor_id || origen.datos?.id_ref || origen.id;
        const idNum = idRef != null ? Number(idRef) : null;
        const vol = obtenerVolumenFinalNodoContenedor("barrica", idNum);
        if (Number.isFinite(vol)) return vol;
        const fallbackVol =
          origen.datos?.volumen ??
          origen.datos?.litros ??
          origen.datos?.litros_directos ??
          litrosPorDefecto;
        if (Number.isFinite(Number(fallbackVol))) return Number(fallbackVol);
      }
      return litrosPorDefecto;
    })();
    const registro = asegurarAsignacionRegistro(
      nodo,
      origen.id,
      esCoupage ? 0 : (Number.isFinite(kilosPorDefecto) && kilosPorDefecto > 0 ? kilosPorDefecto : 0),
      esCoupage ? 0 : (Number.isFinite(litrosPorDefecto) && litrosPorDefecto > 0 ? litrosPorDefecto : 0)
    );
    const tr = document.createElement("tr");
    const nombreBase = describirNodoOrigen(origen);
    const nombre = esCoupage
      ? nombreOrigenBlend(origen)
      : nombreBase;
    const disponibleTexto = esCoupage ? `Disponible: ${Number(litrosNodoDisponibles || 0).toFixed(2)} L` : describirNodoOrigen(origen);
    const valorKilos = registro.kilos && registro.kilos !== 0 ? registro.kilos : "";
    const valorLitros = registro.litros && registro.litros !== 0 ? registro.litros : "";
    tr.innerHTML = `
      <td>${nombre}<br><small>${disponibleTexto}</small></td>
      ${
        esCoupage
          ? ""
          : `<td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorKilos}" data-origen="${key}" data-tipo="kilos"></td>`
      }
      <td><input ${soloLectura ? "readonly" : ""} ${soloLectura ? "disabled" : ""} type="number" step="0.01" min="0" value="${valorLitros}" data-origen="${key}" data-tipo="litros"${esCoupage && Number.isFinite(litrosNodoDisponibles) ? ` data-max-litros="${Number(litrosNodoDisponibles).toFixed(4)}"` : ""}></td>`;
    if (!soloLectura) {
      const inputs = tr.querySelectorAll("input");
      inputs.forEach(input => {
        input.addEventListener("input", () => {
          const valor = Number(input.value);
          const tipo = input.dataset.tipo;
          registro[tipo] = Number.isFinite(valor) ? valor : "";
          if (esCoupage && tipo === "litros") {
            const maxAttr = input.dataset.maxLitros;
            const max = maxAttr != null ? Number(maxAttr) : null;
            if (Number.isFinite(max) && max > 0 && valor > max) {
              registro.litros = max;
              input.value = max.toFixed(2);
              mostrarAviso("No puedes usar m√°s litros de los disponibles en el dep√≥sito.", "error");
            }
            const capDestino = obtenerCapacidadDisponibleDesdeTargets(nodo);
            if (capDestino != null) {
              const totalAsignado = sumarAsignacionesLitros(nodo);
              if (totalAsignado > capDestino + 0.0001) {
                const restante = capDestino - (totalAsignado - (registro.litros || 0));
                const nuevoValor = Math.max(0, restante);
                registro.litros = nuevoValor;
                input.value = nuevoValor.toFixed(2);
                mostrarAviso(
                  `No caben m√°s de ${capDestino.toFixed(2)} L en el destino del blend.`,
                  "error"
                );
              }
            }
          }
          actualizarVariedadDesdeAportes(nodo);
          actualizarVolumenDesdeAsignaciones(nodo);
          guardarEstadoNodos();
          renderFlowNodes();
        });
      });
    }
    tbody.appendChild(tr);
  });
  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function limpiarDistribucionEstilo(nodo) {
  if (!nodo || nodo.tipo !== "estilo" || !nodo.datos?.distribucion) return;
  const permitidos = new Set((nodo.targets || []).map(id => String(id)));
  Object.keys(nodo.datos.distribucion).forEach(key => {
    if (!permitidos.has(key)) {
      delete nodo.datos.distribucion[key];
    }
  });
}

function crearTablaDistribucionEstilo(nodo) {
  const wrapper = document.createElement("div");
  wrapper.className = "tabla-asignaciones-deposito";
  const distribucion = nodo.datos?.distribucion || {};
  const entradasDistrib = Object.entries(distribucion);
  if (!entradasDistrib.length) {
    wrapper.innerHTML = "<p style='font-size:13px; color:#666;'>Conecta este nodo a otro para repartir los kilos/litros.</p>";
    return wrapper;
  }
  const mapaNodos = getNodosPorId();
  const cargaDisponible = obtenerCargaDesdeNodo(nodo) || {};
  const dispKilos = Number(cargaDisponible.kilos || 0);
  const dispLitros = Number(
    cargaDisponible.litros_directos != null
      ? cargaDisponible.litros_directos
      : cargaDisponible.litros || 0
  );
  const totDestinos = nodo.tipo === "coupage" ? obtenerTotalesDestino(nodo) : null;
  const resumen = document.createElement("p");
  resumen.style.fontSize = "12px";
  resumen.style.color = "#777";
  const infoCap =
    totDestinos
      ? ` | Destino: ${Number.isFinite(totDestinos.capTotal) ? totDestinos.capTotal.toFixed(2) + " L cap" : "capacidad n/d"} ¬∑ Libre ${Number.isFinite(totDestinos.libre) ? totDestinos.libre.toFixed(2) + " L" : "‚Äî"}`
      : "";
  resumen.textContent = `Disponible: ${dispKilos.toFixed(2)} kg ¬∑ ${dispLitros.toFixed(2)} L${infoCap}`;
  wrapper.appendChild(resumen);

  const tabla = document.createElement("table");
  tabla.innerHTML = `
    <thead>
      <tr>
        <th>Destino</th>
        <th>Kilos</th>
        <th>Litros</th>
      </tr>
    </thead>`;
  const tbody = document.createElement("tbody");
  const destinos = buildRepartoDestinos(nodo);

  destinos.forEach(dest => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${dest.nombre}</td>
      <td><input type="number" step="0.01" min="0" value="${dest.kilos || ""}" data-destino="${dest.idNodoDestino}" data-tipo="kilos"></td>
      <td><input type="number" step="0.01" min="0" value="${dest.litros || ""}" data-destino="${dest.idNodoDestino}" data-tipo="litros"></td>`;
    tr.querySelectorAll("input").forEach(input => {
      input.addEventListener("input", () => {
        const valor = Number(input.value);
        const tipo = input.dataset.tipo;
        if (!nodo.datos.distribucion[dest.idNodoDestino]) {
          nodo.datos.distribucion[dest.idNodoDestino] = { kilos: 0, litros: 0 };
        }
        nodo.datos.distribucion[dest.idNodoDestino][tipo] = Number.isFinite(valor) ? valor : "";
        guardarEstadoNodos();
        renderFlowNodes();
      });
    });
    tbody.appendChild(tr);
  });

  tabla.appendChild(tbody);
  wrapper.appendChild(tabla);
  return wrapper;
}

function obtenerCargaDistribuida(origen, destinoId, cargaBase) {
  if (!origen || origen.tipo !== "estilo") return null;
  const distribucion = origen.datos?.distribucion || {};
  const registro = distribucion[destinoId != null ? destinoId.toString() : ""];
  if (!registro) return null;
  const kilos = normalizarNumero(registro.kilos);
  const litros = normalizarNumero(registro.litros);
  if (!(kilos > 0 || litros > 0)) return null;
  const carga = { ...cargaBase };
  if (kilos != null) {
    carga.kilos = kilos > 0 ? kilos : 0;
  }
  if (litros != null) {
    const litrosPositivos = litros > 0 ? litros : 0;
    carga.litros_directos = litrosPositivos;
    carga.litros = litrosPositivos;
  }
  return carga;
}


function actualizarVariedadDesdeAportes(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  nodo.datos.variedad = obtenerVariedadDesdeAsignaciones(nodo);
  actualizarVolumenDesdeAsignaciones(nodo);
}

function obtenerVariedadDesdeAsignaciones(nodo) {
  if (!nodo || !nodo.datos?.asignaciones) return "";
  const permitidos = new Set(obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre)));
  const componentes = [];
  let total = 0;
  Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
    const kilos = normalizarNumero(info?.kilos);
    const litros = normalizarNumero(info?.litros);
    const cantidad = (kilos > 0 ? kilos : 0) + (litros > 0 ? litros : 0);
    if (!(cantidad > 0)) return;
    if (!permitidos.has(origenId)) return;
    const origen = obtenerNodoPorId(origenId);
    let nombreVar = "";
    if (origen?.tipo === "entrada" && origen.datos?.id_ref) {
      const entrada = buscarEntradaPorId(origen.datos.id_ref);
      nombreVar = entrada?.variedad || "";
    }
    if (!nombreVar) {
      nombreVar = limpiarTextoVariedad(obtenerVariedadNodo(origen));
    }
    if (!nombreVar) {
      nombreVar = origen?.titulo || `Nodo ${origenId}`;
    }
    componentes.push({ variedad: nombreVar, cantidad });
    total += cantidad;
  });
  if (!componentes.length || !total) return "";
  return componentes
    .map(comp => `${comp.variedad} ${(comp.cantidad / total * 100).toFixed(1)}%`)
    .join(" ¬∑ ");
}

function capYVolDesdeInfo(info, fallbackCap, fallbackVol, extraCap = null) {
  if (!info && fallbackCap == null && fallbackVol == null && extraCap == null) return { cap: null, vol: null };
  const capRaw =
    (info && (info.capacidad_l ?? (info.capacidad_hl != null ? info.capacidad_hl * 100 : null))) ??
    fallbackCap ??
    extraCap;
  const volRaw =
    (info && (info.litros_actuales ?? info.volumen)) ??
    fallbackVol ??
    0;
  return { cap: Number(capRaw), vol: Number(volRaw) };
}

function capacidadDisponibleContenedorDesdeInfo(info, fallbackCap, fallbackVol) {
  const { cap, vol } = capYVolDesdeInfo(info, fallbackCap, fallbackVol);
  if (cap == null || Number.isNaN(cap)) return null;
  const capacidad = Number(cap);
  const volumen = Number(vol) || 0;
  if (!Number.isFinite(capacidad)) return null;
  return Math.max(0, capacidad - volumen);
}

function obtenerCapacidadDisponibleContenedor(nodoDestino) {
  if (!nodoDestino) return null;
  const datos = nodoDestino.datos || {};
  if (nodoDestino.tipo === "deposito") {
    const info = resolverInfoDepositoDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      datos.volumen ?? datos.litros ?? datos.litros_directos
    );
  }
  if (nodoDestino.tipo === "barrica") {
    const info = resolverInfoBarricaDesdeNodo(nodoDestino);
    return capacidadDisponibleContenedorDesdeInfo(
      info,
      datos.capacidad ?? datos.capacidad_l,
      datos.volumen ?? datos.litros ?? datos.litros_directos
    );
  }
  return null;
}

function obtenerTotalesDestino(nodo) {
  if (!nodo || !Array.isArray(nodo.targets) || !nodo.targets.length) return null;
  let capTotal = 0;
  let volTotal = 0;
  let tieneDestino = false;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const datos = dest.datos || {};
    tieneDestino = true;
    if (dest.tipo === "deposito") {
      if (datos.id_ref && (!datos.capacidad && !datos.capacidad_l)) {
        intentarPoblarNodoDeposito(dest);
      }
      const info = resolverInfoDepositoDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    } else if (dest.tipo === "barrica") {
      const info = resolverInfoBarricaDesdeNodo(dest);
      const { cap, vol } = capYVolDesdeInfo(
        info,
        datos.capacidad ?? datos.capacidad_l,
        datos.volumen ?? datos.litros ?? datos.litros_directos
      );
      if (Number.isFinite(cap)) {
        capTotal += cap;
      }
      if (Number.isFinite(vol)) {
        volTotal += vol;
      }
    }
  });
  if (!tieneDestino) return null;
  const libreCalc = Number.isFinite(capTotal) ? Math.max(0, capTotal - volTotal) : null;
  return { capTotal, volTotal, libre: libreCalc };
}

function obtenerCapacidadDisponibleDesdeTargets(nodo) {
  if (!nodo || !Array.isArray(nodo.targets)) return null;
  let total = 0;
  nodo.targets.forEach(tid => {
    const dest = obtenerNodoPorId(tid);
    if (!dest) return;
    const cap = obtenerCapacidadDisponibleContenedor(dest);
    if (cap != null) total += cap;
  });
  return total > 0 ? total : null;
}

function sumarAsignacionesLitros(nodo) {
  if (!nodo?.datos?.asignaciones) return 0;
  return Object.values(nodo.datos.asignaciones).reduce((acc, reg) => {
    const val = Number(reg?.litros);
    return acc + (Number.isFinite(val) ? val : 0);
  }, 0);
}

function calcularTotalesAsignaciones(nodo) {
  if (!nodo?.datos?.asignaciones) return null;
  const permitidos = new Set(
    obtenerPredecesores(nodo.id).map(pre => normalizarIdNodo(pre))
  );
  let totalKilos = 0;
  let totalLitros = 0;
  Object.entries(nodo.datos.asignaciones).forEach(([origenId, info]) => {
    if (!permitidos.has(origenId)) return;
    const kilos = normalizarNumero(info?.kilos);
    const litros = normalizarNumero(info?.litros);
    if (kilos > 0) totalKilos += kilos;
    if (litros > 0) totalLitros += litros;
  });
  const total = totalKilos + totalLitros;
  if (total <= 0) return null;
  return { totalKilos, totalLitros, total }; 
}

function actualizarVolumenDesdeAsignaciones(nodo) {
  if (!nodo || !["deposito", "coupage"].includes(nodo.tipo)) return;
  const totales = calcularTotalesAsignaciones(nodo);
  if (!totales) return;
  nodo.datos.kilos = Number(totales.totalKilos.toFixed(2));
  nodo.datos.litros_directos = Number(totales.totalLitros.toFixed(2));
  nodo.datos.volumen = Number(totales.total.toFixed(2));
  nodo.datos.litros = nodo.datos.volumen;
  if (nodo.tipo === "coupage") {
    nodo.datos.litros_blend = nodo.datos.volumen;
  }
}

function obtenerEstadoDepositoDesdeNodo(idDeposito) {
  if (!idDeposito || !Array.isArray(flujoNodos)) return null;
  const volumenNodo = obtenerVolumenFinalNodoContenedor("deposito", idDeposito);
  let volumen = null;
  if (Number.isFinite(volumenNodo)) {
    volumen = volumenNodo;
  } else {
    const nodo = flujoNodos.find(
      n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idDeposito)
    );
    if (!nodo) return null;
    const totales = calcularTotalesAsignaciones(nodo);
    if (totales) {
      volumen = totales.total;
    } else if (nodo.datos && nodo.datos.volumen != null) {
      volumen = Number(nodo.datos.volumen);
    }
  }
  const variedadTexto =
    obtenerVariedadDesdeAsignaciones(
      flujoNodos.find(n => n.tipo === "deposito" && n.datos && String(n.datos.id_ref) === String(idDeposito))
    ) || "";
  return volumen != null
    ? {
        variedad: variedadTexto,
        volumen,
        enMapa: true,
      }
    : null;
}


const ETAPAS_FLUJO = [
  { id: "entrada", titulo: "Entrada de uva", unidad: "kg" },
  { id: "despalillado", titulo: "Despalillado", unidad: "L" },
  { id: "deposito", titulo: "Dep√≥sitos", unidad: "L" },
  { id: "barrica", titulo: "Barricas", unidad: "L" },
  { id: "embotellado", titulo: "Embotellado", unidad: "L" },
  { id: "salida", titulo: "Salida de bodega", unidad: "L" },
];
const OPCIONES_TIPO_CONTENEDOR = [
  "Siempre lleno",
  "Cerrado",
  "Mastelone",
  "√Ånfora",
  "Foudre",
  "Barrica",
  "Damajuana",
];
const OPCIONES_MATERIAL_CONTENEDOR = [
  "Inox",
  "Fibra de vidrio",
  "Cemento",
  "Barro",
  "Madera",
  "Cristal",
  "Pl√°stico alimentario",
];

function poblarSelectOpciones(selectId, opciones, placeholder = "Selecciona") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    select.appendChild(placeholderOption);
  }
  opciones.forEach(op => {
    const option = document.createElement("option");
    option.value = op;
    option.textContent = op;
    select.appendChild(option);
  });
  if (valorActual && opciones.includes(valorActual)) {
    select.value = valorActual;
  }
}

const FLOW_NODE_TYPES = {
  entrada: {
    label: "Entrada de uva",
    icono: "üçá",
    campos: [
      { id: "id_ref", label: "ID existente", tipo: "number", placeholder: "ID en Entradas" },
      { id: "kilos", label: "Kilos", tipo: "number", placeholder: "1000" },
      { id: "variedad", label: "Variedad", tipo: "text", placeholder: "Tempranillo" },
    ],
  },
  fermentacion: {
    label: "Fermentaci√≥n",
    icono: "‚öóÔ∏è",
    campos: [
      {
        id: "estilo",
        label: "Fermentaci√≥n / Elaboraci√≥n",
        tipo: "select",
        opciones: ["FA", "FML"],
        placeholder: "Selecciona tipo",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  estilo: {
    label: "Elaboraci√≥n",
    icono: "‚öóÔ∏è",
    campos: [
      { id: "kilos", label: "Kilos asignados", tipo: "info" },
      {
        id: "metodo",
        label: "M√©todo de elaboraci√≥n",
        tipo: "select",
        opciones: ["Despalillado", "Pisado", "Prensado", "Uva entera", "Mixto", "Sangrado"],
      },
      { id: "descripcion", label: "Descripci√≥n de elaboraci√≥n", tipo: "textarea", placeholder: "Detalles adicionales" },
    ],
  },
  deposito: {
    label: "Dep√≥sito",
    icono: "üõ¢Ô∏è",
    campos: [
      { id: "id_ref", label: "Nombre de dep√≥sito", tipo: "number", placeholder: "Selecciona dep√≥sito" },
      { id: "capacidad", label: "Capacidad (L)", tipo: "info" },
      { id: "volumen", label: "Volumen (L)", tipo: "info" },
      { id: "tipo", label: "Tipo", tipo: "info" },
      { id: "material", label: "Material", tipo: "info" },
      {
        id: "fase",
        label: "Estado",
        tipo: "select",
        opciones: ["FA", "FML", "CRIANZA"],
        placeholder: "Selecciona estado",
      },
      { id: "control", label: "Control", tipo: "tablaControl" },
    ],
  },
  coupage: {
    label: "Coupage / Blend",
    icono: "üç∑",
    campos: [
      { id: "nombre_blend", label: "Nombre del coupage/vino", tipo: "text", placeholder: "Coupage Tempranillo-Malvar" },
      { id: "litros_blend", label: "Litros totales del blend", tipo: "info" },
      { id: "descripcion", label: "Notas del blend", tipo: "textarea", placeholder: "Proporciones, estilo..." },
    ],
  },
  barrica: {
    label: "Crianza",
    icono: '<img src="/barricas.png" alt="Barrica" style="width:26px;height:26px;object-fit:contain;vertical-align:middle;">',
    campos: [
      { id: "nombre_vino", label: "Nombre vino", tipo: "text", placeholder: "Nombre del vino en crianza" },
      {
        id: "contenedor_id",
        label: "Contenedor asignado",
        tipo: "select",
        opciones: [],
        placeholder: "Selecciona contenedor",
      },
      { id: "tipo", label: "Tipo de contenedor", tipo: "text", placeholder: "Roble franc√©s 225L o Dep√≥sito mixto" },
      { id: "tiempo", label: "Tiempo previsto", tipo: "date", placeholder: "" },
      { id: "tiempo_estimado", label: "Duraci√≥n estimada", tipo: "info" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Batonnage mensual" },
    ],
  },
  embotellado: {
    label: "Embotellado",
    icono: "üçæ",
    campos: [
      {
        id: "botella",
        label: "Tipo de botella",
        tipo: "select",
        opciones: [
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgo√±a 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
      { id: "filtrado", label: "Filtrado", tipo: "text", placeholder: "Tierra blanca" },
      {
        id: "cierre",
        label: "Tipo de cierre",
        tipo: "select",
        opciones: [
          "Corcho natural",
          "Corcho t√©cnico",
          "Corcho aglomerado",
          "Tap√≥n sint√©tico",
          "Stelvin / Screw-cap",
          "Corona",
          "Vidrio Vinolok",
          "Tapa de rosca",
        ],
        placeholder: "Selecciona cierre",
      },
      { id: "botellas_resultantes", label: "Botellas resultantes", tipo: "info" },
    ],
  },
  almacen: {
    label: "Almac√©n",
    icono: "üì¶",
    campos: [
      { id: "condicion", label: "Condici√≥n de guarda", tipo: "text", placeholder: "Horizontal, 15 ¬∫C" },
      { id: "fecha", label: "Fecha de entrada", tipo: "date", placeholder: "" },
    ],
  },
  salida: {
    label: "Salida de bodega",
    icono: "üöõ",
    campos: [
      { id: "destino", label: "Destino", tipo: "text", placeholder: "Cliente / Pa√≠s" },
      { id: "transporte", label: "Cantidad de salida (botellas)", tipo: "text", placeholder: "Palet / Caja / Botella" },
      {
        id: "formato_botella",
        label: "Formato de botella",
        tipo: "select",
        opciones: [
          "Split 0,187 L",
          "Demi 0,375 L",
          "Borgo√±a 0,75 L",
          "Bordelesa 0,75 L",
          "Magnum 1,5 L",
          "Doble Magnum 3 L",
          "Jeroboam 3 L",
          "Rehoboam 4,5 L",
          "Methuselah 6 L",
          "Salmanazar 9 L",
          "Balthazar 12 L",
          "Nebuchadnezzar 15 L",
        ],
        placeholder: "Selecciona formato",
      },
    ],
  },
  prensado: {
    label: "Prensado",
    icono: "üåÄ",
    campos: [
      { id: "merma", label: "Merma (%)", tipo: "number", placeholder: "30" },
      { id: "presion", label: "Presi√≥n", tipo: "text", placeholder: "0.8 bar" },
      { id: "notas", label: "Notas", tipo: "textarea", placeholder: "Observaciones" },
    ],
  },
};
Object.keys(FLOW_NODE_TYPES).forEach(key => {
  const tipo = FLOW_NODE_TYPES[key];
  tipo.campos = tipo.campos || [];
  const ids = new Set(tipo.campos.map(c => c.id));
  const esEntrada = key === "entrada";
  const asegurarCampo = (id, campo) => {
    if (!ids.has(id)) {
      tipo.campos.unshift({ id, ...campo });
      ids.add(id);
    }
  };
  asegurarCampo("fecha", {
    label: "Fecha de entrada",
    tipo: "info",
    soloLectura: true,
  });
  asegurarCampo("variedad", {
    label: "Variedad de uva",
    tipo: "text",
    placeholder: "Tempranillo",
    soloLectura: !esEntrada,
  });
  if (key !== "deposito" && key !== "entrada") {
    asegurarCampo("merma", {
      label: "Merma / p√©rdida (%)",
      tipo: "number",
      placeholder: "0",
    });
  }
  if (key !== "entrada") {
    asegurarCampo("fecha_operacion", {
      label: "Fecha operaci√≥n",
      tipo: "date",
      placeholder: "",
    });
  }
});
let datosEtapasFlujo = {};
let flujoNodos = [];
let nodoConectandoOrigen = null;
let nodoEnEdicion = null;
let dragEstado = null;
let ultimoNodoManual = null;
let filtrosMovimientos = {
  tipo: "",
  desde: "",
  hasta: "",
  contenedor: "",
  contenedor_tipo: "",
};
let filtroAnalisisDeposito = null;

function mostrarAviso(mensaje, tipo = "info") {
  const contenedor = document.getElementById("appAlerts");
  if (!contenedor) return;
  const toast = document.createElement("div");
  toast.className = `toast ${tipo}`;
  toast.textContent = mensaje;
  contenedor.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateX(20px)";
  }, 3500);
  setTimeout(() => toast.remove(), 4200);
}

function mostrarSkeletonTabla(tbodyId, columnas, filas = 3) {
  const tbody = document.getElementById(tbodyId);
  if (!tbody) return;
  const celda = '<td><div class="skeleton-line"></div></td>';
  const fila = `<tr>${celda.repeat(columnas)}</tr>`;
  tbody.innerHTML = new Array(filas).fill(fila).join("");
}

function setFormFeedback(id, mensaje, tipo = "info") {
  const elemento = document.getElementById(id);
  if (!elemento) return;
  elemento.textContent = mensaje || "";
  elemento.className = `form-feedback ${tipo === "error" ? "error" : tipo === "success" ? "success" : ""}`;
}

function obtenerAnadaDesdeFecha(fechaStr) {
  if (!fechaStr) return "";
  const match = fechaStr.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function obtenerValorAnada(valor) {
  if (!valor) return "Sin a√±ada";
  return valor.toString();
}

function coincideConFiltros(anadaVal, vinoVal, filtros) {
  const anadaComparar = obtenerValorAnada(anadaVal);
  const vinoComparar = (vinoVal || "").trim() || "Sin clasificar";
  const okAnada = filtros.anada === "todos" || filtros.anada === anadaComparar;
  const okVino = filtros.vino === "todos" || vinoComparar === filtros.vino;
  return okAnada && okVino;
}

function obtenerInfoContenedor(tipo, id) {
  if (tipo === "deposito") {
    return mapaDepositosPorId && mapaDepositosPorId.get(id);
  }
  if (tipo === "mastelone") {
    return mapaMastelonesPorId && mapaMastelonesPorId.get(id);
  }
  if (tipo === "barrica") {
    return mapaBarricasPorId && mapaBarricasPorId.get(id);
  }
  return null;
}

function obtenerCapacidadFormateada(info) {
  if (!info) return "";
  const capacidad =
    info.capacidad_l != null
      ? Number(info.capacidad_l)
      : info.capacidad_hl != null
      ? Number(info.capacidad_hl) * 100
      : null;
  if (!Number.isFinite(capacidad) || capacidad <= 0) return "";
  return capacidad % 1 === 0 ? `${capacidad.toFixed(0)}L` : `${capacidad.toFixed(2)}L`;
}

function describirContenedor(info, tipoLabel) {
  const partes = [];
  if (tipoLabel) partes.push(tipoLabel);
  if (info) {
    const cap = obtenerCapacidadFormateada(info);
    if (cap) partes.push(cap);
    const material =
      info.material ||
      info.tipo_roble ||
      info.tipo ||
      info.marca ||
      info.clase ||
      "";
    if (material) partes.push(material);
  }
  return partes.join(" ").trim();
}

function parsearFechaValor(valor) {
  if (!valor) return null;
  let base = valor.trim();
  if (!base) return null;
  if (base.includes("/")) {
    const partes = base.split("/");
    if (partes.length === 3) {
      // dd/mm/yyyy -> yyyy-mm-dd
      base = `${partes[2]}-${partes[1].padStart(2, "0")}-${partes[0].padStart(2, "0")}`;
    }
  }
  const fecha = new Date(base);
  return isNaN(fecha.getTime()) ? null : fecha;
}

function calcularMesesEntre(fechaInicio, fechaFin) {
  const inicio = parsearFechaValor(fechaInicio);
  const fin = parsearFechaValor(fechaFin);
  if (!inicio || !fin) return null;
  let meses = (fin.getFullYear() - inicio.getFullYear()) * 12 + (fin.getMonth() - inicio.getMonth());
  if (fin.getDate() < inicio.getDate()) {
    meses -= 1;
  }
  if (meses < 0) meses = 0;
  return meses;
}

function actualizarDuracionPrevista(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  const inicio = nodo.datos?.fecha_operacion || nodo.datos?.fecha;
  const fin = nodo.datos?.tiempo;
  if (!inicio || !fin) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  const meses = calcularMesesEntre(inicio, fin);
  if (meses == null) {
    nodo.datos.tiempo_estimado = "";
    return;
  }
  nodo.datos.tiempo_estimado = meses === 1 ? "1 mes" : `${meses} meses`;
}

function refrescarDuracionModal(nodo) {
  if (!nodo || nodo.tipo !== "barrica") return;
  actualizarDuracionPrevista(nodo);
  const display = document.getElementById("flowField-tiempo_estimado-display");
  if (display) {
    display.textContent = nodo.datos?.tiempo_estimado || "‚Äî";
  }
  const hidden = document.getElementById("flowField-tiempo_estimado");
  if (hidden) {
    hidden.value = nodo.datos?.tiempo_estimado || "";
  }
}

function obtenerVinosEntrada(entrada) {
  const vinos = new Set();
  if (Array.isArray(entrada.destinos)) {
    entrada.destinos.forEach(dest => {
      const info = obtenerInfoContenedor(dest.contenedor_tipo, dest.contenedor_id);
      if (info && info.vino_tipo) {
        vinos.add(info.vino_tipo);
      }
    });
  }
  if (!vinos.size && entrada.variedad) {
    vinos.add(entrada.variedad);
  }
  return vinos;
}

function calcularDatosMapaFlujo() {
  const resultado = {
    entrada: { valor: 0, detalle: "" },
    despalillado: { valor: 0, detalle: "" },
    deposito: { valor: 0, detalle: "" },
    barrica: { valor: 0, detalle: "" },
    embotellado: { valor: 0, detalle: "" },
    salida: { valor: 0, detalle: "" },
  };

  const entradas = cacheEntradas || [];
  resultado.entrada.valor = entradas.reduce((acc, e) => acc + (Number(e.kilos) || 0), 0);
  resultado.entrada.detalle = `${entradas.length} entradas registradas`;

  let litrosDesp = 0;
  entradas.forEach(entrada => {
    if (Array.isArray(entrada.destinos) && entrada.destinos.length) {
      entrada.destinos.forEach(dest => {
        const kilos = Number(dest.kilos) || 0;
        if (dest.directo_prensa) {
          const merma = dest.merma_factor != null ? Number(dest.merma_factor) : FACTOR_MERMA_PRENSA;
          litrosDesp += kilos * (1 - merma);
        } else {
          litrosDesp += kilos;
        }
      });
    } else {
      litrosDesp += Number(entrada.kilos) || 0;
    }
  });
  resultado.despalillado.valor = litrosDesp;
  resultado.despalillado.detalle = "Estimaci√≥n tras despalillado / prensado";

  const depositos = (cacheDepositos || []).concat(cacheMastelones || []);
  resultado.deposito.valor = depositos.reduce((acc, d) => acc + (Number(d.litros_actuales) || 0), 0);
  resultado.deposito.detalle = `${depositos.length} dep√≥sitos / mastelones`;

  const barricas = cacheBarricas || [];
  resultado.barrica.valor = barricas.reduce((acc, b) => acc + (Number(b.litros_actuales) || 0), 0);
  resultado.barrica.detalle = `${barricas.length} barricas activas`;

  const embotellados = cacheEmbotellados || [];
  resultado.embotellado.valor = embotellados.reduce((acc, e) => acc + (Number(e.litros) || 0), 0);
  resultado.embotellado.detalle = `${embotellados.length} lotes embotellados`;

  const salidas = (cacheMovimientos || []).filter(m => {
    const tipo = (m.tipo || "").toLowerCase();
    return tipo === "venta" || tipo === "salida" || tipo === "expedicion" || m.destino_tipo === "venta";
  });
  resultado.salida.valor = salidas.reduce((acc, m) => acc + (Number(m.litros) || 0), 0);
  resultado.salida.detalle = `${salidas.length} movimientos de salida`;

  return resultado;
}

function actualizarMapaFlujo() {
  datosEtapasFlujo = calcularDatosMapaFlujo();
}

function exportarNodosComoImagen() {
  const canvas = document.getElementById("flowCanvas");
  if (!canvas) return;
  const svg = document.getElementById("flowConnections");
  const ventana = window.open("", "printNodes");
  ventana.document.write("<html><head><title>Mapa de nodos</title><style>body{font-family:Arial,sans-serif;padding:20px;}</style></head><body>");
  ventana.document.write("<h2>Mapa de nodos</h2>");
  ventana.document.write(svg.outerHTML);
  ventana.document.write(canvas.innerHTML);
  ventana.document.write("</body></html>");
  ventana.document.close();
  ventana.focus();
  ventana.print();
  ventana.close();
}

async function inicializarFlowEditor() {
  await cargarNodosGuardados();
  renderFlowNodes();
  const canvas = document.getElementById("flowCanvas");
  if (canvas) {
    canvas.addEventListener("click", () => cancelarConexionEnCurso());
  }
  window.addEventListener("resize", renderFlowConnections);
}

function generarIdNodo() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `nodo-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
}

function crearNodoManual(tipo) {
  const config = FLOW_NODE_TYPES[tipo];
  if (!config) return;
  const nodo = {
    id: generarIdNodo(),
    tipo,
    titulo: config.label,
    x: 60 + flujoNodos.length * 40,
    y: 60 + flujoNodos.length * 20,
    datos: {},
    targets: [],
  };
  actualizarTituloNodo(nodo);
  asegurarMermaPorDefecto(nodo);
  flujoNodos.push(nodo);
  ultimoNodoManual = nodo.id;
  guardarEstadoNodos();
  renderFlowNodes();
  abrirFlowModal(nodo.id);
}

async function sembrarNodosDesdeDatos() {
  // Refrescar datos antes de sembrar
  await Promise.all([cargarResumen(), cargarDepositos(), cargarBarricas(), cargarEntradas(), cargarMovimientos()]);
  actualizarMapaFlujo();
  flujoNodos = ETAPAS_FLUJO.map((etapa, idx) => {
    const nodo = {
      id: generarIdNodo(),
      tipo:
        etapa.id === "despalillado"
          ? "estilo"
          : etapa.id === "barrica"
          ? "barrica"
          : etapa.id === "embotellado"
          ? "embotellado"
          : etapa.id === "salida"
          ? "salida"
          : etapa.id === "entrada"
          ? "entrada"
          : "deposito",
      titulo: etapa.titulo,
      x: 80 + idx * 180,
      y: 120 + (idx % 2) * 120,
      datos: {
        resumen: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].detalle
          : "",
        valor: datosEtapasFlujo[etapa.id]
          ? datosEtapasFlujo[etapa.id].valor.toLocaleString("es-ES", { maximumFractionDigits: 1 })
          : "0",
      },
      targets: [],
    };
    actualizarTituloNodo(nodo);
    asegurarMermaPorDefecto(nodo);
    return nodo;
  });
  for (let i = 0; i < flujoNodos.length - 1; i++) {
    flujoNodos[i].targets.push(flujoNodos[i + 1].id);
  }
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  guardarEstadoNodos();
  renderFlowNodes();
}

function renderFlowNodes() {
  const canvas = document.getElementById("flowCanvas");
  if (!canvas) return;
  canvas.innerHTML = "";
  flujoNodos.forEach(nodo => {
    if (nodo.tipo === "deposito") {
      rellenarDatosDepositoDesdeCache(nodo);
      actualizarTituloNodo(nodo);
    }
    const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo" };
    const div = document.createElement("div");
    div.className = "flow-node";
    div.style.left = `${nodo.x}px`;
    div.style.top = `${nodo.y}px`;
    div.dataset.id = nodo.id;

    const headerWrap = document.createElement("div");
    headerWrap.style.display = "flex";
    headerWrap.style.alignItems = "center";
    headerWrap.style.gap = "6px";
    const icon = document.createElement("span");
    icon.className = "flow-node-icon";
    if (config.icono && config.icono.trim().startsWith("<")) {
      icon.innerHTML = config.icono;
    } else {
      icon.textContent = config.icono || "‚óè";
    }
    headerWrap.appendChild(icon);
    const header = document.createElement("h4");
    header.textContent = nodo.titulo || config.label;
    headerWrap.appendChild(header);
    div.appendChild(headerWrap);

    const unidadBadge = document.createElement("div");
    unidadBadge.className = "flow-unit";
    unidadBadge.textContent = obtenerUnidadVisual(nodo);
    div.appendChild(unidadBadge);

    const variedadVisible = obtenerVariedadVisibleNodo(nodo);
    if (variedadVisible) {
      const subtitleVar = document.createElement("div");
      subtitleVar.className = "flow-node-subtitle";
      subtitleVar.textContent = variedadVisible;
      subtitleVar.style.whiteSpace = "pre-line";
      div.appendChild(subtitleVar);
    }
    if (nodo.tipo === "estilo" && nodo.datos?.metodo) {
      const metodoSubtitle = document.createElement("div");
      metodoSubtitle.className = "flow-node-subtitle";
      metodoSubtitle.textContent = nodo.datos.metodo;
      metodoSubtitle.style.fontSize = "11px";
      metodoSubtitle.style.opacity = "0.8";
      div.appendChild(metodoSubtitle);
    }
    const controls = document.createElement("div");
    controls.className = "flow-node-controls";
    const btnEditar = document.createElement("button");
    btnEditar.className = "blue";
    btnEditar.title = "Editar";
    btnEditar.addEventListener("pointerdown", e => e.stopPropagation());
    btnEditar.addEventListener("click", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });
    const btnConectar = document.createElement("button");
    btnConectar.className = `green ${nodoConectandoOrigen === nodo.id ? "conectando" : ""}`;
    btnConectar.title = "Conectar";
    if (nodoConectandoOrigen === nodo.id) {
      btnConectar.classList.add("conectando");
    }
    btnConectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnConectar.addEventListener("click", e => {
      e.stopPropagation();
      prepararConexion(nodo.id);
    });
    const btnDesconectar = document.createElement("button");
    btnDesconectar.className = "red";
    btnDesconectar.title = "Desconectar";
    btnDesconectar.addEventListener("pointerdown", e => e.stopPropagation());
    btnDesconectar.addEventListener("click", e => {
      e.stopPropagation();
      if (!nodo._clickDesconectar) {
        desconectarNodo(nodo.id);
        nodo._clickDesconectar = Date.now();
        mostrarAviso("Pulsa de nuevo r√°pidamente para eliminar el nodo.", "info");
        setTimeout(() => {
          if (nodo._clickDesconectar && Date.now() - nodo._clickDesconectar > 800) {
            delete nodo._clickDesconectar;
          }
        }, 900);
      } else if (Date.now() - nodo._clickDesconectar < 800) {
        delete nodo._clickDesconectar;
        eliminarNodoPorId(nodo.id);
      } else {
        nodo._clickDesconectar = Date.now();
      }
    });
    controls.appendChild(btnEditar);
    controls.appendChild(btnConectar);
    controls.appendChild(btnDesconectar);
    div.appendChild(controls);

    div.addEventListener("pointerdown", e => iniciarArrastreNodo(e, nodo.id));
    div.addEventListener("click", () => {
      if (dragEstado && dragEstado.activo) return;
      if (nodoConectandoOrigen && nodoConectandoOrigen !== nodo.id) {
        conectarNodos(nodoConectandoOrigen, nodo.id);
        nodoConectandoOrigen = null;
        renderFlowNodes();
      } else {
        mostrarInfoNodo(nodo.id);
      }
    });
    div.addEventListener("dblclick", e => {
      e.stopPropagation();
      abrirFlowModal(nodo.id);
    });
    canvas.appendChild(div);
  });
  renderFlowConnections();
}

function resumenNodo(nodo) {
  const datos = nodo.datos || {};
  if (datos.resumen) return datos.resumen;
  const keys = Object.keys(datos).filter(k => datos[k]);
  if (!keys.length) return "Doble clic para detallar";
  return keys
    .slice(0, 2)
    .map(k => `${k}: ${datos[k]}`)
    .join(" ¬∑ ");
}

function renderFlowConnections() {
  const svg = document.getElementById("flowConnections");
  const canvas = document.getElementById("flowCanvas");
  const layer = document.getElementById("flowConnectionsLayer");
  if (!svg || !canvas) return;
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  const targetLayer = layer || svg;
  if (layer) {
    layer.innerHTML = "";
  } else {
    svg.innerHTML = "";
  }
  const nodosDom = new Map();
  canvas.querySelectorAll(".flow-node").forEach(nodeEl => {
    nodosDom.set(nodeEl.dataset.id, nodeEl);
  });

  flujoNodos.forEach(nodo => {
    const origenEl = nodosDom.get(nodo.id);
    if (!origenEl) return;
    const x1 = nodo.x + origenEl.offsetWidth / 2;
    const y1 = nodo.y + origenEl.offsetHeight / 2;
    (nodo.targets || []).forEach(targetId => {
      const destinoEl = nodosDom.get(targetId);
      if (!destinoEl) return;
      const destinoNodo = flujoNodos.find(n => n.id === targetId);
      if (!destinoNodo) return;
      const x2 = destinoNodo.x + destinoEl.offsetWidth / 2;
      const y2 = destinoNodo.y + destinoEl.offsetHeight / 2;
      const curva = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const delta = Math.max(Math.abs(x2 - x1) / 2, 60);
      const d = `M${x1} ${y1} C ${x1 + delta} ${y1}, ${x2 - delta} ${y2}, ${x2} ${y2}`;
      curva.setAttribute("d", d);
      curva.setAttribute("class", "flow-connector-line");
      (layer || svg).appendChild(curva);
    });
  });
}

function iniciarArrastreNodo(ev, nodoId) {
  const nodo = flujoNodos.find(n => n.id === nodoId);
  if (!nodo) return;
  const editor = document.getElementById("flowEditor");
  const canvas = document.getElementById("flowCanvas");
  const editorRect = editor.getBoundingClientRect();
  const posX = ev.clientX - editorRect.left + editor.scrollLeft;
  const posY = ev.clientY - editorRect.top + editor.scrollTop;
  dragEstado = {
    id: nodoId,
    offsetX: posX - nodo.x,
    offsetY: posY - nodo.y,
    startX: ev.clientX,
    startY: ev.clientY,
    activo: false,
    elemento: ev.currentTarget,
    editor,
  };
  ev.currentTarget.classList.add("dragging");
  ev.currentTarget.setPointerCapture(ev.pointerId);
  ev.currentTarget.addEventListener("pointermove", moverNodoArrastre);
  ev.currentTarget.addEventListener("pointerup", finalizarArrastreNodo);
  ev.currentTarget.addEventListener("pointercancel", finalizarArrastreNodo);
}

function moverNodoArrastre(ev) {
  if (!dragEstado) return;
  const nodo = flujoNodos.find(n => n.id === dragEstado.id);
  if (!nodo) return;
  const canvas = document.getElementById("flowCanvas");
  const editor = dragEstado.editor || document.getElementById("flowEditor");
  const editorRect = editor.getBoundingClientRect();
  const dx = ev.clientX - dragEstado.startX;
  const dy = ev.clientY - dragEstado.startY;
  if (!dragEstado.activo) {
    if (Math.abs(dx) + Math.abs(dy) < 4) {
      return;
    }
    dragEstado.activo = true;
  }
  const nodoWidth = dragEstado.elemento ? dragEstado.elemento.offsetWidth : 120;
  const nodoHeight = dragEstado.elemento ? dragEstado.elemento.offsetHeight : 70;
  const posX = ev.clientX - editorRect.left + editor.scrollLeft;
  const posY = ev.clientY - editorRect.top + editor.scrollTop;
  const maxX = Math.max(0, canvas.offsetWidth - nodoWidth - 10);
  const maxY = Math.max(0, canvas.offsetHeight - nodoHeight - 10);
  nodo.x = Math.min(Math.max(posX - dragEstado.offsetX, 10), maxX);
  nodo.y = Math.min(Math.max(posY - dragEstado.offsetY, 10), maxY);
  if (dragEstado.elemento) {
    dragEstado.elemento.style.left = `${nodo.x}px`;
    dragEstado.elemento.style.top = `${nodo.y}px`;
  }
  renderFlowConnections();
}

function finalizarArrastreNodo(ev) {
  if (ev.currentTarget) {
    ev.currentTarget.classList.remove("dragging");
    ev.currentTarget.removeEventListener("pointermove", moverNodoArrastre);
    ev.currentTarget.removeEventListener("pointerup", finalizarArrastreNodo);
    ev.currentTarget.removeEventListener("pointercancel", finalizarArrastreNodo);
  }
  if (dragEstado && dragEstado.activo) {
    guardarEstadoNodos();
  }
  dragEstado = null;
}

function prepararConexion(id) {
  if (nodoConectandoOrigen === id) {
    nodoConectandoOrigen = null;
  } else if (!nodoConectandoOrigen) {
    nodoConectandoOrigen = id;
  } else {
    conectarNodos(nodoConectandoOrigen, id);
    nodoConectandoOrigen = null;
  }
  renderFlowNodes();
}

function cancelarConexionEnCurso() {
  if (nodoConectandoOrigen) {
    nodoConectandoOrigen = null;
    renderFlowNodes();
    mostrarAviso("Conexi√≥n cancelada.", "info");
  }
}

function conectarNodos(origenId, destinoId, silencioso = false) {
  if (origenId === destinoId) return;
  const origen = flujoNodos.find(n => n.id === origenId);
  const destino = flujoNodos.find(n => n.id === destinoId);
  if (!origen) return;
  if (destino && esNodoPrensado(destino) && obtenerUnidadNodo(origen) === "litros") {
    mostrarAviso("No puedes enviar litros a un nodo de prensado/sangrado. La conversi√≥n ya se realiz√≥ antes.", "error");
    return;
  }
  origen.targets = origen.targets || [];
  if (!origen.targets.includes(destinoId)) {
    const snapshot = JSON.parse(JSON.stringify(flujoNodos));
    origen.targets.push(destinoId);
    if (origen.tipo === "estilo") {
      origen.datos = origen.datos || {};
      origen.datos.distribucion = origen.datos.distribucion || {};
      const key = destinoId.toString();
      if (!origen.datos.distribucion[key]) {
        origen.datos.distribucion[key] = { kilos: 0, litros: 0 };
      }
    }
    if (destino) {
      sembrarDatosIniciales(origen, destino);
    }
    redistribuirCargas(origen);
    const validacion = validarLimitesFlujo();
    if (!validacion.ok) {
      flujoNodos = snapshot;
      renderFlowNodes();
      const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
      const unidad = validacion.unidad || "u.";
      mostrarAviso(
        `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}.`,
        "error"
      );
      return;
    }
    guardarEstadoNodos();
    renderFlowNodes();
    if (!silencioso) {
      mostrarAviso("Nodos conectados.", "success");
    }
  }
}

function completarCargaVisual(carga) {
  if (!carga) return null;
  if (carga.litros == null && carga.litros_directos != null) {
    const litrosDirectos = normalizarNumero(carga.litros_directos);
    if (litrosDirectos > 0) {
      carga.litros = Number(litrosDirectos.toFixed(4));
    }
  }
  return carga;
}

function obtenerLitrosDesdePredecesores(nodo) {
  if (!nodo) return 0;
  const padres = obtenerPredecesores(nodo.id);
  return padres.reduce((acc, pre) => {
    const carga = obtenerCargaDesdeNodo(pre);
    const litros = normalizarNumero(
      carga?.litros_directos != null ? carga.litros_directos : carga?.litros
    );
    return acc + (Number.isFinite(litros) ? litros : 0);
  }, 0);
}

function actualizarBotellasResultantes(nodo) {
  if (!nodo || nodo.tipo !== "embotellado") return;
  const selectBotella = document.getElementById("flowField-botella");
  const display = document.getElementById("flowField-botellas_resultantes-display");
  const hidden = document.getElementById("flowField-botellas_resultantes");
  if (!selectBotella || !display || !hidden) return;
  const litrosDisponibles = obtenerLitrosDesdePredecesores(nodo);
  const volBotella = VOLUMEN_BOTELLA_L[selectBotella.value] || 0;
  const botellas = volBotella > 0 ? Math.floor(litrosDisponibles / volBotella) : 0;
  display.textContent = botellas ? `${botellas} uds (${litrosDisponibles.toFixed(2)} L disponibles)` : "‚Äî";
  hidden.value = botellas;
}

async function asegurarJsPDF() {
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  const cargar = src =>
    new Promise(resolve => {
      const script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.onload = resolve;
      script.onerror = resolve;
      document.head.appendChild(script);
    });
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
  await cargar("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js");
  return window.jspdf && window.jspdf.jsPDF ? window.jspdf.jsPDF : null;
}

async function exportarTablaControlPDF(nodo) {
  try {
    const jsPDF = await asegurarJsPDF();
    if (!jsPDF) {
      alert("No se pudo generar el PDF (jsPDF no se carg√≥). Usa Imprimir como PDF.");
      return;
    }
    const doc = new jsPDF();
    const anada =
      nodo.datos?.anada ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha) ||
      obtenerAnadaDesdeFecha(nodo.datos?.fecha_operacion) ||
      "";
    const titulo = `Control anal√≠tico de ${nodo.titulo || "Dep√≥sito"}${anada ? " ¬∑ a√±ada " + anada : ""}`;
    doc.setFontSize(14);
    doc.text(titulo, 14, 18);
    doc.setFontSize(11);

    const depInfo = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const variedad = depInfo?.vino_tipo || nodo.datos?.variedad || nodo.datos?.vino || "";
    const tipoDep = depInfo?.tipo || nodo.datos?.tipo || "Dep√≥sito";
    const capacidadRaw =
      depInfo?.capacidad_l ??
      (depInfo?.capacidad_hl != null ? depInfo.capacidad_hl * 100 : nodo.datos?.capacidad);
    const capacidad = Number.isFinite(capacidadRaw) ? `${Number(capacidadRaw).toFixed(2)} L` : "‚Äî";
    const volumenRaw =
      nodo.datos?.volumen ??
      nodo.datos?.litros ??
      nodo.datos?.litros_directos ??
      depInfo?.litros_actuales;
    const volumen = Number.isFinite(Number(volumenRaw))
      ? `${Number(volumenRaw).toFixed(2)} L`
      : "‚Äî";

    const infoLines = [
      `Variedad de uva: ${variedad || "‚Äî"}`,
      `Tipo de dep√≥sito: ${tipoDep || "‚Äî"}`,
      `Capacidad dep√≥sito: ${capacidad}`,
      `Volumen uva/vino: ${volumen}`,
    ];
    doc.setFontSize(10);
    infoLines.forEach((linea, idx) => {
      doc.text(linea, 14, 24 + idx * 6);
    });

    const startYTable = 24 + infoLines.length * 6 + 6;

    const formatearFechaCorta = fechaStr => {
      if (!fechaStr) return "";
      const d = new Date(fechaStr);
      if (isNaN(d.getTime())) return fechaStr;
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    };

    const filas = (nodo.datos?.control || []).map(reg => [
      formatearFechaCorta(reg.fecha),
      reg.densidad || "",
      reg.temperatura || "",
      reg.productos || "",
    ]);
    const body = filas.length ? filas : [["", "", "", ""]];
    const headers = [["Fecha", "Densidad", "¬∞C", "Productos"]];
    const autoTable = (window.jspdf && window.jspdf.autoTable) || (doc && doc.autoTable);
    if (autoTable) {
      (window.jspdf && window.jspdf.autoTable ? window.jspdf.autoTable : doc.autoTable).call(doc, {
        head: headers,
        body,
        startY: startYTable,
        styles: { fontSize: 11, cellPadding: 4 },
        headStyles: { fillColor: [60, 0, 90], textColor: 255 },
        alternateRowStyles: { fillColor: [245, 240, 248] },
      });
    } else {
      let y = startYTable;
      doc.text(headers[0].join(" | "), 14, y);
      y += 8;
      body.forEach(row => {
        doc.text(row.join(" | "), 14, y);
        y += 8;
      });
    }
    const nombreArchivo = `control-${(nodo.titulo || "deposito").toString().replace(/\s+/g, "-")}.pdf`;
    doc.save(nombreArchivo);
  } catch (err) {
    console.error("Error generando PDF de control:", err);
    alert("No se pudo generar el PDF.");
  }
}

function escalarCarga(cargaBase, factor) {
  if (!cargaBase || !Number.isFinite(factor)) return null;
  const carga = { ...cargaBase };
  if (carga.kilos != null) carga.kilos = Number((carga.kilos * factor).toFixed(4));
  if (carga.litros_directos != null) {
    carga.litros_directos = Number((carga.litros_directos * factor).toFixed(4));
  }
  if (carga.litros != null) {
    carga.litros = Number((carga.litros * factor).toFixed(4));
  }
  return completarCargaVisual(carga);
}

function prepararCargaParaDestino(origen, destino, cargaBase, totalDestinos) {
  if (!origen || !destino || !cargaBase) return null;
  const origenKey = normalizarIdNodo(origen);
  let carga = null;
  if (origen.tipo === "estilo") {
    carga = obtenerCargaDistribuida(origen, destino.id, cargaBase);
  }
  if (carga) {
    return completarCargaVisual(carga);
  }
  if (destino.tipo === "deposito") {
    const kilosBase = normalizarNumero(cargaBase.kilos);
    const litrosBase = normalizarNumero(
      cargaBase.litros_directos != null ? cargaBase.litros_directos : cargaBase.litros
    );
    const registro = asegurarAsignacionRegistro(
      destino,
      origen.id,
      kilosBase > 0 ? kilosBase : 0,
      litrosBase > 0 ? litrosBase : 0
    );
    const kilos = normalizarNumero(registro.kilos);
    const litros = normalizarNumero(registro.litros);
    const tieneCarga = (kilos > 0) || (litros > 0);
    const carga = { ...cargaBase };
    if (!tieneCarga) {
      carga.kilos = 0;
      carga.litros_directos = 0;
      return completarCargaVisual(carga);
    }
    carga.kilos = kilos > 0 ? kilos : 0;
    carga.litros_directos = litros > 0 ? litros : 0;
    return completarCargaVisual(carga);
  }
  const registro = destino.datos?.asignaciones?.[origenKey];
  if (registro) {
    const kilos = normalizarNumero(registro.kilos);
    const litros = normalizarNumero(registro.litros);
    const carga = { ...cargaBase };
    if (kilos >= 0) carga.kilos = Number.isFinite(kilos) ? kilos : undefined;
    if (litros >= 0) carga.litros_directos = Number.isFinite(litros) ? litros : undefined;
    return completarCargaVisual(carga);
  }

  // Reparto autom√°tico: dividir entre destinos si el origen tiene varias salidas
  if (totalDestinos <= 1) {
    return { ...cargaBase };
  }
  const cargaDividida = escalarCarga(cargaBase, 1 / totalDestinos);
  return cargaDividida;
}

function redistribuirCargas(origen, visitados = new Set()) {
  if (!origen || visitados.has(origen.id)) return;
  visitados.add(origen.id);
  const targets = (origen.targets || [])
    .map(id => flujoNodos.find(n => n.id === id))
    .filter(Boolean);
  if (!targets.length) {
    visitados.delete(origen.id);
    return;
  }
  const cargaBase = obtenerCargaDesdeNodo(origen);
  if (!cargaBase) {
    visitados.delete(origen.id);
    return;
  }
  // Repartir autom√°ticamente la carga entre todos los destinos (sin remanente)
  if (targets.length > 1) {
    const shareKilos =
      cargaBase.kilos != null ? Number((Number(cargaBase.kilos) / targets.length).toFixed(4)) : null;
    const baseLitros =
      cargaBase.litros_directos != null
        ? Number(cargaBase.litros_directos)
        : cargaBase.litros != null
        ? Number(cargaBase.litros)
        : null;
    const shareLitros = baseLitros != null ? Number((baseLitros / targets.length).toFixed(4)) : null;
    targets.forEach(dest => {
      if (TIPOS_CONTENEDOR_FLUJO.has(dest.tipo)) {
        const registro = asegurarAsignacionRegistro(dest, origen.id);
        if (shareKilos != null) registro.kilos = shareKilos;
        if (shareLitros != null) {
          registro.litros = shareLitros;
        }
      }
    });
  }
  let cargaLibre = { ...cargaBase };
  const totalDestinos = targets.length;
  targets.forEach(dest => {
    const cargaDestino = prepararCargaParaDestino(origen, dest, cargaLibre, totalDestinos);
    if (cargaDestino) {
      const aplicado = manejarTransferenciaNodo(origen, dest, cargaDestino);
      if (origen.tipo === "estilo" && aplicado) {
        const kilosUsados = normalizarNumero(aplicado.kilos) || 0;
        const litrosUsados = normalizarNumero(aplicado.litros_directos ?? aplicado.litros) || 0;
        if (cargaLibre.kilos != null) {
          cargaLibre.kilos = Math.max(0, cargaLibre.kilos - kilosUsados);
        }
        if (cargaLibre.litros_directos != null) {
          cargaLibre.litros_directos = Math.max(0, cargaLibre.litros_directos - litrosUsados);
          cargaLibre.litros = cargaLibre.litros_directos;
        }
      }
    } else if (dest.tipo === "deposito") {
      actualizarVariedadDesdeAportes(dest);
    }
    redistribuirCargas(dest, visitados);
  });
  visitados.delete(origen.id);
}

function manejarTransferenciaNodo(origen, destino, cargaPersonalizada = null) {
  if (!origen || !destino) return;
  origen.datos = origen.datos || {};
  destino.datos = destino.datos || {};
  asegurarMermaPorDefecto(origen);
  asegurarMermaPorDefecto(destino);
  const cargaBase = obtenerCargaDesdeNodo(origen);
  if (!cargaBase) return;
  const unidadOrigen = obtenerUnidadNodo(origen);
  const esCargaManual = cargaPersonalizada?.__manual === true;
  let carga = completarCargaVisual(cargaPersonalizada ? { ...cargaPersonalizada } : { ...cargaBase });

  if (!carga) return;

  const factorMermaOrigen = !esNodoConversor(origen) ? obtenerFactorMermaNodo(origen) : 0;
  if (factorMermaOrigen > 0 && !esCargaManual) {
    carga = aplicarMermaACarga(carga, factorMermaOrigen);
  }

  if (esNodoPrensado(destino)) {
    if (unidadOrigen === "litros") {
      mostrarAviso("Ya est√°s trabajando en litros; no puedes volver a convertir con otro prensado o sangrado.", "error");
      return null;
    }
    const kilosAsignados = normalizarNumero(carga.kilos);
    const litrosDirectosAsignados = normalizarNumero(carga.litros_directos);
    if (!(kilosAsignados > 0 || litrosDirectosAsignados > 0)) {
      return null;
    }
    const factor = obtenerFactorMermaNodo(destino);
    const litrosPrensados = kilosAsignados > 0 ? aplicarMerma(kilosAsignados, factor) : 0;
    const totalSalida = litrosPrensados + (litrosDirectosAsignados > 0 ? litrosDirectosAsignados : 0);
    aplicarCargaANodo(destino, {
      variedad: carga.variedad,
      litros: totalSalida,
      litros_directos: totalSalida,
      kilos: 0,
      parcela: carga.parcela,
      anada: carga.anada,
      fecha: carga.fecha,
    });
    return {
      ...carga,
      kilos: 0,
      litros: totalSalida,
      litros_directos: totalSalida,
    };
  }

  if (esNodoPrensado(origen)) {
    const baseKilos = normalizarNumero(carga.kilos);
    const factor = obtenerFactorMermaNodo(origen);
    const litrosTrasPrensa = baseKilos > 0 ? aplicarMerma(baseKilos, factor) : 0;
    const litrosDirectosPrevios = normalizarNumero(carga.litros_directos);
    const total = litrosTrasPrensa + (litrosDirectosPrevios > 0 ? litrosDirectosPrevios : 0);
    carga.kilos = 0;
    if (total > 0) {
      carga.litros_directos = total;
      carga.litros = total;
      origen.datos.kilos = 0;
      origen.datos.litros_directos = total;
      origen.datos.litros = total;
      origen.datos.volumen = total;
      guardarEstadoNodos();
      mostrarInfoNodo(origen.id);
    }
  }

  // Trasiego: contenedor a contenedor (dep√≥sitos, barricas, almac√©n).
  if (esConexionTrasiego(origen, destino)) {
    const baseTrasiego =
      normalizarNumero(carga.litros) ??
      (normalizarNumero(carga.kilos) ?? normalizarNumero(carga.litros_directos));
    if (baseTrasiego > 0) {
      const litrosTrasiego = aplicarMerma(baseTrasiego, FACTOR_MERMA_TRASIEGO);
      carga.litros = litrosTrasiego;
      carga.litros_directos = litrosTrasiego;
      carga.kilos = carga.kilos && carga.kilos > 0 ? litrosTrasiego : carga.kilos;
    }
  }

  carga = completarCargaVisual(carga);

  aplicarCargaANodo(destino, carga);

  if (destino.tipo === "deposito" && destino.datos.id_ref) {
    actualizarDepositoContenido(destino.datos.id_ref, carga.variedad, carga.litros, carga.anada);
  }
  if (destino.tipo === "deposito") {
    const registro = asegurarAsignacionRegistro(destino, origen.id);
    const litrosFinales =
      normalizarNumero(carga.litros_directos) ??
      normalizarNumero(carga.litros) ??
      0;
    const kilosFinales = normalizarNumero(carga.kilos) ?? 0;
    if (litrosFinales > 0) {
      registro.litros = Number(litrosFinales.toFixed(2));
    }
    if (kilosFinales > 0) {
      registro.kilos = Number(kilosFinales.toFixed(2));
    } else if (esNodoPrensado(origen)) {
      registro.kilos = 0;
    }
    actualizarVariedadDesdeAportes(destino);
    guardarEstadoNodos();
  }
}

function normalizarNumero(valor) {
  if (valor === undefined || valor === null || valor === "") return null;
  const limpio = typeof valor === "string" ? valor.replace(",", ".") : valor;
  const numero = Number(limpio);
  return Number.isFinite(numero) ? numero : null;
}

function obtenerVariedadNodo(nodo, visitados = new Set()) {
  if (!nodo) return "";
  const key = nodo.id || nodo;
  if (visitados.has(key)) return "";
  visitados.add(key);
  const datos = nodo.datos || {};
  if (datos.variedad) return datos.variedad;
  if (datos.vino) return datos.vino;
  if (nodo.tipo === "entrada" && datos.id_ref) {
    const entrada = buscarEntradaPorId(datos.id_ref);
    if (entrada?.variedad) return entrada.variedad;
  }
  if (nodo.tipo === "deposito") {
    const varAsign = obtenerVariedadDesdeAsignaciones(nodo);
    if (varAsign) return varAsign;
  }
  const padres = obtenerPredecesores(nodo.id);
  for (const pre of padres) {
    const varPadre = obtenerVariedadNodo(pre, visitados);
    if (varPadre) return varPadre;
  }
  return "";
}

function obtenerCargaDesdeNodo(nodo) {
  if (!nodo) return null;
  const unidadNodo = obtenerUnidadNodo(nodo);
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref && nodo.datos?.kilos == null) {
    intentarPoblarNodoEntrada(nodo);
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref && nodo.datos?.codigo == null) {
    intentarPoblarNodoDeposito(nodo);
  }
  const datos = { ...(nodo.datos || {}) };
  if (nodo.tipo === "entrada" && nodo.datos?.id_ref) {
    const entrada = buscarEntradaPorId(nodo.datos.id_ref);
    if (entrada) {
      if (datos.kilos == null && entrada.kilos != null) datos.kilos = entrada.kilos;
      if (!datos.variedad && entrada.variedad) datos.variedad = entrada.variedad;
      if (!datos.anada && entrada.anada) datos.anada = entrada.anada;
      if (!datos.fecha && entrada.fecha) datos.fecha = entrada.fecha.slice(0, 10);
    }
  }
  if (nodo.tipo === "deposito" && nodo.datos?.id_ref) {
    const deposito = buscarDepositoPorId(nodo.datos.id_ref);
    if (deposito) {
      if (datos.volumen == null && deposito.litros_actuales != null) datos.volumen = deposito.litros_actuales;
      if (!datos.variedad && deposito.vino_tipo) datos.variedad = deposito.vino_tipo;
      if (!datos.anada && deposito.vino_anio) datos.anada = deposito.vino_anio;
      if (!datos.fecha && deposito.fecha_uso) datos.fecha = deposito.fecha_uso.slice(0, 10);
    }
  }
  const variedad = obtenerVariedadNodo(nodo);
  const kilos = normalizarNumero(datos.kilos);
  const litrosDirectos = normalizarNumero(datos.litros_directos);
  const litrosVolumen = normalizarNumero(
    datos.volumen != null ? datos.volumen : datos.litros != null ? datos.litros : datos.valor
  );
  const carga = {};
  if (variedad) carga.variedad = variedad;
  if (unidadNodo === "litros") {
    const litrosFinal =
      litrosDirectos != null
        ? litrosDirectos
        : litrosVolumen != null
        ? litrosVolumen
        : kilos != null
        ? kilos
        : null;
    if (litrosFinal != null) {
      const litrosVal = Number(litrosFinal.toFixed(4));
      carga.litros_directos = litrosVal;
      carga.litros = litrosVal;
    }
    if (carga.litros != null) {
      carga.kilos = 0;
    }
  } else {
    if (kilos != null) carga.kilos = kilos;
    if (litrosDirectos != null) carga.litros_directos = litrosDirectos;
    if (carga.kilos == null && litrosVolumen != null) {
      carga.kilos = litrosVolumen;
    }
  }
  if (datos.parcela) carga.parcela = datos.parcela;
  const anada = datos.anada || obtenerAnadaDesdeFecha(datos.fecha);
  if (anada) carga.anada = anada;
  if (datos.fecha) carga.fecha = datos.fecha;
  return Object.keys(carga).length ? carga : null;
}

function obtenerMermaDefault(nodo) {
  if (esNodoSangrado(nodo)) return MERMA_DEFAULT_SANGRADO;
  if (esNodoPrensado(nodo)) return MERMA_DEFAULT_PRENSADO;
  return MERMA_DEFAULT_GENERAL;
}

function asegurarMermaPorDefecto(nodo) {
  if (!nodo) return;
  nodo.datos = nodo.datos || {};
  const mermaActual = normalizarNumero(nodo.datos.merma);
  if (mermaActual == null) {
    const valor = obtenerMermaDefault(nodo);
    nodo.datos.merma = Number.isFinite(valor) ? valor : 0;
  }
}

function obtenerFactorMermaNodo(nodo) {
  const mermaDatos = nodo?.datos ? normalizarNumero(nodo.datos.merma) : null;
  const base = mermaDatos != null ? mermaDatos : obtenerMermaDefault(nodo);
  const factor = Number.isFinite(base) ? base / 100 : 0;
  return Math.min(Math.max(factor, 0), 0.95);
}

function aplicarMerma(base, factor) {
  const resultado = base * (1 - factor);
  return Number.isFinite(resultado) ? Number(resultado.toFixed(2)) : 0;
}

function aplicarMermaACarga(carga, factor) {
  if (!carga || !(factor > 0)) return carga;
  const copia = { ...carga };
  if (copia.kilos != null) copia.kilos = aplicarMerma(copia.kilos, factor);
  if (copia.litros != null) copia.litros = aplicarMerma(copia.litros, factor);
  if (copia.litros_directos != null) {
    copia.litros_directos = aplicarMerma(copia.litros_directos, factor);
  }
  return copia;
}

function esConexionTrasiego(origen, destino) {
  return (
    TIPOS_NODO_CONTENEDOR.has(origen.tipo) &&
    TIPOS_NODO_CONTENEDOR.has(destino.tipo) &&
    origen.id !== destino.id
  );
}

function aplicarCargaANodo(nodo, carga) {
  nodo.datos = nodo.datos || {};
  const unidadDestino = obtenerUnidadNodo(nodo);
  if (carga.variedad) {
    nodo.datos.variedad = carga.variedad;
  }
  if (carga.parcela) {
    nodo.datos.parcela = carga.parcela;
  }
  if (carga.anada) {
    nodo.datos.anada = carga.anada;
  }
  if (carga.kilos != null) {
    nodo.datos.kilos = Number(carga.kilos.toFixed(2));
  }
  if (carga.litros != null) {
    const litros = Number(carga.litros.toFixed(2));
    nodo.datos.volumen = litros;
    nodo.datos.litros = litros;
    if (unidadDestino === "litros") {
      nodo.datos.kilos = 0;
    }
  }
  if (carga.litros_directos != null) {
    nodo.datos.litros_directos = Number(carga.litros_directos.toFixed(2));
    if (unidadDestino === "litros") {
      nodo.datos.kilos = 0;
    }
  }
  if (carga.fecha) {
    nodo.datos.fecha = carga.fecha;
    if (!nodo.datos.fecha_operacion) {
      nodo.datos.fecha_operacion = carga.fecha;
    }
  }
}

function desconectarNodo(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  if (!nodo) return;
  const afectados = new Set();
  nodo.targets = [];
  flujoNodos.forEach(other => {
    if (other.targets) {
      const longitudInicial = other.targets.length;
      other.targets = other.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== other.targets.length) {
        afectados.add(other.id);
        if (other.tipo === "estilo") {
          limpiarDistribucionEstilo(other);
        }
      }
    }
  });
  if (nodo.tipo === "estilo") {
    limpiarDistribucionEstilo(nodo);
  }
  if (nodoConectandoOrigen === id) {
    nodoConectandoOrigen = null;
  }
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Conexiones eliminadas para este nodo.", "info");
}

function eliminarNodoPorId(id) {
  const afectados = new Set();
  flujoNodos = flujoNodos.filter(n => n.id !== id);
  flujoNodos.forEach(n => {
    if (n.targets) {
      const longitudInicial = n.targets.length;
      n.targets = n.targets.filter(targetId => targetId !== id);
      if (longitudInicial !== n.targets.length) {
        afectados.add(n.id);
        if (n.tipo === "estilo") {
          limpiarDistribucionEstilo(n);
        }
      }
    }
  });
  ultimoNodoManual = flujoNodos.length ? flujoNodos[flujoNodos.length - 1].id : null;
  afectados.forEach(origenId => {
    const origen = flujoNodos.find(n => n.id === origenId);
    redistribuirCargas(origen);
  });
  flujoNodos.forEach(n => limpiarAsignacionesOrfanas(n));
  limpiarNodosSinEntradas();
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarAviso("Nodo eliminado.", "error");
}

async function actualizarDepositoContenido(idRef, variedad, volumen, anada) {
  if (!idRef) return;
  const dep = cacheDepositos.find(d => d.id === Number(idRef));
  if (!dep) return;
  const materialActual = dep.material || dep.contenido || "";
  try {
    const res = await fetch(`/api/depositos/${idRef}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo: dep.codigo,
        tipo: dep.tipo,
        capacidad_l:
          dep.capacidad_l != null ? dep.capacidad_l : dep.capacidad_hl != null ? dep.capacidad_hl * 100 : null,
        material: materialActual,
        contenido: materialActual,
        elaboracion: dep.elaboracion,
        vino_tipo: variedad || dep.vino_tipo,
        vino_anio: anada || dep.vino_anio,
        fecha_uso: dep.fecha_uso,
        clase: dep.clase || "deposito",
        estado: dep.estado || "vacio",
      }),
    });
    if (res.ok) {
      await cargarDepositos();
    }
  } catch (err) {
    console.error("No se pudo actualizar el dep√≥sito:", err);
  }
}

function mostrarInfoNodo(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  const panel = document.getElementById("flowNodeInfo");
  if (!panel) return;
  if (!nodo) {
    panel.textContent = "Selecciona un nodo para ver los detalles.";
    return;
  }
  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
  const campos = config.campos || [];
  const detalles = campos
    .map(campo => {
      const valor = obtenerValorCampoVisual(nodo, campo);
      return `<strong>${campo.label}:</strong> ${valor || "‚Äî"}`;
    })
    .join("<br>");
  panel.innerHTML = `<strong>${config.icono || "‚óè"} ${nodo.titulo || config.label}</strong><br>${detalles || "Sin datos"}`;
}

function abrirFlowModal(id) {
  const nodo = flujoNodos.find(n => n.id === id);
  if (!nodo) return;
  nodoEnEdicion = nodo;
  const modal = document.getElementById("flowModal");
  const titulo = document.getElementById("flowModalTitulo");
  const form = document.getElementById("flowModalForm");
  if (!modal || !titulo || !form) return;
  const config = FLOW_NODE_TYPES[nodo.tipo] || { label: nodo.titulo || "Nodo", campos: [] };
  let nombreExtra = "";
  if (nodo.tipo === "deposito") {
    const infoDep = nodo.datos?.id_ref ? buscarDepositoPorId(nodo.datos.id_ref) : null;
    const nom = nodo.datos?.codigo || infoDep?.codigo;
    if (nom) nombreExtra = ` ${nom}`;
  } else if (nodo.tipo === "barrica") {
    const infoBar = nodo.datos?.contenedor_id ? buscarBarricaPorId(nodo.datos.contenedor_id) : null;
    const nom = nodo.datos?.tipo || infoBar?.codigo || (nodo.datos?.contenedor_id ? `#${nodo.datos.contenedor_id}` : "");
    if (nom) nombreExtra = ` ${nom}`;
  }
  const tituloTexto = `Editar ${config.label}${nombreExtra}`;
  if (config.icono && config.icono.trim().startsWith("<")) {
    titulo.innerHTML = `${config.icono} ${tituloTexto}`;
  } else if (config.icono) {
    titulo.textContent = `${config.icono} ${tituloTexto}`;
  } else {
    titulo.textContent = tituloTexto;
  }
  form.innerHTML = "";
  const camposOrdenados = ordenarCamposParaModal(config.campos);
  camposOrdenados.forEach(campo => {
    const label = document.createElement("label");
    label.textContent = campo.label;
    form.appendChild(label);
    if (campo.tipo === "tablaControl") {
      const tabla = crearTablaControlFermentacion(nodo);
      form.appendChild(tabla);
      return;
    }
    if (campo.tipo === "info") {
      const info = document.createElement("div");
      info.className = "campo-info";
      info.id = `flowField-${campo.id}-display`;
      const texto = obtenerValorCampoVisual(nodo, campo);
      info.textContent = texto || "‚Äî";
      form.appendChild(info);
      const hidden = document.createElement("input");
      hidden.type = "hidden";
      hidden.id = `flowField-${campo.id}`;
      hidden.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
      form.appendChild(hidden);
      return;
    }
    const esCampoProtegido =
      (nodo.tipo === "entrada" && campo.id !== "id_ref" && campo.id !== "merma") ||
      (["variedad", "fecha"].includes(campo.id) && nodo.tipo !== "entrada");
  const esCampoUnidadBloqueada =
      ["kilos", "litros", "litros_directos", "volumen"].includes(campo.id) &&
      nodo.tipo !== "entrada";
    let input;
    if (campo.tipo === "textarea") {
      input = document.createElement("textarea");
    } else if (campo.tipo === "select") {
      input = document.createElement("select");
      if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
        const tipoSeleccionado = nodo.datos?.contenedor_tipo || "";
        poblarSelectContenedorCrianza(input, tipoSeleccionado, nodo.datos?.contenedor_id || "");
      } else {
        if (campo.placeholder) {
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = campo.placeholder;
          placeholderOption.disabled = true;
          placeholderOption.selected = true;
          input.appendChild(placeholderOption);
        }
        (campo.opciones || []).forEach(op => {
          const option = document.createElement("option");
          option.value = op;
          option.textContent = op;
          input.appendChild(option);
        });
      }
    } else if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input = document.createElement("select");
      const ids = nodo.tipo === "entrada"
        ? (cacheEntradas || []).map(e => ({ id: e.id, label: `Entrada #${e.id} (${e.variedad || ""})` }))
        : ([...(cacheDepositos || []), ...(cacheMastelones || [])].map(d => ({
            id: d.id,
            label: d.codigo || `Dep√≥sito #${d.id}`,
          })));
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "Selecciona ID";
      input.appendChild(empty);
      ids.forEach(item => {
        const option = document.createElement("option");
        option.value = item.id;
        option.textContent = item.label;
        input.appendChild(option);
      });
    } else {
      input = document.createElement("input");
      input.type = campo.tipo || "text";
    }
    input.id = `flowField-${campo.id}`;
    if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      const clave = claveContenedor(nodo.datos?.contenedor_tipo);
      input.value =
        clave && nodo.datos?.contenedor_id
          ? `${clave}:${nodo.datos.contenedor_id}`
          : "";
    } else {
      input.value = nodo.datos ? nodo.datos[campo.id] || "" : "";
    }
    if (campo.placeholder) input.placeholder = campo.placeholder;
    if (esCampoProtegido || campo.soloLectura || esCampoUnidadBloqueada) {
      if (input.tagName === "SELECT") {
        input.disabled = true;
      } else {
        input.readOnly = true;
      }
      input.classList.add("field-readonly");
      input.title = esCampoProtegido
        ? "Dato sincronizado desde Entrada de uva"
        : "El volumen se calcula autom√°ticamente en el flujo";
    }
    if (campo.id === "id_ref" && (nodo.tipo === "entrada" || nodo.tipo === "deposito")) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos.id_ref = input.value;
        if (nodo.tipo === "entrada") {
          intentarPoblarNodoEntrada(nodo);
        } else {
          intentarPoblarNodoDeposito(nodo);
        }
        config.campos.forEach(c => {
          const campoInput = document.getElementById(`flowField-${c.id}`);
          if (campoInput && nodo.datos[c.id] != null) {
            campoInput.value = nodo.datos[c.id];
          }
        });
        renderFlowNodes();
        mostrarInfoNodo(nodo.id);
      });
    } else if (campo.id === "contenedor_id" && nodo.tipo === "barrica") {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        const valor = input.value;
        if (!valor) {
          nodo.datos.contenedor_id = "";
          nodo.datos.contenedor_tipo = "";
          nodo.datos.tipo = "";
          guardarEstadoNodos();
          renderFlowNodes();
          return;
        }
        const [tipoSeleccionado, idSeleccionado] = valor.split(":");
        const idNumerico = idSeleccionado ? Number(idSeleccionado) : "";
        nodo.datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Dep√≥sito";
        nodo.datos.contenedor_id = idNumerico;
        const infoCont = obtenerInfoContenedor(
          nodo.datos.contenedor_tipo === "Barrica" ? "barrica" : "deposito",
          idNumerico
        );
        const descripcion = describirContenedor(infoCont, nodo.datos.contenedor_tipo);
        nodo.datos.tipo = descripcion || nodo.datos.contenedor_tipo || "";
        const tipoInput = document.getElementById("flowField-tipo");
        if (tipoInput) {
          tipoInput.value = nodo.datos.tipo;
        }
        guardarEstadoNodos();
        renderFlowNodes();
      });
    }
    if (
      nodo.tipo === "barrica" &&
      (campo.id === "tiempo" || campo.id === "fecha_operacion")
    ) {
      input.addEventListener("change", () => {
        nodo.datos = nodo.datos || {};
        nodo.datos[campo.id] = input.value;
        refrescarDuracionModal(nodo);
      });
    }
    if (nodo.tipo === "embotellado" && campo.id === "botella") {
      input.addEventListener("change", () => actualizarBotellasResultantes(nodo));
    }
    form.appendChild(input);
  });
  if (nodo.tipo === "barrica") {
    refrescarDuracionModal(nodo);
  }
  if (nodo.tipo === "embotellado") {
    actualizarBotellasResultantes(nodo);
  }
  if (nodo.tipo === "coupage") {
    const labelAsign = document.createElement("label");
    labelAsign.textContent =
      "Selecciona los litros de cada dep√≥sito para el blend";
    form.appendChild(labelAsign);
    form.appendChild(crearTablaAsignacionesDeposito(nodo));
  }
  if (nodo.tipo === "estilo") {
    const labelDistrib = document.createElement("label");
    labelDistrib.textContent = "Reparto de kilos/litros hacia los nodos conectados";
    form.appendChild(labelDistrib);
    form.appendChild(crearTablaDistribucionEstilo(nodo));
  }
  modal.classList.add("visible");
}

function cerrarFlowModal() {
  const modal = document.getElementById("flowModal");
  if (modal) modal.classList.remove("visible");
  nodoEnEdicion = null;
}

function guardarNodoDesdeModal() {
  if (!nodoEnEdicion) return;
  const nodoId = nodoEnEdicion.id;
  const snapshot = JSON.parse(JSON.stringify(flujoNodos));
  const config = FLOW_NODE_TYPES[nodoEnEdicion.tipo];
  const datos = {};
  const metodoPrevio = nodoEnEdicion.datos?.metodo || "";
  const eraConversorAntes =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoPrevio) ||
    esMetodoSangrado(metodoPrevio);
  if (config) {
    config.campos.forEach(campo => {
      if (campo.tipo === "tablaControl") return;
      const input = document.getElementById(`flowField-${campo.id}`);
      if (input) {
        if (campo.id === "contenedor_id" && nodoEnEdicion.tipo === "barrica") {
          const valor = input.value;
          if (!valor) {
            datos.contenedor_id = "";
            datos.contenedor_tipo = "";
          } else {
            const [tipoSeleccionado, idSeleccionado] = valor.split(":");
            datos.contenedor_tipo = tipoSeleccionado === "barrica" ? "Barrica" : "Dep√≥sito";
            datos.contenedor_id = idSeleccionado ? Number(idSeleccionado) : "";
          }
        } else {
          datos[campo.id] = input.value;
        }
      } else if (nodoEnEdicion.datos && nodoEnEdicion.datos[campo.id] != null) {
        datos[campo.id] = nodoEnEdicion.datos[campo.id];
      }
    });
  }
  const metodoCandidato = datos.metodo != null ? datos.metodo : metodoPrevio;
  const esConversorCandidato =
    nodoEnEdicion.tipo === "prensado" ||
    esMetodoPrensado(metodoCandidato) ||
    esMetodoSangrado(metodoCandidato);
  if (esConversorCandidato && obtenerUnidadEntrante(nodoEnEdicion) === "litros") {
    const inputMetodo = document.getElementById("flowField-metodo");
    if (inputMetodo) inputMetodo.value = metodoPrevio || "";
    mostrarAviso("Ya tienes l√≠quido en litros antes de este punto; no puedes volver a convertir con prensado o sangrado.", "error");
    return;
  }
  nodoEnEdicion.datos = { ...(nodoEnEdicion.datos || {}), ...datos };
  asegurarMermaPorDefecto(nodoEnEdicion);
  if (esConversorCandidato) {
    const mermaActual = normalizarNumero(nodoEnEdicion.datos.merma);
    const mermaDeseada = esMetodoSangrado(metodoCandidato)
      ? MERMA_DEFAULT_SANGRADO
      : MERMA_DEFAULT_PRENSADO;
    if (mermaActual == null || (mermaActual === MERMA_DEFAULT_GENERAL && !eraConversorAntes)) {
      nodoEnEdicion.datos.merma = mermaDeseada;
    }
  }
  actualizarDuracionPrevista(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "deposito") {
    const volumenEditado = Number(nodoEnEdicion.datos.volumen);
    if (Number.isFinite(volumenEditado)) {
      nodoEnEdicion.datos.kilos = volumenEditado;
    }
  }
  actualizarTituloNodo(nodoEnEdicion);
  if (nodoEnEdicion.tipo === "entrada") {
    intentarPoblarNodoEntrada(nodoEnEdicion);
  } else if (nodoEnEdicion.tipo === "deposito") {
    intentarPoblarNodoDeposito(nodoEnEdicion);
    actualizarVariedadDesdeAportes(nodoEnEdicion);
  }
  redistribuirCargas(nodoEnEdicion);
  const validacion = validarLimitesFlujo();
  if (!validacion.ok) {
    flujoNodos = snapshot;
    nodoEnEdicion = flujoNodos.find(n => n.id === nodoId) || null;
    renderFlowNodes();
    const etiquetaNodo = obtenerEtiquetaNodoLimite(validacion.nodo);
    const unidad = validacion.unidad || "u.";
    mostrarAviso(
      `${etiquetaNodo} solo dispone de ${Number(validacion.limite).toFixed(1)} ${unidad} y ya tienes asignados ${Number(validacion.consumo).toFixed(1)} ${unidad}. Reduce la cantidad antes de continuar.`,
      "error"
    );
    return;
  }
  guardarEstadoNodos();
  renderFlowNodes();
  mostrarInfoNodo(nodoId);
  sincronizarNodoConSistema(nodoEnEdicion);
  cerrarFlowModal();
}

function intentarPoblarNodoEntrada(nodo) {
  const id = Number(nodo.datos.id_ref);
  if (!id || !Array.isArray(cacheEntradas)) return;
  const entrada = cacheEntradas.find(e => e.id === id);
  if (!entrada) {
    mostrarAviso("No se encontr√≥ la entrada con ese ID.", "error");
    return;
  }
  nodo.datos.fecha = entrada.fecha ? entrada.fecha.slice(0, 10) : nodo.datos.fecha;
  if (!nodo.datos.fecha_operacion && nodo.datos.fecha) {
    nodo.datos.fecha_operacion = nodo.datos.fecha;
  }
  nodo.datos.kilos = entrada.kilos ?? nodo.datos.kilos;
  nodo.datos.variedad = entrada.variedad || nodo.datos.variedad;
  nodo.datos.parcela = entrada.parcela || nodo.datos.parcela;
  const anadaEntrada = entrada.anada || obtenerAnadaDesdeFecha(entrada.fecha);
  nodo.datos.anada = anadaEntrada || nodo.datos.anada;
  nodo.datos.viticultor = entrada.viticultor || nodo.datos.viticultor;
  nodo.datos.tipo_suelo = entrada.tipo_suelo || nodo.datos.tipo_suelo;
  nodo.datos.anos_vid = entrada.anos_vid || nodo.datos.anos_vid;
  actualizarTituloNodo(nodo);
  mostrarAviso("Datos del nodo cargados desde la entrada.", "success");
  redistribuirCargas(nodo);
}

function intentarPoblarNodoDeposito(nodo) {
  const id = Number(nodo.datos.id_ref);
  if (!id || !Array.isArray(cacheDepositos)) return;
  const deposito = cacheDepositos.find(d => d.id === id);
  if (!deposito) {
    mostrarAviso("No se encontr√≥ el dep√≥sito con ese ID.", "error");
    return;
  }
  const camposResguardar = ["volumen", "tipo", "material", "fase", "kilos", "variedad"];
  const valoresPrevios = {};
  camposResguardar.forEach(campo => {
    if (nodo.datos && nodo.datos[campo] != null && nodo.datos[campo] !== "") {
      valoresPrevios[campo] = nodo.datos[campo];
    }
  });
  const controlPrevio = Array.isArray(nodo.datos.control)
    ? nodo.datos.control.map(item => ({ ...item }))
    : null;
  const asignacionesPrevias = nodo.datos.asignaciones
    ? JSON.parse(JSON.stringify(nodo.datos.asignaciones))
    : null;
  nodo.datos.codigo = deposito.codigo || nodo.datos.codigo;
  nodo.datos.capacidad = deposito.capacidad_l || (deposito.capacidad_hl ? deposito.capacidad_hl * 100 : nodo.datos.capacidad);
  nodo.datos.volumen = deposito.litros_actuales ?? nodo.datos.volumen;
  nodo.datos.vino = deposito.vino_tipo || nodo.datos.vino;
  // No sobreescribir variedad: se hereda desde la entrada/asignaciones
  nodo.datos.estado = deposito.estado || nodo.datos.estado;
  nodo.datos.fecha = deposito.fecha_uso ? deposito.fecha_uso.slice(0, 10) : nodo.datos.fecha;
  nodo.datos.material = deposito.material || deposito.contenido || nodo.datos.material;
  nodo.datos.tipo = deposito.tipo || nodo.datos.tipo;
  Object.entries(valoresPrevios).forEach(([campo, valor]) => {
    nodo.datos[campo] = valor;
  });
  if (controlPrevio) {
    nodo.datos.control = controlPrevio;
  }
  if (asignacionesPrevias) {
    nodo.datos.asignaciones = asignacionesPrevias;
  }
  actualizarTituloNodo(nodo);
  mostrarAviso("Datos del nodo cargados desde el dep√≥sito.", "success");
  redistribuirCargas(nodo);
}

function eliminarNodoActivo() {
  if (!nodoEnEdicion) return;
  flujoNodos = flujoNodos.filter(n => n.id !== nodoEnEdicion.id);
  flujoNodos.forEach(n => {
    n.targets = (n.targets || []).filter(t => t !== nodoEnEdicion.id);
  });
  guardarEstadoNodos();
  renderFlowNodes();
  cerrarFlowModal();
}

function guardarEstadoNodos() {
  try {
    localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
  } catch (err) {
    console.warn("No se pudo guardar nodos en localStorage:", err);
  }
  if (temporizadorGuardadoFlujo) {
    clearTimeout(temporizadorGuardadoFlujo);
  }
  temporizadorGuardadoFlujo = setTimeout(() => {
    temporizadorGuardadoFlujo = null;
    guardarFlujoEnServidor();
  }, RETARDO_GUARDADO_FLUJO);
}

async function cargarNodosGuardados() {
  try {
    const res = await fetch("/api/flujo");
    if (res.ok) {
      const data = await res.json();
      if (Array.isArray(data.nodos)) {
        flujoNodos = data.nodos;
        flujoNodos.forEach(n => {
          actualizarTituloNodo(n);
          actualizarVariedadDesdeAportes(n);
          asegurarMermaPorDefecto(n);
          if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
            intentarPoblarNodoDeposito(n);
          }
        });
        localStorage.setItem("flowNodes", JSON.stringify(flujoNodos));
        return;
      }
    }
  } catch (err) {
    console.warn("No se pudo cargar flujo del servidor:", err);
  }
  try {
    const guardados = JSON.parse(localStorage.getItem("flowNodes"));
    if (Array.isArray(guardados)) {
      flujoNodos = guardados;
      flujoNodos.forEach(n => {
        actualizarTituloNodo(n);
        actualizarVariedadDesdeAportes(n);
        asegurarMermaPorDefecto(n);
        if (n.tipo === "deposito" && n.datos?.id_ref && !n.datos?.codigo) {
          intentarPoblarNodoDeposito(n);
        }
      });
    }
  } catch (err) {
    flujoNodos = [];
  }
}

async function guardarFlujoEnServidor() {
  try {
    await fetch("/api/flujo", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ nodos: flujoNodos }),
    });
  } catch (err) {
    console.warn("No se pudo sincronizar el flujo con el servidor:", err);
  }
}

function limpiarNodosFlujo() {
  if (!confirm("¬øEliminar todos los nodos del mapa?")) return;
  flujoNodos = [];
  guardarEstadoNodos();
  renderFlowNodes();
  guardarFlujoEnServidor();
}

async function sincronizarNodoConSistema(nodo) {
  if (!nodo || nodo.datos?.sincronizado) return;
  try {
    switch (nodo.tipo) {
      case "entrada":
        await sincronizarEntradaDesdeNodo(nodo);
        break;
      case "embotellado":
        await sincronizarEmbotelladoDesdeNodo(nodo);
        break;
      default:
        // Para dep√≥sitos y barricas solo se crea desde el formulario manual.
        break;
    }
  } catch (err) {
    console.error("No se pudo sincronizar nodo:", err);
    mostrarAviso("No se pudo sincronizar el nodo con la base de datos.", "error");
  }
}

async function sincronizarEntradaDesdeNodo(nodo) {
  if (nodo.datos.id_ref) {
    mostrarAviso("La entrada ya existe en la base de datos.", "info");
    nodo.datos.sincronizado = true;
    return;
  }
  const kilos = Number(nodo.datos.kilos || 0);
  if (!kilos) {
    mostrarAviso("Indica kilos para sincronizar la entrada.", "error");
    return;
  }
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    variedad: nodo.datos.variedad || "Variedad nodo",
    viticultor: "",
    tipo_suelo: "",
    parcela: nodo.datos.parcela || "",
    anos_vid: null,
    kilos,
    destinos: [],
  };
  const res = await fetch("/api/entradas_uva", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la entrada desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Entrada creada desde el nodo.", "success");
    await cargarEntradas();
  }
}

async function sincronizarDepositoDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || nodo.datos.volumen || 0);
  if (!capacidad) {
    mostrarAviso("Indica capacidad para el dep√≥sito.", "error");
    return;
  }
  const material = nodo.datos.material || nodo.datos.contenido || "";
  const body = {
    codigo,
    clase: "deposito",
    tipo: nodo.datos.tipo || "",
    capacidad_l: capacidad,
    material,
    contenido: material,
    vino_tipo: nodo.datos.variedad || nodo.datos.vino || "",
    vino_anio: nodo.datos.anada || "",
    elaboracion: nodo.datos.elaboracion || "",
    fecha_uso: nodo.datos.fecha || null,
    estado: nodo.datos.estado || "vacio",
  };
  const res = await fetch("/api/depositos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el dep√≥sito desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Dep√≥sito creado desde el nodo.", "success");
    await cargarDepositos();
  }
}

async function sincronizarBarricaDesdeNodo(nodo) {
  const codigo = nodo.datos.codigo || nodo.id.slice(-4).toUpperCase();
  const capacidad = Number(nodo.datos.capacidad || 225);
  const body = {
    codigo,
    capacidad_l: capacidad,
    tipo_roble: nodo.datos.tipo || "",
    tostado: nodo.datos.tostado || "",
    marca: nodo.datos.marca || "",
    anio: nodo.datos.anio || "",
    vino_anio: nodo.datos.anada || "",
    vino_tipo: nodo.datos.vino || "",
  };
  const res = await fetch("/api/barricas", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear la barrica desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Barrica creada desde el nodo.", "success");
    await cargarBarricas();
  }
}

async function sincronizarEmbotelladoDesdeNodo(nodo) {
  const litros = Number(nodo.datos.litros || 0);
  if (!litros) {
    mostrarAviso("Indica litros para el embotellado.", "error");
    return;
  }
  const body = {
    fecha: nodo.datos.fecha || new Date().toISOString(),
    contenedor_tipo: nodo.datos.origen_tipo || "deposito",
    contenedor_id: Number(nodo.datos.origen_id || 1),
    litros,
    botellas: Number(nodo.datos.botellas || 0) || null,
    lote: nodo.datos.lote || "",
    nota: nodo.datos.notas || "",
  };
  const res = await fetch("/api/embotellados", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const ok = await manejarRespuesta(res, "No se pudo crear el embotellado desde el nodo.");
  if (ok) {
    nodo.datos.sincronizado = true;
    mostrarAviso("Embotellado creado desde el nodo.", "success");
    await cargarEmbotellados();
  }
}

function toggleNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (!menu || !toggle) return;
  menu.classList.toggle("visible");
  toggle.classList.toggle("open");
}

function cerrarNavMenu() {
  const menu = document.getElementById("navMenu");
  const toggle = document.getElementById("navToggle");
  if (menu) menu.classList.remove("visible");
  if (toggle) toggle.classList.remove("open");
}

function obtenerInicialesUsuario(usuario) {
  if (!usuario) return "--";
  const partes = usuario
    .split(/[^A-Za-z0-9]+/)
    .map(p => p.trim())
    .filter(Boolean);
  if (!partes.length) {
    return usuario.slice(0, 2).toUpperCase();
  }
  if (partes.length === 1) {
    return (partes[0][0] || partes[0]).toUpperCase().slice(0, 2);
  }
  return (
    (partes[0][0] || "") +
    (partes[1][0] || "")
  ).toUpperCase();
}

function obtenerNodoPorId(idBuscado) {
  const idNorm = normalizarIdNodo(idBuscado);
  return flujoNodos.find(n => normalizarIdNodo(n.id) === idNorm) || null;
}

function obtenerVolumenFinalNodoContenedor(tipo, idRef) {
  if (!idRef || !Array.isArray(flujoNodos)) return null;
  const idStr = String(idRef);
  const coincide = n =>
    n.tipo === tipo &&
    n.datos &&
    (
      (n.datos.id_ref != null && String(n.datos.id_ref) === idStr) ||
      (n.datos.contenedor_id != null && String(n.datos.contenedor_id) === idStr) ||
      (n.datos.codigo != null && String(n.datos.codigo) === idStr) ||
      String(n.id) === idStr
    );
  const candidatos = flujoNodos.filter(coincide);
  if (!candidatos.length) return null;
  const esFinal = nodo => {
    const targets = nodo.targets || [];
    return !targets.some(tid => {
      const target = obtenerNodoPorId(tid);
      return target && TIPOS_CONTENEDOR_FLUJO.has(target.tipo);
    });
  };
  const finales = candidatos.filter(esFinal);
  const elegidos = finales.length ? finales : candidatos;
  const ultimo = elegidos[elegidos.length - 1];
  const volumen = Number(ultimo?.datos?.volumen ?? ultimo?.datos?.litros);
  return Number.isFinite(volumen) ? volumen : null;
}

function obtenerEstadoBarricaDesdeNodo(idBarrica) {
  if (!idBarrica || !Array.isArray(flujoNodos)) return null;
  const volumenNodo = obtenerVolumenFinalNodoContenedor("barrica", idBarrica);
  if (Number.isFinite(volumenNodo)) {
    return { volumen: volumenNodo, enMapa: true };
  }
  const idStr = String(idBarrica);
  const nodo = flujoNodos.find(
    n =>
      n.tipo === "barrica" &&
      n.datos &&
      (String(n.datos.id_ref || "") === idStr ||
        String(n.datos.contenedor_id || "") === idStr ||
        String(n.datos.codigo || "") === idStr ||
        String(n.id || "") === idStr)
  );
  if (!nodo) return null;
  const volumen = nodo.datos?.volumen != null ? Number(nodo.datos.volumen) : null;
  return volumen != null ? { volumen, enMapa: true } : null;
}

async function cargarUsuarioActivo() {
  const badge = document.getElementById("userBadge");
  const marca = document.getElementById("marcaTexto");
  const submarca = document.getElementById("submarcaTexto");
  if (!badge) return;
  badge.textContent = "‚Äî";
  try {
    const res = await fetch("/api/me", { credentials: "same-origin" });
    if (!res.ok) {
      badge.textContent = "??";
      return;
    }
    const data = await res.json();
    badge.textContent = obtenerInicialesUsuario(data.usuario);
    badge.setAttribute("title", data.usuario);
    if (marca && data.bodega_nombre) {
      const nombre = data.bodega_nombre || "";
      const prefijo = /^bodega\b/i.test(nombre.trim()) ? nombre.trim() : `Bodega ${nombre.trim()}`;
      marca.textContent = prefijo;
    }
    if (submarca) {
      submarca.textContent = "";
    }
  } catch (err) {
    console.error("Error cargando usuario:", err);
    badge.textContent = "!!";
  }
}

function irAFormulario(seccion, campo) {
  mostrarSeccion(seccion);
  setTimeout(() => {
    const elemento = document.getElementById(campo);
    if (elemento) {
      elemento.scrollIntoView({ behavior: "smooth", block: "center" });
      elemento.focus();
    }
  }, 320);
}

document.addEventListener("click", event => {
  const navMenu = document.getElementById("navMenu");
  const navToggle = document.getElementById("navToggle");
  if (
    navMenu &&
    navToggle &&
    !navMenu.contains(event.target) &&
    !navToggle.contains(event.target)
  ) {
    cerrarNavMenu();
  }
});

document.addEventListener("DOMContentLoaded", () => {
  mostrarSeccion("bodega");
  poblarSelectOpciones("depTipo", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterial", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectOpciones("depTipoEdit", OPCIONES_TIPO_CONTENEDOR, "Tipo de contenedor");
  poblarSelectOpciones("depMaterialEdit", OPCIONES_MATERIAL_CONTENEDOR, "Material");
  poblarSelectEstados("depEstadoEdit");
  const navToggleBtn = document.getElementById("navToggle");
  if (navToggleBtn) {
    navToggleBtn.addEventListener("click", event => {
      event.stopPropagation();
      mostrarSeccion("bodega");
      toggleNavMenu();
    });
  }
  inicializarFlowEditor();
  cargarUsuarioActivo();
});
let planoDrag = null;
let mapaDepositosPorId = new Map();
let mapaBarricasPorId = new Map();
let mapaMastelonesPorId = new Map();
let entradaEditandoId = null;
const MERMA_DEFAULT_PRENSADO = 30;
const MERMA_DEFAULT_SANGRADO = 40;
const MERMA_DEFAULT_GENERAL = 0;
const FACTOR_MERMA_PRENSA = MERMA_DEFAULT_PRENSADO / 100;
const FACTOR_MERMA_TRASIEGO = 0.02;
const ESTADOS_DEPOSITO_UI = [
  { id: "fa", label: "FA", descripcion: "Fermentaci√≥n alcoh√≥lica", color: "#d85c5c" },
  { id: "fml", label: "FML", descripcion: "Fermentaci√≥n malol√°ctica", color: "#c47d21" },
  { id: "reposo", label: "Reposo", descripcion: "Reposo / Crianza", color: "#8c6ff7" },
  { id: "limpio", label: "Limpio", descripcion: "Limpio y listo", color: "#40a578" },
  { id: "vacio", label: "Vac√≠o", descripcion: "Vac√≠o", color: "#9ba1b0" },
  { id: "mantenimiento", label: "Mant.", descripcion: "Mantenimiento / Limpieza", color: "#f0a500" },
  { id: "analitica", label: "Anal√≠tica", descripcion: "Anal√≠tica pendiente", color: "#ff7aa8" },
];
const TIPOS_NODO_CONTENEDOR = new Set(["deposito", "barrica", "almacen", "coupage"]);
const VOLUMEN_BOTELLA_L = {
  "Split 0,187 L": 0.187,
  "Demi 0,375 L": 0.375,
  "Borgo√±a 0,75 L": 0.75,
  "Bordelesa 0,75 L": 0.75,
  "Magnum 1,5 L": 1.5,
  "Doble Magnum 3 L": 3,
  "Jeroboam 3 L": 3,
  "Rehoboam 4,5 L": 4.5,
  "Methuselah 6 L": 6,
  "Salmanazar 9 L": 9,
  "Balthazar 12 L": 12,
  "Nebuchadnezzar 15 L": 15,
};

function obtenerInfoEstadoDeposito(id) {
  if (!id) return ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
  return ESTADOS_DEPOSITO_UI.find(e => e.id === id) || ESTADOS_DEPOSITO_UI.find(e => e.id === "vacio");
}

function poblarSelectEstados(selectId, placeholder = "Selecciona estado") {
  const select = document.getElementById(selectId);
  if (!select) return;
  const valorActual = select.value;
  select.innerHTML = "";
  if (placeholder) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder;
    opt.disabled = true;
    opt.selected = true;
    select.appendChild(opt);
  }
  ESTADOS_DEPOSITO_UI.forEach(estado => {
    const option = document.createElement("option");
    option.value = estado.id;
    option.textContent = `${estado.label} ¬∑ ${estado.descripcion}`;
    select.appendChild(option);
  });
  if (valorActual) {
    const existente = Array.from(select.options).find(op => op.value === valorActual);
    if (existente) {
      select.value = valorActual;
    }
  }
}

function claveContenedor(tipo) {
  if (!tipo) return "";
  const normal = tipo.toString().toLowerCase();
  if (normal.includes("barrica")) return "barrica";
  return "deposito";
}

function poblarSelectContenedorCrianza(select, tipoPreferido = "", valorId = "") {
  if (!select) return;
  select.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Selecciona dep√≥sito o barrica";
  placeholder.disabled = true;
  if (!valorId) {
    placeholder.selected = true;
  }
  select.appendChild(placeholder);
  const agregarOpciones = (lista, tipoLabel) => {
    if (!Array.isArray(lista)) return;
    const tipoKey = tipoLabel === "Barrica" ? "barrica" : "deposito";
    lista.forEach(item => {
      const option = document.createElement("option");
      option.value = `${tipoKey}:${item.id}`;
      option.dataset.tipo = tipoKey;
      option.dataset.id = item.id;
      const etiquetaBase = item.codigo || item.nombre || item.etiqueta || "";
      const fallback = tipoLabel === "Barrica" ? `Barrica #${item.id}` : `Dep√≥sito #${item.id}`;
      option.textContent = `${tipoLabel} ¬∑ ${etiquetaBase || fallback}`;
      select.appendChild(option);
    });
  };
  agregarOpciones(cacheDepositos, "Dep√≥sito");
  agregarOpciones(cacheBarricas, "Barrica");
  let valorSeleccionado = "";
  if (valorId) {
    const tipoKey = claveContenedor(tipoPreferido) || "deposito";
    valorSeleccionado = `${tipoKey}:${valorId}`;
  }
  if (valorSeleccionado) {
    select.value = valorSeleccionado;
  } else {
    select.selectedIndex = 0;
  }
}

async function manejarRespuesta(res, mensajeError) {
  if (res.ok) return true;
  let info = null;
  try {
    info = await res.json();
  } catch (e) {}
  mostrarAviso((info && info.error) || mensajeError, "error");
  return false;
}

function actualizarBarra(idBar, idLabel, valor, unidad, max) {
  const bar = document.getElementById(idBar);
  const label = document.getElementById(idLabel);
  if (label) {
    const rounded = Math.round(valor).toLocaleString();
    label.textContent = `${rounded} ${unidad}`;
  }
  if (bar) {
    const porcentaje = max > 0 ? Math.max(8, (valor / max) * 100) : 0;
    bar.style.width = `${Math.min(100, porcentaje)}%`;
  }
}

function actualizarGraficosResumen(data) {
  const kilos = Number(data.kilos_entrados || 0);
  const litrosDepositos = Number(data.litros_depositos || 0);
  const litrosMastelones = Number(data.litros_mastelones || 0);
  const litrosBarricas = Number(data.litros_barricas || 0);
  const litrosTotales = litrosDepositos + litrosMastelones + litrosBarricas;
  const maxValor = Math.max(kilos, litrosTotales, 1);

  actualizarBarra("chartKilosBar", "chartKilosValue", kilos, "kg", maxValor);
  actualizarBarra("chartLitrosBar", "chartLitrosValue", litrosTotales, "L", maxValor);

  const detalle = document.getElementById("chartLitrosDetalle");
  if (detalle) {
    const depTxt = `${Math.round(litrosDepositos).toLocaleString()} L`;
    const mastTxt = `${Math.round(litrosMastelones).toLocaleString()} L`;
    const barrTxt = `${Math.round(litrosBarricas).toLocaleString()} L`;
    detalle.innerHTML = `
      üõ¢ Dep√≥sitos: ${depTxt} ¬∑
      ü™£ Mastelones: ${mastTxt} ¬∑
      <span style="display:inline-flex; align-items:center; gap:4px;">
        <img src="/barricas.png" alt="Barricas" style="width:16px; height:16px; object-fit:contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); mix-blend-mode:multiply; background:transparent;">
        Barricas: ${barrTxt}
      </span>
    `;
  }
}

function formatearNumeroCorto(valor) {
  const num = Number(valor) || 0;
  if (Math.abs(num) >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (Math.abs(num) >= 1000) return `${(num / 1000).toFixed(1)}k`;
  return num.toLocaleString("es-ES", { maximumFractionDigits: 0 });
}

function actualizarIndicadores() {
  const depPrincipal = document.getElementById("indicadorDepositosPrincipal");
  if (!depPrincipal) return;

  const calcularTotales = lista =>
    (lista || []).reduce(
      (acc, item) => {
        const capacidad = Number(
          item.capacidad_l ?? (item.capacidad_hl ? item.capacidad_hl * 100 : 0)
        ) || 0;
        const volumen = Number(item.litros_actuales || 0) || 0;
        return {
          capacidad: acc.capacidad + capacidad,
          volumen: acc.volumen + volumen,
        };
      },
      { capacidad: 0, volumen: 0 }
    );

  const dep = calcularTotales(cacheDepositos);
  const depPorcentaje = dep.capacidad > 0 ? Math.round((dep.volumen / dep.capacidad) * 100) : 0;
  depPrincipal.textContent = `${depPorcentaje}% ocupado`;
  const depDetalle = document.getElementById("indicadorDepositosDetalle");
  if (depDetalle) {
    depDetalle.textContent = `${formatearLitrosPlano(dep.volumen)} de ${formatearLitrosPlano(
      dep.capacidad
    )}`;
  }
  const depExtra = document.getElementById("indicadorDepositosExtra");
  if (depExtra) {
    const libre = Math.max(dep.capacidad - dep.volumen, 0);
    depExtra.textContent = libre
      ? `${formatearLitrosPlano(libre)} libres`
      : "Sin capacidad libre";
  }

  const mast = calcularTotales(cacheMastelones);
  const mastPrincipal = document.getElementById("indicadorMastelonesPrincipal");
  if (mastPrincipal) {
    const mastPorcentaje =
      mast.capacidad > 0 ? Math.round((mast.volumen / mast.capacidad) * 100) : 0;
    mastPrincipal.textContent = `${mastPorcentaje}% ocupado`;
    const mastDetalle = document.getElementById("indicadorMastelonesDetalle");
    if (mastDetalle) {
      mastDetalle.textContent = `${formatearLitrosPlano(mast.volumen)} de ${formatearLitrosPlano(
        mast.capacidad
      )}`;
    }
    const mastExtra = document.getElementById("indicadorMastelonesExtra");
    if (mastExtra) {
      const libre = Math.max(mast.capacidad - mast.volumen, 0);
      mastExtra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Sin capacidad libre";
    }
  }

  const bar = calcularTotales(cacheBarricas);
  const barPrincipal = document.getElementById("indicadorBarricasPrincipal");
  if (barPrincipal) {
    const barPorcentaje = bar.capacidad > 0 ? Math.round((bar.volumen / bar.capacidad) * 100) : 0;
    barPrincipal.textContent = `${barPorcentaje}% ocupado`;
    const detalle = document.getElementById("indicadorBarricasDetalle");
    if (detalle) {
      detalle.textContent = `${formatearLitrosPlano(bar.volumen)} de ${formatearLitrosPlano(
        bar.capacidad
      )}`;
    }
    const extra = document.getElementById("indicadorBarricasExtra");
    if (extra) {
      const libre = Math.max(bar.capacidad - bar.volumen, 0);
      extra.textContent = libre
        ? `${formatearLitrosPlano(libre)} libres`
        : "Barricas al m√°ximo";
    }
  }

  const totalBotellas = (cacheEmbotellados || []).reduce(
    (acc, e) => acc + (Number(e.botellas) || 0),
    0
  );
  const embPrincipal = document.getElementById("indicadorEmbotelladosPrincipal");
  if (embPrincipal) {
    embPrincipal.textContent = `${formatearNumeroCorto(totalBotellas)} botellas`;
    const detalle = document.getElementById("indicadorEmbotelladosDetalle");
    if (detalle) {
      detalle.textContent = totalBotellas
        ? `${totalBotellas.toLocaleString("es-ES")} botellas embotelladas`
        : "A√∫n no hay embotellados recientes";
    }
  }
}
function actualizarAprovechamientoAnual() {
  const tbody = document.getElementById("tablaAprovechamiento");
  if (!tbody) return;

  const kilosPorAnada = {};
  (cacheEntradas || []).forEach(e => {
    const anada = (e.anada || obtenerAnadaDesdeFecha(e.fecha || "") || "Sin a√±ada").toString();
    const kilos = Number(e.kilos || 0);
    kilosPorAnada[anada] = (kilosPorAnada[anada] || 0) + kilos;
  });

  const litrosPorAnada = {};
  const acumularLitros = (coleccion, campoAnada) => {
    coleccion.forEach(item => {
      const litros = Number(item.litros_actuales || 0);
      if (!litros) return;
      const anada = (item[campoAnada] || "Sin a√±ada").toString();
      litrosPorAnada[anada] = (litrosPorAnada[anada] || 0) + litros;
    });
  };
  acumularLitros(cacheDepositos || [], "vino_anio");
  acumularLitros(cacheMastelones || [], "vino_anio");
  acumularLitros(cacheBarricas || [], "vino_anio");

  const todas = Array.from(new Set([...Object.keys(kilosPorAnada), ...Object.keys(litrosPorAnada)]));
  todas.sort((a, b) => {
    const numA = Number(a);
    const numB = Number(b);
    if (Number.isNaN(numA) || Number.isNaN(numB)) return a.localeCompare(b);
    return numB - numA;
  });

  tbody.innerHTML = "";
  if (!todas.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="4">No hay datos disponibles todav√≠a.</td>';
    tbody.appendChild(tr);
    return;
  }

  todas.forEach(anada => {
    const kilos = kilosPorAnada[anada] || 0;
    const litros = litrosPorAnada[anada] || 0;
    const aprovechamiento = kilos > 0 ? ((litros / kilos) * 100) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${anada}</td>
      <td>${kilos.toLocaleString("es-ES", { maximumFractionDigits: 0 })} kg</td>
      <td>${litros.toLocaleString("es-ES", { maximumFractionDigits: 1 })} L</td>
      <td>${aprovechamiento.toFixed(1)} %</td>
    `;
    tbody.appendChild(tr);
  });
}

function renderPlano() {
  const canvas = document.getElementById("planoCanvas");
  const mensaje = document.getElementById("planoMensaje");
  if (!canvas || !mensaje) return;

  const canvasWidth = canvas.clientWidth || canvas.offsetWidth || 600;
  const canvasHeight = canvas.clientHeight || canvas.offsetHeight || 400;
  const cardWidth = 102;
  const cardHeight = 108;
  const offsetXPercent = (cardWidth / canvasWidth) * 100;
  const offsetYPercent = (cardHeight / canvasHeight) * 100;

  canvas.innerHTML = "";
  const elementos = [
    ...cacheDepositos.map(d => ({
      tipo: "deposito",
      id: d.id,
      codigo: d.codigo,
      pos_x: d.pos_x,
      pos_y: d.pos_y,
      capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
      volumen: (() => {
        const vNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
        if (Number.isFinite(vNodo)) return vNodo;
        return d.litros_actuales ?? 0;
      })(),
      detalle: d.material || d.contenido || d.elaboracion || "",
      vino_tipo: d.vino_tipo || "",
      contenido: d.material || d.contenido || "",
      elaboracion: d.elaboracion || "",
      estado: d.estado || "vacio",
      colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
    })),
    ...cacheMastelones.map(d => ({
      tipo: "mastelone",
      id: d.id,
      codigo: d.codigo,
      pos_x: d.pos_x,
      pos_y: d.pos_y,
      capacidad: d.capacidad_l ?? (d.capacidad_hl ? d.capacidad_hl * 100 : null),
      volumen: d.litros_actuales ?? 0,
      detalle: d.material || d.contenido || d.elaboracion || "",
      vino_tipo: d.vino_tipo || "",
      contenido: d.material || d.contenido || "",
      elaboracion: d.elaboracion || "",
      estado: d.estado || "vacio",
      colorReferencia: d.vino_tipo || d.material || d.contenido || d.elaboracion || "",
    })),
    ...cacheBarricas.map(b => ({
      tipo: "barrica",
      id: b.id,
      codigo: b.codigo,
      pos_x: b.pos_x,
      pos_y: b.pos_y,
      capacidad: b.capacidad_l ?? null,
      volumen: (() => {
        const vNodo = obtenerVolumenFinalNodoContenedor("barrica", b.id);
        if (Number.isFinite(vNodo)) return vNodo;
        return b.litros_actuales ?? 0;
      })(),
      detalle: [b.tipo_roble, b.tostado].filter(Boolean).join(" ¬∑ "),
      vino_tipo: b.vino_tipo || "",
      vino_anio: b.vino_anio || "",
      marca: b.marca || "",
      anio: b.anio || "",
      colorReferencia: b.vino_tipo || "",
    })),
  ];

  if (!elementos.length) {
    mensaje.textContent = "A√±ade dep√≥sitos, mastelones o barricas para empezar.";
    const placeholder = document.createElement("div");
    placeholder.className = "plano-placeholder";
    placeholder.textContent = "Sin elementos todav√≠a";
    canvas.appendChild(placeholder);
    return;
  }

  mensaje.textContent = "Arrastra las tarjetas para guardar su posici√≥n.";
  elementos.forEach((item, idx) => {
    const bloque = document.createElement("div");
    bloque.className = `plano-item ${item.tipo}`;
    const etiquetaBase =
      item.tipo === "deposito" ? "Dep" : item.tipo === "mastelone" ? "Mas" : "Bar";
    const etiqueta = item.codigo ? `${etiquetaBase} ${item.codigo}` : `${etiquetaBase} ${item.id}`;
    const capacidad = item.capacidad != null ? Number(item.capacidad) : null;
    const volumen = item.volumen != null ? Number(item.volumen) : 0;
    const porcentaje =
      capacidad && capacidad > 0 ? Math.min(100, Math.round((volumen / capacidad) * 100)) : 0;

    const header = document.createElement("div");
    header.className = "plano-card-header";
    const estadoInfo = obtenerInfoEstadoDeposito(item.estado);
    const subtitulo =
      item.tipo === "deposito"
        ? "Dep√≥sito"
        : item.tipo === "mastelone"
        ? "Mastelone"
        : "Barrica";
    header.innerHTML = `<span>${etiqueta}</span><small>${subtitulo}</small>`;
    const estadoBadge = document.createElement("span");
    estadoBadge.className = `estado-pill mini estado-${estadoInfo.id}`;
    estadoBadge.textContent = estadoInfo.label;
    header.appendChild(estadoBadge);
    bloque.appendChild(header);

    const body = document.createElement("div");
    body.className = "plano-card-body";
    const icono = document.createElement("div");
    icono.className = `plano-card-barrel ${item.tipo}`;
    icono.innerHTML = `<span>${(porcentaje || 0).toString()}%</span>`;
    body.appendChild(icono);

    const info = document.createElement("div");
    info.className = "plano-card-info";
    info.innerHTML = `
      <div>
        <small>Capacidad</small>
        <strong>${formatearLitrosPlano(capacidad)}</strong>
      </div>
      <div>
        <small>Contenido</small>
        <strong>${formatearLitrosPlano(volumen)}</strong>
      </div>
    `;
    body.appendChild(info);

    const colorVino =
      obtenerColorVino(item.colorReferencia) ||
      (item.tipo === "barrica"
        ? "#c48a1b"
        : item.tipo === "mastelone"
        ? "#8b1b2b"
        : "#8f97a8");
    const progress = document.createElement("div");
    progress.className = "plano-card-progress";
    const barra = document.createElement("div");
    barra.className = "plano-card-progress-bar";
    barra.style.background = colorVino;
    const alturaBarra = capacidad && capacidad > 0 ? porcentaje : 0;
    barra.style.height = `${alturaBarra}%`;
    const etiquetaPorcentaje = document.createElement("span");
    etiquetaPorcentaje.textContent = `${porcentaje}%`;
    progress.appendChild(barra);
    progress.appendChild(etiquetaPorcentaje);

    bloque.appendChild(progress);
    bloque.appendChild(body);

    const extra = document.createElement("div");
    extra.className = "plano-card-extra";
    const principalDeposito = [
      item.vino_tipo,
      item.vino_anio,
      item.contenido || item.elaboracion || "",
    ]
      .filter(Boolean)
      .join(" ¬∑ ");
    const detallePrincipal =
      item.tipo === "deposito" || item.tipo === "mastelone"
        ? principalDeposito || "Sin contenido"
        : [item.vino_tipo, item.vino_anio].filter(Boolean).join(" ¬∑ ") ||
          item.detalle ||
          "Sin notas";
    const detalleSecundario =
      item.tipo === "deposito" || item.tipo === "mastelone"
        ? ""
        : [item.marca, item.anio || null].filter(Boolean).join(" ¬∑ ");
    extra.textContent = [detallePrincipal, detalleSecundario].filter(Boolean).join(" ¬∑ ");
    bloque.appendChild(extra);

  const defaultX = 6 + (idx * 13) % 80;
  const defaultY = 8 + (idx * 17) % 70;
  const x = item.pos_x != null ? item.pos_x : defaultX;
  const y = item.pos_y != null ? item.pos_y : defaultY;

  const clampedX = Math.max(0, Math.min(100 - offsetXPercent, x));
  const clampedY = Math.max(0, Math.min(100 - offsetYPercent, y));
    bloque.style.left = `${clampedX}%`;
    bloque.style.top = `${clampedY}%`;
  bloque.dataset.posx = clampedX;
  bloque.dataset.posy = clampedY;
  bloque.addEventListener("dblclick", () => irAlContenedor(item));

  bloque.addEventListener("pointerdown", ev => iniciarArrastrePlano(ev, item, bloque));
  canvas.appendChild(bloque);
});
}

function iniciarArrastrePlano(ev, item, elemento) {
  ev.preventDefault();
  const canvas = document.getElementById("planoCanvas");
  if (!canvas) return;
  const rect = elemento.getBoundingClientRect();

  planoDrag = {
    item,
    elemento,
    pointerId: ev.pointerId,
    canvas,
    offsetX: ev.clientX - rect.left,
    offsetY: ev.clientY - rect.top,
    current: {
      x: parseFloat(elemento.dataset.posx) || 0,
      y: parseFloat(elemento.dataset.posy) || 0,
    },
  };

  elemento.classList.add("arrastrando");
  window.addEventListener("pointermove", moverElementoPlano);
  window.addEventListener("pointerup", soltarElementoPlano);
  window.addEventListener("pointercancel", cancelarArrastrePlano);
}

function moverElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  const { canvas, elemento, offsetX, offsetY } = planoDrag;
  const rect = canvas.getBoundingClientRect();

  let px = ev.clientX - rect.left - offsetX;
  let py = ev.clientY - rect.top - offsetY;

  const maxX = rect.width - elemento.offsetWidth;
  const maxY = rect.height - elemento.offsetHeight;

  px = Math.max(0, Math.min(maxX, px));
  py = Math.max(0, Math.min(maxY, py));

  const xPercent = (px / rect.width) * 100;
  const yPercent = (py / rect.height) * 100;

  elemento.style.left = `${xPercent}%`;
  elemento.style.top = `${yPercent}%`;
  elemento.dataset.posx = xPercent;
  elemento.dataset.posy = yPercent;
  planoDrag.current = { x: xPercent, y: yPercent };
}

function soltarElementoPlano(ev) {
  if (!planoDrag || ev.pointerId !== planoDrag.pointerId) return;
  finalizarArrastrePlano(true);
}

function cancelarArrastrePlano() {
  finalizarArrastrePlano(false);
}

function finalizarArrastrePlano(guardar) {
  if (!planoDrag) return;
  window.removeEventListener("pointermove", moverElementoPlano);
  window.removeEventListener("pointerup", soltarElementoPlano);
  window.removeEventListener("pointercancel", cancelarArrastrePlano);

  if (planoDrag.elemento) {
    planoDrag.elemento.classList.remove("arrastrando");
  }

  if (guardar && planoDrag.current) {
    guardarPosicionPlano(planoDrag.item, planoDrag.current.x, planoDrag.current.y);
  } else {
    renderPlano();
  }

  planoDrag = null;
}

async function guardarPosicionPlano(item, x, y) {
  const url =
    item.tipo === "deposito" || item.tipo === "mastelone"
      ? `/api/depositos/${item.id}/posicion`
      : `/api/barricas/${item.id}/posicion`;
  const pos = {
    pos_x: Math.round(x * 100) / 100,
    pos_y: Math.round(y * 100) / 100,
  };

  try {
    const res = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pos),
    });
    if (!res.ok) throw new Error("Error HTTP " + res.status);
    actualizarCachePlano(item, pos.pos_x, pos.pos_y);
  } catch (err) {
    console.error("Error guardando posici√≥n:", err);
    alert("No se pudo guardar la nueva ubicaci√≥n. Se restaurar√° la vista.");
    renderPlano();
  }
}

function actualizarCachePlano(item, x, y) {
  if (item.tipo === "deposito") {
    const dep = cacheDepositos.find(d => d.id === item.id);
    if (dep) {
      dep.pos_x = x;
      dep.pos_y = y;
    }
  } else if (item.tipo === "mastelone") {
    const mas = cacheMastelones.find(d => d.id === item.id);
    if (mas) {
      mas.pos_x = x;
      mas.pos_y = y;
    }
  } else {
    const bar = cacheBarricas.find(b => b.id === item.id);
    if (bar) {
      bar.pos_x = x;
      bar.pos_y = y;
    }
  }
}

// ---------- Resumen (bodega) ----------
async function cargarResumen() {
  try {
    // 1) Resumen principal (kilos, dep√≥sitos, barricas)
    const res = await fetch("/api/resumen");
    if (!res.ok) return;
    const data = await res.json();

    document.getElementById("resumenKilos").textContent =
      (data.kilos_entrados || 0).toFixed(0) + " kg";

    document.getElementById("resumenDepositos").textContent =
      data.depositos || 0;

    document.getElementById("resumenBarricas").textContent =
      data.barricas || 0;
    actualizarGraficosResumen(data);

  } catch (err) {
    console.error("Error cargando resumen:", err);
  }
}
        // ---------- Entradas de uva ----------
        async function cargarEntradas() {
            try {
                mostrarSkeletonTabla("tablaEntradas", 10, 4);
                const res = await fetch("/api/entradas_uva");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEntradas = datos;

                const tbody = document.getElementById("tablaEntradas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="10">No hay entradas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const anada = e.anada || obtenerAnadaDesdeFecha(e.fecha || "");
                    const fechaEntrada = formatearFechaCorta(e.fecha);
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${e.id}</td>
                        <td>${fechaEntrada}</td>
                        <td>${anada}</td>
                        <td>${e.variedad || ""}</td>
                        <td>${e.viticultor || ""}</td>
                        <td>${e.tipo_suelo || ""}</td>
                        <td>${e.parcela || ""}</td>
                        <td>${e.anos_vid || ""}</td>
                        <td>${e.kilos ?? ""}</td>
                        <td>
                            <button class="small-btn" style="margin-right:6px;"
                                onclick="editarEntradaUva(${e.id})">
                                Editar
                            </button>
                            <button class="small-btn" style="background:#c00; color:#fff;"
                                onclick="eliminarEntradaUva(${e.id})">
                                Borrar
                            </button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
                renderResumenParcelas();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando entradas:", err);
            }
        }

function renderResumenParcelas() {
            const tbody = document.getElementById("tablaResumenParcelas");
            if (!tbody) return;
            tbody.innerHTML = "";

            if (!cacheEntradas.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin datos todav√≠a.</td>';
                tbody.appendChild(tr);
                return;
            }

            const resumen = {};
            cacheEntradas.forEach(e => {
                const parcela = (e.parcela || "Sin parcela").trim() || "Sin parcela";
                if (!resumen[parcela]) {
                    resumen[parcela] = { viajes: 0, kilos: 0, ultima: null };
                }
                resumen[parcela].viajes += 1;
                const kilos = Number(e.kilos || 0);
                resumen[parcela].kilos += Number.isNaN(kilos) ? 0 : kilos;
                const fecha = e.fecha || "";
                if (!resumen[parcela].ultima || fecha > resumen[parcela].ultima) {
                    resumen[parcela].ultima = fecha;
                }
            });

            Object.entries(resumen).forEach(([parcela, info]) => {
                const fecha = info.ultima ? new Date(info.ultima) : null;
                const fechaStr = formatearFechaCorta(info.ultima);
                const horaStr =
                    fecha && !Number.isNaN(fecha)
                        ? fecha.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" })
                        : "";
                const kilosValor = Number(info.kilos || 0);
                const kilosTexto =
                    kilosValor > 0
                        ? `${kilosValor.toLocaleString("es-ES", { minimumFractionDigits: 0 })} kg`
                        : "0 kg";
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${parcela}</td>
                    <td>${info.viajes}</td>
                    <td>${kilosTexto}</td>
                    <td>${fechaStr}</td>
                    <td>${horaStr}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function cancelarEdicionEntrada() {
            entradaEditandoId = null;
            const form = document.getElementById("formEntradaUva");
            if (form) form.reset();
            actualizarAnadaEntrada();
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Registrar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "none";
        }

        async function crearEntradaUva(ev) {
            ev.preventDefault();
            setFormFeedback("feedbackEntradaUva", "");
            const fecha = document.getElementById("entradaFecha").value;
            const variedad = document.getElementById("entradaVariedad").value;
            const viticultor = document.getElementById("entradaViticultor").value;
            const parcela = document.getElementById("entradaParcela").value;
            const tipo_suelo = document.getElementById("entradaSuelo").value;
            const anos_vid = document.getElementById("entradaAnosVid").value;
            const kilos = parseFloat(document.getElementById("entradaKilos").value || "0");

            if (!fecha || !variedad || !kilos) {
                setFormFeedback("feedbackEntradaUva", "Faltan datos: fecha, variedad o kilos.", "error");
                return;
            }

            try {
                const body = {
                    fecha,
                    variedad,
                    viticultor,
                    tipo_suelo,
                    parcela,
                    anos_vid,
                    kilos
                };
                const url = entradaEditandoId ? `/api/entradas_uva/${entradaEditandoId}` : "/api/entradas_uva";
                const metodo = entradaEditandoId ? "PUT" : "POST";
                const res = await fetch(url, {
                    method: metodo,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                cancelarEdicionEntrada();
                await Promise.all([
                    cargarEntradas(),
                    cargarResumen(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarMovimientos(),
                ]);
                setFormFeedback("feedbackEntradaUva", "Entrada registrada correctamente.", "success");
                mostrarAviso("Entrada registrada en la bodega.", "success");
            } catch (err) {
                console.error("Error creando entrada:", err);
                setFormFeedback("feedbackEntradaUva", "Error al registrar la entrada de uva.", "error");
                mostrarAviso("No se pudo registrar la entrada.", "error");
            }
        }

        function editarEntradaUva(id) {
            const entrada = cacheEntradas.find(e => e.id === id);
            if (!entrada) {
                mostrarAviso("No encuentro esa entrada.", "error");
                return;
            }
            entradaEditandoId = id;
            document.getElementById("entradaFecha").value = formatearFechaParaInput(entrada.fecha);
            document.getElementById("entradaVariedad").value = entrada.variedad || "";
            document.getElementById("entradaParcela").value = entrada.parcela || "";
            document.getElementById("entradaViticultor").value = entrada.viticultor || "";
            document.getElementById("entradaSuelo").value = entrada.tipo_suelo || "";
            document.getElementById("entradaAnosVid").value = entrada.anos_vid || "";
            document.getElementById("entradaKilos").value = entrada.kilos ?? "";
            const btnGuardar = document.getElementById("btnGuardarEntrada");
            if (btnGuardar) btnGuardar.textContent = "Actualizar entrada";
            const btnCancelar = document.getElementById("btnCancelarEdicionEntrada");
            if (btnCancelar) btnCancelar.style.display = "inline-flex";
            document.getElementById("entradas").scrollIntoView({ behavior: "smooth", block: "start" });
        }

        async function eliminarEntradaUva(id) {
            if (!confirm("¬øSeguro que quieres borrar esta entrada de uva?")) return;
            try {
                const res = await fetch(`/api/entradas_uva/${id}`, { method: "DELETE" });
                if (!res.ok) throw new Error();
                if (entradaEditandoId === id) {
                    cancelarEdicionEntrada();
                }
                await Promise.all([cargarEntradas(), cargarResumen(), cargarDepositos(), cargarBarricas(), cargarMovimientos()]);
            } catch (err) {
                console.error("Error borrando entrada:", err);
                alert("No se pudo borrar la entrada.");
            }
        }
// ---------- Dep√≥sitos (con edici√≥n de volumen, contenido y fecha) ----------
async function cargarDepositos() {
  try {
    mostrarSkeletonTabla("tablaDepositos", 9);
    const res = await fetch("/api/depositos");
    if (!res.ok) {
      console.error("Error HTTP al cargar dep√≥sitos:", res.status);
      return;
    }

    const datos = await res.json();
    const separados = datos.reduce(
      (acc, item) => {
        const clase = (item.clase || "deposito").toLowerCase();
        if (clase === "mastelone") {
          acc.mastelones.push(item);
        } else {
          acc.depositos.push(item);
        }
        return acc;
      },
      { depositos: [], mastelones: [] }
    );

    cacheDepositos = separados.depositos;
    cacheMastelones = separados.mastelones;
    // Vol√∫menes desde nodos (√∫ltimo eslab√≥n)
    cacheDepositos.forEach(d => {
      const volNodo = obtenerVolumenFinalNodoContenedor("deposito", d.id);
      if (Number.isFinite(volNodo)) {
        d.litros_actuales = volNodo;
      }
    });
    mapaDepositosPorId = new Map(cacheDepositos.map(d => [d.id, d]));
    mapaMastelonesPorId = new Map(cacheMastelones.map(d => [d.id, d]));

    const listaTabla = [...cacheDepositos, ...cacheMastelones];
    renderTablaContenedores(listaTabla, "tablaDepositos", "No hay dep√≥sitos ni mastelones.");
    renderPlano();
    renderAnalisisLab();
    actualizarIndicadores();
    actualizarAprovechamientoAnual();
    actualizarMapaFlujo();
  } catch (err) {
    console.error("Error cargando dep√≥sitos:", err);
  }
}

function renderTablaContenedores(lista, tablaId, mensajeVacio) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  tbody.innerHTML = "";

  if (!lista.length) {
    tbody.innerHTML = `<tr><td colspan="9">${mensajeVacio}</td></tr>`;
    return;
  }

  lista.forEach(d => {
    const estadoNodo = obtenerEstadoDepositoDesdeNodo(d.id);
    let vol = Number(d.litros_actuales || 0);
    let variedad = d.vino_tipo || "";
    if (estadoNodo && estadoNodo.enMapa) {
      if (estadoNodo.volumen != null) {
        vol = Number(estadoNodo.volumen);
      }
      if (estadoNodo.variedad) {
        variedad = estadoNodo.variedad;
      }
    } else {
      vol = null;
      variedad = "";
    }
    const capacidad =
      d.capacidad_l != null
        ? Number(d.capacidad_l).toFixed(0)
        : d.capacidad_hl != null
        ? Number(d.capacidad_hl * 100).toFixed(0)
        : "";
    const material = d.material || d.contenido || "";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${d.id}</td>
      <td>${d.codigo || ""}</td>
      <td>${capacidad}</td>
      <td>${d.tipo || ""}</td>
      <td>${material}</td>
      <td>${variedad || "‚Äî"}</td>
      <td>${vol != null ? formatearLitrosPlano(vol) : "‚Äî"}</td>
      <td>
        <button class="small-btn"
          onclick="editarDepositoDatos(${d.id})">
          Editar
        </button>
      </td>
      <td>
        <button
          onclick="eliminarDeposito(${d.id}, ${vol})"
          style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
          Borrar
        </button>
      </td>
    `;
    tbody.appendChild(tr);
  });
}
  // No dejar borrar si tiene vino dentro
async function eliminarDeposito(id, volumen) {
  const registro =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  const clase = registro ? (registro.clase || "deposito") : "deposito";
  const etiqueta = clase === "mastelone" ? "mastelone" : "dep√≥sito";

  if (volumen > 0) {
    alert(`No puedes borrar un ${etiqueta} que todav√≠a tiene vino. Pon el volumen a 0 primero.`);
    return;
  }

  const ok = confirm(`¬øSeguro que quieres borrar este ${etiqueta}?`);
  if (!ok) return;

  try {
    const res = await fetch(`/api/depositos/${id}`, {
      method: "DELETE"
    });

    if (!res.ok) {
      alert("Error borrando el dep√≥sito.");
      console.error("Error HTTP al borrar dep√≥sito:", res.status);
      return;
    }

    alert("Dep√≥sito borrado.");
    cargarDepositos();
  } catch (err) {
    console.error("Error borrando dep√≥sito:", err);
    alert("Error borrando el dep√≥sito (mira la consola del servidor).");
  }
}
async function crearDeposito(ev) {
  ev.preventDefault();
  setFormFeedback("feedbackDepositos", "");

  const codigo = document.getElementById("depCodigo").value.trim();
  const tipo = document.getElementById("depTipo").value;
  const clase = (tipo || "").trim().toLowerCase() === "mastelone" ? "mastelone" : "deposito";
  const capacidad_l = Number(document.getElementById("depCapacidad").value || 0);
  const estado = "vacio";
  const material = document.getElementById("depMaterial").value;
  const vino_tipo = "";
  const vino_anio = "";
  const elaboracion = "";
  const fecha_uso = null;
  if (!codigo) {
    setFormFeedback("feedbackDepositos", "El c√≥digo del contenedor es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackDepositos", "Introduce una capacidad v√°lida en litros.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackDepositos", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackDepositos", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch("/api/depositos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        clase,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        vino_tipo,
        vino_anio,
        elaboracion,
        fecha_uso,
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "Error creando dep√≥sito");
    if (!ok) return;

    // Limpia el formulario
    document.getElementById("formDeposito").reset();
    // Vuelve a cargar la tabla
    await Promise.all([cargarDepositos(), cargarResumen()]);
    setFormFeedback("feedbackDepositos", "Contenedor creado correctamente.", "success");
    mostrarAviso("Nuevo contenedor registrado.", "success");
  } catch (err) {
    console.error("Error creando dep√≥sito:", err);
    setFormFeedback("feedbackDepositos", "Error creando dep√≥sito.", "error");
    mostrarAviso("No se pudo crear el contenedor.", "error");
  }
}
function editarDepositoDatos(id) {
  const dep =
    cacheDepositos.find(d => d.id === id) ||
    cacheMastelones.find(d => d.id === id);
  if (!dep) {
    mostrarAviso("No encuentro ese dep√≥sito.", "error");
    return;
  }
  abrirModalDeposito(dep);
}

function abrirModalDeposito(dep) {
  depositoEditando = { ...dep };
  const modal = document.getElementById("modalDeposito");
  if (!modal) return;
  const capacidad =
    dep.capacidad_l != null
      ? Number(dep.capacidad_l)
      : dep.capacidad_hl != null
      ? Number(dep.capacidad_hl * 100)
      : "";
  const campos = {
    depCodigoEdit: dep.codigo || "",
    depCapacidadEdit: capacidad || "",
    depVolumenEdit: dep.litros_actuales != null ? Number(dep.litros_actuales).toFixed(1) : "0",
  };
  Object.entries(campos).forEach(([id, valor]) => {
    const input = document.getElementById(id);
    if (input) input.value = valor ?? "";
  });
  const tipoSelect = document.getElementById("depTipoEdit");
  if (tipoSelect) {
    tipoSelect.value = dep.tipo || "";
  }
  const materialSelect = document.getElementById("depMaterialEdit");
  if (materialSelect) {
    materialSelect.value = dep.material || dep.contenido || "";
  }
  const estadoSelect = document.getElementById("depEstadoEdit");
  if (estadoSelect) {
    estadoSelect.value = dep.estado || "vacio";
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = dep.vino_tipo || "Sin variedad";
  }
  setFormFeedback("feedbackEditarDeposito", "");
  modal.classList.add("visible");
}

function cerrarModalDeposito() {
  depositoEditando = null;
  const modal = document.getElementById("modalDeposito");
  if (modal) {
    modal.classList.remove("visible");
  }
  const form = document.getElementById("formEditarDeposito");
  if (form) {
    form.reset();
  }
  const variedadInfo = document.getElementById("depVariedadInfo");
  if (variedadInfo) {
    variedadInfo.textContent = "‚Äî";
  }
  setFormFeedback("feedbackEditarDeposito", "");
}

async function guardarEdicionDeposito(ev) {
  ev.preventDefault();
  if (!depositoEditando) return;
  const codigo = document.getElementById("depCodigoEdit").value.trim();
  const capacidad_l = Number(document.getElementById("depCapacidadEdit").value || 0);
  const volumenNuevo = Number(document.getElementById("depVolumenEdit").value || 0);
  const tipo = document.getElementById("depTipoEdit").value;
  const material = document.getElementById("depMaterialEdit").value;
  const estado = document.getElementById("depEstadoEdit").value || "vacio";

  if (!codigo) {
    setFormFeedback("feedbackEditarDeposito", "El c√≥digo es obligatorio.", "error");
    return;
  }
  if (!capacidad_l || capacidad_l <= 0) {
    setFormFeedback("feedbackEditarDeposito", "Introduce una capacidad v√°lida.", "error");
    return;
  }
  if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
    setFormFeedback("feedbackEditarDeposito", "El volumen debe ser un n√∫mero positivo.", "error");
    return;
  }
  if (!tipo) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el tipo de contenedor.", "error");
    return;
  }
  if (!material) {
    setFormFeedback("feedbackEditarDeposito", "Selecciona el material del contenedor.", "error");
    return;
  }

  try {
    const res = await fetch(`/api/depositos/${depositoEditando.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        codigo,
        tipo,
        capacidad_l,
        material,
        contenido: material,
        elaboracion: depositoEditando.elaboracion,
        vino_tipo: depositoEditando.vino_tipo,
        vino_anio: depositoEditando.vino_anio,
        fecha_uso: depositoEditando.fecha_uso,
        clase: depositoEditando.clase || "deposito",
        estado,
      }),
    });
    const ok = await manejarRespuesta(res, "No se pudo actualizar el dep√≥sito.");
    if (!ok) return;
    await aplicarAjusteDeposito(
      depositoEditando.id,
      Number(depositoEditando.litros_actuales || 0),
      volumenNuevo,
      depositoEditando.clase || "deposito"
    );
    await Promise.all([cargarDepositos(), cargarMovimientos(), cargarResumen()]);
    mostrarAviso("Dep√≥sito actualizado.", "success");
    cerrarModalDeposito();
  } catch (err) {
    console.error("Error actualizando dep√≥sito:", err);
    setFormFeedback("feedbackEditarDeposito", "No se pudo actualizar el dep√≥sito.", "error");
  }
}
async function aplicarAjusteDeposito(id, volumenActual, nuevo, clase = "deposito") {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const tipoMovimiento = clase === "mastelone" ? "mastelone" : "deposito";
  const etiqueta = tipoMovimiento === "mastelone" ? "mastelone" : "dep√≥sito";
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: tipoMovimiento,
        destino_id: id,
        litros: delta,
        perdida_litros: null,
        nota: `Ajuste de volumen desde edici√≥n de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: tipoMovimiento,
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        perdida_litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) desde edici√≥n de ${etiqueta} (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste de volumen:", err);
    alert("No se pudo registrar el ajuste de volumen.");
  }
}
async function editarBarricaDatos(id) {
    const bar = cacheBarricas.find(b => b.id === id);
    if (!bar) {
        alert("No encuentro esa barrica.");
        return;
    }

    const codigo = prompt("C√≥digo:", bar.codigo || "");
    if (codigo === null || !codigo.trim()) return;

    const capacidadStr = prompt(
        "Capacidad (L):",
        bar.capacidad_l != null ? bar.capacidad_l : ""
    );
    if (capacidadStr === null) return;
    const capacidad_l = Number(capacidadStr);
    if (Number.isNaN(capacidad_l) || capacidad_l <= 0) {
        alert("Introduce una capacidad v√°lida.");
        return;
    }

    const volumenStr = prompt(
        "Volumen actual (L):",
        bar.litros_actuales != null ? bar.litros_actuales : 0
    );
    if (volumenStr === null) return;
    const volumenNuevo = Number(volumenStr);
    if (Number.isNaN(volumenNuevo) || volumenNuevo < 0) {
        alert("Introduce un volumen v√°lido.");
        return;
    }

    const tipoResp = prompt("Tipo de roble:", bar.tipo_roble || "");
    if (tipoResp === null) return;
    const tipo_roble = tipoResp.trim() || null;

    const tostadoResp = prompt("Tostado:", bar.tostado || "");
    if (tostadoResp === null) return;
    const tostado = tostadoResp.trim() || null;

    const marcaResp = prompt("Marca:", bar.marca || "");
    if (marcaResp === null) return;
    const marca = marcaResp.trim() || null;

    const anioResp = prompt("A√±o:", bar.anio || "");
    if (anioResp === null) return;
    const anio = anioResp.trim() || null;

    const vinoAnioResp = prompt("A√±ada:", bar.vino_anio || "");
    if (vinoAnioResp === null) return;
    const vino_anio = vinoAnioResp.trim() || null;

    const vinoResp = prompt(
        "Tipo de vino (1=tinto, 2=blanco, 3=rosado/clarete o escribe texto):",
        bar.vino_tipo || ""
    );
    if (vinoResp === null) return;
    const vino_tipo_normalizado = normalizarTipoVino(vinoResp, bar.vino_tipo);
    const vino_tipo = vino_tipo_normalizado || null;

    try {
        const res = await fetch(`/api/barricas/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                codigo: codigo.trim(),
                capacidad_l,
                tipo_roble,
                tostado,
                marca,
                anio,
                vino_anio,
                vino_tipo,
            }),
        });
        const ok = await manejarRespuesta(res, "No se pudo actualizar la barrica.");
        if (!ok) return;
        await aplicarAjusteBarrica(id, Number(bar.litros_actuales || 0), volumenNuevo);
        await cargarBarricas();
        await cargarMovimientos();
        await cargarResumen();
    } catch (err) {
        console.error("Error actualizando barrica:", err);
        alert("No se pudo actualizar la barrica.");
    }
}

async function eliminarBarrica(id, volumen) {
    if (volumen > 0) {
        alert("No puedes borrar una barrica que a√∫n tiene vino. Ajusta el volumen a 0 primero.");
        return;
    }

    if (!confirm("¬øSeguro que quieres borrar esta barrica?")) return;

    try {
        const res = await fetch(`/api/barricas/${id}`, { method: "DELETE" });
        if (!res.ok) throw new Error();
        alert("Barrica borrada.");
        await cargarBarricas();
        await cargarResumen();
    } catch (err) {
        console.error("Error borrando barrica:", err);
        alert("No se pudo borrar la barrica.");
    }
}
async function aplicarAjusteBarrica(id, volumenActual, nuevo) {
  const delta = nuevo - volumenActual;
  if (Math.abs(delta) < 0.0001) {
    return;
  }

  const ahora = new Date().toISOString();
  const body = delta > 0
    ? {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: null,
        origen_id: null,
        destino_tipo: "barrica",
        destino_id: id,
        litros: delta,
        nota: `Ajuste de volumen en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      }
    : {
        fecha: ahora,
        fecha_hora: ahora,
        tipo: "ajuste",
        origen_tipo: "barrica",
        origen_id: id,
        destino_tipo: "merma",
        destino_id: null,
        litros: Math.abs(delta),
        nota: `Ajuste de volumen (merma) en barrica (antes: ${volumenActual} L, ahora: ${nuevo} L)`,
      };

  try {
    const res = await fetch("/api/movimientos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error();
  } catch (err) {
    console.error("Error aplicando ajuste en barrica:", err);
    alert("No se pudo registrar el ajuste de volumen en la barrica.");
  }
}

function obtenerNombreDeposito(id) {
  const dep = mapaDepositosPorId.get(id);
  return dep ? dep.codigo || `Dep√≥sito ${id}` : `Dep√≥sito ${id}`;
}

function obtenerNombreMastelone(id) {
  const mas = mapaMastelonesPorId.get(id);
  return mas ? mas.codigo || `Mastelone ${id}` : `Mastelone ${id}`;
}

function obtenerNombreBarrica(id) {
  const bar = mapaBarricasPorId.get(id);
  return bar ? bar.codigo || `Barrica ${id}` : `Barrica ${id}`;
}

function formatearUbicacionMovimiento(tipo, id) {
  if (!tipo || !id) return "";
  if (tipo === "deposito") {
    return obtenerNombreDeposito(Number(id));
  }
  if (tipo === "mastelone") {
    return obtenerNombreMastelone(Number(id));
  }
  if (tipo === "barrica") {
    return obtenerNombreBarrica(Number(id));
  }
  return `${tipo.charAt(0).toUpperCase() + tipo.slice(1)} ${id}`;
}

function formatearLitrosPlano(valor) {
  if (valor == null || Number.isNaN(Number(valor))) return "‚Äî";
  return `${Number(valor).toLocaleString("es-ES", { maximumFractionDigits: 1 })} L`;
}

function formatearFechaCorta(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  return fecha.toLocaleDateString("es-ES");
}

function formatearFechaParaInput(valor) {
  if (!valor) return "";
  const fecha = new Date(valor);
  if (Number.isNaN(fecha.getTime())) return "";
  const pad = numero => numero.toString().padStart(2, "0");
  const a√±o = fecha.getFullYear();
  const mes = pad(fecha.getMonth() + 1);
  const dia = pad(fecha.getDate());
  const horas = pad(fecha.getHours());
  const minutos = pad(fecha.getMinutes());
  return `${a√±o}-${mes}-${dia}T${horas}:${minutos}`;
}

function obtenerColorVino(texto) {
  if (!texto) return null;
  const t = texto
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
  if (t.includes("blanc")) return "#f5d372";
  if (t.includes("ros") || t.includes("clarete")) return "#f48fb1";
  if (t.includes("tinto") || t.includes("red") || t.includes("tannat")) return "#7b1b47";
  return null;
}

function normalizarTipoVino(entrada, actual = "") {
  if (entrada == null) return actual || "";
  const textoOriginal = entrada.toString().trim();
  if (!textoOriginal) return actual || "";
  const limpio = textoOriginal
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();

  if (["1", "tinto", "vino tinto"].includes(limpio)) return "Vino tinto";
  if (["2", "blanco", "vino blanco"].includes(limpio)) return "Vino blanco";
  if (
    ["3", "rosado", "rosa", "clarete", "vino rosado", "vino clarete"].includes(limpio)
  ) {
    return "Vino rosado / Clarete";
  }
  return textoOriginal;
}

function obtenerAnadaDesdeFecha(fecha) {
  if (!fecha) return "";
  const match = fecha.match(/^(\d{4})/);
  return match ? match[1] : "";
}

function actualizarAnadaEntrada() {
  const fecha = document.getElementById("entradaFecha");
  const campo = document.getElementById("entradaAnada");
  if (!campo) return;
  campo.value = fecha ? obtenerAnadaDesdeFecha(fecha.value) : "";
}

function resolverContenedorId(tipo, valor) {
  if (!valor) return null;
  if (/^\d+$/.test(valor)) {
    return Number(valor);
  }
  const normalizado = valor.toLowerCase();
  if (tipo === "deposito") {
    const dep = cacheDepositos.find(d => (d.codigo || "").toLowerCase() === normalizado);
    return dep ? dep.id : null;
  }
  if (tipo === "mastelone") {
    const mas = cacheMastelones.find(m => (m.codigo || "").toLowerCase() === normalizado);
    return mas ? mas.id : null;
  }
  if (tipo === "barrica") {
    const bar = cacheBarricas.find(b => (b.codigo || "").toLowerCase() === normalizado);
    return bar ? bar.id : null;
  }
  return null;
}

function irAlContenedor(item) {
  if (!item || !item.tipo) return;
  if (item.tipo === "deposito" || item.tipo === "mastelone") {
    mostrarSeccion("depositos");
    scrollToContenedor("tablaDepositos", dep => dep.codigo === item.codigo || dep.id === item.id);
  } else if (item.tipo === "barrica") {
    mostrarSeccion("barricas");
    scrollToContenedor("tablaBarricas", bar => bar.codigo === item.codigo || bar.id === item.id);
  }
}

function scrollToContenedor(tablaId, predicate) {
  const tbody = document.getElementById(tablaId);
  if (!tbody) return;
  const filas = Array.from(tbody.querySelectorAll("tr"));
  const target = filas.find(tr => {
    const celdas = tr.querySelectorAll("td");
    if (!celdas.length) return false;
    const id = Number(celdas[0].textContent.trim());
    const codigo = celdas[1] ? celdas[1].textContent.trim() : "";
    return predicate({ id, codigo });
  });
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    target.classList.add("resaltado");
    setTimeout(() => target.classList.remove("resaltado"), 1500);
  }
}

function obtenerMovimientosFiltrados() {
  let datos = Array.isArray(cacheMovimientos) ? [...cacheMovimientos] : [];
  const { tipo, desde, hasta, contenedor, contenedor_tipo } = filtrosMovimientos;
  if (tipo) {
    const filtroTipo = tipo.toLowerCase();
    datos = datos.filter(m => (m.tipo || "").toLowerCase() === filtroTipo);
  }

  const fechaDesde = desde ? new Date(desde) : null;
  const fechaHasta = hasta ? new Date(hasta) : null;

  if (fechaDesde instanceof Date && !Number.isNaN(fechaDesde.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp >= fechaDesde.getTime();
    });
  }

  if (fechaHasta instanceof Date && !Number.isNaN(fechaHasta.getTime())) {
    datos = datos.filter(m => {
      const stamp = new Date(m.fecha || m.fecha_hora || "").getTime();
      return Number.isNaN(stamp) ? true : stamp <= fechaHasta.getTime();
    });
  }

  if (contenedor) {
    const valor = contenedor.trim();
    const candidatos = [];
    if (!contenedor_tipo || contenedor_tipo === "deposito") {
      const idDep = resolverContenedorId("deposito", valor);
      if (idDep) candidatos.push({ tipo: "deposito", id: idDep });
    }
    if (!contenedor_tipo || contenedor_tipo === "mastelone") {
      const idMas = resolverContenedorId("mastelone", valor);
      if (idMas) candidatos.push({ tipo: "mastelone", id: idMas });
    }
    if (!contenedor_tipo || contenedor_tipo === "barrica") {
      const idBar = resolverContenedorId("barrica", valor);
      if (idBar) candidatos.push({ tipo: "barrica", id: idBar });
    }
    if (!candidatos.length) {
      return [];
    }
    datos = datos.filter(m =>
      candidatos.some(
        info =>
          (m.origen_tipo === info.tipo && Number(m.origen_id) === info.id) ||
          (m.destino_tipo === info.tipo && Number(m.destino_id) === info.id)
      )
    );
  }

  return datos;
}

function renderMovimientos() {
  const tbody = document.getElementById("tablaMovimientos");
  if (!tbody) return;
  const datos = obtenerMovimientosFiltrados();
  tbody.innerHTML = "";

  if (!datos.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = '<td colspan="8">No hay movimientos registrados.</td>';
    tbody.appendChild(tr);
    return;
  }

  datos.forEach(m => {
    const fecha = m.fecha || m.fecha_hora || "";
    const fechaTexto = formatearFechaCorta(fecha);
    const litros = m.litros != null ? m.litros : m.volumen_l ?? "";
    const origen = formatearUbicacionMovimiento(m.origen_tipo, m.origen_id);
    const destino = formatearUbicacionMovimiento(m.destino_tipo, m.destino_id);
    const tr = document.createElement("tr");
    tr.innerHTML = `
        <td>${fechaTexto}</td>
        <td>${m.tipo || ""}</td>
        <td>${litros}</td>
        <td>${m.perdida_litros != null ? m.perdida_litros : ""}</td>
        <td>${origen.trim()}</td>
        <td>${destino.trim()}</td>
        <td>${m.nota || ""}</td>
        <td><button class="small-btn" style="background:#c04b4b; color:#fff;" onclick="eliminarMovimiento(${m.id})">Borrar</button></td>
    `;
    tbody.appendChild(tr);
  });
}

async function limpiarHistorialMovimientos() {
  const confirmar = confirm(
    "¬øSeguro que quieres borrar todo el historial de movimientos? Esta acci√≥n no se puede deshacer."
  );
  if (!confirmar) return;

  try {
    const res = await fetch("/api/movimientos", { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo limpiar el historial.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error limpiando historial de movimientos:", err);
    alert("Error al limpiar el historial de movimientos.");
  }
}

async function eliminarMovimiento(id) {
  const confirmar = confirm("¬øBorrar este movimiento? Esta acci√≥n no se puede deshacer.");
  if (!confirmar) return;
  try {
    const res = await fetch(`/api/movimientos/${id}`, { method: "DELETE" });
    const ok = await manejarRespuesta(res, "No se pudo borrar el movimiento.");
    if (!ok) return;
    await cargarMovimientos();
    await cargarResumen();
  } catch (err) {
    console.error("Error borrando movimiento:", err);
    alert("No se pudo borrar el movimiento.");
  }
}

function aplicarFiltrosMovimientos() {
  filtrosMovimientos = {
    tipo: (document.getElementById("filtroMovTipo").value || "").toLowerCase(),
    desde: document.getElementById("filtroMovDesde").value || "",
    hasta: document.getElementById("filtroMovHasta").value || "",
    contenedor: document.getElementById("filtroMovContenedor").value.trim(),
    contenedor_tipo: document.getElementById("filtroMovContTipo").value || "",
  };
  renderMovimientos();
}

function limpiarFiltrosMovimientos() {
  document.getElementById("filtroMovTipo").value = "";
  document.getElementById("filtroMovDesde").value = "";
  document.getElementById("filtroMovHasta").value = "";
  document.getElementById("filtroMovContenedor").value = "";
  document.getElementById("filtroMovContTipo").value = "";
  filtrosMovimientos = { tipo: "", desde: "", hasta: "", contenedor: "", contenedor_tipo: "" };
  renderMovimientos();
}

async function exportarMovimientosCSV() {
  try {
    const res = await fetch("/api/export/movimientos");
    if (!res.ok) throw new Error();
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const enlace = document.createElement("a");
    const fecha = new Date().toISOString().slice(0, 10);
    enlace.href = url;
    enlace.download = `movimientos-${fecha}.csv`;
    document.body.appendChild(enlace);
    enlace.click();
    enlace.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Error exportando movimientos:", err);
    alert("No se pudo exportar el historial de movimientos.");
  }
}

async function obtenerHistorialCompleto(tipo, id) {
  try {
    const res = await fetch(`/api/contenedores/${tipo}/${id}/historial`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (err) {
    console.warn("Fallo al usar endpoint combinado, usando modo local:", err);
    return await construirHistorialLocal(tipo, id);
  }
}

async function construirHistorialLocal(tipo, id) {
  const registrosRes = await fetch(`/api/registros/${tipo}/${id}`);
  if (!registrosRes.ok) throw new Error("No se pudieron obtener registros anal√≠ticos");
  const registros = await registrosRes.json();

  let movimientos = cacheMovimientos;
  if (!movimientos || !movimientos.length) {
    const movRes = await fetch("/api/movimientos");
    if (!movRes.ok) throw new Error("No se pudieron obtener movimientos");
    movimientos = await movRes.json();
  }

  const analiticosNormalizados = registros.map(r => ({
    categoria: "analitico",
    fecha: r.fecha_hora,
    densidad: r.densidad,
    temperatura_c: r.temperatura_c,
    nota_sensorial: r.nota_sensorial,
    nota: r.nota,
  }));

  const movimientosRelacionados = movimientos
    .filter(
      m =>
        (m.origen_tipo === tipo && Number(m.origen_id) === id) ||
        (m.destino_tipo === tipo && Number(m.destino_id) === id)
    )
    .map(m => ({
      categoria: "movimiento",
      fecha: m.fecha,
      tipo: m.tipo,
      litros: m.litros,
      origen_tipo: m.origen_tipo,
      origen_id: m.origen_id,
      destino_tipo: m.destino_tipo,
      destino_id: m.destino_id,
      nota: m.nota,
    }));

  return [...analiticosNormalizados, ...movimientosRelacionados].sort(
    (a, b) => new Date(b.fecha || 0) - new Date(a.fecha || 0)
  );
}
        // ---------- Barricas ----------
        async function cargarBarricas() {
            try {
                mostrarSkeletonTabla("tablaBarricas", 11);
                const res = await fetch("/api/barricas");
                if (!res.ok) return;
                const datos = await res.json();
                cacheBarricas = datos;
                cacheBarricas.forEach(b => {
                    const volNodo = obtenerVolumenFinalNodoContenedor("barrica", b.id);
                    if (Number.isFinite(volNodo)) {
                        b.litros_actuales = volNodo;
                    }
                });
                mapaBarricasPorId = new Map(datos.map(b => [b.id, b]));
                renderPlano();

                const tbody = document.getElementById("tablaBarricas");
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="11">No hay barricas registradas.</td>';
                    tbody.appendChild(tr);
                    return;
                }

               datos.forEach(b => {
                    const estadoNodo = obtenerEstadoBarricaDesdeNodo(b.id);
                    const vol = estadoNodo?.volumen != null
                        ? Number(estadoNodo.volumen || 0).toFixed(1)
                        : Number(b.litros_actuales || 0).toFixed(1);
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
        <td>${b.id}</td>
        <td>${b.codigo || ""}</td>
        <td>${b.capacidad_l ?? ""}</td>
        <td>${(b.tipo_roble || "")} ${b.tostado || ""}</td>
        <td>${b.marca || ""}</td>
        <td>${b.anio || ""}</td>
        <td>${b.vino_anio || ""}</td>
        <td>${b.vino_tipo || ""}</td>
        <td>${vol}</td>
        <td>
            <button class="small-btn"
                onclick="editarBarricaDatos(${b.id})">
                Editar
            </button>
        </td>
        <td>
            <button
                onclick="eliminarBarrica(${b.id}, ${vol})"
                style="background:#c00; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                Borrar
            </button>
        </td>
    `;
                    tbody.appendChild(tr);
});
                actualizarIndicadores();
                actualizarAprovechamientoAnual();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando barricas:", err);
            }
        }

        async function crearBarrica(ev) {
            ev.preventDefault();
            const codigo = document.getElementById("barCodigo").value;
            const capacidad_l = parseFloat(document.getElementById("barCapacidad").value || "0");
            const tipo_roble = document.getElementById("barTipo").value;
            const tostado = document.getElementById("barTostado").value;
            const marca = document.getElementById("barMarca").value;
            const anio = document.getElementById("barAnio").value;
            const vino_anio = document.getElementById("barVinoAnio").value;
            const vino_tipo = document.getElementById("barVinoTipo").value;

            if (!codigo || !capacidad_l) {
                alert("Faltan datos de la barrica (c√≥digo, capacidad).");
                return;
            }

            try {
                const body = { codigo, capacidad_l, tipo_roble, tostado, marca, anio, vino_anio, vino_tipo };
                const res = await fetch("/api/barricas", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al crear la barrica.");
                if (!ok) return;

                document.getElementById("formBarrica").reset();
                cargarBarricas();
                cargarResumen();
            } catch (err) {
                console.error("Error creando barrica:", err);
            }
        }

        // ---------- Almac√©n de limpieza ----------
        async function cargarLimpieza() {
            try {
                const res = await fetch("/api/limpieza");
                if (!res.ok) return;
                const datos = await res.json();
                cacheLimpieza = datos;

                const tbody = document.getElementById("tablaLimpieza");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoLimpieza(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos de limpieza:", err);
            }
        }

        async function crearProductoLimpieza(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("limNombre").value.trim();
            const lote = document.getElementById("limLote").value.trim();
            const cantidad = parseFloat(document.getElementById("limCantidad").value || "0");
            const unidad = document.getElementById("limUnidad").value.trim();
            const nota = document.getElementById("limNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad v√°lida.");
                return;
            }

            try {
                const res = await fetch("/api/limpieza", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formLimpieza").reset();
                cargarLimpieza();
            } catch (err) {
                console.error("Error creando producto de limpieza:", err);
            }
        }

        async function registrarUsoLimpieza(id) {
            const prod = cacheLimpieza.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inv√°lida.");
                return;
            }

            let destino_tipo = null;
            let destino_id = null;
            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vac√≠o:", "")
                .trim()
                .toLowerCase();
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("C√≥digo o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor v√°lido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/limpieza/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarLimpieza();
            } catch (err) {
                console.error("Error registrando consumo de limpieza:", err);
            }
        }

        // ---------- Productos enol√≥gicos ----------
        async function cargarEnologicos() {
            try {
                const res = await fetch("/api/enologicos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEnologicos = datos;
                const tbody = document.getElementById("tablaEnologicos");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">No hay productos registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(prod => {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${prod.nombre || ""}</td>
                        <td>${prod.lote || ""}</td>
                        <td>${prod.unidad || ""}</td>
                        <td>${(prod.cantidad_disponible ?? 0).toFixed(2)}</td>
                        <td>
                            <button class="small-btn" onclick="registrarUsoEnologico(${prod.id})">Registrar uso</button>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando productos enol√≥gicos:", err);
            }
        }

        async function crearProductoEnologico(ev) {
            ev.preventDefault();
            const nombre = document.getElementById("enoNombre").value.trim();
            const lote = document.getElementById("enoLote").value.trim();
            const cantidad = parseFloat(document.getElementById("enoCantidad").value || "0");
            const unidad = document.getElementById("enoUnidad").value.trim();
            const nota = document.getElementById("enoNota").value.trim();

            if (!nombre || !lote || !cantidad || cantidad <= 0) {
                alert("Completa nombre, lote y una cantidad v√°lida.");
                return;
            }

            try {
                const res = await fetch("/api/enologicos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ nombre, lote, cantidad, unidad, nota }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el producto.");
                if (!ok) return;
                document.getElementById("formEnologicos").reset();
                cargarEnologicos();
            } catch (err) {
                console.error("Error creando producto enol√≥gico:", err);
            }
        }

async function registrarUsoEnologico(id) {
            const prod = cacheEnologicos.find(p => p.id === id);
            if (!prod) {
                alert("Producto no encontrado.");
                return;
            }
            const cantidadStr = prompt(
                `Cantidad a usar de ${prod.nombre} (${prod.unidad || "unidad"}). Disponible: ${(prod.cantidad_disponible ?? 0).toFixed(2)}`,
                ""
            );
            if (cantidadStr === null) return;
            const cantidad = Number(cantidadStr);
            if (!cantidad || cantidad <= 0) {
                alert("Cantidad inv√°lida.");
                return;
            }

            const tipoDestino = prompt("Tipo de destino (deposito/barrica/mastelone) o deja vac√≠o:", "")
                .trim()
                .toLowerCase();
            let destino_tipo = null;
            let destino_id = null;
            if (tipoDestino && (tipoDestino === "deposito" || tipoDestino === "barrica" || tipoDestino === "mastelone")) {
                const cont = prompt("C√≥digo o ID del contenedor destino:", "");
                if (cont === null || !cont.trim()) {
                    alert("Debes indicar un contenedor v√°lido.");
                    return;
                }
                const idCont = resolverContenedorId(tipoDestino, cont.trim());
                if (!idCont) {
                    alert("No se encuentra el contenedor indicado.");
                    return;
                }
                destino_tipo = tipoDestino;
                destino_id = idCont;
            }

            const nota = prompt("Nota (opcional):", "") || "";

            try {
                const res = await fetch("/api/enologicos/consumos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        producto_id: id,
                        cantidad,
                        destino_tipo,
                        destino_id,
                        nota,
                    }),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el consumo.");
                if (!ok) return;
                await cargarEnologicos();
            } catch (err) {
                console.error("Error registrando consumo enol√≥gico:", err);
            }
        }

        // ---------- Movimientos ----------
        async function cargarMovimientos() {
            try {
                mostrarSkeletonTabla("tablaMovimientos", 8, 4);
                const res = await fetch("/api/movimientos");
                if (!res.ok) return;
                const datos = await res.json();
                cacheMovimientos = datos;
                renderMovimientos();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando movimientos:", err);
            }
        }

        function actualizarCamposMovimiento() {
            const tipoSelect = document.getElementById("movTipo");
            const origenTipo = document.getElementById("movOrigenTipo");
            const origenId = document.getElementById("movOrigenId");
            const origenNota = document.getElementById("movOrigenNota");
            const esPrensado = tipoSelect && tipoSelect.value === "prensado";

            if (esPrensado) {
                if (origenTipo) {
                    origenTipo.value = "";
                    origenTipo.disabled = true;
                }
                if (origenId) {
                    origenId.value = "";
                    origenId.disabled = true;
                }
                if (origenNota) {
                    origenNota.style.display = "block";
                }
            } else {
                if (origenTipo) {
                    origenTipo.disabled = false;
                }
                if (origenId) {
                    origenId.disabled = false;
                }
                if (origenNota) {
                    origenNota.style.display = "none";
                }
            }
        }

        async function crearMovimiento(ev) {
            ev.preventDefault();
            let fecha = document.getElementById("movFecha").value;
            if (!fecha) {
                fecha = new Date().toISOString();
            }
            const fecha_hora = fecha;

            const tipo = document.getElementById("movTipo").value;
            const destino_tipo = document.getElementById("movDestinoTipo").value || null;
            const origenTipoEl = document.getElementById("movOrigenTipo");
            const origenIdEl = document.getElementById("movOrigenId");
            let origen_tipo = origenTipoEl ? (origenTipoEl.value || null) : null;
            const origenRaw = origenIdEl ? origenIdEl.value.trim() : "";
            const destinoRaw = document.getElementById("movDestinoId").value.trim();

            let origen_id = null;
            let destino_id = null;
            const esPrensado = tipo === "prensado";

            if (!esPrensado && origenRaw) {
                if (/^\d+$/.test(origenRaw)) {
                    origen_id = parseInt(origenRaw, 10);
                } else if (origen_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === origenRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro dep√≥sito con c√≥digo " + origenRaw, "error");
                        return;
                    }
                    origen_id = dep.id;
                } else if (origen_tipo === "mastelone") {
                    const mas = cacheMastelones.find(m => m.codigo === origenRaw);
                    if (!mas) {
                        setFormFeedback("feedbackMovimientos", "No encuentro mastelone con c√≥digo " + origenRaw, "error");
                        return;
                    }
                    origen_id = mas.id;
                } else if (origen_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === origenRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con c√≥digo " + origenRaw, "error");
                        return;
                    }
                    origen_id = bar.id;
                } else {
                    setFormFeedback("feedbackMovimientos", "Para usar un c√≥digo como origen, el tipo debe ser dep√≥sito, mastelone o barrica.", "error");
                    return;
                }
            }

            if (esPrensado) {
                origen_tipo = null;
                origen_id = null;
            }

            if (destinoRaw) {
                if (/^\d+$/.test(destinoRaw)) {
                    destino_id = parseInt(destinoRaw, 10);
                } else if (destino_tipo === "deposito") {
                    const dep = cacheDepositos.find(d => d.codigo === destinoRaw);
                    if (!dep) {
                        setFormFeedback("feedbackMovimientos", "No encuentro dep√≥sito con c√≥digo " + destinoRaw, "error");
                        return;
                    }
                    destino_id = dep.id;
                } else if (destino_tipo === "barrica") {
                    const bar = cacheBarricas.find(b => b.codigo === destinoRaw);
                    if (!bar) {
                        setFormFeedback("feedbackMovimientos", "No encuentro barrica con c√≥digo " + destinoRaw, "error");
                        return;
                    }
                    destino_id = bar.id;
    } else if (destino_tipo === "mastelone") {
        const mas = cacheMastelones.find(m => m.codigo === destinoRaw);
        if (!mas) {
            setFormFeedback("feedbackMovimientos", "No encuentro mastelone con c√≥digo " + destinoRaw, "error");
            return;
        }
        destino_id = mas.id;
    } else {
        setFormFeedback("feedbackMovimientos", "Para usar un c√≥digo como destino, el tipo debe ser dep√≥sito, mastelone o barrica.", "error");
        return;
    }
}

            const litros = parseFloat(document.getElementById("movLitros").value || "0");
            const perdida_litros = document.getElementById("movPerdida").value
                ? parseFloat(document.getElementById("movPerdida").value)
                : null;
            const nota = document.getElementById("movNota").value;

            if (!litros || litros <= 0) {
                setFormFeedback("feedbackMovimientos", "Los litros deben ser mayores que 0.", "error");
                return;
            }

            const body = {
                fecha,
                fecha_hora,
                tipo,
                origen_tipo,
                origen_id,
                destino_tipo,
                destino_id,
                litros,
                perdida_litros,
                nota,
            };

            try {
                const res = await fetch("/api/movimientos", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al guardar el movimiento.");
                if (!ok) return;

                document.getElementById("formMovimiento").reset();
                actualizarCamposMovimiento();
                await Promise.all([
                    cargarMovimientos(),
                    cargarDepositos(),
                    cargarBarricas(),
                    cargarResumen(),
                ]);
                setFormFeedback("feedbackMovimientos", "Movimiento registrado.", "success");
                mostrarAviso("Movimiento registrado.", "success");
            } catch (err) {
                console.error("Error creando movimiento:", err);
                setFormFeedback("feedbackMovimientos", "No se pudo crear el movimiento.", "error");
                mostrarAviso("Error al crear el movimiento.", "error");
            }
        }

        // ---------- Embotellado ----------
        async function cargarEmbotellados() {
            try {
                const res = await fetch("/api/embotellados");
                if (!res.ok) return;
                const datos = await res.json();
                cacheEmbotellados = datos;
                const tbody = document.getElementById("tablaEmbotellados");
                if (!tbody) return;
                tbody.innerHTML = "";

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="5">A√∫n no hay embotellados registrados.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(e => {
                    const origen = formatearUbicacionMovimiento(e.contenedor_tipo, e.contenedor_id);
                    const fecha = formatearFechaCorta(e.fecha);
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${origen}</td>
                        <td>${e.botellas ?? ""}</td>
                        <td>${e.lote || ""}</td>
                        <td>${e.nota || ""}</td>
                    `;
                    tbody.appendChild(tr);
                });
                actualizarIndicadores();
                actualizarMapaFlujo();
            } catch (err) {
                console.error("Error cargando embotellados:", err);
            }
        }

        async function crearEmbotellado(ev) {
            ev.preventDefault();
            const fecha = document.getElementById("embFecha").value;
            const contenedor_tipo = document.getElementById("embTipo").value;
            const contenedorValor = document.getElementById("embContenedor").value.trim();
            const botellas = parseInt(document.getElementById("embBotellas").value || "0", 10) || null;
            const lote = document.getElementById("embLote").value.trim();
            const nota = document.getElementById("embNota").value.trim();

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id) {
                alert("No encuentro ese contenedor.");
                return;
            }
            if (!botellas || botellas <= 0) {
                alert("Las botellas deben ser mayores que 0.");
                return;
            }

            // Volumen interno estimado para registrar el movimiento; 0.75 L por botella como referencia.
            const litros = Number((botellas * 0.75).toFixed(3));

            const body = {
                fecha,
                contenedor_tipo,
                contenedor_id,
                litros,
                botellas,
                lote,
                nota,
            };

            try {
                const res = await fetch("/api/embotellados", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al registrar el embotellado.");
                if (!ok) return;
                document.getElementById("formEmbotellado").reset();
                await Promise.all([cargarEmbotellados(), cargarBarricas(), cargarDepositos(), cargarMovimientos(), cargarResumen()]);
            } catch (err) {
                console.error("Error creando embotellado:", err);
            }
        }

        // ---------- Registros anal√≠ticos ----------
        async function crearRegistroAnalitico(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("regTipo").value;
            const contenedorValor = document.getElementById("regId").value.trim();
            const fecha_hora = document.getElementById("regFecha").value;
            const densidad = document.getElementById("regDensidad").value
                ? parseFloat(document.getElementById("regDensidad").value)
                : null;
            const temperatura_c = document.getElementById("regTemperatura").value
                ? parseFloat(document.getElementById("regTemperatura").value)
                : null;
            const nota_sensorial = document.getElementById("regNotaSensorial").value;
            const nota = document.getElementById("regNota").value;

            const contenedor_id = resolverContenedorId(contenedor_tipo, contenedorValor);
            if (!contenedor_id || !fecha_hora) {
                alert("Indica un contenedor v√°lido y la fecha/hora.");
                return;
            }

            const body = {
                contenedor_tipo,
                contenedor_id,
                fecha_hora,
                densidad,
                temperatura_c,
                nota_sensorial,
                nota,
            };

            try {
                const res = await fetch("/api/registros", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) throw new Error();

                document.getElementById("formAnalitico").reset();
                cargarResumen();
                alert("Registro anal√≠tico guardado.");
            } catch (err) {
                console.error("Error guardando registro anal√≠tico:", err);
                alert("Error al guardar el registro anal√≠tico.");
            }
        }

        async function cargarHistorialAnalitico() {
            const tipo = document.getElementById("histTipo").value;
            const valor = document.getElementById("histId").value.trim();
            const id = resolverContenedorId(tipo, valor);
            const tbody = document.getElementById("tablaRegistros");
            tbody.innerHTML = "";

            if (!id) {
                alert("Indica un contenedor v√°lido (n√∫mero o c√≥digo).");
                return;
            }

            try {
                const datos = await obtenerHistorialCompleto(tipo, id);

                if (!datos.length) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = '<td colspan="4">No hay registros para este contenedor.</td>';
                    tbody.appendChild(tr);
                    return;
                }

                datos.forEach(r => {
                    const tr = document.createElement("tr");
                    const fecha = formatearFechaCorta(r.fecha || r.fecha_hora);
                    let evento = "";
                    let detalle = "";

                    if (r.categoria === "analitico") {
                        evento = "Registro anal√≠tico";
                        const partes = [];
                        if (r.densidad != null) partes.push(`Densidad: ${r.densidad}`);
                        if (r.temperatura_c != null) partes.push(`Temp: ${r.temperatura_c} ¬∞C`);
                        detalle = partes.join(" ¬∑ ");
                    } else if (r.categoria === "movimiento") {
                        evento = `Movimiento: ${r.tipo || ""}`;
                        const origen = formatearUbicacionMovimiento(r.origen_tipo, r.origen_id);
                        const destino = formatearUbicacionMovimiento(r.destino_tipo, r.destino_id);
                        detalle = `${r.litros || 0} L ¬∑ ${origen || "‚Äî"} ‚Üí ${destino || "‚Äî"}`;
                    } else {
                        evento = "Evento";
                        detalle = "";
                    }
                    const notas = [];
                    if (r.nota_sensorial) {
                        notas.push(`Sensorial: ${r.nota_sensorial}`);
                    }
                    if (r.nota) {
                        const textoNota = r.categoria === "analitico" ? `Nota: ${r.nota}` : r.nota;
                        notas.push(textoNota);
                    }
                    const notaTexto = notas.join(" ¬∑ ");

                    tr.innerHTML = `
                        <td>${fecha}</td>
                        <td>${evento}</td>
                        <td>${detalle}</td>
                        <td>${notaTexto}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (err) {
                console.error("Error cargando historial anal√≠tico:", err);
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="4">Error al cargar el historial.</td>';
                tbody.appendChild(tr);
            }
        }

        // ---------- An√°lisis Laboratorio ----------
        async function crearAnalisisLab(ev) {
            ev.preventDefault();
            const contenedor_tipo = document.getElementById("labTipoContenedor").value;
            const depositoValor = document.getElementById("labDeposito").value.trim();
            const contenedor_id = resolverContenedorId(contenedor_tipo, depositoValor);
            const fecha = document.getElementById("labFecha").value;
            const laboratorio = document.getElementById("labLaboratorio").value;
            const descripcion = document.getElementById("labDescripcion").value;
            const archivoInput = document.getElementById("labArchivo");
            const archivo = archivoInput.files[0];
            const mensaje = document.getElementById("labMensaje");

            if (!contenedor_id) {
                mensaje.textContent = "Indica un contenedor v√°lido.";
                return;
            }
            if (!archivo) {
                mensaje.textContent = "Selecciona un PDF.";
                return;
            }
            if (archivo.type && archivo.type !== "application/pdf") {
                mensaje.textContent = "Solo se permiten PDF.";
                return;
            }

            try {
                mensaje.textContent = "Subiendo PDF...";
                const archivo_base64 = await leerArchivoBase64(archivo);
                const body = {
                    contenedor_id,
                    contenedor_tipo,
                    fecha,
                    laboratorio,
                    descripcion,
                    archivo_nombre: archivo.name,
                    archivo_base64,
                };
                const res = await fetch("/api/analisis-lab", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                const ok = await manejarRespuesta(res, "Error al subir el an√°lisis.");
                if (!ok) {
                    mensaje.textContent = "No se pudo guardar.";
                    return;
                }
                document.getElementById("formAnalisisLab").reset();
                mensaje.textContent = "An√°lisis guardado correctamente.";
                await cargarAnalisisLab(filtroAnalisisDeposito);
                setTimeout(() => (mensaje.textContent = ""), 3000);
            } catch (err) {
                console.error("Error subiendo PDF:", err);
                mensaje.textContent = "Error al guardar el an√°lisis.";
            }
        }

        async function cargarAnalisisLab(nuevoFiltro) {
            if (arguments.length > 0) {
                filtroAnalisisDeposito = nuevoFiltro;
            }
            const filtroActual = filtroAnalisisDeposito;
            mostrarSkeletonTabla("tablaAnalisisLab", 5);
            try {
                let url = "/api/analisis-lab";
                if (filtroActual && (filtroActual.id || filtroActual.tipo)) {
                    const params = new URLSearchParams();
                    if (filtroActual.id) params.set("deposito_id", filtroActual.id);
                    if (filtroActual.tipo) params.set("tipo", filtroActual.tipo);
                    const qs = params.toString();
                    if (qs) {
                        url += `?${qs}`;
                    }
                }
                const res = await fetch(url);
                if (!res.ok) throw new Error();
                cacheAnalisisLab = await res.json();
                renderAnalisisLab();
            } catch (err) {
                console.error("Error cargando an√°lisis:", err);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="5">No se pudieron cargar los an√°lisis.</td></tr>';
                }
            }
        }

        function renderAnalisisLab() {
            const tbody = document.getElementById("tablaAnalisisLab");
            if (!tbody) return;
            tbody.innerHTML = "";
            if (!cacheAnalisisLab.length) {
                const tr = document.createElement("tr");
                tr.innerHTML = '<td colspan="5">Sin an√°lisis registrados todav√≠a.</td>';
                tbody.appendChild(tr);
                return;
            }
            cacheAnalisisLab.forEach(reg => {
                const tr = document.createElement("tr");
                const fecha = reg.fecha ? formatearFechaCorta(reg.fecha) : "‚Äî";
                const tipoCont = reg.contenedor_tipo || "deposito";
                const contenedor =
                    formatearUbicacionMovimiento(tipoCont, reg.deposito_id) ||
                    `${tipoCont} ${reg.deposito_id}`;
                const laboratorio = reg.laboratorio || "‚Äî";
                const descripcion = reg.descripcion || "‚Äî";
                const archivo =
                    reg.archivo_url
                        ? `<a href="${reg.archivo_url}" target="_blank" rel="noopener">Descargar PDF</a>`
                        : "‚Äî";
                tr.innerHTML = `
                    <td>${fecha}</td>
                    <td>${contenedor}</td>
                    <td>${laboratorio}</td>
                    <td>${descripcion}</td>
                    <td>${archivo}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function aplicarFiltroAnalisisLab() {
            const valor = document.getElementById("labFiltroDeposito").value.trim();
            const tipoSelect = document.getElementById("labFiltroTipo").value;
            if (!valor && !tipoSelect) {
                await cargarAnalisisLab(null);
                return;
            }
            let filtro = null;
            if (valor) {
                let tipoCont = tipoSelect || "";
                let id = null;
                if (tipoCont) {
                    id = resolverContenedorId(tipoCont, valor);
                } else {
                    id = resolverContenedorId("deposito", valor);
                    tipoCont = id ? "deposito" : "";
                    if (!id) {
                        id = resolverContenedorId("mastelone", valor);
                        if (id) tipoCont = "mastelone";
                    }
                }
                if (!id) {
                    alert("No encuentro un contenedor con ese c√≥digo/ID.");
                    return;
                }
                filtro = { id, tipo: tipoCont };
            } else if (tipoSelect) {
                filtro = { id: null, tipo: tipoSelect };
            }
            await cargarAnalisisLab(filtro);
        }

        async function limpiarFiltroAnalisisLab() {
            document.getElementById("labFiltroDeposito").value = "";
            document.getElementById("labFiltroTipo").value = "";
            await cargarAnalisisLab(null);
        }

        function leerArchivoBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error("No se pudo leer el archivo"));
                reader.readAsDataURL(file);
            });
        }

        // ---------- Inicializaci√≥n ----------
        (async function init() {
            await cargarNodosGuardados();
            mostrarSeccion("bodega");
            await Promise.all([
                cargarResumen(),
                cargarDepositos(),
                cargarBarricas(),
                cargarEntradas(),
                cargarMovimientos(),
                cargarLimpieza(),
                cargarEnologicos(),
                cargarEmbotellados(),
                cargarAnalisisLab(),
            ]);

            const campoFechaEntrada = document.getElementById("entradaFecha");
            if (campoFechaEntrada) {
                campoFechaEntrada.addEventListener("change", actualizarAnadaEntrada);
                actualizarAnadaEntrada();
            }
            const movTipoSelect = document.getElementById("movTipo");
            if (movTipoSelect) {
                movTipoSelect.addEventListener("change", actualizarCamposMovimiento);
                actualizarCamposMovimiento();
            }
        })();
    </script>
</body>
</html>
